{"root":1168,"crate_version":"9.8.0","includes_private":false,"index":{"604":{"id":604,"crate_id":0,"name":"debug_assert_fn_err_le_x","span":{"filename":"src/assert_fn_err/assert_fn_err_le_x.rs","begin":[509,0],"end":[515,1]},"visibility":"public","docs":"Assert a function error is less than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≤ expr\n\nThis macro provides the same statements as [`assert_fn_err_le_x`](macro.assert_fn_err_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)\n* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)\n* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)\n","links":{"macro@crate::assert_fn_err_le_x":602,"macro@crate::debug_assert_fn_err_le_x":604},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"327":{"id":327,"crate_id":0,"name":"assert_not_matches","span":{"filename":"src/assert_matches/assert_not_matches.rs","begin":[156,0],"end":[181,1]},"visibility":"public","docs":"Assert expression is Some.\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 'a';\nassert_not_matches!(a, 'b'..='z');\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 'a';\nassert_not_matches!(a, 'a'..='z');\n# });\n// assertion failed: `assert_not_matches!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_matches.html\n//  args: `a, 'a'..='z'`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_matches!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_matches.html\\n\",\n#     \" args: `a, 'a'..='z'`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_matches`](macro@crate::assert_not_matches)\n* [`assert_not_matches_as_result`](macro@crate::assert_not_matches_as_result)\n* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)\n","links":{"macro@crate::assert_not_matches_as_result":328,"macro@crate::debug_assert_not_matches":329,"macro@crate::assert_not_matches":327,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_matches {\n    ($expression:expr, $pattern:pat if $guard:expr $(,)?) => { ... };\n    ($expression:expr, $pattern:pat) => { ... };\n    ($expression:expr, $pattern:pat if $guard:expr, $($message:tt)+) => { ... };\n    ($expression:expr, $pattern:pat, $($message:tt)+) => { ... };\n}"}},"931":{"id":931,"crate_id":0,"name":"assert_program_args_stdout_gt_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt_x.rs","begin":[1,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stdout_gt_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)\n* [`assert_program_args_stdout_gt_x_as_result`](macro@crate::assert_program_args_stdout_gt_x_as_result)\n* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)","links":{"macro@crate::assert_program_args_stdout_gt_x_as_result":929,"macro@crate::debug_assert_program_args_stdout_gt_x":930,"macro@crate::assert_program_args_stdout_gt_x":928},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"50":{"id":50,"crate_id":0,"name":"assert_f32_ne","span":{"filename":"src/assert_f32/assert_f32_ne.rs","begin":[277,0],"end":[290,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is not equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 1.0 / 3.0;\nassert_f32_ne!(a, b);\n# });\n// assertion failed: `assert_f32_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f32_ne.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.33333334`,`\n//     diff: `0`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f32_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f32_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.33333334`,\\n\",\n#     \"    diff: `0`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f32_ne`](macro@crate::assert_f32_ne)\n* [`assert_f32_ne_as_result`](macro@crate::assert_f32_ne_as_result)\n* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)\n","links":{"macro@crate::assert_f32_ne":50,"macro@crate::debug_assert_f32_ne":52,"macro@crate::assert_f32_ne_as_result":51,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"654":{"id":654,"crate_id":0,"name":"assert_fn_ok_le_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le_x.rs","begin":[1,0],"end":[515,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_le_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)\n* [`assert_fn_ok_le_x_as_result`](macro@crate::assert_fn_ok_le_x_as_result)\n* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)","links":{"macro@crate::debug_assert_fn_ok_le_x":653,"macro@crate::assert_fn_ok_le_x":651,"macro@crate::assert_fn_ok_le_x_as_result":652},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"377":{"id":377,"crate_id":0,"name":"assert_ok_eq_x","span":{"filename":"src/assert_ok/assert_ok_eq_x.rs","begin":[1,0],"end":[350,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Ok(1);\nlet b: i8 = 1;\nassert_ok_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)\n* [`assert_ok_eq_x_as_result`](macro@crate::assert_ok_eq_x_as_result)\n* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)","links":{"macro@crate::assert_ok_eq_x":374,"macro@crate::assert_ok_eq_x_as_result":375,"macro@crate::debug_assert_ok_eq_x":376},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"981":{"id":981,"crate_id":0,"name":"assert_program_args_stderr_eq_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq_x.rs","begin":[1,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stderr_eq_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)\n* [`assert_program_args_stderr_eq_x_as_result`](macro@crate::assert_program_args_stderr_eq_x_as_result)\n* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)","links":{"macro@crate::debug_assert_program_args_stderr_eq_x":980,"macro@crate::assert_program_args_stderr_eq_x":978,"macro@crate::assert_program_args_stderr_eq_x_as_result":979},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"100":{"id":100,"crate_id":0,"name":"assert_abs_diff_ne_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne_x.rs","begin":[329,0],"end":[342,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nPseudocode:<br>\n|Δ| ≠ x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_ne_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 10;\nlet b = 13;\nlet x = 3;\nassert_abs_diff_ne_x!(a, b, x);\n# });\n// assertion failed: `assert_abs_diff_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_abs_diff_ne_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `2`,\n//      |Δ|: `3`,\n//  |Δ| ≠ x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_abs_diff_ne_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_abs_diff_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `3`,\\n\",\n#     \"     |Δ|: `3`,\\n\",\n#     \" |Δ| ≠ x: false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)\n* [`assert_abs_diff_ne_x_as_result`](macro@crate::assert_abs_diff_ne_x_as_result)\n* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)\n","links":{"macro@crate::debug_assert_abs_diff_ne_x":102,"macro@crate::assert_abs_diff_ne_x_as_result":101,"macro@crate::assert_abs_diff_ne_x":100,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_ne_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"704":{"id":704,"crate_id":0,"name":"assert_fs_read_to_string_lt_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt_x.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) < expr\n\n* If true, return (path_into_string, expr_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_lt_x!(path, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"bravo.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_lt_x!(path, x);\n# });\n// assertion failed: `assert_fs_read_to_string_lt_x!(a_path, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_lt_x.html\n//  a_path label: `path`,\n//  a_path debug: `\\\"bravo.txt\\\"`,\n//  b_expr label: `x`,\n//  b_expr debug: `\\\"alfa\\\\n\\\"`,\n//      a string: `\\\"bravo\\\\n\\\"`,\n//      b string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_lt_x!(a_path, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_lt_x.html\\n\",\n#     \" a_path label: `path`,\\n\",\n#     \" a_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \" b_expr label: `x`,\\n\",\n#     \" b_expr debug: `\\\"alfa\\\\n\\\"`,\\n\",\n#     \"     a string: `bravo\\n`,\\n\",\n#     \"     b string: `alfa\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)\n* [`assert_fs_read_to_string_lt_x_as_result`](macro@crate::assert_fs_read_to_string_lt_x_as_result)\n* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)\n","links":{"macro@crate::assert_fs_read_to_string_lt_x":704,"macro@crate::assert_fs_read_to_string_lt_x_as_result":705,"macro@crate::debug_assert_fs_read_to_string_lt_x":706,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_lt_x {\n    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"427":{"id":427,"crate_id":0,"name":"assert_poll_ready_ne","span":{"filename":"src/assert_poll/assert_poll_ready_ne.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are not equal.\n\nDeprecated. Please rename from `assert_poll_ready_ne` into `assert_ready_ne` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"150":{"id":150,"crate_id":0,"name":"debug_assert_diff_ne_x","span":{"filename":"src/assert_diff/assert_diff_ne_x.rs","begin":[472,0],"end":[478,1]},"visibility":"public","docs":"Assert a difference is not equal to an expression.\n\nPseudocode:<br>\nΔ = x\n\nThis macro provides the same statements as [`assert_diff_ne_x`](macro.assert_diff_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)\n* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)\n* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)\n","links":{"macro@crate::assert_diff_ne_x_as_result":149,"macro@crate::assert_diff_ne_x":148,"macro@crate::debug_assert_diff_ne_x":150},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_diff_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1031":{"id":1031,"crate_id":0,"name":"assert_status_code_value_gt","span":{"filename":"src/assert_status/assert_status_code_value_gt.rs","begin":[263,0],"end":[276,1]},"visibility":"public","docs":"Assert a status code value is greater than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_gt!(a, b);\n# });\n// assertion failed: `assert_status_code_value_gt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_gt.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  b value: `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_gt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`\\n\",\n#     \"  b code: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)\n* [`assert_status_code_value_gt_as_result`](macro@crate::assert_status_code_value_gt_as_result)\n* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)\n","links":{"macro@crate::assert_status_code_value_gt":1031,"macro@crate::assert_status_code_value_gt_as_result":1032,"macro@crate::debug_assert_status_code_value_gt":1033,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_gt {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };\n}"}},"754":{"id":754,"crate_id":0,"name":"assert_io_read_to_string_gt_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt_x.rs","begin":[244,0],"end":[257,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"aa\");\nassert_io_read_to_string_gt_x!(reader, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_gt_x!(reader, x);\n# });\n// assertion failed: `assert_io_read_to_string_gt_x!(a_reader, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_gt_x.html\n//  a_reader label: `reader`,\n//  a_reader debug: `[97, 108, 102, 97]`,\n//    b_expr label: `x`,\n//    b_expr debug: `\\\"zz\\\"`,\n//               a: `\\\"alfa\\\"`,\n//               b: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_gt_x!(a_reader, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_gt_x.html\\n\",\n#     \" a_reader label: `reader`,\\n\",\n#     \" a_reader debug: `[97, 108, 102, 97]`,\\n\",\n#     \"   b_expr label: `x`,\\n\",\n#     \"   b_expr debug: `\\\"zz\\\"`,\\n\",\n#     \"              a: `\\\"alfa\\\"`,\\n\",\n#     \"              b: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)\n* [`assert_io_read_to_string_gt_x_as_result`](macro@crate::assert_io_read_to_string_gt_x_as_result)\n* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)\n","links":{"macro@crate::assert_io_read_to_string_gt_x_as_result":755,"macro@crate::assert_io_read_to_string_gt_x":754,"macro@crate::debug_assert_io_read_to_string_gt_x":756,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_gt_x {\n    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"477":{"id":477,"crate_id":0,"name":"debug_assert_iter_gt","span":{"filename":"src/assert_iter/assert_iter_gt.rs","begin":[298,0],"end":[304,1]},"visibility":"public","docs":"Assert an iterable is greater than another.\n\nPseudocode:<br>\n(collection1 into iter) > (collection2 into iter)\n\nThis macro provides the same statements as [`assert_iter_gt`](macro.assert_iter_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_iter_gt`](macro@crate::assert_iter_gt)\n* [`assert_iter_gt`](macro@crate::assert_iter_gt)\n* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)\n","links":{"macro@crate::debug_assert_iter_gt":477,"macro@crate::assert_iter_gt":475},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_iter_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"200":{"id":200,"crate_id":0,"name":"assert_count_gt","span":{"filename":"src/assert_count/assert_count_gt.rs","begin":[1,0],"end":[344,1]},"visibility":"public","docs":"Assert a count is greater than another.\n\nPseudocode:<br>\na.count() > b.count()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\".chars();\nlet b = \"x\".chars();\nassert_count_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_gt`](macro@crate::assert_count_gt)\n* [`assert_count_gt_as_result`](macro@crate::assert_count_gt_as_result)\n* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)","links":{"macro@crate::assert_count_gt":197,"macro@crate::debug_assert_count_gt":199,"macro@crate::assert_count_gt_as_result":198},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"804":{"id":804,"crate_id":0,"name":"assert_command_stdout_eq_x","span":{"filename":"src/assert_command/assert_command_stdout_eq_x.rs","begin":[248,0],"end":[261,1]},"visibility":"public","docs":"Assert a command stdout string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_command_stdout_eq_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_eq_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stdout_eq_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_eq_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[122, 122]`,\n//     expr value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_eq_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_eq_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[122, 122]`,\\n\",\n#     \"    expr value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)\n* [`assert_command_stdout_eq_x_as_result`](macro@crate::assert_command_stdout_eq_x_as_result)\n* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)\n","links":{"macro@crate::assert_command_stdout_eq_x_as_result":805,"macro@crate::debug_assert_command_stdout_eq_x":806,"macro@crate::assert_command_stdout_eq_x":804,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_eq_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"527":{"id":527,"crate_id":0,"name":"debug_assert_fn_gt","span":{"filename":"src/assert_fn/assert_fn_gt.rs","begin":[524,0],"end":[530,1]},"visibility":"public","docs":"Assert a function output is greater than another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\nThis macro provides the same statements as [`assert_fn_gt`](macro.assert_fn_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_gt`](macro@crate::assert_fn_gt)\n* [`assert_fn_gt`](macro@crate::assert_fn_gt)\n* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)\n","links":{"macro@crate::assert_fn_gt":525,"macro@crate::debug_assert_fn_gt":527},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"250":{"id":250,"crate_id":0,"name":"assert_ends_with","span":{"filename":"src/assert_ends_with/assert_ends_with.rs","begin":[1,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) ends with an expression (such as a string).\n\nPseudocode:<br>\na.ends_with(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String ends with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"fa\";\nassert_ends_with!(sequence, subsequence);\n\n// Vector ends with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [3];\nassert_ends_with!(sequence, subsequence);\n```\n\n# Module macros\n\n* [`assert_ends_with`](macro@crate::assert_ends_with)\n* [`assert_ends_with_as_result`](macro@crate::assert_ends_with_as_result)\n* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)","links":{"macro@crate::assert_ends_with":247,"macro@crate::debug_assert_ends_with":249,"macro@crate::assert_ends_with_as_result":248},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1131":{"id":1131,"crate_id":0,"name":"assert_bag_impl_prep","span":{"filename":"src/assert_bag/mod.rs","begin":[97,0],"end":[111,1]},"visibility":"public","docs":"Assert bag implementation preparation.","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_impl_prep {\n    ($impl_into_iter:expr $(,)?) => { ... };\n}"}},"854":{"id":854,"crate_id":0,"name":"assert_command_stderr_lt","span":{"filename":"src/assert_command/assert_command_stderr_lt.rs","begin":[1,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stderr string is less than another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stderr_lt`](macro@crate::assert_command_stderr_lt)\n* [`assert_command_stderr_lt_as_result`](macro@crate::assert_command_stderr_lt_as_result)\n* [`debug_assert_command_stderr_lt`](macro@crate::debug_assert_command_stderr_lt)","links":{"macro@crate::debug_assert_command_stderr_lt":853,"macro@crate::assert_command_stderr_lt":851,"macro@crate::assert_command_stderr_lt_as_result":852},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"577":{"id":577,"crate_id":0,"name":"assert_fn_err_gt","span":{"filename":"src/assert_fn_err/assert_fn_err_gt.rs","begin":[1,0],"end":[591,1]},"visibility":"public","docs":"Assert a function Err(…) is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 20;\nlet b: i8 = 10;\nassert_fn_err_gt!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)\n* [`assert_fn_err_gt_as_result`](macro@crate::assert_fn_err_gt_as_result)\n* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)","links":{"macro@crate::assert_fn_err_gt":574,"macro@crate::assert_fn_err_gt_as_result":575,"macro@crate::debug_assert_fn_err_gt":576},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"300":{"id":300,"crate_id":0,"name":"debug_assert_len_eq_x","span":{"filename":"src/assert_len/assert_len_eq_x.rs","begin":[329,0],"end":[335,1]},"visibility":"public","docs":"Assert a length is equal to an expression.\n\nPseudocode:<br>\na.len() = b\n\nThis macro provides the same statements as [`assert_len_eq_x`](macro.assert_len_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)\n* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)\n* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)\n","links":{"macro@crate::assert_len_eq_x":298,"macro@crate::debug_assert_len_eq_x":300},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"904":{"id":904,"crate_id":0,"name":"assert_program_args_stdout_gt","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt.rs","begin":[313,0],"end":[326,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"a\", \"a\"];\nassert_program_args_stdout_gt!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\"];\nassert_program_args_stdout_gt!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_gt.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stdout\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s%s\\\", \\\"z\\\", \\\"z\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_gt.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s%s\\\", \\\"z\\\", \\\"z\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)\n* [`assert_program_args_stdout_gt_as_result`](macro@crate::assert_program_args_stdout_gt_as_result)\n* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)\n","links":{"macro@crate::assert_program_args_stdout_gt_as_result":905,"macro@crate::debug_assert_program_args_stdout_gt":906,"macro@crate::assert_program_args_stdout_gt":904,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_gt {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"23":{"id":23,"crate_id":0,"name":"assert_eq_f32_as_result","span":{"filename":"src/assert_eq_f32.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na = b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_eq_f32`](macro@crate::assert_eq_f32)\n* [`assert_eq_f32_as_result`](macro@crate::assert_eq_f32_as_result)\n* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)\n","links":{"macro@crate::debug_assert_eq_f32":24,"macro@crate::assert_eq_f32":22,"macro@crate::assert_eq_f32_as_result":23},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_eq_f32_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"627":{"id":627,"crate_id":0,"name":"assert_fn_ok_le","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le.rs","begin":[339,0],"end":[372,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_le!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 2;\nlet b: i8 = 1;\nassert_fn_ok_le!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_ok_le!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_le.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `2`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `1`,\n//                 a: `\\\"2\\\"`,\n//                 b: `\\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_le!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_le.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `2`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `1`,\\n\",\n#     \"                a: `\\\"2\\\"`,\\n\",\n#     \"                b: `\\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)\n* [`assert_fn_ok_le_as_result`](macro@crate::assert_fn_ok_le_as_result)\n* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)\n","links":{"macro@crate::debug_assert_fn_ok_le":629,"macro@crate::assert_fn_ok_le":627,"macro@crate::assert_fn_ok_le_as_result":628,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_le {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"350":{"id":350,"crate_id":0,"name":"assert_err_ne_as_result","span":{"filename":"src/assert_err/assert_err_ne.rs","begin":[41,0],"end":[90,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_err_ne`](macro@crate::assert_err_ne)\n* [`assert_err_ne_as_result`](macro@crate::assert_err_ne_as_result)\n* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)\n","links":{"macro@crate::debug_assert_err_ne":351,"macro@crate::assert_err_ne_as_result":350,"macro@crate::assert_err_ne":349},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"954":{"id":954,"crate_id":0,"name":"assert_program_args_stderr_eq","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq.rs","begin":[313,0],"end":[326,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"alfa\"];\nassert_program_args_stderr_eq!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_eq!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_eq.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stderr\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s\\\", \\\"zz\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_eq.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s\\\", \\\"zz\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)\n* [`assert_program_args_stderr_eq_as_result`](macro@crate::assert_program_args_stderr_eq_as_result)\n* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)\n","links":{"macro@crate::debug_assert_program_args_stderr_eq":956,"macro@crate::assert_program_args_stderr_eq":954,"macro@crate::assert_program_args_stderr_eq_as_result":955,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_eq {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"73":{"id":73,"crate_id":0,"name":"debug_assert_f64_lt","span":{"filename":"src/assert_f64/assert_f64_lt.rs","begin":[321,0],"end":[327,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is less than another within f64::EPSILON.\n\nPseudocode:<br>\na < b\n\nThis macro provides the same statements as [`assert_f64_lt`](macro.assert_f64_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f64_lt`](macro@crate::assert_f64_lt)\n* [`assert_f64_lt`](macro@crate::assert_f64_lt)\n* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)\n","links":{"macro@crate::debug_assert_f64_lt":73,"macro@crate::assert_f64_lt":71},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f64_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"677":{"id":677,"crate_id":0,"name":"assert_fs_read_to_string_le_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)\n\n* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)\n* [`assert_fs_read_to_string_le_as_result`](macro@crate::assert_fs_read_to_string_le_as_result)\n* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)\n","links":{"macro@crate::assert_fs_read_to_string_le":676,"macro@crate::debug_assert_fs_read_to_string_le":678,"macro@crate::assert_fs_read_to_string_le_as_result":677},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_le_as_result {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n}"}},"400":{"id":400,"crate_id":0,"name":"debug_assert_some","span":{"filename":"src/assert_some/assert_some.rs","begin":[239,0],"end":[245,1]},"visibility":"public","docs":"Assert expression is Some.\n\nPseudocode:<br>\na is Some\n\nThis macro provides the same statements as [`assert_some`](macro.assert_some.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_some`](macro@crate::assert_some)\n* [`assert_some`](macro@crate::assert_some)\n* [`debug_assert_some`](macro@crate::debug_assert_some)\n","links":{"macro@crate::assert_some":398,"macro@crate::debug_assert_some":400},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_some {\n    ($($arg:tt)*) => { ... };\n}"}},"1004":{"id":1004,"crate_id":0,"name":"assert_program_args_stderr_string_contains_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_contains.rs","begin":[47,0],"end":[111,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)\n\n* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stderr ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)\n* [`assert_program_args_stderr_string_contains_as_result`](macro@crate::assert_program_args_stderr_string_contains_as_result)\n* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)\n","links":{"macro@crate::debug_assert_program_args_stderr_string_contains":1005,"macro@crate::assert_program_args_stderr_string_contains":1003,"macro@crate::assert_program_args_stderr_string_contains_as_result":1004},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_string_contains_as_result {\n    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };\n}"}},"123":{"id":123,"crate_id":0,"name":"assert_approx_eq","span":{"filename":"src/assert_approx/assert_approx_eq.rs","begin":[1,0],"end":[359,1]},"visibility":"public","docs":"Assert a number is approximately equal to another.\n\nPseudocode:<br>\n| a - b | ≤ 1e-6\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000011;\nassert_approx_eq!(a, b);\n```\n\n## Comparisons\n\nThis crate provides macro groups that test approximations and nearness:\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq) and\n  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate\n  equality within 1e-6. The macro name and the approximate value are chosen\n  to be similar to the longtime popular rust crate `assert_approx_eq`.\n\n* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error\n  (i.e. delta). This is the magnitude of the difference between the exact\n  value and the approximation.\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative\n  error (i.e. epsilon). This is the absolute error divided by the magnitude\n  of the exact value. This can be used to compare approximations of numbers\n  of wildly differing size.\n\nExamples:\n\n* Approximating the number 100 and 103 has an absolute error (approx) of 3\n  and a relative error (epsilon) of 0.03.\n\n* Approximating the number 1,000,000 and 1,000,003 has an absolute error\n  (approx) of 3, and a relative error (epsilon) of 0.000003.\n\n* For many kinds of applications, the relative error is more important than\n  the absolute error.\n\n## Thanks\n\n* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for\n  creating and maintaining the `assert_approx_eq` crate.\n\n* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for\n  creating and maintaining `assert_in_approx` and `assert_in_epsilon` code.\n\n# Module macros\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq)\n* [`assert_approx_eq_as_result`](macro@crate::assert_approx_eq_as_result)\n* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)","links":{"macro@crate::assert_in_delta":119,"macro@crate::assert_approx_eq":117,"macro@crate::assert_approx_ne":118,"macro@crate::debug_assert_approx_eq":122,"macro@crate::assert_in_epsilon":120,"macro@crate::assert_approx_eq_as_result":121},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"727":{"id":727,"crate_id":0,"name":"assert_io_read_to_string_ge_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge.rs","begin":[42,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)\n* [`assert_io_read_to_string_ge_as_result`](macro@crate::assert_io_read_to_string_ge_as_result)\n* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)\n","links":{"macro@crate::assert_io_read_to_string_ge":726,"macro@crate::debug_assert_io_read_to_string_ge":728,"macro@crate::assert_io_read_to_string_ge_as_result":727},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ge_as_result {\n    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };\n}"}},"450":{"id":450,"crate_id":0,"name":"assert_bag_eq","span":{"filename":"src/assert_bag/assert_bag_eq.rs","begin":[205,0],"end":[218,1]},"visibility":"public","docs":"Assert a bag is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] in order to print the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 1];\nlet b = [1, 1];\nassert_bag_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 1];\nlet b = [1, 1, 1];\nassert_bag_eq!(a, b);\n# });\n// assertion failed: `assert_bag_eq!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_bag_eq.html\n//  a label: `a`,\n//  a debug: `[1, 1]`,\n//  b label: `b`,\n//  b debug: `[1, 1, 1]`,\n//    a bag: `{1: 2}`,\n//    b bag: `{1: 3}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_bag_eq!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_bag_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 1]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 1, 1]`,\\n\",\n#     \"   a bag: `{1: 2}`,\\n\",\n#     \"   b bag: `{1: 3}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_eq`](macro@crate::assert_bag_eq)\n* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)\n* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)\n","links":{"macro@crate::assert_bag_eq":450,"macro@crate::assert_bag_eq_as_result":451,"macro@crate::debug_assert_bag_eq":452,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_eq {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1054":{"id":1054,"crate_id":0,"name":"assert_status_code_value_ge_x","span":{"filename":"src/assert_status/assert_status_code_value_ge_x.rs","begin":[1,0],"end":[385,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet b = 1;\nassert_status_code_value_ge_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)\n* [`assert_status_code_value_ge_x_as_result`](macro@crate::assert_status_code_value_ge_x_as_result)\n* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)","links":{"macro@crate::assert_status_code_value_ge_x":1051,"macro@crate::debug_assert_status_code_value_ge_x":1053,"macro@crate::assert_status_code_value_ge_x_as_result":1052},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"173":{"id":173,"crate_id":0,"name":"assert_any_as_result","span":{"filename":"src/assert_any.rs","begin":[44,0],"end":[69,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_any`](macro@crate::assert_any)\n* [`assert_any_as_result`](macro@crate::assert_any_as_result)\n* [`debug_assert_any`](macro@crate::debug_assert_any)\n","links":{"macro@crate::assert_any":172,"macro@crate::assert_any_as_result":173,"macro@crate::debug_assert_any":174},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_any_as_result {\n    ($collection:expr, $predicate:expr $(,)?) => { ... };\n}"}},"777":{"id":777,"crate_id":0,"name":"assert_io_read_to_string_is_match","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_is_match.rs","begin":[1,0],"end":[315,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is a match to a regex.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) matches matcher\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet reader = \"hello\".as_bytes();\nlet matcher = Regex::new(r\"ell\").expect(\"regex\");\nassert_io_read_to_string_is_match!(reader, matcher);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)\n* [`assert_io_read_to_string_is_match_as_result`](macro@crate::assert_io_read_to_string_is_match_as_result)\n* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)","links":{"macro@crate::assert_io_read_to_string_is_match_as_result":775,"macro@crate::assert_io_read_to_string_is_match":774,"macro@crate::debug_assert_io_read_to_string_is_match":776},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"500":{"id":500,"crate_id":0,"name":"assert_set_disjoint","span":{"filename":"src/assert_set/assert_set_disjoint.rs","begin":[205,0],"end":[218,1]},"visibility":"public","docs":"Assert a set is disjoint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)\n\n* If true, return `(a_set, b_set)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [3, 4];\nassert_set_disjoint!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [2, 3];\nassert_set_disjoint!(a, b);\n# });\n// assertion failed: `assert_set_disjoint!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_set_disjoint.html\n//  a label: `a`,\n//  a debug: `[1, 2]`,\n//  b label: `b`,\n//  b debug: `[2, 3]`,\n//        a: `{1, 2}`,\n//        b: `{2, 3}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_set_disjoint!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_set_disjoint.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[2, 3]`,\\n\",\n#     \"       a: `{1, 2}`,\\n\",\n#     \"       b: `{2, 3}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)\n* [`assert_set_disjoint_as_result`](macro@crate::assert_set_disjoint_as_result)\n* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)\n","links":{"macro@crate::assert_set_disjoint_as_result":501,"macro@crate::debug_assert_set_disjoint":502,"macro@crate::assert_set_disjoint":500,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_disjoint {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"223":{"id":223,"crate_id":0,"name":"debug_assert_count_gt_x","span":{"filename":"src/assert_count/assert_count_gt_x.rs","begin":[329,0],"end":[335,1]},"visibility":"public","docs":"Assert a count is greater than an expression.\n\nPseudocode:<br>\na.count() > b\n\nThis macro provides the same statements as [`assert_count_gt_x`](macro.assert_count_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)\n* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)\n* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)\n","links":{"macro@crate::debug_assert_count_gt_x":223,"macro@crate::assert_count_gt_x":221},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1104":{"id":1104,"crate_id":0,"name":"assert_result_ok_ne_as_result","span":{"filename":"src/assert_result/assert_result_ok_ne.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nPlease rename from `assert_result_ok_ne_as_result` into `assert_ok_ne_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_ok_ne_as_result` into `assert_ok_ne_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_ok_ne_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"827":{"id":827,"crate_id":0,"name":"assert_command_stdout_string_contains","span":{"filename":"src/assert_command/assert_command_stdout_string_contains.rs","begin":[234,0],"end":[247,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) contains (expr into string)\n\n* If true, return (command ⇒ stdout ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\nThis uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.\n\n* The containee can be a &str, char, a slice of chars, or a function or\nclosure that determines if a character contains.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet containee = \"lf\";\nassert_command_stdout_string_contains!(command, containee);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet containee = \"zz\";\nassert_command_stdout_string_contains!(command, containee);\n# });\n// assertion failed: `assert_command_stdout_string_contains!(command, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_string_contains.html\n//    command label: `command`,\n//    command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//    command value: `\\\"alfa\\\"`,\n//  containee label: `containee`,\n//  containee debug: `\\\"zz\\\"`,\n//  containee value: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_string_contains!(command, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_string_contains.html\\n\",\n#     \"   command label: `command`,\\n\",\n#     \"   command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \"   command value: `\\\"alfa\\\"`,\\n\",\n#     \" containee label: `containee`,\\n\",\n#     \" containee debug: `\\\"zz\\\"`,\\n\",\n#     \" containee value: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)\n* [`assert_command_stdout_string_contains_as_result`](macro@crate::assert_command_stdout_string_contains_as_result)\n* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)\n","links":{"macro@crate::assert_command_stdout_string_contains_as_result":828,"macro@crate::assert_command_stdout_string_contains":827,"macro@crate::debug_assert_command_stdout_string_contains":829,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_string_contains {\n    ($command:expr, $containee:expr $(,)?) => { ... };\n    ($command:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"550":{"id":550,"crate_id":0,"name":"assert_fn_gt_x_as_result","span":{"filename":"src/assert_fn/assert_fn_gt_x.rs","begin":[41,0],"end":[107,1]},"visibility":"public","docs":"Assert a function output is greater than an expression.\n\nPseudocode:<br>\nfunction(a) > b\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)\n* [`assert_fn_gt_x_as_result`](macro@crate::assert_fn_gt_x_as_result)\n* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)\n","links":{"macro@crate::assert_fn_gt_x":549,"macro@crate::assert_fn_gt_x_as_result":550,"macro@crate::debug_assert_fn_gt_x":551},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_gt_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"273":{"id":273,"crate_id":0,"name":"assert_is_match","span":{"filename":"src/assert_is_match/mod.rs","begin":[1,0],"end":[21,25]},"visibility":"public","docs":"Assert for method is_match(…).\n\nThese macros help with any item that implements self.is_match(…).\n\n* [`assert_is_match!(matcher, matchee)`](macro@crate::assert_is_match) ≈ matcher.is_match(matchee)\n\n* [`assert_not_match!(matcher, matchee)`](macro@crate::assert_not_match) ≈ !matcher.is_match(matchee)\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet a = Regex::new(r\"lf\").expect(\"regex\");\nlet b = \"alfa\";\nassert_is_match!(a, b);\n```","links":{"macro@crate::assert_is_match":265,"macro@crate::assert_not_match":269},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[268,272],"is_stripped":false}}},"1154":{"id":1154,"crate_id":0,"name":"assert_program_args_stdout_contains_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_contains.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nDeprecated. Please rename from `assert_program_args_stdout_contains_as_result` to `assert_program_args_stdout_string_contains_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stdout_contains_as_result` to `assert_program_args_stdout_string_contains_as_result`."},"inner":{"macro":"macro_rules! assert_program_args_stdout_contains_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"877":{"id":877,"crate_id":0,"name":"debug_assert_command_stderr_lt_x","span":{"filename":"src/assert_command/assert_command_stderr_lt_x.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stderr string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_lt_x`](macro.assert_command_stderr_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)\n* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)\n* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)\n","links":{"macro@crate::assert_command_stderr_lt_x":875,"macro@crate::debug_assert_command_stderr_lt_x":877},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"600":{"id":600,"crate_id":0,"name":"debug_assert_fn_err_gt_x","span":{"filename":"src/assert_fn_err/assert_fn_err_gt_x.rs","begin":[567,0],"end":[573,1]},"visibility":"public","docs":"Assert a function error is greater than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) > expr\n\nThis macro provides the same statements as [`assert_fn_err_gt_x`](macro.assert_fn_err_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)\n* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)\n* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)\n","links":{"macro@crate::assert_fn_err_gt_x":598,"macro@crate::debug_assert_fn_err_gt_x":600},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"323":{"id":323,"crate_id":0,"name":"assert_matches","span":{"filename":"src/assert_matches/assert_matches.rs","begin":[156,0],"end":[181,1]},"visibility":"public","docs":"Assert expression is Some.\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 'a';\nassert_matches!(a, 'a'..='z');\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 'a';\nassert_matches!(a, 'b'..='z');\n# });\n// assertion failed: `assert_matches!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_matches.html\n//  args: `a, 'b'..='z'`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_matches!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_matches.html\\n\",\n#     \" args: `a, 'b'..='z'`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_matches`](macro@crate::assert_matches)\n* [`assert_matches_as_result`](macro@crate::assert_matches_as_result)\n* [`debug_assert_matches`](macro@crate::debug_assert_matches)\n","links":{"macro@crate::assert_matches":323,"macro@crate::debug_assert_matches":325,"macro@crate::assert_matches_as_result":324,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_matches {\n    ($expression:expr, $pattern:pat if $guard:expr $(,)?) => { ... };\n    ($expression:expr, $pattern:pat) => { ... };\n    ($expression:expr, $pattern:pat if $guard:expr, $($message:tt)+) => { ... };\n    ($expression:expr, $pattern:pat, $($message:tt)+) => { ... };\n}"}},"927":{"id":927,"crate_id":0,"name":"assert_program_args_stdout_ge_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge_x.rs","begin":[1,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stdout_ge_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)\n* [`assert_program_args_stdout_ge_x_as_result`](macro@crate::assert_program_args_stdout_ge_x_as_result)\n* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)","links":{"macro@crate::assert_program_args_stdout_ge_x_as_result":925,"macro@crate::assert_program_args_stdout_ge_x":924,"macro@crate::debug_assert_program_args_stdout_ge_x":926},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"46":{"id":46,"crate_id":0,"name":"assert_f32_lt","span":{"filename":"src/assert_f32/assert_f32_lt.rs","begin":[257,0],"end":[270,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na < b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333331;\nassert_f32_lt!(a, b);\n# });\n// assertion failed: `assert_f32_lt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f32_lt.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.3333331`,`\n//     diff: `0.00000029802322`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f32_lt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f32_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333331`,\\n\",\n#     \"    diff: `0.00000023841858`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f32_lt`](macro@crate::assert_f32_lt)\n* [`assert_f32_lt_as_result`](macro@crate::assert_f32_lt_as_result)\n* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)\n","links":{"macro@crate::debug_assert_f32_lt":48,"macro@crate::assert_f32_lt":46,"macro@crate::assert_f32_lt_as_result":47,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_lt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"650":{"id":650,"crate_id":0,"name":"assert_fn_ok_gt_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt_x.rs","begin":[1,0],"end":[573,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 2;\nlet b = String::from(\"1\");\nassert_fn_ok_gt_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)\n* [`assert_fn_ok_gt_x_as_result`](macro@crate::assert_fn_ok_gt_x_as_result)\n* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)","links":{"macro@crate::assert_fn_ok_gt_x_as_result":648,"macro@crate::debug_assert_fn_ok_gt_x":649,"macro@crate::assert_fn_ok_gt_x":647},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"373":{"id":373,"crate_id":0,"name":"assert_ok_ne","span":{"filename":"src/assert_ok/assert_ok_ne.rs","begin":[1,0],"end":[393,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Ok(1);\nlet b: Result<i8, i8> = Ok(2);\nassert_ok_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_ok_ne`](macro@crate::assert_ok_ne)\n* [`assert_ok_ne_as_result`](macro@crate::assert_ok_ne_as_result)\n* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)","links":{"macro@crate::assert_ok_ne_as_result":371,"macro@crate::assert_ok_ne":370,"macro@crate::debug_assert_ok_ne":372},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"977":{"id":977,"crate_id":0,"name":"assert_program_args_stderr_ne","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne.rs","begin":[1,0],"end":[470,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_ne!(a_program, a_args, b_program, b_args);\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)\n* [`assert_program_args_stderr_ne_as_result`](macro@crate::assert_program_args_stderr_ne_as_result)\n* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)","links":{"macro@crate::debug_assert_program_args_stderr_ne":976,"macro@crate::assert_program_args_stderr_ne":974,"macro@crate::assert_program_args_stderr_ne_as_result":975},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"96":{"id":96,"crate_id":0,"name":"assert_abs_diff_lt_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt_x.rs","begin":[299,0],"end":[312,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nPseudocode:<br>\n|Δ| < x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 10;\nlet b = 13;\nlet x = 4;\nassert_abs_diff_lt_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_lt_x!(a, b, x);\n# });\n// assertion failed: `assert_abs_diff_lt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_abs_diff_lt_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `2`,\n//      |Δ|: `3`,\n//  |Δ| < x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_abs_diff_lt_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_abs_diff_lt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `2`,\\n\",\n#     \"     |Δ|: `3`,\\n\",\n#     \" |Δ| < x: false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)\n* [`assert_abs_diff_lt_x_as_result`](macro@crate::assert_abs_diff_lt_x_as_result)\n* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)\n","links":{"macro@crate::assert_abs_diff_lt_x_as_result":97,"macro@crate::debug_assert_abs_diff_lt_x":98,"macro@crate::assert_abs_diff_lt_x":96,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_lt_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"700":{"id":700,"crate_id":0,"name":"assert_fs_read_to_string_le_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le_x.rs","begin":[277,0],"end":[290,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≤ expr\n\n* If true, return (path_into_string, expr_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_le_x!(path, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"bravo.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_le_x!(path, x);\n# });\n// assertion failed: `assert_fs_read_to_string_le_x!(a_path, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_le_x.html\n//  a_path label: `path`,\n//  a_path debug: `\\\"bravo.txt\\\"`,\n//  b_expr label: `x`,\n//  b_expr debug: `\\\"alfa\\\\n\\\"`,\n//      a string: `\\\"bravo\\\\n\\\"`,\n//      b string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_le_x!(a_path, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_le_x.html\\n\",\n#     \" a_path label: `path`,\\n\",\n#     \" a_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \" b_expr label: `x`,\\n\",\n#     \" b_expr debug: `\\\"alfa\\\\n\\\"`,\\n\",\n#     \"     a string: `bravo\\n`,\\n\",\n#     \"     b string: `alfa\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)\n* [`assert_fs_read_to_string_le_x_as_result`](macro@crate::assert_fs_read_to_string_le_x_as_result)\n* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)\n","links":{"macro@crate::assert_fs_read_to_string_le_x_as_result":701,"macro@crate::debug_assert_fs_read_to_string_le_x":702,"macro@crate::assert_fs_read_to_string_le_x":700,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_le_x {\n    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"423":{"id":423,"crate_id":0,"name":"assert_pending","span":{"filename":"src/assert_pending/mod.rs","begin":[1,0],"end":[21,23]},"visibility":"public","docs":"Assert for Pending items.\n\nThese macros help compare Pending items, such as `::std::Poll::Pending` or similar.\n\nAssert expression is Pending:\n\n* [`assert_pending!(a)`](macro@crate::assert_pending)\n  ≈ a is Pending\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\n\nlet a: Poll<i8> = Pending;\nassert_pending!(a);\n```","links":{"macro@crate::assert_pending":419},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[422],"is_stripped":false}}},"1027":{"id":1027,"crate_id":0,"name":"assert_status_code_value_ge","span":{"filename":"src/assert_status/assert_status_code_value_ge.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_ge!(a, b);\n# });\n// assertion failed: `assert_status_code_value_ge!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_ge.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  b value: `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_ge!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`\\n\",\n#     \"  b code: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)\n* [`assert_status_code_value_ge_as_result`](macro@crate::assert_status_code_value_ge_as_result)\n* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)\n","links":{"macro@crate::assert_status_code_value_ge_as_result":1028,"macro@crate::debug_assert_status_code_value_ge":1029,"macro@crate::assert_status_code_value_ge":1027,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ge {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };\n}"}},"146":{"id":146,"crate_id":0,"name":"debug_assert_diff_lt_x","span":{"filename":"src/assert_diff/assert_diff_lt_x.rs","begin":[463,0],"end":[469,1]},"visibility":"public","docs":"Assert a difference is less than an expression.\n\nPseudocode:<br>\nΔ < x\n\nThis macro provides the same statements as [`assert_diff_lt_x`](macro.assert_diff_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)\n* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)\n* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)\n","links":{"macro@crate::assert_diff_lt_x":144,"macro@crate::assert_diff_lt_x_as_result":145,"macro@crate::debug_assert_diff_lt_x":146},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_diff_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"750":{"id":750,"crate_id":0,"name":"assert_io_read_to_string_ge_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge_x.rs","begin":[264,0],"end":[277,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"aa\");\nassert_io_read_to_string_ge_x!(reader, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_ge_x!(reader, x);\n# });\n// assertion failed: `assert_io_read_to_string_ge_x!(a_reader, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_ge_x.html\n//  a_reader label: `reader`,\n//  a_reader debug: `[97, 108, 102, 97]`,\n//    b_expr label: `x`,\n//    b_expr debug: `\\\"zz\\\"`,\n//               a: `\\\"alfa\\\"`,\n//               b: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_ge_x!(a_reader, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_ge_x.html\\n\",\n#     \" a_reader label: `reader`,\\n\",\n#     \" a_reader debug: `[97, 108, 102, 97]`,\\n\",\n#     \"   b_expr label: `x`,\\n\",\n#     \"   b_expr debug: `\\\"zz\\\"`,\\n\",\n#     \"              a: `\\\"alfa\\\"`,\\n\",\n#     \"              b: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)\n* [`assert_io_read_to_string_ge_x_as_result`](macro@crate::assert_io_read_to_string_ge_x_as_result)\n* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)\n","links":{"macro@crate::assert_io_read_to_string_ge_x":750,"macro@crate::assert_io_read_to_string_ge_x_as_result":751,"macro@crate::debug_assert_io_read_to_string_ge_x":752,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ge_x {\n    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"473":{"id":473,"crate_id":0,"name":"debug_assert_iter_ge","span":{"filename":"src/assert_iter/assert_iter_ge.rs","begin":[273,0],"end":[279,1]},"visibility":"public","docs":"Assert an iterable is greater than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≥ (collection2 into iter)\n\nThis macro provides the same statements as [`assert_iter_ge`](macro.assert_iter_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_iter_ge`](macro@crate::assert_iter_ge)\n* [`assert_iter_ge`](macro@crate::assert_iter_ge)\n* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)\n","links":{"macro@crate::debug_assert_iter_ge":473,"macro@crate::assert_iter_ge":471},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_iter_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"1077":{"id":1077,"crate_id":0,"name":"debug_assert_success_false","span":{"filename":"src/assert_success/assert_success_false.rs","begin":[259,0],"end":[265,1]},"visibility":"public","docs":"Assert a failure method is true.\n\nPseudocode:<br>\na.success() = false\n\nThis macro provides the same statements as [`assert_success_false`](macro.assert_success_false.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_success_false`](macro@crate::assert_success_false)\n* [`assert_success_false`](macro@crate::assert_success_false)\n* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)\n","links":{"macro@crate::assert_success_false":1075,"macro@crate::debug_assert_success_false":1077},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_success_false {\n    ($($arg:tt)*) => { ... };\n}"}},"196":{"id":196,"crate_id":0,"name":"assert_count_ge","span":{"filename":"src/assert_count/assert_count_ge.rs","begin":[1,0],"end":[345,1]},"visibility":"public","docs":"Assert a count is greater than or equal to another.\n\nPseudocode:<br>\na.count() ≥ b.count()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\".chars();\nlet b = \"x\".chars();\nassert_count_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_ge`](macro@crate::assert_count_ge)\n* [`assert_count_ge_as_result`](macro@crate::assert_count_ge_as_result)\n* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)","links":{"macro@crate::assert_count_ge_as_result":194,"macro@crate::debug_assert_count_ge":195,"macro@crate::assert_count_ge":193},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"800":{"id":800,"crate_id":0,"name":"assert_command_stdout_ne","span":{"filename":"src/assert_command/assert_command_stdout_ne.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"alfa\"]);\nassert_command_stdout_ne!(a, b);\n# });\n// assertion failed: `assert_command_stdout_ne!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_ne.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_ne!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b value: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_ne`](macro@crate::assert_command_stdout_ne)\n* [`assert_command_stdout_ne_as_result`](macro@crate::assert_command_stdout_ne_as_result)\n* [`debug_assert_command_stdout_ne`](macro@crate::debug_assert_command_stdout_ne)\n","links":{"macro@crate::assert_command_stdout_ne_as_result":801,"macro@crate::assert_command_stdout_ne":800,"macro@crate::debug_assert_command_stdout_ne":802,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ne {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"523":{"id":523,"crate_id":0,"name":"debug_assert_fn_ge","span":{"filename":"src/assert_fn/assert_fn_ge.rs","begin":[466,0],"end":[472,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\nThis macro provides the same statements as [`assert_fn_ge`](macro.assert_fn_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ge`](macro@crate::assert_fn_ge)\n* [`assert_fn_ge`](macro@crate::assert_fn_ge)\n* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)\n","links":{"macro@crate::assert_fn_ge":521,"macro@crate::debug_assert_fn_ge":523},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"1127":{"id":1127,"crate_id":0,"name":"debug_assert_poll_ready_eq","span":{"filename":"src/assert_poll/assert_poll_ready_eq.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are equal.\n\nDeprecated. Please rename from `debug_assert_poll_ready_eq` into `debug_assert_ready_eq` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_poll_ready_eq` into `debug_assert_ready_eq` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_poll_ready_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"246":{"id":246,"crate_id":0,"name":"assert_email_address","span":{"filename":"src/assert_email_address/mod.rs","begin":[1,0],"end":[17,33]},"visibility":"public","docs":"Assert expression is possibly an email address or not.\n\n* [`assert_email_address!(a)`](macro@crate::assert_email_address) ≈ email_address(a)\n\n* [`assert_not_email_address!(a)`](macro@crate::assert_email_address) ≈ not_email_address(a)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"hello@example.com\";\nassert_email_address!(a);\n```","links":{"macro@crate::assert_email_address":238},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[241,245],"is_stripped":false}}},"850":{"id":850,"crate_id":0,"name":"assert_command_stderr_le","span":{"filename":"src/assert_command/assert_command_stderr_le.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stderr_le`](macro@crate::assert_command_stderr_le)\n* [`assert_command_stderr_le_as_result`](macro@crate::assert_command_stderr_le_as_result)\n* [`debug_assert_command_stderr_le`](macro@crate::debug_assert_command_stderr_le)","links":{"macro@crate::debug_assert_command_stderr_le":849,"macro@crate::assert_command_stderr_le_as_result":848,"macro@crate::assert_command_stderr_le":847},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"573":{"id":573,"crate_id":0,"name":"assert_fn_err_ge","span":{"filename":"src/assert_fn_err/assert_fn_err_ge.rs","begin":[1,0],"end":[533,1]},"visibility":"public","docs":"Assert a function Err(…) is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 20;\nlet b: i8 = 10;\nassert_fn_err_ge!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)\n* [`assert_fn_err_ge_as_result`](macro@crate::assert_fn_err_ge_as_result)\n* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)","links":{"macro@crate::assert_fn_err_ge_as_result":571,"macro@crate::debug_assert_fn_err_ge":572,"macro@crate::assert_fn_err_ge":570},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"296":{"id":296,"crate_id":0,"name":"debug_assert_len_ne","span":{"filename":"src/assert_len/assert_len_ne.rs","begin":[339,0],"end":[345,1]},"visibility":"public","docs":"Assert a length is not equal to another.\n\nPseudocode:<br>\na.len() ≠ b.len()\n\nThis macro provides the same statements as [`assert_len_ne`](macro.assert_len_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_ne`](macro@crate::assert_len_ne)\n* [`assert_len_ne`](macro@crate::assert_len_ne)\n* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)\n","links":{"macro@crate::debug_assert_len_ne":296,"macro@crate::assert_len_ne":294},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"19":{"id":19,"crate_id":0,"name":"assert_lt","span":{"filename":"src/assert_lt.rs","begin":[1,0],"end":[483,1]},"visibility":"public","docs":"Assert an expression is less than another.\n\nPseudocode:<br>\na < b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 1;\nlet b = 2;\nassert_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_lt`](macro@crate::assert_lt)\n* [`assert_lt_as_result`](macro@crate::assert_lt_as_result)\n* [`debug_assert_lt`](macro@crate::debug_assert_lt)","links":{"macro@crate::assert_lt_as_result":17,"macro@crate::debug_assert_lt":18,"macro@crate::assert_lt":16},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"900":{"id":900,"crate_id":0,"name":"assert_program_args_stdout_ge","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge.rs","begin":[356,0],"end":[369,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"a\", \"a\"];\nassert_program_args_stdout_ge!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\"];\nassert_program_args_stdout_ge!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_ge.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stdout\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s%s\\\", \\\"z\\\", \\\"z\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_ge.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s%s\\\", \\\"z\\\", \\\"z\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)\n* [`assert_program_args_stdout_ge_as_result`](macro@crate::assert_program_args_stdout_ge_as_result)\n* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)\n","links":{"macro@crate::assert_program_args_stdout_ge_as_result":901,"macro@crate::assert_program_args_stdout_ge":900,"macro@crate::debug_assert_program_args_stdout_ge":902,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ge {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"623":{"id":623,"crate_id":0,"name":"assert_fn_ok_gt","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt.rs","begin":[359,0],"end":[392,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 2;\nlet b: i8 = 1;\nassert_fn_ok_gt!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_gt!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_ok_gt!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_gt.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `2`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"2\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_gt!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_gt.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `2`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"2\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)\n* [`assert_fn_ok_gt_as_result`](macro@crate::assert_fn_ok_gt_as_result)\n* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)\n","links":{"macro@crate::assert_fn_ok_gt":623,"macro@crate::assert_fn_ok_gt_as_result":624,"macro@crate::debug_assert_fn_ok_gt":625,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_gt {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"346":{"id":346,"crate_id":0,"name":"assert_err_eq_as_result","span":{"filename":"src/assert_err/assert_err_eq.rs","begin":[41,0],"end":[90,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_err_eq`](macro@crate::assert_err_eq)\n* [`assert_err_eq_as_result`](macro@crate::assert_err_eq_as_result)\n* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)\n","links":{"macro@crate::assert_err_eq":345,"macro@crate::assert_err_eq_as_result":346,"macro@crate::debug_assert_err_eq":347},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"69":{"id":69,"crate_id":0,"name":"debug_assert_f64_le","span":{"filename":"src/assert_f64/assert_f64_le.rs","begin":[381,0],"end":[387,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\nThis macro provides the same statements as [`assert_f64_le`](macro.assert_f64_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f64_le`](macro@crate::assert_f64_le)\n* [`assert_f64_le`](macro@crate::assert_f64_le)\n* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)\n","links":{"macro@crate::assert_f64_le":67,"macro@crate::debug_assert_f64_le":69},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f64_le {\n    ($($arg:tt)*) => { ... };\n}"}},"950":{"id":950,"crate_id":0,"name":"assert_program_args_stdout_string_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_is_match.rs","begin":[254,0],"end":[267,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)\n\n* If true, return (a_program + a_args ⇒ command ⇒ stdout ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse regex::Regex;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_program_args_stdout_string_is_match!(program, args, matcher);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet matcher = Regex::new(r\"zz\").expect(\"regex\");\nassert_program_args_stdout_string_is_match!(program, args, matcher);\n# });\n// assertion failed: `assert_program_args_stdout_string_is_match!(a_program, b_matcher)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_string_is_match.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_matcher label: `matcher`,\n//  b_matcher debug: `Regex(\\\"zz\\\")`,\n//                a: `\\\"alfa\\\"`,\n//                b: `Regex(\\\"zz\\\")`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_string_is_match!(a_program, b_matcher)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_string_is_match.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_matcher label: `matcher`,\\n\",\n#     \" b_matcher debug: `Regex(\\\"zz\\\")`,\\n\",\n#     \"               a: `\\\"alfa\\\"`,\\n\",\n#     \"               b: `Regex(\\\"zz\\\")`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)\n* [`assert_program_args_stdout_string_is_match_as_result`](macro@crate::assert_program_args_stdout_string_is_match_as_result)\n* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_program_args_stdout_string_is_match":952,"macro@crate::assert_program_args_stdout_string_is_match":950,"macro@crate::assert_program_args_stdout_string_is_match_as_result":951},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_string_is_match {\n    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $matcher:expr, $($message:tt)+) => { ... };\n}"}},"673":{"id":673,"crate_id":0,"name":"assert_fs_read_to_string_gt_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt.rs","begin":[41,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)\n\n* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)\n* [`assert_fs_read_to_string_gt_as_result`](macro@crate::assert_fs_read_to_string_gt_as_result)\n* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)\n","links":{"macro@crate::assert_fs_read_to_string_gt":672,"macro@crate::debug_assert_fs_read_to_string_gt":674,"macro@crate::assert_fs_read_to_string_gt_as_result":673},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_gt_as_result {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n}"}},"396":{"id":396,"crate_id":0,"name":"assert_option_some_ne","span":{"filename":"src/assert_option/assert_option_some_ne.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nDeprecated. Please rename from `assert_option_some_ne` into `assert_some_ne` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1000":{"id":1000,"crate_id":0,"name":"assert_program_args_stderr_ne_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne_x.rs","begin":[1,0],"end":[406,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'x', b'x'];\nassert_program_args_stderr_ne_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)\n* [`assert_program_args_stderr_ne_x_as_result`](macro@crate::assert_program_args_stderr_ne_x_as_result)\n* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)","links":{"macro@crate::assert_program_args_stderr_ne_x":997,"macro@crate::debug_assert_program_args_stderr_ne_x":999,"macro@crate::assert_program_args_stderr_ne_x_as_result":998},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"119":{"id":119,"crate_id":0,"name":"assert_in_delta","span":{"filename":"src/assert_in/assert_in_delta.rs","begin":[283,0],"end":[296,1]},"visibility":"public","docs":"Assert a number is within delta of another.\n\nPseudocode:<br>\n| a - b | ≤ Δ\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 11;\nlet delta: i8 = 1;\nassert_in_delta!(a, b, delta);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 12;\nlet delta: i8 = 1;\nassert_in_delta!(a, b, delta);\n# });\n// assertion failed: `assert_in_delta!(a, b, Δ)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_in_delta.html\n//        a label: `a`,\n//        a debug: `10`,\n//        b label: `b`,\n//        b debug: `12`,\n//        Δ label: `delta`,\n//        Δ debug: `1`,\n//      | a - b |: `2`,\n//  | a - b | ≤ Δ: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_in_delta!(a, b, Δ)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_in_delta.html\\n\",\n#     \"       a label: `a`,\\n\",\n#     \"       a debug: `10`,\\n\",\n#     \"       b label: `b`,\\n\",\n#     \"       b debug: `12`,\\n\",\n#     \"       Δ label: `delta`,\\n\",\n#     \"       Δ debug: `1`,\\n\",\n#     \"     | a - b |: `2`,\\n\",\n#     \" | a - b | ≤ Δ: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThe macros `assert_in_delta` and `assert_in_epsilon` can test\napproximations:\n\n* For an approximation, the absolute error (i.e. delta) is the magnitude of\n  the difference between the exact value and the approximation. For this,\n use the macro\n\n* For an approximation, the relative error (i.e. epsilon) is the absolute\n  error divided by the magnitude of the exact value. This can be used to\n  compare approximations of numbers of wildly differing size.\n\n* For example, approximating the number 1,000 with an absolute error of 3\n  is, in most applications, much worse than approximating the number\n  1,000,000 with an absolute error of 3; in the first case the relative\n  error is 0.003 and in the second it is only 0.000003.\n\n* Thanks to Ruby minitest for the example and documentation.\n\n# Module macros\n\n* [`assert_in_delta`](macro@crate::assert_in_delta)\n* [`assert_in_delta_as_result`](macro@crate::assert_in_delta_as_result)\n* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)\n","links":{"macro@crate::assert_in_delta":119,"`panic!`":1081,"macro@crate::debug_assert_in_delta":158,"macro@crate::assert_in_delta_as_result":157},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_delta {\n    ($a:expr, $b:expr, $delta:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $delta:expr, $($message:tt)+) => { ... };\n}"}},"723":{"id":723,"crate_id":0,"name":"assert_io_read_to_string_eq_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq.rs","begin":[42,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)\n* [`assert_io_read_to_string_eq_as_result`](macro@crate::assert_io_read_to_string_eq_as_result)\n* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)\n","links":{"macro@crate::assert_io_read_to_string_eq":722,"macro@crate::debug_assert_io_read_to_string_eq":724,"macro@crate::assert_io_read_to_string_eq_as_result":723},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_eq_as_result {\n    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };\n}"}},"446":{"id":446,"crate_id":0,"name":"assert_ready_ne_x_as_result","span":{"filename":"src/assert_ready/assert_ready_ne_x.rs","begin":[45,0],"end":[90,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ b\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_ready_ne_x`](macro.assert_ready_ne_x.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)\n* [`assert_ready_ne_x_as_result`](macro@crate::assert_ready_ne_x_as_result)\n* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)\n","links":{"macro@crate::assert_ready_ne_x":445,"macro@crate::assert_ready_ne_x_as_result":446,"macro@crate::debug_assert_ready_ne_x":447},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_ne_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1050":{"id":1050,"crate_id":0,"name":"assert_status_code_value_eq_x","span":{"filename":"src/assert_status/assert_status_code_value_eq_x.rs","begin":[1,0],"end":[380,1]},"visibility":"public","docs":"Assert a status code value is equal to an expression.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 1;\nassert_status_code_value_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)\n* [`assert_status_code_value_eq_x_as_result`](macro@crate::assert_status_code_value_eq_x_as_result)\n* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)","links":{"macro@crate::assert_status_code_value_eq_x":1047,"macro@crate::assert_status_code_value_eq_x_as_result":1048,"macro@crate::debug_assert_status_code_value_eq_x":1049},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"169":{"id":169,"crate_id":0,"name":"assert_all_as_result","span":{"filename":"src/assert_all.rs","begin":[44,0],"end":[69,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_all`](macro@crate::assert_all)\n* [`assert_all_as_result`](macro@crate::assert_all_as_result)\n* [`debug_assert_all`](macro@crate::debug_assert_all)\n","links":{"macro@crate::debug_assert_all":170,"macro@crate::assert_all":168,"macro@crate::assert_all_as_result":169},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_all_as_result {\n    ($collection:expr, $predicate:expr $(,)?) => { ... };\n}"}},"773":{"id":773,"crate_id":0,"name":"assert_io_read_to_string_contains","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_contains.rs","begin":[1,0],"end":[316,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() contains a pattern.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) contains (expr ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"hello\".as_bytes();\nlet containee = \"ell\";\nassert_io_read_to_string_contains!(reader, containee);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)\n* [`assert_io_read_to_string_contains_as_result`](macro@crate::assert_io_read_to_string_contains_as_result)\n* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)","links":{"macro@crate::debug_assert_io_read_to_string_contains":772,"macro@crate::assert_io_read_to_string_contains":770,"macro@crate::assert_io_read_to_string_contains_as_result":771},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"496":{"id":496,"crate_id":0,"name":"assert_set_ne","span":{"filename":"src/assert_set/assert_set_ne.rs","begin":[205,0],"end":[218,1]},"visibility":"public","docs":"Assert a set is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)\n\n* If true, return `(a_set, b_set)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [3, 4];\nassert_set_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [1, 2];\nassert_set_ne!(a, b);\n# });\n// assertion failed: `assert_set_ne!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_set_ne.html\n//  a label: `a`,\n//  a debug: `[1, 2]`,\n//  b label: `b`,\n//  b debug: `[1, 2]`,\n//        a: `{1, 2}`,\n//        b: `{1, 2}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_set_ne!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_set_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 2]`,\\n\",\n#     \"       a: `{1, 2}`,\\n\",\n#     \"       b: `{1, 2}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_ne`](macro@crate::assert_set_ne)\n* [`assert_set_ne_as_result`](macro@crate::assert_set_ne_as_result)\n* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)\n","links":{"macro@crate::debug_assert_set_ne":498,"macro@crate::assert_set_ne":496,"macro@crate::assert_set_ne_as_result":497,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_ne {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1100":{"id":1100,"crate_id":0,"name":"debug_assert_result_ok","span":{"filename":"src/assert_result/assert_result_ok.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nDeprecated. Please rename from `debug_assert_result_ok` into `debug_assert_ok` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_result_ok` into `debug_assert_ok` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_result_ok {\n    ($($arg:tt)*) => { ... };\n}"}},"219":{"id":219,"crate_id":0,"name":"debug_assert_count_ge_x","span":{"filename":"src/assert_count/assert_count_ge_x.rs","begin":[332,0],"end":[338,1]},"visibility":"public","docs":"Assert a count is greater than or equal to an expression.\n\nPseudocode:<br>\na.count() ≥ b\n\nThis macro provides the same statements as [`assert_count_ge_x`](macro.assert_count_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)\n* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)\n* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)\n","links":{"macro@crate::assert_count_ge_x":217,"macro@crate::debug_assert_count_ge_x":219},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"823":{"id":823,"crate_id":0,"name":"assert_command_stdout_lt_x","span":{"filename":"src/assert_command/assert_command_stdout_lt_x.rs","begin":[1,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stdout string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_lt_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)\n* [`assert_command_stdout_lt_x_as_result`](macro@crate::assert_command_stdout_lt_x_as_result)\n* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)","links":{"macro@crate::debug_assert_command_stdout_lt_x":822,"macro@crate::assert_command_stdout_lt_x":820,"macro@crate::assert_command_stdout_lt_x_as_result":821},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"546":{"id":546,"crate_id":0,"name":"assert_fn_ge_x_as_result","span":{"filename":"src/assert_fn/assert_fn_ge_x.rs","begin":[41,0],"end":[107,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≥ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)\n* [`assert_fn_ge_x_as_result`](macro@crate::assert_fn_ge_x_as_result)\n* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)\n","links":{"macro@crate::debug_assert_fn_ge_x":547,"macro@crate::assert_fn_ge_x_as_result":546,"macro@crate::assert_fn_ge_x":545},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ge_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"1150":{"id":1150,"crate_id":0,"name":"assert_command_stderr_is_match_as_result","span":{"filename":"src/assert_command/assert_command_stderr_is_match.rs","begin":[14,0],"end":[18,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nDeprecated. Please rename from `assert_command_stderr_is_match_as_result`\ninto `assert_command_stderr_string_is_match_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stderr_is_match_as_result` into `assert_command_stderr_string_is_match_as_result`."},"inner":{"macro":"macro_rules! assert_command_stderr_is_match_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"269":{"id":269,"crate_id":0,"name":"assert_not_match","span":{"filename":"src/assert_is_match/assert_not_match.rs","begin":[189,0],"end":[202,1]},"visibility":"public","docs":"Assert an expression (such as a regex) is not a match for an expression (such as a string).\n\nPseudocode:<br>\n¬ a.is_match(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse regex::Regex;\n\n# fn main() {\nlet a = Regex::new(r\"xx\").expect(\"regex\");\nlet b = \"alfa\";\nassert_not_match!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = Regex::new(r\"lf\").expect(\"regex\");\nlet b = \"alfa\";\nassert_not_match!(a, b);\n# });\n// assertion failed: `assert_not_match!(matcher, matchee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_match.html\n//  matcher label: `a`,\n//  matcher debug: `Regex(\\\"lf\\\")`,\n//  matchee label: `b`,\n//  matchee debug: `\\\"alfa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_match!(matcher, matchee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_match.html\\n\",\n#     \" matcher label: `a`,\\n\",\n#     \" matcher debug: `Regex(\\\"lf\\\")`,\\n\",\n#     \" matchee label: `b`,\\n\",\n#     \" matchee debug: `\\\"alfa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_match`](macro@crate::assert_not_match)\n* [`assert_not_match_as_result`](macro@crate::assert_not_match_as_result)\n* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)\n","links":{"macro@crate::assert_not_match":269,"macro@crate::debug_assert_not_match":271,"macro@crate::assert_not_match_as_result":270,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_match {\n    ($matcher:expr, $matchee:expr $(,)?) => { ... };\n    ($matcher:expr, $matchee:expr, $($message:tt)+) => { ... };\n}"}},"873":{"id":873,"crate_id":0,"name":"debug_assert_command_stderr_le_x","span":{"filename":"src/assert_command/assert_command_stderr_le_x.rs","begin":[375,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_le_x`](macro.assert_command_stderr_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)\n* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)\n* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)\n","links":{"macro@crate::debug_assert_command_stderr_le_x":873,"macro@crate::assert_command_stderr_le_x":871},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"596":{"id":596,"crate_id":0,"name":"debug_assert_fn_err_ge_x","span":{"filename":"src/assert_fn_err/assert_fn_err_ge_x.rs","begin":[509,0],"end":[515,1]},"visibility":"public","docs":"Assert a function error is greater than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≥ expr\n\nThis macro provides the same statements as [`assert_fn_err_ge_x`](macro.assert_fn_err_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)\n* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)\n* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)\n","links":{"macro@crate::debug_assert_fn_err_ge_x":596,"macro@crate::assert_fn_err_ge_x":594},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"319":{"id":319,"crate_id":0,"name":"assert_len_ne_x_as_result","span":{"filename":"src/assert_len/assert_len_ne_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a length is not equal to an expression.\n\nPseudocode:<br>\na.len() ≠ b\n\n* If true, return Result `Ok((a.len(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)\n* [`assert_len_ne_x_as_result`](macro@crate::assert_len_ne_x_as_result)\n* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)\n","links":{"macro@crate::debug_assert_len_ne_x":320,"macro@crate::assert_len_ne_x_as_result":319,"macro@crate::assert_len_ne_x":318},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ne_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"923":{"id":923,"crate_id":0,"name":"assert_program_args_stdout_eq_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq_x.rs","begin":[1,0],"end":[409,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stdout_eq_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)\n* [`assert_program_args_stdout_eq_x_as_result`](macro@crate::assert_program_args_stdout_eq_x_as_result)\n* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)","links":{"macro@crate::assert_program_args_stdout_eq_x":920,"macro@crate::debug_assert_program_args_stdout_eq_x":922,"macro@crate::assert_program_args_stdout_eq_x_as_result":921},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"42":{"id":42,"crate_id":0,"name":"assert_f32_le","span":{"filename":"src/assert_f32/assert_f32_le.rs","begin":[317,0],"end":[330,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333331;\nassert_f32_le!(a, b);\n# });\n// assertion failed: `assert_f32_le!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f32_le.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.3333331`,`\n//     diff: `0.00000023841858`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f32_le!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f32_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333331`,\\n\",\n#     \"    diff: `0.00000023841858`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f32_le`](macro@crate::assert_f32_le)\n* [`assert_f32_le_as_result`](macro@crate::assert_f32_le_as_result)\n* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_f32_le":44,"macro@crate::assert_f32_le":42,"macro@crate::assert_f32_le_as_result":43},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_le {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"646":{"id":646,"crate_id":0,"name":"assert_fn_ok_ge_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge_x.rs","begin":[1,0],"end":[515,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 2;\nlet b = String::from(\"1\");\nassert_fn_ok_ge_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)\n* [`assert_fn_ok_ge_x_as_result`](macro@crate::assert_fn_ok_ge_x_as_result)\n* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)","links":{"macro@crate::assert_fn_ok_ge_x_as_result":644,"macro@crate::assert_fn_ok_ge_x":643,"macro@crate::debug_assert_fn_ok_ge_x":645},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"369":{"id":369,"crate_id":0,"name":"assert_ok_eq","span":{"filename":"src/assert_ok/assert_ok_eq.rs","begin":[1,0],"end":[356,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Ok(1);\nlet b: Result<i8, i8> = Ok(1);\nassert_ok_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_ok_eq`](macro@crate::assert_ok_eq)\n* [`assert_ok_eq_as_result`](macro@crate::assert_ok_eq_as_result)\n* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)","links":{"macro@crate::assert_ok_eq":366,"macro@crate::debug_assert_ok_eq":368,"macro@crate::assert_ok_eq_as_result":367},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"973":{"id":973,"crate_id":0,"name":"assert_program_args_stderr_lt","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt.rs","begin":[1,0],"end":[448,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_lt!(a_program, a_args, b_program, b_args);\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)\n* [`assert_program_args_stderr_lt_as_result`](macro@crate::assert_program_args_stderr_lt_as_result)\n* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)","links":{"macro@crate::assert_program_args_stderr_lt_as_result":971,"macro@crate::debug_assert_program_args_stderr_lt":972,"macro@crate::assert_program_args_stderr_lt":970},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"92":{"id":92,"crate_id":0,"name":"assert_abs_diff_le_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le_x.rs","begin":[329,0],"end":[342,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≤ x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 10;\nlet b = 13;\nlet x = 4;\nassert_abs_diff_le_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_le_x!(a, b, x);\n# });\n// assertion failed: `assert_abs_diff_le_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_abs_diff_le_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `2`,\n//      |Δ|: `3`,\n//  |Δ| ≤ x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_abs_diff_le_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_abs_diff_le_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `2`,\\n\",\n#     \"     |Δ|: `3`,\\n\",\n#     \" |Δ| ≤ x: false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)\n* [`assert_abs_diff_le_x_as_result`](macro@crate::assert_abs_diff_le_x_as_result)\n* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)\n","links":{"macro@crate::debug_assert_abs_diff_le_x":94,"macro@crate::assert_abs_diff_le_x":92,"macro@crate::assert_abs_diff_le_x_as_result":93,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_le_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"696":{"id":696,"crate_id":0,"name":"assert_fs_read_to_string_gt_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt_x.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) > expr\n\n* If true, return (path_into_string, expr_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"bravo.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_gt_x!(path, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_gt_x!(path, x);\n# });\n// assertion failed: `assert_fs_read_to_string_gt_x!(a_path, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_gt_x.html\n//  a_path label: `path`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_expr label: `x`,\n//  b_expr debug: `\\\"bravo\\\\n\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `bravo\\\\n`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_gt_x!(a_path, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_gt_x.html\\n\",\n#     \" a_path label: `path`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_expr label: `x`,\\n\",\n#     \" b_expr debug: `\\\"bravo\\\\n\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `bravo\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)\n* [`assert_fs_read_to_string_gt_x_as_result`](macro@crate::assert_fs_read_to_string_gt_x_as_result)\n* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)\n","links":{"macro@crate::assert_fs_read_to_string_gt_x_as_result":697,"`panic!`":1081,"macro@crate::debug_assert_fs_read_to_string_gt_x":698,"macro@crate::assert_fs_read_to_string_gt_x":696},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_gt_x {\n    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"419":{"id":419,"crate_id":0,"name":"assert_pending","span":{"filename":"src/assert_pending/assert_pending.rs","begin":[161,0],"end":[174,1]},"visibility":"public","docs":"Assert an expression is Pending.\n\nPseudocode:<br>\na is Pending\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::task::Poll;\nuse std::task::Poll::*;\n# fn main() {\nlet a: Poll<i8> = Pending;\nassert_pending!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Poll<i8> = Ready(1);\nassert_pending!(a);\n# });\n// assertion failed: `assert_pending!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_pending.html\n//  a label: `a`,\n//  a debug: `Ready(1)`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_pending!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_pending.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ready(1)`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_pending`](macro@crate::assert_pending)\n* [`assert_pending_as_result`](macro@crate::assert_pending_as_result)\n* [`debug_assert_pending`](macro@crate::debug_assert_pending)\n","links":{"macro@crate::debug_assert_pending":421,"macro@crate::assert_pending":419,"macro@crate::assert_pending_as_result":420,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_pending {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"142":{"id":142,"crate_id":0,"name":"debug_assert_diff_le_x","span":{"filename":"src/assert_diff/assert_diff_le_x.rs","begin":[472,0],"end":[478,1]},"visibility":"public","docs":"Assert a difference is less than or equal to an expression.\n\nPseudocode:<br>\nΔ ≤ x\n\nThis macro provides the same statements as [`assert_diff_le_x`](macro.assert_diff_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)\n* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)\n* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)\n","links":{"macro@crate::debug_assert_diff_le_x":142,"macro@crate::assert_diff_le_x_as_result":141,"macro@crate::assert_diff_le_x":140},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_diff_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1023":{"id":1023,"crate_id":0,"name":"assert_status_code_value_eq","span":{"filename":"src/assert_status/assert_status_code_value_eq.rs","begin":[263,0],"end":[276,1]},"visibility":"public","docs":"Assert a status code value is equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_eq!(a, b);\n# });\n// assertion failed: `assert_status_code_value_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_eq.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`,\n//  b value: `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`\\n\",\n#     \"  b code: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)\n* [`assert_status_code_value_eq_as_result`](macro@crate::assert_status_code_value_eq_as_result)\n* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_status_code_value_eq":1025,"macro@crate::assert_status_code_value_eq":1023,"macro@crate::assert_status_code_value_eq_as_result":1024},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_eq {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };\n}"}},"746":{"id":746,"crate_id":0,"name":"assert_io_read_to_string_eq_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq_x.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) = expr\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"alfa\");\nassert_io_read_to_string_eq_x!(reader, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_eq_x!(reader, x);\n# });\n// assertion failed: `assert_io_read_to_string_eq_x!(a_reader, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_eq_x.html\n//  a_reader label: `reader`,\n//  a_reader debug: `[97, 108, 102, 97]`,\n//    b_expr label: `x`,\n//    b_expr debug: `\\\"zz\\\"`,\n//               a: `\\\"alfa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_eq_x!(a_reader, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_eq_x.html\\n\",\n#     \" a_reader label: `reader`,\\n\",\n#     \" a_reader debug: `[97, 108, 102, 97]`,\\n\",\n#     \"   b_expr label: `x`,\\n\",\n#     \"   b_expr debug: `\\\"zz\\\"`,\\n\",\n#     \"              a: `\\\"alfa\\\"`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)\n* [`assert_io_read_to_string_eq_x_as_result`](macro@crate::assert_io_read_to_string_eq_x_as_result)\n* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)\n","links":{"macro@crate::debug_assert_io_read_to_string_eq_x":748,"macro@crate::assert_io_read_to_string_eq_x":746,"macro@crate::assert_io_read_to_string_eq_x_as_result":747,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_eq_x {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"469":{"id":469,"crate_id":0,"name":"debug_assert_iter_eq","span":{"filename":"src/assert_iter/assert_iter_eq.rs","begin":[253,0],"end":[259,1]},"visibility":"public","docs":"Assert an iterable is equal to another.\n\nPseudocode:<br>\n(collection1 into iter) = (collection2 into iter)\n\nThis macro provides the same statements as [`assert_iter_eq`](macro.assert_iter_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_iter_eq`](macro@crate::assert_iter_eq)\n* [`assert_iter_eq`](macro@crate::assert_iter_eq)\n* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)\n","links":{"macro@crate::debug_assert_iter_eq":469,"macro@crate::assert_iter_eq":467},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_iter_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"192":{"id":192,"crate_id":0,"name":"assert_count_eq","span":{"filename":"src/assert_count/assert_count_eq.rs","begin":[1,0],"end":[344,1]},"visibility":"public","docs":"Assert a count is equal to another.\n\nPseudocode:<br>\na.count() = b.count()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = \"x\".chars();\nassert_count_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_eq`](macro@crate::assert_count_eq)\n* [`assert_count_eq_as_result`](macro@crate::assert_count_eq_as_result)\n* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)","links":{"macro@crate::assert_count_eq_as_result":190,"macro@crate::debug_assert_count_eq":191,"macro@crate::assert_count_eq":189},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1073":{"id":1073,"crate_id":0,"name":"debug_assert_success","span":{"filename":"src/assert_success/assert_success.rs","begin":[259,0],"end":[265,1]},"visibility":"public","docs":"Assert a success method is true.\n\nPseudocode:<br>\na.success() = true\n\nThis macro provides the same statements as [`assert_success`](macro.assert_success.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_success`](macro@crate::assert_success)\n* [`assert_success`](macro@crate::assert_success)\n* [`debug_assert_success`](macro@crate::debug_assert_success)\n","links":{"macro@crate::assert_success":1071,"macro@crate::debug_assert_success":1073},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_success {\n    ($($arg:tt)*) => { ... };\n}"}},"796":{"id":796,"crate_id":0,"name":"assert_command_stdout_lt","span":{"filename":"src/assert_command/assert_command_stdout_lt.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a command stdout string is less than another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stdout_lt!(a, b);\n# });\n// assertion failed: `assert_command_stdout_lt!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_lt.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"aa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[97, 997]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_lt!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"aa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_lt`](macro@crate::assert_command_stdout_lt)\n* [`assert_command_stdout_lt_as_result`](macro@crate::assert_command_stdout_lt_as_result)\n* [`debug_assert_command_stdout_lt`](macro@crate::debug_assert_command_stdout_lt)\n","links":{"macro@crate::assert_command_stdout_lt_as_result":797,"macro@crate::debug_assert_command_stdout_lt":798,"macro@crate::assert_command_stdout_lt":796,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_lt {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"519":{"id":519,"crate_id":0,"name":"debug_assert_fn_eq","span":{"filename":"src/assert_fn/assert_fn_eq.rs","begin":[430,0],"end":[436,1]},"visibility":"public","docs":"Assert a function output is equal to another.\n\nPseudocode:<br>\na_function(a) == b_function(b)\n\nThis macro provides the same statements as [`assert_fn_eq`](macro.assert_fn_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_eq`](macro@crate::assert_fn_eq)\n* [`assert_fn_eq`](macro@crate::assert_fn_eq)\n* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)\n","links":{"macro@crate::assert_fn_eq":517,"macro@crate::debug_assert_fn_eq":519},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"242":{"id":242,"crate_id":0,"name":"assert_not_email_address","span":{"filename":"src/assert_email_address/assert_not_email_address.rs","begin":[298,0],"end":[311,1]},"visibility":"public","docs":"Assert expression is possibly not an email address.\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"hello*example.com\";\nassert_not_email_address!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"hello@example.com\";\nassert_not_email_address!(a);\n# });\n// assertion failed: `assert_not_email_address!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_email_address.html\n//  Email address has local part with valid length 1..64, then an '@' sign, then a domain part with valid length 1..255.\n//  a label: `a`,\n//  a debug: `\\\"hello@example.com\\\"`,\n//  a: `hello@example.com`,\n//  local part length: 5,\n//  domain part length: 11\",\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_email_address!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_email_address.html\\n\",\n#     \" email address has local part with valid length 1..64, then an '@' sign, then a domain part with valid length 1..255.\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"hello@example.com\\\"`,\\n\",\n#     \" a: `hello@example.com`,\\n\",\n#     \" local part length: 5,\\n\",\n#     \" domain part length: 11\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_email_address`](macro@crate::assert_not_email_address)\n* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)\n* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)\n","links":{"macro@crate::debug_assert_not_email_address":244,"macro@crate::assert_not_email_address_as_result":243,"macro@crate::assert_not_email_address":242,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_email_address {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"1123":{"id":1123,"crate_id":0,"name":"assert_poll_ready","span":{"filename":"src/assert_poll/assert_poll_ready.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nDeprecated. Please rename from `assert_poll_ready` into `assert_ready` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_ready` into `assert_ready` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_ready {\n    ($($arg:tt)*) => { ... };\n}"}},"846":{"id":846,"crate_id":0,"name":"assert_command_stderr_gt","span":{"filename":"src/assert_command/assert_command_stderr_gt.rs","begin":[1,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stderr string is greater than another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stderr_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stderr_gt`](macro@crate::assert_command_stderr_gt)\n* [`assert_command_stderr_gt_as_result`](macro@crate::assert_command_stderr_gt_as_result)\n* [`debug_assert_command_stderr_gt`](macro@crate::debug_assert_command_stderr_gt)","links":{"macro@crate::debug_assert_command_stderr_gt":845,"macro@crate::assert_command_stderr_gt":843,"macro@crate::assert_command_stderr_gt_as_result":844},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"569":{"id":569,"crate_id":0,"name":"assert_fn_err_eq","span":{"filename":"src/assert_fn_err/assert_fn_err_eq.rs","begin":[1,0],"end":[498,1]},"visibility":"public","docs":"Assert a function Err(…) is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b: i8 = 10;\nassert_fn_err_eq!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)\n* [`assert_fn_err_eq_as_result`](macro@crate::assert_fn_err_eq_as_result)\n* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)","links":{"macro@crate::assert_fn_err_eq":566,"macro@crate::debug_assert_fn_err_eq":568,"macro@crate::assert_fn_err_eq_as_result":567},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"292":{"id":292,"crate_id":0,"name":"debug_assert_len_lt","span":{"filename":"src/assert_len/assert_len_lt.rs","begin":[338,0],"end":[344,1]},"visibility":"public","docs":"Assert a length is less than another.\n\nPseudocode:<br>\na.len() < b.len()\n\nThis macro provides the same statements as [`assert_len_lt`](macro.assert_len_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_lt`](macro@crate::assert_len_lt)\n* [`assert_len_lt`](macro@crate::assert_len_lt)\n* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)\n","links":{"macro@crate::assert_len_lt":290,"macro@crate::debug_assert_len_lt":292},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"15":{"id":15,"crate_id":0,"name":"assert_le","span":{"filename":"src/assert_le.rs","begin":[1,0],"end":[491,1]},"visibility":"public","docs":"Assert an expression is less than or equal to another.\n\nPseudocode:<br>\na ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 1;\nlet b = 2;\nassert_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_le`](macro@crate::assert_le)\n* [`assert_le_as_result`](macro@crate::assert_le_as_result)\n* [`debug_assert_le`](macro@crate::debug_assert_le)","links":{"macro@crate::assert_le":12,"macro@crate::assert_le_as_result":13,"macro@crate::debug_assert_le":14},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"896":{"id":896,"crate_id":0,"name":"assert_program_args_stdout_eq","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq.rs","begin":[313,0],"end":[326,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"];\nassert_program_args_stdout_eq!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\" ];\nassert_program_args_stdout_eq!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_eq.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stdout\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s%s\\\", \\\"z\\\", \\\"z\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_eq.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s%s\\\", \\\"z\\\", \\\"z\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)\n* [`assert_program_args_stdout_eq_as_result`](macro@crate::assert_program_args_stdout_eq_as_result)\n* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)\n","links":{"macro@crate::assert_program_args_stdout_eq":896,"macro@crate::debug_assert_program_args_stdout_eq":898,"macro@crate::assert_program_args_stdout_eq_as_result":897,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_eq {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"619":{"id":619,"crate_id":0,"name":"assert_fn_ok_ge","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge.rs","begin":[339,0],"end":[372,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 2;\nlet b: i8 = 1;\nassert_fn_ok_ge!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_ge!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_ok_ge!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_ge.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `2`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"2\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_ge!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_ge.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `2`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"2\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)\n* [`assert_fn_ok_ge_as_result`](macro@crate::assert_fn_ok_ge_as_result)\n* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fn_ok_ge":621,"macro@crate::assert_fn_ok_ge_as_result":620,"macro@crate::assert_fn_ok_ge":619},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ge {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"342":{"id":342,"crate_id":0,"name":"assert_err_as_result","span":{"filename":"src/assert_err/assert_err.rs","begin":[40,0],"end":[60,1]},"visibility":"public","docs":"Assert expression is Err.\n\nPseudocode:<br>\na is Err(a1)\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_err`](macro@crate::assert_err)\n* [`assert_err_as_result`](macro@crate::assert_err_as_result)\n* [`debug_assert_err`](macro@crate::debug_assert_err)\n","links":{"macro@crate::debug_assert_err":343,"macro@crate::assert_err":341,"macro@crate::assert_err_as_result":342},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"65":{"id":65,"crate_id":0,"name":"debug_assert_f64_gt","span":{"filename":"src/assert_f64/assert_f64_gt.rs","begin":[321,0],"end":[327,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is greater than another within f64::EPSILON.\n\nPseudocode:<br>\na > b\n\nThis macro provides the same statements as [`assert_f64_gt`](macro.assert_f64_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f64_gt`](macro@crate::assert_f64_gt)\n* [`assert_f64_gt`](macro@crate::assert_f64_gt)\n* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)\n","links":{"macro@crate::assert_f64_gt":63,"macro@crate::debug_assert_f64_gt":65},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f64_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"946":{"id":946,"crate_id":0,"name":"assert_program_args_stdout_string_contains","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_contains.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) contains (expr into string)\n\n* If true, return (a_program + a_args ⇒ command ⇒ stdout ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\nThis uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.\n\n* The containee can be a &str, char, a slice of chars, or a function or\nclosure that determines if a character contains.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet containee = \"lf\";\nassert_program_args_stdout_string_contains!(program, args, containee);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet containee = \"zz\";\nassert_program_args_stdout_string_contains!(program, args, containee);\n# });\n// assertion failed: `assert_program_args_stdout_string_contains!(a_program, a_args, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_string_contains.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  containee label: `containee`,\n//  containee debug: `\\\"zz\\\"`,\n//                a: `\\\"alfa\\\"`,\n//                b: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_string_contains!(a_program, a_args, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_string_contains.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" containee label: `containee`,\\n\",\n#     \" containee debug: `\\\"zz\\\"`,\\n\",\n#     \"               a: `\\\"alfa\\\"`,\\n\",\n#     \"               b: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)\n* [`assert_program_args_stdout_string_contains_as_result`](macro@crate::assert_program_args_stdout_string_contains_as_result)\n* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)\n","links":{"macro@crate::assert_program_args_stdout_string_contains_as_result":947,"macro@crate::assert_program_args_stdout_string_contains":946,"macro@crate::debug_assert_program_args_stdout_string_contains":948,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_string_contains {\n    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"669":{"id":669,"crate_id":0,"name":"assert_fs_read_to_string_ge_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge.rs","begin":[41,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)\n\n* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)\n* [`assert_fs_read_to_string_ge_as_result`](macro@crate::assert_fs_read_to_string_ge_as_result)\n* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)\n","links":{"macro@crate::assert_fs_read_to_string_ge_as_result":669,"macro@crate::debug_assert_fs_read_to_string_ge":670,"macro@crate::assert_fs_read_to_string_ge":668},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ge_as_result {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n}"}},"392":{"id":392,"crate_id":0,"name":"assert_none","span":{"filename":"src/assert_none/mod.rs","begin":[1,0],"end":[19,20]},"visibility":"public","docs":"Assert for None items.\n\nThese macros help compare None items, such as `::std::Option::None` or similar.\n\nAssert expression is None:\n\n* [`assert_none!(a)`](macro@crate::assert_none)\n  ≈ a is None\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::None;\nassert_none!(a);\n```","links":{"macro@crate::assert_none":388},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[391],"is_stripped":false}}},"996":{"id":996,"crate_id":0,"name":"assert_program_args_stderr_lt_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt_x.rs","begin":[1,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_lt_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)\n* [`assert_program_args_stderr_lt_x_as_result`](macro@crate::assert_program_args_stderr_lt_x_as_result)\n* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)","links":{"macro@crate::debug_assert_program_args_stderr_lt_x":995,"macro@crate::assert_program_args_stderr_lt_x_as_result":994,"macro@crate::assert_program_args_stderr_lt_x":993},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"115":{"id":115,"crate_id":0,"name":"assert_abs_diff_ge","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge.rs","begin":[25,0],"end":[29,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_ge` into `assert_abs_diff_ge_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_ge` into `assert_abs_diff_ge_x`."},"inner":{"macro":"macro_rules! assert_abs_diff_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"719":{"id":719,"crate_id":0,"name":"assert_fs_read_to_string_is_match","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_is_match.rs","begin":[1,0],"end":[342,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) matches expr\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet path = \"alfa.txt\";\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_fs_read_to_string_is_match!(path, matcher);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)\n* [`assert_fs_read_to_string_is_match_as_result`](macro@crate::assert_fs_read_to_string_is_match_as_result)\n* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)","links":{"macro@crate::assert_fs_read_to_string_is_match_as_result":717,"macro@crate::debug_assert_fs_read_to_string_is_match":718,"macro@crate::assert_fs_read_to_string_is_match":716},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"442":{"id":442,"crate_id":0,"name":"assert_ready_eq_x_as_result","span":{"filename":"src/assert_ready/assert_ready_eq_x.rs","begin":[45,0],"end":[90,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = b\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_ready_eq_x`](macro.assert_ready_eq_x.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)\n* [`assert_ready_eq_x_as_result`](macro@crate::assert_ready_eq_x_as_result)\n* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)\n","links":{"macro@crate::debug_assert_ready_eq_x":443,"macro@crate::assert_ready_eq_x_as_result":442,"macro@crate::assert_ready_eq_x":441},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_eq_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1046":{"id":1046,"crate_id":0,"name":"assert_status_code_value_ne","span":{"filename":"src/assert_status/assert_status_code_value_ne.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne_as_result`](macro@crate::assert_status_code_value_ne_as_result)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)","links":{"macro@crate::assert_status_code_value_ne_as_result":1044,"macro@crate::assert_status_code_value_ne":1043,"macro@crate::debug_assert_status_code_value_ne":1045},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"165":{"id":165,"crate_id":0,"name":"debug_assert_in_range","span":{"filename":"src/assert_in/assert_in_range.rs","begin":[325,0],"end":[331,1]},"visibility":"public","docs":"Assert an item is in a range.\n\nPseudocode:<br>\na is in range\n\nThis macro provides the same statements as [`assert_in_range`](macro.assert_in_range.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_in_range`](macro@crate::assert_in_range)\n* [`assert_in_range`](macro@crate::assert_in_range)\n* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)\n","links":{"macro@crate::assert_in_range":163,"macro@crate::debug_assert_in_range":165},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_in_range {\n    ($($arg:tt)*) => { ... };\n}"}},"769":{"id":769,"crate_id":0,"name":"assert_io_read_to_string_ne_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne_x.rs","begin":[1,0],"end":[362,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_ne_x!(reader, x);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)\n* [`assert_io_read_to_string_ne_x_as_result`](macro@crate::assert_io_read_to_string_ne_x_as_result)\n* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)","links":{"macro@crate::assert_io_read_to_string_ne_x":766,"macro@crate::assert_io_read_to_string_ne_x_as_result":767,"macro@crate::debug_assert_io_read_to_string_ne_x":768},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"492":{"id":492,"crate_id":0,"name":"assert_set_eq","span":{"filename":"src/assert_set/assert_set_eq.rs","begin":[207,0],"end":[220,1]},"visibility":"public","docs":"Assert a set is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) = (b_collection ⇒ b_set)\n\n* If true, return `(a_set, b_set)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [2, 1];\nassert_set_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [3, 4];\nassert_set_eq!(a, b);\n# });\n// assertion failed: `assert_set_eq!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_set_eq.html\n//  a label: `a`,\n//  a debug: `[1, 2]`,\n//  b label: `b`,\n//  b debug: `[3, 4]`,\n//        a: `{1, 2}`,\n//        b: `{3, 4}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_set_eq!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_set_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[3, 4]`,\\n\",\n#     \"       a: `{1, 2}`,\\n\",\n#     \"       b: `{3, 4}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_eq`](macro@crate::assert_set_eq)\n* [`assert_set_eq_as_result`](macro@crate::assert_set_eq_as_result)\n* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)\n","links":{"macro@crate::debug_assert_set_eq":494,"macro@crate::assert_set_eq":492,"macro@crate::assert_set_eq_as_result":493,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_eq {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"215":{"id":215,"crate_id":0,"name":"debug_assert_count_eq_x","span":{"filename":"src/assert_count/assert_count_eq_x.rs","begin":[329,0],"end":[335,1]},"visibility":"public","docs":"Assert a count is equal to an expression.\n\nPseudocode:<br>\na.count() = b\n\nThis macro provides the same statements as [`assert_count_eq_x`](macro.assert_count_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)\n* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)\n* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)\n","links":{"macro@crate::debug_assert_count_eq_x":215,"macro@crate::assert_count_eq_x":213},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1096":{"id":1096,"crate_id":0,"name":"assert_result_err","span":{"filename":"src/assert_result/assert_result_err.rs","begin":[26,0],"end":[30,1]},"visibility":"public","docs":"Assert expression is Err.\n\nDeprecated. Please rename from `assert_result_err` into `assert_err` because more developers prefer the shorter name.","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_err` into `assert_err` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_err {\n    ($($arg:tt)*) => { ... };\n}"}},"819":{"id":819,"crate_id":0,"name":"assert_command_stdout_le_x","span":{"filename":"src/assert_command/assert_command_stdout_le_x.rs","begin":[1,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_le_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)\n* [`assert_command_stdout_le_x_as_result`](macro@crate::assert_command_stdout_le_x_as_result)\n* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)","links":{"macro@crate::assert_command_stdout_le_x":816,"macro@crate::assert_command_stdout_le_x_as_result":817,"macro@crate::debug_assert_command_stdout_le_x":818},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"542":{"id":542,"crate_id":0,"name":"assert_fn_eq_x_as_result","span":{"filename":"src/assert_fn/assert_fn_eq_x.rs","begin":[41,0],"end":[107,1]},"visibility":"public","docs":"Assert a function output is equal to an expression.\n\nPseudocode:<br>\nfunction(a) = b\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)\n* [`assert_fn_eq_x_as_result`](macro@crate::assert_fn_eq_x_as_result)\n* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)\n","links":{"macro@crate::assert_fn_eq_x":541,"macro@crate::debug_assert_fn_eq_x":543,"macro@crate::assert_fn_eq_x_as_result":542},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_eq_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"265":{"id":265,"crate_id":0,"name":"assert_is_match","span":{"filename":"src/assert_is_match/assert_is_match.rs","begin":[189,0],"end":[202,1]},"visibility":"public","docs":"Assert a matcher is a match for an expression.\n\nPseudocode:<br>\na.is_match(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse regex::Regex;\n\n# fn main() {\nlet a = Regex::new(r\"lf\").expect(\"regex\");\nlet b = \"alfa\";\nassert_is_match!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = Regex::new(r\"xx\").expect(\"regex\");\nlet b = \"alfa\";\nassert_is_match!(a, b);\n# });\n// assertion failed: `assert_is_match!(matcher, matchee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_is_match.html\n//  matcher label: `a`,\n//  matcher debug: `Regex(\\\"xx\\\")`,\n//  matchee label: `b`,\n//  matchee debug: `\\\"alfa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_is_match!(matcher, matchee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_is_match.html\\n\",\n#     \" matcher label: `a`,\\n\",\n#     \" matcher debug: `Regex(\\\"xx\\\")`,\\n\",\n#     \" matchee label: `b`,\\n\",\n#     \" matchee debug: `\\\"alfa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_is_match`](macro@crate::assert_is_match)\n* [`assert_is_match_as_result`](macro@crate::assert_is_match_as_result)\n* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)\n","links":{"macro@crate::assert_is_match":265,"macro@crate::debug_assert_is_match":267,"macro@crate::assert_is_match_as_result":266,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_is_match {\n    ($matcher:expr, $matchee:expr $(,)?) => { ... };\n    ($matcher:expr, $matchee:expr, $($message:tt)+) => { ... };\n}"}},"1146":{"id":1146,"crate_id":0,"name":"debug_assert_command_stdout_is_match","span":{"filename":"src/assert_command/assert_command_stdout_is_match.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nDeprecated. Please rename from `debug_assert_command_stdout_is_match` into `debug_assert_command_stdout_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_command_stdout_is_match` into `debug_assert_command_stdout_string_is_match`."},"inner":{"macro":"macro_rules! debug_assert_command_stdout_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"869":{"id":869,"crate_id":0,"name":"debug_assert_command_stderr_gt_x","span":{"filename":"src/assert_command/assert_command_stderr_gt_x.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stderr string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_gt_x`](macro.assert_command_stderr_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)\n* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)\n* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)\n","links":{"macro@crate::assert_command_stderr_gt_x":867,"macro@crate::debug_assert_command_stderr_gt_x":869},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"592":{"id":592,"crate_id":0,"name":"debug_assert_fn_err_eq_x","span":{"filename":"src/assert_fn_err/assert_fn_err_eq_x.rs","begin":[465,0],"end":[471,1]},"visibility":"public","docs":"Assert a function error is equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) = expr\n\nThis macro provides the same statements as [`assert_fn_err_eq_x`](macro.assert_fn_err_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)\n* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)\n* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)\n","links":{"macro@crate::assert_fn_err_eq_x":590,"macro@crate::debug_assert_fn_err_eq_x":592},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"315":{"id":315,"crate_id":0,"name":"assert_len_lt_x_as_result","span":{"filename":"src/assert_len/assert_len_lt_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a length is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\n* If true, return Result `Ok((a.len(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)\n* [`assert_len_lt_x_as_result`](macro@crate::assert_len_lt_x_as_result)\n* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)\n","links":{"macro@crate::debug_assert_len_lt_x":316,"macro@crate::assert_len_lt_x_as_result":315,"macro@crate::assert_len_lt_x":314},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_lt_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"919":{"id":919,"crate_id":0,"name":"assert_program_args_stdout_ne","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne.rs","begin":[1,0],"end":[468,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (b_program + b_args ⇒ command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\" ];\nassert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)\n* [`assert_program_args_stdout_ne_as_result`](macro@crate::assert_program_args_stdout_ne_as_result)\n* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)","links":{"macro@crate::assert_program_args_stdout_ne":916,"macro@crate::debug_assert_program_args_stdout_ne":918,"macro@crate::assert_program_args_stdout_ne_as_result":917},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"38":{"id":38,"crate_id":0,"name":"assert_f32_gt","span":{"filename":"src/assert_f32/assert_f32_gt.rs","begin":[257,0],"end":[270,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is greater than another within f32::EPSILON.\n\nPseudocode:<br>\na > b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333331;\nassert_f32_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_gt!(a, b);\n# });\n// assertion failed: `assert_f32_gt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f32_gt.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.3333336`,`\n//     diff: `-0.00000029802322`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f32_gt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f32_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333336`,\\n\",\n#     \"    diff: `-0.0000002682209`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f32_gt`](macro@crate::assert_f32_gt)\n* [`assert_f32_gt_as_result`](macro@crate::assert_f32_gt_as_result)\n* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)\n","links":{"macro@crate::assert_f32_gt":38,"macro@crate::debug_assert_f32_gt":40,"macro@crate::assert_f32_gt_as_result":39,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_gt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"642":{"id":642,"crate_id":0,"name":"assert_fn_ok_eq_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq_x.rs","begin":[1,0],"end":[477,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b = String::from(\"1\");\nassert_fn_ok_eq_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)\n* [`assert_fn_ok_eq_x_as_result`](macro@crate::assert_fn_ok_eq_x_as_result)\n* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)","links":{"macro@crate::debug_assert_fn_ok_eq_x":641,"macro@crate::assert_fn_ok_eq_x":639,"macro@crate::assert_fn_ok_eq_x_as_result":640},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"365":{"id":365,"crate_id":0,"name":"assert_ok","span":{"filename":"src/assert_ok/assert_ok.rs","begin":[1,0],"end":[247,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nPseudocode:<br>\na is Ok.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Ok(1);\nassert_ok!(a);\n```\n\n# Module macros\n\n* [`assert_ok`](macro@crate::assert_ok)\n* [`assert_ok_as_result`](macro@crate::assert_ok_as_result)\n* [`debug_assert_ok`](macro@crate::debug_assert_ok)","links":{"macro@crate::assert_ok":362,"macro@crate::assert_ok_as_result":363,"macro@crate::debug_assert_ok":364},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"969":{"id":969,"crate_id":0,"name":"assert_program_args_stderr_le","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le.rs","begin":[1,0],"end":[471,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_le!(a_program, a_args, b_program, b_args);\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)\n* [`assert_program_args_stderr_le_as_result`](macro@crate::assert_program_args_stderr_le_as_result)\n* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)","links":{"macro@crate::assert_program_args_stderr_le":966,"macro@crate::debug_assert_program_args_stderr_le":968,"macro@crate::assert_program_args_stderr_le_as_result":967},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"88":{"id":88,"crate_id":0,"name":"assert_abs_diff_gt_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt_x.rs","begin":[299,0],"end":[312,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nPseudocode:<br>\n|Δ| > x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_gt_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 10;\nlet b = 13;\nlet x = 4;\nassert_abs_diff_gt_x!(a, b, x);\n# });\n// assertion failed: `assert_abs_diff_gt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_abs_diff_gt_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `4`,\n//      |Δ|: `3`,\n//  |Δ| > x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_abs_diff_gt_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_abs_diff_gt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `4`,\\n\",\n#     \"     |Δ|: `3`,\\n\",\n#     \" |Δ| > x: false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)\n* [`assert_abs_diff_gt_x_as_result`](macro@crate::assert_abs_diff_gt_x_as_result)\n* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)\n","links":{"macro@crate::debug_assert_abs_diff_gt_x":90,"macro@crate::assert_abs_diff_gt_x":88,"macro@crate::assert_abs_diff_gt_x_as_result":89,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_gt_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"692":{"id":692,"crate_id":0,"name":"assert_fs_read_to_string_ge_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge_x.rs","begin":[277,0],"end":[290,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≥ expr\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"bravo.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_ge_x!(path, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_ge_x!(path, x);\n# });\n// assertion failed: `assert_fs_read_to_string_ge_x!(a_path, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_ge_x.html\n//  a_path label: `path`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_expr label: `x`,\n//  b_expr debug: `\\\"bravo\\\\n\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `bravo\\\\n`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_ge_x!(a_path, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_ge_x.html\\n\",\n#     \" a_path label: `path`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_expr label: `x`,\\n\",\n#     \" b_expr debug: `\\\"bravo\\\\n\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `bravo\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)\n* [`assert_fs_read_to_string_ge_x_as_result`](macro@crate::assert_fs_read_to_string_ge_x_as_result)\n* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)\n","links":{"`panic!`":1081,"macro@crate::assert_fs_read_to_string_ge_x":692,"macro@crate::debug_assert_fs_read_to_string_ge_x":694,"macro@crate::assert_fs_read_to_string_ge_x_as_result":693},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ge_x {\n    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"415":{"id":415,"crate_id":0,"name":"assert_some_ne_x_as_result","span":{"filename":"src/assert_some/assert_some_ne_x.rs","begin":[44,0],"end":[89,1]},"visibility":"public","docs":"Assert a.is_some() and a.unwrap() are equal to another.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ b\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_some_ne_x`](macro.assert_some_ne_x.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)\n* [`assert_some_ne_x_as_result`](macro@crate::assert_some_ne_x_as_result)\n* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)\n","links":{"macro@crate::debug_assert_some_ne_x":416,"macro@crate::assert_some_ne_x":414,"macro@crate::assert_some_ne_x_as_result":415},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_ne_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"138":{"id":138,"crate_id":0,"name":"debug_assert_diff_gt_x","span":{"filename":"src/assert_diff/assert_diff_gt_x.rs","begin":[463,0],"end":[469,1]},"visibility":"public","docs":"Assert a difference is greater than an expression.\n\nPseudocode:<br>\nΔ > x\n\nThis macro provides the same statements as [`assert_diff_gt_x`](macro.assert_diff_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)\n* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)\n* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)\n","links":{"macro@crate::assert_diff_gt_x_as_result":137,"macro@crate::assert_diff_gt_x":136,"macro@crate::debug_assert_diff_gt_x":138},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_diff_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1019":{"id":1019,"crate_id":0,"name":"assert_status_failure","span":{"filename":"src/assert_status/assert_status_failure.rs","begin":[180,0],"end":[193,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nassert_status_failure!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"0\");\nassert_status_failure!(a);\n# });\n// assertion failed: `assert_status_failure!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_failure.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"0\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_failure!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_failure.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"0\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_failure`](macro@crate::assert_status_failure)\n* [`assert_status_failure_as_result`](macro@crate::assert_status_failure_as_result)\n* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)\n","links":{"macro@crate::assert_status_failure":1019,"macro@crate::assert_status_failure_as_result":1020,"macro@crate::debug_assert_status_failure":1021,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_failure {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"742":{"id":742,"crate_id":0,"name":"assert_io_read_to_string_ne","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\".as_bytes();\nlet b = \"alfa\".as_bytes();\nassert_io_read_to_string_ne!(a, b);\n# });\n// assertion failed: `assert_io_read_to_string_ne!(a_reader, b_reader)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_ne.html\n//  a label: `a`,\n//  a debug: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `[97, 108, 102, 97]`,\n//        a: `\\\"alfa\\\"`,\n//        b: `\\\"alfa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_ne!(a_reader, b_reader)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[97, 108, 102, 97]`,\\n\",\n#     \"       a: `\\\"alfa\\\"`,\\n\",\n#     \"       b: `\\\"alfa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)\n* [`assert_io_read_to_string_ne_as_result`](macro@crate::assert_io_read_to_string_ne_as_result)\n* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)\n","links":{"macro@crate::assert_io_read_to_string_ne_as_result":743,"macro@crate::assert_io_read_to_string_ne":742,"macro@crate::debug_assert_io_read_to_string_ne":744,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ne {\n    ($a_reader:expr, $b:expr $(,)?) => { ... };\n    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"465":{"id":465,"crate_id":0,"name":"assert_bag_superbag","span":{"filename":"src/assert_bag/assert_bag_superbag.rs","begin":[1,0],"end":[361,1]},"visibility":"public","docs":"Assert a bag is a superbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 1, 1];\nlet b = [1, 1];\nassert_bag_superbag!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)\n* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)\n* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)","links":{"macro@crate::assert_bag_superbag_as_result":463,"macro@crate::debug_assert_bag_superbag":464,"macro@crate::assert_bag_superbag":462},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"188":{"id":188,"crate_id":0,"name":"assert_contains","span":{"filename":"src/assert_contains/mod.rs","begin":[1,0],"end":[36,28]},"visibility":"public","docs":"Assert for a container and a containee.\n\nThese macros help with comparison of a container (such as a string, array, range)\nand a containee (such as a string substring, an array element, a range value).\n\n* [`assert_contains(container, containee)`](macro@crate::assert_contains) ≈ container.contains(containee)\n\n* [`assert_not_contains!(container, containee)`](macro@crate::assert_not_contains) ≈ !container.contains(containee)\n\nThese macros work with many kinds of Rust types, such as String, Vec, Range, HashSet.\nThe specifics depend on each type's implementation of a method `contains`, and some types\nrequire the second argument to be borrowable, so be sure to check the Rust documentation.\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String contains substring\nlet a: &str = \"alfa\";\nlet b: &str = \"lf\";\nassert_contains!(a, b);\n\n// Range contains value\nlet a = 1..3;\nlet b = 2;\nassert_contains!(a, &b); // Borrow\n\n// Vector contains &element\nlet a = vec![1, 2, 3];\nlet b = 2;\nassert_contains!(a, &b); // Borrow\n```","links":{"macro@crate::assert_contains":180,"macro@crate::assert_not_contains":184},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[183,187],"is_stripped":false}}},"1069":{"id":1069,"crate_id":0,"name":"assert_status_code_value_ne_x","span":{"filename":"src/assert_status/assert_status_code_value_ne_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 1;\nassert_status_code_value_ne_x!(a, b);\n# });\n// assertion failed: `assert_status_code_value_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_ne_x.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne_x_as_result`](macro@crate::assert_status_code_value_ne_x_as_result)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)\n","links":{"macro@crate::debug_assert_status_code_value_ne":1045,"macro@crate::assert_status_code_value_ne_x_as_result":1067,"macro@crate::assert_status_code_value_ne":1043,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ne_x {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"792":{"id":792,"crate_id":0,"name":"assert_command_stdout_le","span":{"filename":"src/assert_command/assert_command_stdout_le.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stdout_le!(a, b);\n# });\n// assertion failed: `assert_command_stdout_le!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_le.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"aa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_le!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"aa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_le`](macro@crate::assert_command_stdout_le)\n* [`assert_command_stdout_le_as_result`](macro@crate::assert_command_stdout_le_as_result)\n* [`debug_assert_command_stdout_le`](macro@crate::debug_assert_command_stdout_le)\n","links":{"macro@crate::assert_command_stdout_le_as_result":793,"macro@crate::debug_assert_command_stdout_le":794,"macro@crate::assert_command_stdout_le":792,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_le {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"515":{"id":515,"crate_id":0,"name":"assert_set_superset","span":{"filename":"src/assert_set/assert_set_superset.rs","begin":[1,0],"end":[306,1]},"visibility":"public","docs":"Assert a set is a superset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2, 3];\nlet b = [1, 2];\nassert_set_superset!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_superset`](macro@crate::assert_set_superset)\n* [`assert_set_superset_as_result`](macro@crate::assert_set_superset_as_result)\n* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)","links":{"macro@crate::debug_assert_set_superset":514,"macro@crate::assert_set_superset":512,"macro@crate::assert_set_superset_as_result":513},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"238":{"id":238,"crate_id":0,"name":"assert_email_address","span":{"filename":"src/assert_email_address/assert_email_address.rs","begin":[339,0],"end":[352,1]},"visibility":"public","docs":"Assert expression is possibly an email address.\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"hello@example.com\";\nassert_email_address!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"hello*example.com\";\nassert_email_address!(a);\n# });\n// assertion failed: `assert_email_address!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_email_address.html\n//  Email address must contain an '@' at sign.\n//  a label: `a`,\n//  a debug: `\\\"hello*example.com\\\"`,\n//  a: `hello*example.com`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_email_address!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_email_address.html\\n\",\n#     \" email address must contain an '@' at sign.\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"hello*example.com\\\"`,\\n\",\n#     \" a: `hello*example.com`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_email_address`](macro@crate::assert_email_address)\n* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)\n* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)\n","links":{"macro@crate::assert_email_address_as_result":239,"macro@crate::debug_assert_email_address":240,"macro@crate::assert_email_address":238,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_email_address {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"1119":{"id":1119,"crate_id":0,"name":"assert_poll_pending_as_result","span":{"filename":"src/assert_poll/assert_poll_pending.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an expression.is_pending() is true.\n\nDeprecated. Please rename from `assert_poll_pending_as_result` into `assert_pending_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_pending_as_result` into `assert_pending_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_pending_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"842":{"id":842,"crate_id":0,"name":"assert_command_stderr_ge","span":{"filename":"src/assert_command/assert_command_stderr_ge.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stderr_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stderr_ge`](macro@crate::assert_command_stderr_ge)\n* [`assert_command_stderr_ge_as_result`](macro@crate::assert_command_stderr_ge_as_result)\n* [`debug_assert_command_stderr_ge`](macro@crate::debug_assert_command_stderr_ge)","links":{"macro@crate::assert_command_stderr_ge_as_result":840,"macro@crate::debug_assert_command_stderr_ge":841,"macro@crate::assert_command_stderr_ge":839},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"565":{"id":565,"crate_id":0,"name":"assert_fn","span":{"filename":"src/assert_fn/mod.rs","begin":[1,0],"end":[48,23]},"visibility":"public","docs":"Assert for comparing functions.\n\nThese macros help compare functions that return anything.\nThe macros call the functions, then compare the return values.\n\nCompare a function with another function:\n\n* [`assert_fn_eq!(a_function, b_function)`](macro@crate::assert_fn_eq) ≈ a_function() = b_function()\n* [`assert_fn_ne!(a_function, b_function)`](macro@crate::assert_fn_ne) ≈ a_function() ≠ b_function()\n* [`assert_fn_ge!(a_function, b_function)`](macro@crate::assert_fn_ge) ≈ a_function() ≥ b_function()\n* [`assert_fn_gt!(a_function, b_function)`](macro@crate::assert_fn_gt) ≈ a_function() > b_function()\n* [`assert_fn_le!(a_function, b_function)`](macro@crate::assert_fn_le) ≈ a_function() ≤ b_function()\n* [`assert_fn_lt!(a_function, b_function)`](macro@crate::assert_fn_lt) ≈ a_function() < b_function()\n\nCompare a function with an expression:\n\n* [`assert_fn_eq_x!(function, expr)`](macro@crate::assert_fn_eq_x) ≈ function() = expr\n* [`assert_fn_ne_x!(function, expr)`](macro@crate::assert_fn_ne_x) ≈ function() ≠ expr\n* [`assert_fn_ge_x!(function, expr)`](macro@crate::assert_fn_ge_x) ≈ function() ≥ expr\n* [`assert_fn_gt_x!(function, expr)`](macro@crate::assert_fn_gt_x) ≈ function() > expr\n* [`assert_fn_le_x!(function, expr)`](macro@crate::assert_fn_le_x) ≈ function() ≤ expr\n* [`assert_fn_lt_x!(function, expr)`](macro@crate::assert_fn_lt_x) ≈ function() < expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_eq!(i8::abs, a, i8::abs, b);\n```","links":{"macro@crate::assert_fn_eq_x":541,"macro@crate::assert_fn_eq":517,"macro@crate::assert_fn_lt":533,"macro@crate::assert_fn_ge_x":545,"macro@crate::assert_fn_gt_x":549,"macro@crate::assert_fn_le_x":553,"macro@crate::assert_fn_ge":521,"macro@crate::assert_fn_gt":525,"macro@crate::assert_fn_le":529,"macro@crate::assert_fn_lt_x":557,"macro@crate::assert_fn_ne_x":561,"macro@crate::assert_fn_ne":537},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[520,524,528,532,536,540,544,548,552,556,560,564],"is_stripped":false}}},"288":{"id":288,"crate_id":0,"name":"debug_assert_len_le","span":{"filename":"src/assert_len/assert_len_le.rs","begin":[339,0],"end":[345,1]},"visibility":"public","docs":"Assert a length is less than or equal to another.\n\nPseudocode:<br>\na.len() ≤ b.len()\n\nThis macro provides the same statements as [`assert_len_le`](macro.assert_len_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_le`](macro@crate::assert_len_le)\n* [`assert_len_le`](macro@crate::assert_len_le)\n* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)\n","links":{"macro@crate::debug_assert_len_le":288,"macro@crate::assert_len_le":286},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_le {\n    ($($arg:tt)*) => { ... };\n}"}},"892":{"id":892,"crate_id":0,"name":"assert_command_stderr_string_is_match","span":{"filename":"src/assert_command/assert_command_stderr_string_is_match.rs","begin":[1,0],"end":[333,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) is match (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\nuse regex::Regex;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_command_stderr_string_is_match!(command, matcher);\n```\n\n# Module macros\n\n* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)\n* [`assert_command_stderr_string_is_match_as_result`](macro@crate::assert_command_stderr_string_is_match_as_result)\n* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)","links":{"macro@crate::assert_command_stderr_string_is_match_as_result":890,"macro@crate::assert_command_stderr_string_is_match":889,"macro@crate::debug_assert_command_stderr_string_is_match":891},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"11":{"id":11,"crate_id":0,"name":"assert_gt","span":{"filename":"src/assert_gt.rs","begin":[1,0],"end":[481,1]},"visibility":"public","docs":"Assert an expression is greater than another.\n\nPseudocode:<br>\na > b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 2;\nlet b = 1;\nassert_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_gt`](macro@crate::assert_gt)\n* [`assert_gt_as_result`](macro@crate::assert_gt_as_result)\n* [`debug_assert_gt`](macro@crate::debug_assert_gt)","links":{"macro@crate::debug_assert_gt":10,"macro@crate::assert_gt_as_result":9,"macro@crate::assert_gt":8},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"615":{"id":615,"crate_id":0,"name":"assert_fn_ok_eq","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq.rs","begin":[321,0],"end":[354,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = 1;\nassert_fn_ok_eq!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_eq!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_ok_eq!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_eq.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `2`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"2\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_eq!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_eq.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `2`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"2\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)\n* [`assert_fn_ok_eq_as_result`](macro@crate::assert_fn_ok_eq_as_result)\n* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)\n","links":{"macro@crate::assert_fn_ok_eq":615,"macro@crate::debug_assert_fn_ok_eq":617,"macro@crate::assert_fn_ok_eq_as_result":616,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_eq {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"338":{"id":338,"crate_id":0,"name":"debug_assert_starts_with","span":{"filename":"src/assert_starts_with/assert_starts_with.rs","begin":[287,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) starts with an expression (such as a string).\n\nPseudocode:<br>\na.starts_with(b)\n\nThis macro provides the same statements as [`assert_starts_with`](macro.assert_starts_with.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_starts_with`](macro@crate::assert_starts_with)\n* [`assert_starts_with`](macro@crate::assert_starts_with)\n* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)\n","links":{"macro@crate::debug_assert_starts_with":338,"macro@crate::assert_starts_with":336},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_starts_with {\n    ($($arg:tt)*) => { ... };\n}"}},"942":{"id":942,"crate_id":0,"name":"debug_assert_program_args_stdout_ne_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne_x.rs","begin":[411,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_ne_x`](macro.assert_program_args_stdout_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)\n* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)\n* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)\n","links":{"macro@crate::assert_program_args_stdout_ne_x":940,"macro@crate::debug_assert_program_args_stdout_ne_x":942},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"61":{"id":61,"crate_id":0,"name":"debug_assert_f64_ge","span":{"filename":"src/assert_f64/assert_f64_ge.rs","begin":[381,0],"end":[387,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is greater than or equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\nThis macro provides the same statements as [`assert_f64_ge`](macro.assert_f64_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f64_ge`](macro@crate::assert_f64_ge)\n* [`assert_f64_ge`](macro@crate::assert_f64_ge)\n* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)\n","links":{"macro@crate::assert_f64_ge":59,"macro@crate::debug_assert_f64_ge":61},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f64_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"665":{"id":665,"crate_id":0,"name":"assert_fs_read_to_string_eq_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)\n\n* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)\n* [`assert_fs_read_to_string_eq_as_result`](macro@crate::assert_fs_read_to_string_eq_as_result)\n* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)\n","links":{"macro@crate::assert_fs_read_to_string_eq_as_result":665,"macro@crate::assert_fs_read_to_string_eq":664,"macro@crate::debug_assert_fs_read_to_string_eq":666},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_eq_as_result {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n}"}},"388":{"id":388,"crate_id":0,"name":"assert_none","span":{"filename":"src/assert_none/assert_none.rs","begin":[156,0],"end":[169,1]},"visibility":"public","docs":"Assert expression is None.\n\nPseudocode:<br>\na is None\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Option<i8> = Option::None;\nassert_none!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Option<i8> = Option::Some(1);\nassert_none!(a);\n# });\n// assertion failed: `assert_none!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_none.html\n//  a label: `a`,\n//  a debug: `Some(1)`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_none!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_none.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Some(1)`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_none`](macro@crate::assert_none)\n* [`assert_none_as_result`](macro@crate::assert_none_as_result)\n* [`debug_assert_none`](macro@crate::debug_assert_none)\n","links":{"macro@crate::assert_none":388,"macro@crate::assert_none_as_result":389,"macro@crate::debug_assert_none":390,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_none {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"992":{"id":992,"crate_id":0,"name":"assert_program_args_stderr_le_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le_x.rs","begin":[1,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_le_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)\n* [`assert_program_args_stderr_le_x_as_result`](macro@crate::assert_program_args_stderr_le_x_as_result)\n* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)","links":{"macro@crate::assert_program_args_stderr_le_x_as_result":990,"macro@crate::debug_assert_program_args_stderr_le_x":991,"macro@crate::assert_program_args_stderr_le_x":989},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"111":{"id":111,"crate_id":0,"name":"assert_abs_diff_ne","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne.rs","begin":[25,0],"end":[29,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_ne` into `assert_abs_diff_ne_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_ne` into `assert_abs_diff_ne_x`."},"inner":{"macro":"macro_rules! assert_abs_diff_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"715":{"id":715,"crate_id":0,"name":"assert_fs_read_to_string_contains","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_contains.rs","begin":[1,0],"end":[342,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) contains a pattern.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) contains expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"alfa.txt\";\nlet containee = \"alfa\";\nassert_fs_read_to_string_contains!(path, containee);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)\n* [`assert_fs_read_to_string_contains_as_result`](macro@crate::assert_fs_read_to_string_contains_as_result)\n* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)","links":{"macro@crate::debug_assert_fs_read_to_string_contains":714,"macro@crate::assert_fs_read_to_string_contains":712,"macro@crate::assert_fs_read_to_string_contains_as_result":713},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"438":{"id":438,"crate_id":0,"name":"assert_ready_ne_as_result","span":{"filename":"src/assert_ready/assert_ready_ne.rs","begin":[45,0],"end":[92,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_ready_ne`](macro.assert_ready_ne.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ready_ne`](macro@crate::assert_ready_ne)\n* [`assert_ready_ne_as_result`](macro@crate::assert_ready_ne_as_result)\n* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)\n","links":{"macro@crate::assert_ready_ne":437,"macro@crate::debug_assert_ready_ne":439,"macro@crate::assert_ready_ne_as_result":438},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1042":{"id":1042,"crate_id":0,"name":"assert_status_code_value_lt","span":{"filename":"src/assert_status/assert_status_code_value_lt.rs","begin":[1,0],"end":[396,1]},"visibility":"public","docs":"Assert a status code value is less than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)\n* [`assert_status_code_value_lt_as_result`](macro@crate::assert_status_code_value_lt_as_result)\n* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)","links":{"macro@crate::assert_status_code_value_lt":1039,"macro@crate::assert_status_code_value_lt_as_result":1040,"macro@crate::debug_assert_status_code_value_lt":1041},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"161":{"id":161,"crate_id":0,"name":"debug_assert_in_epsilon","span":{"filename":"src/assert_in/assert_in_epsilon.rs","begin":[383,0],"end":[389,1]},"visibility":"public","docs":"Assert a number is within epsilon of another.\n\nPseudocode:<br>\n| a - b | ≤ ε * min(a, b)\n\nThis macro provides the same statements as [`assert_in_epsilon`](macro.assert_in_epsilon.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)\n* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)\n","links":{"macro@crate::assert_in_epsilon":120,"macro@crate::debug_assert_in_epsilon":161},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_in_epsilon {\n    ($($arg:tt)*) => { ... };\n}"}},"765":{"id":765,"crate_id":0,"name":"assert_io_read_to_string_lt_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt_x.rs","begin":[1,0],"end":[371,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_lt_x!(reader, x);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)\n* [`assert_io_read_to_string_lt_x_as_result`](macro@crate::assert_io_read_to_string_lt_x_as_result)\n* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)","links":{"macro@crate::assert_io_read_to_string_lt_x":762,"macro@crate::assert_io_read_to_string_lt_x_as_result":763,"macro@crate::debug_assert_io_read_to_string_lt_x":764},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"488":{"id":488,"crate_id":0,"name":"assert_iter_ne_as_result","span":{"filename":"src/assert_iter/assert_iter_ne.rs","begin":[45,0],"end":[74,1]},"visibility":"public","docs":"Assert an iterable is not equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≠ (collection2 into iter)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_ne`](macro@crate::assert_iter_ne)\n* [`assert_iter_ne_as_result`](macro@crate::assert_iter_ne_as_result)\n* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)\n","links":{"macro@crate::assert_iter_ne_as_result":488,"macro@crate::assert_iter_ne":487,"macro@crate::debug_assert_iter_ne":489},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_ne_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"1092":{"id":1092,"crate_id":0,"name":"debug_assert_abs_diff_lt","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt.rs","begin":[39,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nDeprecated. Please rename from `debug_assert_abs_diff_lt` into `debug_assert_abs_diff_lt_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_abs_diff_lt` into `debug_assert_abs_diff_lt_x`."},"inner":{"macro":"macro_rules! debug_assert_abs_diff_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"211":{"id":211,"crate_id":0,"name":"debug_assert_count_ne","span":{"filename":"src/assert_count/assert_count_ne.rs","begin":[339,0],"end":[345,1]},"visibility":"public","docs":"Assert a count is not equal to another.\n\nPseudocode:<br>\na.count() ≠ b.count()\n\nThis macro provides the same statements as [`assert_count_ne`](macro.assert_count_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_ne`](macro@crate::assert_count_ne)\n* [`assert_count_ne`](macro@crate::assert_count_ne)\n* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)\n","links":{"macro@crate::assert_count_ne":209,"macro@crate::debug_assert_count_ne":211},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"815":{"id":815,"crate_id":0,"name":"assert_command_stdout_gt_x","span":{"filename":"src/assert_command/assert_command_stdout_gt_x.rs","begin":[1,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stdout string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stdout_gt_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)\n* [`assert_command_stdout_gt_x_as_result`](macro@crate::assert_command_stdout_gt_x_as_result)\n* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)","links":{"macro@crate::assert_command_stdout_gt_x":812,"macro@crate::assert_command_stdout_gt_x_as_result":813,"macro@crate::debug_assert_command_stdout_gt_x":814},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"538":{"id":538,"crate_id":0,"name":"assert_fn_ne_as_result","span":{"filename":"src/assert_fn/assert_fn_ne.rs","begin":[41,0],"end":[113,1]},"visibility":"public","docs":"Assert a function output is not equal to another.\n\nPseudocode:<br>\na_function(a) ≠ b_function(b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ne`](macro@crate::assert_fn_ne)\n* [`assert_fn_ne_as_result`](macro@crate::assert_fn_ne_as_result)\n* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)\n","links":{"macro@crate::assert_fn_ne_as_result":538,"macro@crate::debug_assert_fn_ne":539,"macro@crate::assert_fn_ne":537},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ne_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"1142":{"id":1142,"crate_id":0,"name":"assert_command_stdout_contains","span":{"filename":"src/assert_command/assert_command_stdout_contains.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nDeprecated. Please rename from `assert_command_stdout_contains` into `assert_command_stdout_string_contains`.\")]\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stdout_contains` into `assert_command_stdout_string_contains`."},"inner":{"macro":"macro_rules! assert_command_stdout_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"261":{"id":261,"crate_id":0,"name":"assert_not_empty_as_result","span":{"filename":"src/assert_is_empty/assert_not_empty.rs","begin":[40,0],"end":[63,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is not empty.\n\nPseudocode:<br>\n¬ a.is_empty()\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_empty`](macro@crate::assert_not_empty)\n* [`assert_not_empty_as_result`](macro@crate::assert_not_empty_as_result)\n* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)\n","links":{"macro@crate::debug_assert_not_empty":262,"macro@crate::assert_not_empty":260,"macro@crate::assert_not_empty_as_result":261},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_empty_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"865":{"id":865,"crate_id":0,"name":"debug_assert_command_stderr_ge_x","span":{"filename":"src/assert_command/assert_command_stderr_ge_x.rs","begin":[375,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_ge_x`](macro.assert_command_stderr_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)\n* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)\n* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)\n","links":{"macro@crate::assert_command_stderr_ge_x":863,"macro@crate::debug_assert_command_stderr_ge_x":865},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"588":{"id":588,"crate_id":0,"name":"debug_assert_fn_err_ne","span":{"filename":"src/assert_fn_err/assert_fn_err_ne.rs","begin":[491,0],"end":[497,1]},"visibility":"public","docs":"Assert a function error is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_err_ne`](macro.assert_fn_err_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)\n* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)\n* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)\n","links":{"macro@crate::assert_fn_err_ne":586,"macro@crate::debug_assert_fn_err_ne":588},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"311":{"id":311,"crate_id":0,"name":"assert_len_le_x_as_result","span":{"filename":"src/assert_len/assert_len_le_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a length is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\n* If true, return Result `Ok((a.len(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_le_x`](macro@crate::assert_len_le_x)\n* [`assert_len_le_x_as_result`](macro@crate::assert_len_le_x_as_result)\n* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)\n","links":{"macro@crate::assert_len_le_x":310,"macro@crate::assert_len_le_x_as_result":311,"macro@crate::debug_assert_len_le_x":312},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_le_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"915":{"id":915,"crate_id":0,"name":"assert_program_args_stdout_lt","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt.rs","begin":[1,0],"end":[449,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\"];\nassert_program_args_stdout_lt!(a_program, a_args, b_program, b_args);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)\n* [`assert_program_args_stdout_lt_as_result`](macro@crate::assert_program_args_stdout_lt_as_result)\n* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)","links":{"macro@crate::assert_program_args_stdout_lt_as_result":913,"macro@crate::debug_assert_program_args_stdout_lt":914,"macro@crate::assert_program_args_stdout_lt":912},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"34":{"id":34,"crate_id":0,"name":"assert_f32_ge","span":{"filename":"src/assert_f32/assert_f32_ge.rs","begin":[317,0],"end":[330,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333331;\nassert_f32_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_ge!(a, b);\n# });\n// assertion failed: `assert_f32_ge!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f32_ge.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.3333336`,`\n//     diff: `-0.00000029802322`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f32_ge!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f32_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333336`,\\n\",\n#     \"    diff: `-0.0000002682209`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f32_ge`](macro@crate::assert_f32_ge)\n* [`assert_f32_ge_as_result`](macro@crate::assert_f32_ge_as_result)\n* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)\n","links":{"macro@crate::assert_f32_ge":34,"macro@crate::debug_assert_f32_ge":36,"macro@crate::assert_f32_ge_as_result":35,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_ge {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"638":{"id":638,"crate_id":0,"name":"assert_fn_ok_ne","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne.rs","begin":[1,0],"end":[497,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_ne!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)\n* [`assert_fn_ok_ne_as_result`](macro@crate::assert_fn_ok_ne_as_result)\n* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)","links":{"macro@crate::debug_assert_fn_ok_ne":637,"macro@crate::assert_fn_ok_ne":635,"macro@crate::assert_fn_ok_ne_as_result":636},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"361":{"id":361,"crate_id":0,"name":"assert_err","span":{"filename":"src/assert_err/mod.rs","begin":[1,0],"end":[37,24]},"visibility":"public","docs":"Assert for Err(…) items.\n\nThese macros help compare Err(…) items, such as `::std::Result::Err` or similar.\n\nAssert expression is Err:\n\n* [`assert_err!(a)`](macro@crate::assert_err) ≈ a is Err(_)\n\nCompare Err(…) to another Err(…):\n\n* [`assert_err_eq!(a, b)`](macro@crate::assert_err_eq) ≈ (a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)\n* [`assert_err_ne!(a, b)`](macro@crate::assert_err_ne) ≈ (a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)\n\nCompare Err(…) to an expression:\n\n* [`assert_err_eq_x!(a, expr)`](macro@crate::assert_err_eq_x) ≈ (a ⇒ Err(a1) ⇒ a1) = expr\n* [`assert_err_ne_x!(a, expr)`](macro@crate::assert_err_ne_x) ≈ (a ⇒ Err(a1) ⇒ a1) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Err(1);\nassert_err!(a);\n```","links":{"macro@crate::assert_err_ne":349,"macro@crate::assert_err_eq":345,"macro@crate::assert_err_eq_x":353,"macro@crate::assert_err":341,"macro@crate::assert_err_ne_x":357},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[344,348,352,356,360],"is_stripped":false}}},"965":{"id":965,"crate_id":0,"name":"assert_program_args_stderr_gt","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt.rs","begin":[1,0],"end":[449,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"aa\"];\nassert_program_args_stderr_gt!(a_program, a_args, b_program, b_args);\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)\n* [`assert_program_args_stderr_gt_as_result`](macro@crate::assert_program_args_stderr_gt_as_result)\n* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)","links":{"macro@crate::assert_program_args_stderr_gt":962,"macro@crate::debug_assert_program_args_stderr_gt":964,"macro@crate::assert_program_args_stderr_gt_as_result":963},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"84":{"id":84,"crate_id":0,"name":"assert_abs_diff_ge_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge_x.rs","begin":[339,0],"end":[352,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≥ x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_ge_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 10;\nlet b = 13;\nlet x = 4;\nassert_abs_diff_ge_x!(a, b, x);\n# });\n// assertion failed: `assert_abs_diff_ge_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_abs_diff_ge_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `4`,\n//      |Δ|: `3`,\n//  |Δ| ≥ x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_abs_diff_ge_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_abs_diff_ge_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `4`,\\n\",\n#     \"     |Δ|: `3`,\\n\",\n#     \" |Δ| ≥ x: false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)\n* [`assert_abs_diff_ge_x_as_result`](macro@crate::assert_abs_diff_ge_x_as_result)\n* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)\n","links":{"macro@crate::assert_abs_diff_ge_x":84,"macro@crate::debug_assert_abs_diff_ge_x":86,"macro@crate::assert_abs_diff_ge_x_as_result":85,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_ge_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"688":{"id":688,"crate_id":0,"name":"assert_fs_read_to_string_eq_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq_x.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) = expr\n\n* If true, return `path_into_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"alfa.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_eq_x!(path, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_eq_x!(path, x);\n# });\n// assertion failed: `assert_fs_read_to_string_eq_x!(a_path, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_eq_x.html\n//  a_path label: `path`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_expr label: `x`,\n//  b_expr debug: `\\\"bravo\\\\n\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `bravo\\\\n`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_eq_x!(a_path, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_eq_x.html\\n\",\n#     \" a_path label: `path`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_expr label: `x`,\\n\",\n#     \" b_expr debug: `\\\"bravo\\\\n\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `bravo\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)\n* [`assert_fs_read_to_string_eq_x_as_result`](macro@crate::assert_fs_read_to_string_eq_x_as_result)\n* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)\n","links":{"macro@crate::debug_assert_fs_read_to_string_eq_x":690,"macro@crate::assert_fs_read_to_string_eq_x_as_result":689,"macro@crate::assert_fs_read_to_string_eq_x":688,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_eq_x {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"411":{"id":411,"crate_id":0,"name":"assert_some_eq_x_as_result","span":{"filename":"src/assert_some/assert_some_eq_x.rs","begin":[44,0],"end":[89,1]},"visibility":"public","docs":"Assert a.is_some() and a.unwrap() are equal to another.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = b\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_some_eq_x`](macro.assert_some_eq_x.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)\n* [`assert_some_eq_x_as_result`](macro@crate::assert_some_eq_x_as_result)\n* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)\n","links":{"macro@crate::assert_some_eq_x_as_result":411,"macro@crate::assert_some_eq_x":410,"macro@crate::debug_assert_some_eq_x":412},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_eq_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1015":{"id":1015,"crate_id":0,"name":"assert_status_success_false","span":{"filename":"src/assert_status/assert_status_success_false.rs","begin":[180,0],"end":[193,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nassert_status_success_false!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"0\");\nassert_status_success_false!(a);\n# });\n// assertion failed: `assert_status_success_false!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_success_false.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"0\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_success_false!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_success_false.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"0\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_success_false`](macro@crate::assert_status_success_false)\n* [`assert_status_success_false_as_result`](macro@crate::assert_status_success_false_as_result)\n* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)\n","links":{"macro@crate::assert_status_success_false_as_result":1016,"macro@crate::assert_status_success_false":1015,"macro@crate::debug_assert_status_success_false":1017,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_success_false {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"134":{"id":134,"crate_id":0,"name":"debug_assert_diff_ge_x","span":{"filename":"src/assert_diff/assert_diff_ge_x.rs","begin":[472,0],"end":[478,1]},"visibility":"public","docs":"Assert a difference is greater than or equal to an expression.\n\nPseudocode:<br>\nΔ ≥ x\n\nThis macro provides the same statements as [`assert_diff_ge_x`](macro.assert_diff_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)\n* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)\n* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)\n","links":{"macro@crate::assert_diff_ge_x":132,"macro@crate::assert_diff_ge_x_as_result":133,"macro@crate::debug_assert_diff_ge_x":134},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_diff_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"738":{"id":738,"crate_id":0,"name":"assert_io_read_to_string_lt","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt.rs","begin":[243,0],"end":[256,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\".as_bytes();\nlet b = \"aa\".as_bytes();\nassert_io_read_to_string_lt!(a, b);\n# });\n// assertion failed: `assert_io_read_to_string_lt!(a_reader, b_reader)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_lt.html\n//  a label: `a`,\n//  a debug: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `[97, 97]`,\n//        a: `\\\"alfa\\\"`,\n//        b: `\\\"aa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_lt!(a_reader, b_reader)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[97, 97]`,\\n\",\n#     \"       a: `\\\"alfa\\\"`,\\n\",\n#     \"       b: `\\\"aa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)\n* [`assert_io_read_to_string_lt_as_result`](macro@crate::assert_io_read_to_string_lt_as_result)\n* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)\n","links":{"macro@crate::assert_io_read_to_string_lt":738,"macro@crate::assert_io_read_to_string_lt_as_result":739,"macro@crate::debug_assert_io_read_to_string_lt":740,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_lt {\n    ($a_reader:expr, $b:expr $(,)?) => { ... };\n    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"461":{"id":461,"crate_id":0,"name":"assert_bag_subbag","span":{"filename":"src/assert_bag/assert_bag_subbag.rs","begin":[1,0],"end":[361,1]},"visibility":"public","docs":"Assert a bag is a subbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 1];\nlet b = [1, 1, 1];\nassert_bag_subbag!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)\n* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)\n* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)","links":{"macro@crate::assert_bag_subbag_as_result":459,"macro@crate::debug_assert_bag_subbag":460,"macro@crate::assert_bag_subbag":458},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1065":{"id":1065,"crate_id":0,"name":"debug_assert_status_code_value_lt_x","span":{"filename":"src/assert_status/assert_status_code_value_lt_x.rs","begin":[374,0],"end":[380,1]},"visibility":"public","docs":"Assert a status code value is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\nThis macro provides the same statements as [`assert_status_code_value_lt_x`](macro.assert_status_code_value_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)\n* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)\n* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)\n","links":{"macro@crate::debug_assert_status_code_value_lt_x":1065,"macro@crate::assert_status_code_value_lt_x":1063},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"184":{"id":184,"crate_id":0,"name":"assert_not_contains","span":{"filename":"src/assert_contains/assert_not_contains.rs","begin":[619,0],"end":[632,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not contain an expression (such as a substring).\n\nPseudocode:<br>\n¬ a.contains(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::collections::HashSet;\n# use std::panic;\n\n# fn main() {\n// String contains substring\nlet a = \"alfa\";\nlet b = \"zz\";\nassert_not_contains!(a, b);\n\n// Range contains value\nlet a = 1..3;\nlet b = 4;\nassert_not_contains!(a, &b);\n\n// Vector contains element\nlet a = vec![1, 2, 3];\nlet b = 4;\nassert_not_contains!(a, &b);\n\n// HashSet does not contain element.\n// Notice the &b because the macro calls HashSet.contains(&self, &value).\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b: String = String::from(\"2\");\nassert_not_contains!(a, &b);\n\n// HashSet does not contain element with automatic borrow optimization.\n// Notice the b because the value type &str is already a reference,\n// which HashSet.contains knows how to borrow to compare to String.\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b = \"2\";\nassert_not_contains!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\";\nlet b = \"lf\";\nassert_not_contains!(a, b);\n# });\n// assertion failed: `assert_not_contains!(container, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_contains.html\n//  container label: `a`,\n//  container debug: `\\\"alfa\\\"`,\n//  containee label: `b`,\n//  containee debug: `\\\"lf\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_contains!(container, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_contains.html\\n\",\n#     \" container label: `a`,\\n\",\n#     \" container debug: `\\\"alfa\\\"`,\\n\",\n#     \" containee label: `b`,\\n\",\n#     \" containee debug: `\\\"lf\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_contains`](macro@crate::assert_not_contains)\n* [`assert_not_contains_as_result`](macro@crate::assert_not_contains_as_result)\n* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)\n","links":{"macro@crate::assert_not_contains":184,"macro@crate::debug_assert_not_contains":186,"macro@crate::assert_not_contains_as_result":185,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_contains {\n    ($container:expr, $containee:expr $(,)?) => { ... };\n    ($container:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"788":{"id":788,"crate_id":0,"name":"assert_command_stdout_gt","span":{"filename":"src/assert_command/assert_command_stdout_gt.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a command stdout string is greater than another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stdout_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_gt!(a, b);\n# });\n// assertion failed: `assert_command_stdout_gt!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_gt.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"zz\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_gt!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"zz\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_gt`](macro@crate::assert_command_stdout_gt)\n* [`assert_command_stdout_gt_as_result`](macro@crate::assert_command_stdout_gt_as_result)\n* [`debug_assert_command_stdout_gt`](macro@crate::debug_assert_command_stdout_gt)\n","links":{"macro@crate::assert_command_stdout_gt_as_result":789,"macro@crate::debug_assert_command_stdout_gt":790,"macro@crate::assert_command_stdout_gt":788,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_gt {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"511":{"id":511,"crate_id":0,"name":"assert_set_subset","span":{"filename":"src/assert_set/assert_set_subset.rs","begin":[1,0],"end":[304,1]},"visibility":"public","docs":"Assert a set is a subset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [1, 2, 3];\nassert_set_subset!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_subset`](macro@crate::assert_set_subset)\n* [`assert_set_subset_as_result`](macro@crate::assert_set_subset_as_result)\n* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)","links":{"macro@crate::debug_assert_set_subset":510,"macro@crate::assert_set_subset":508,"macro@crate::assert_set_subset_as_result":509},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1115":{"id":1115,"crate_id":0,"name":"debug_assert_option_some_eq","span":{"filename":"src/assert_option/assert_option_some_eq.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nDeprecated. Please rename from `debug_assert_option_some_eq` into `debug_assert_some_eq` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_option_some_eq` into `debug_assert_some_eq` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_option_some_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"234":{"id":234,"crate_id":0,"name":"assert_count_ne_x_as_result","span":{"filename":"src/assert_count/assert_count_ne_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a count is not equal to an expression.\n\nPseudocode:<br>\na.count() ≠ b\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)\n* [`assert_count_ne_x_as_result`](macro@crate::assert_count_ne_x_as_result)\n* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)\n","links":{"macro@crate::assert_count_ne_x_as_result":234,"macro@crate::debug_assert_count_ne_x":235,"macro@crate::assert_count_ne_x":233},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ne_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"838":{"id":838,"crate_id":0,"name":"assert_command_stderr_eq","span":{"filename":"src/assert_command/assert_command_stderr_eq.rs","begin":[1,0],"end":[393,1]},"visibility":"public","docs":"Assert a command stderr string is equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n# Example\n\n```\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"alfa\"]);\nassert_command_stderr_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stderr_eq`](macro@crate::assert_command_stderr_eq)\n* [`assert_command_stderr_eq_as_result`](macro@crate::assert_command_stderr_eq_as_result)\n* [`debug_assert_command_stderr_eq`](macro@crate::debug_assert_command_stderr_eq)","links":{"macro@crate::assert_command_stderr_eq":835,"macro@crate::assert_command_stderr_eq_as_result":836,"macro@crate::debug_assert_command_stderr_eq":837},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"561":{"id":561,"crate_id":0,"name":"assert_fn_ne_x","span":{"filename":"src/assert_fn/assert_fn_ne_x.rs","begin":[243,0],"end":[277,1]},"visibility":"public","docs":"Assert a function output is not equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≠ b\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_ne_x!(i8::abs, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_ne_x!(i8::abs, a, b);\n# });\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-1`,\n//      b_expr label: `b`,\n//      b_expr debug: `1`,\n//                 a: `1`,\n//                 b: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ne_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ne_x.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `1`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)\n* [`assert_fn_ne_x_as_result`](macro@crate::assert_fn_ne_x_as_result)\n* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)\n","links":{"macro@crate::debug_assert_fn_ne_x":563,"macro@crate::assert_fn_ne_x":561,"macro@crate::assert_fn_ne_x_as_result":562,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ne_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"1165":{"id":1165,"crate_id":0,"name":"assert_program_args_stderr_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stderr_is_match.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nDeprecated. Please rename from `assert_program_args_stderr_is_match` to `assert_program_args_stderr_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stderr_is_match` to `assert_program_args_stderr_string_is_match`."},"inner":{"macro":"macro_rules! assert_program_args_stderr_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"284":{"id":284,"crate_id":0,"name":"debug_assert_len_gt","span":{"filename":"src/assert_len/assert_len_gt.rs","begin":[338,0],"end":[344,1]},"visibility":"public","docs":"Assert a length is greater than another.\n\nPseudocode:<br>\na.len() > b.len()\n\nThis macro provides the same statements as [`assert_len_gt`](macro.assert_len_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_gt`](macro@crate::assert_len_gt)\n* [`assert_len_gt`](macro@crate::assert_len_gt)\n* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)\n","links":{"macro@crate::debug_assert_len_gt":284,"macro@crate::assert_len_gt":282},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"7":{"id":7,"crate_id":0,"name":"assert_ge","span":{"filename":"src/assert_ge.rs","begin":[1,0],"end":[492,1]},"visibility":"public","docs":"Assert an expression is greater than or equal to another.\n\nPseudocode:<br>\na ≥ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 2;\nlet b = 1;\nassert_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_ge`](macro@crate::assert_ge)\n* [`assert_ge_as_result`](macro@crate::assert_ge_as_result)\n* [`debug_assert_ge`](macro@crate::debug_assert_ge)","links":{"macro@crate::assert_ge_as_result":5,"macro@crate::debug_assert_ge":6,"macro@crate::assert_ge":4},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"888":{"id":888,"crate_id":0,"name":"assert_command_stderr_string_contains","span":{"filename":"src/assert_command/assert_command_stderr_string_contains.rs","begin":[1,0],"end":[334,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) contains (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet containee = \"lf\";\nassert_command_stderr_string_contains!(command, containee);\n```\n\n# Module macros\n\n* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)\n* [`assert_command_stderr_string_contains_as_result`](macro@crate::assert_command_stderr_string_contains_as_result)\n* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)","links":{"macro@crate::assert_command_stderr_string_contains":885,"macro@crate::debug_assert_command_stderr_string_contains":887,"macro@crate::assert_command_stderr_string_contains_as_result":886},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"611":{"id":611,"crate_id":0,"name":"assert_fn_err_ne_x_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_ne_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function error is not equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≠ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)\n* [`assert_fn_err_ne_x_as_result`](macro@crate::assert_fn_err_ne_x_as_result)\n* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)\n","links":{"macro@crate::assert_fn_err_ne_x":610,"macro@crate::assert_fn_err_ne_x_as_result":611,"macro@crate::debug_assert_fn_err_ne_x":612},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ne_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"334":{"id":334,"crate_id":0,"name":"debug_assert_not_starts_with","span":{"filename":"src/assert_starts_with/assert_not_starts_with.rs","begin":[287,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not start with an expression (such as a string).\n\nPseudocode:<br>\n¬ a.starts_with(b)\n\nThis macro provides the same statements as [`assert_not_starts_with`](macro.assert_not_starts_with.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)\n* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)\n* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)\n","links":{"macro@crate::assert_not_starts_with":332,"macro@crate::debug_assert_not_starts_with":334},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_starts_with {\n    ($($arg:tt)*) => { ... };\n}"}},"57":{"id":57,"crate_id":0,"name":"debug_assert_f64_eq","span":{"filename":"src/assert_f64/assert_f64_eq.rs","begin":[361,0],"end":[367,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\nThis macro provides the same statements as [`assert_f64_eq`](macro.assert_f64_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f64_eq`](macro@crate::assert_f64_eq)\n* [`assert_f64_eq`](macro@crate::assert_f64_eq)\n* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)\n","links":{"macro@crate::debug_assert_f64_eq":57,"macro@crate::assert_f64_eq":55},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f64_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"938":{"id":938,"crate_id":0,"name":"debug_assert_program_args_stdout_lt_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt_x.rs","begin":[400,0],"end":[406,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_lt_x`](macro.assert_program_args_stdout_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)\n* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)\n* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)\n","links":{"macro@crate::assert_program_args_stdout_lt_x":936,"macro@crate::debug_assert_program_args_stdout_lt_x":938},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"661":{"id":661,"crate_id":0,"name":"debug_assert_fn_ok_ne_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne_x.rs","begin":[470,0],"end":[476,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr\n\nThis macro provides the same statements as [`assert_fn_ok_ne_x`](macro.assert_fn_ok_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)\n* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)\n* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)\n","links":{"macro@crate::assert_fn_ok_ne_x":659,"macro@crate::debug_assert_fn_ok_ne_x":661},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"384":{"id":384,"crate_id":0,"name":"assert_result_ok","span":{"filename":"src/assert_result/assert_result_ok.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nDeprecated. Please rename from `assert_result_ok` into `assert_ok` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"107":{"id":107,"crate_id":0,"name":"assert_abs_diff_le","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le.rs","begin":[1,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_le` into `assert_abs_diff_le_x`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"988":{"id":988,"crate_id":0,"name":"assert_program_args_stderr_gt_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt_x.rs","begin":[1,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stderr_gt_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)\n* [`assert_program_args_stderr_gt_x_as_result`](macro@crate::assert_program_args_stderr_gt_x_as_result)\n* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)","links":{"macro@crate::debug_assert_program_args_stderr_gt_x":987,"macro@crate::assert_program_args_stderr_gt_x":985,"macro@crate::assert_program_args_stderr_gt_x_as_result":986},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"711":{"id":711,"crate_id":0,"name":"assert_fs_read_to_string_ne_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne_x.rs","begin":[1,0],"end":[399,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_ne_x!(path, x);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)\n* [`assert_fs_read_to_string_ne_x_as_result`](macro@crate::assert_fs_read_to_string_ne_x_as_result)\n* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)","links":{"macro@crate::debug_assert_fs_read_to_string_ne_x":710,"macro@crate::assert_fs_read_to_string_ne_x":708,"macro@crate::assert_fs_read_to_string_ne_x_as_result":709},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"434":{"id":434,"crate_id":0,"name":"assert_ready_eq_as_result","span":{"filename":"src/assert_ready/assert_ready_eq.rs","begin":[45,0],"end":[92,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_ready_eq`](macro.assert_ready_eq.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ready_eq`](macro@crate::assert_ready_eq)\n* [`assert_ready_eq_as_result`](macro@crate::assert_ready_eq_as_result)\n* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)\n","links":{"macro@crate::assert_ready_eq":433,"macro@crate::assert_ready_eq_as_result":434,"macro@crate::debug_assert_ready_eq":435},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1038":{"id":1038,"crate_id":0,"name":"assert_status_code_value_le","span":{"filename":"src/assert_status/assert_status_code_value_le.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)\n* [`assert_status_code_value_le_as_result`](macro@crate::assert_status_code_value_le_as_result)\n* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)","links":{"macro@crate::assert_status_code_value_le_as_result":1036,"macro@crate::debug_assert_status_code_value_le":1037,"macro@crate::assert_status_code_value_le":1035},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"157":{"id":157,"crate_id":0,"name":"assert_in_delta_as_result","span":{"filename":"src/assert_in/assert_in_delta.rs","begin":[83,0],"end":[119,1]},"visibility":"public","docs":"Assert a number is within delta of another.\n\nPseudocode:<br>\n| a - b | ≤ Δ\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_in_delta`](macro@crate::assert_in_delta)\n* [`assert_in_delta_as_result`](macro@crate::assert_in_delta_as_result)\n* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)\n","links":{"macro@crate::assert_in_delta":119,"macro@crate::debug_assert_in_delta":158,"`Err`":1082,"macro@crate::assert_in_delta_as_result":157},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_delta_as_result {\n    ($a:expr, $b:expr, $delta:expr $(,)?) => { ... };\n}"}},"761":{"id":761,"crate_id":0,"name":"assert_io_read_to_string_le_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le_x.rs","begin":[1,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_le_x!(reader, x);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)\n* [`assert_io_read_to_string_le_x_as_result`](macro@crate::assert_io_read_to_string_le_x_as_result)\n* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)","links":{"macro@crate::assert_io_read_to_string_le_x":758,"macro@crate::debug_assert_io_read_to_string_le_x":760,"macro@crate::assert_io_read_to_string_le_x_as_result":759},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"484":{"id":484,"crate_id":0,"name":"assert_iter_lt_as_result","span":{"filename":"src/assert_iter/assert_iter_lt.rs","begin":[45,0],"end":[74,1]},"visibility":"public","docs":"Assert an iterable is less than another.\n\nPseudocode:<br>\n(collection1 into iter) < (collection2 into iter)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_lt`](macro@crate::assert_iter_lt)\n* [`assert_iter_lt_as_result`](macro@crate::assert_iter_lt_as_result)\n* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)\n","links":{"macro@crate::debug_assert_iter_lt":485,"macro@crate::assert_iter_lt":483,"macro@crate::assert_iter_lt_as_result":484},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_lt_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"1088":{"id":1088,"crate_id":0,"name":"debug_assert_abs_diff_gt","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt.rs","begin":[39,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nDeprecated. Please rename from `debug_assert_abs_diff_gt` into `debug_assert_abs_diff_gt_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_abs_diff_gt` into `debug_assert_abs_diff_gt_x`."},"inner":{"macro":"macro_rules! debug_assert_abs_diff_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"207":{"id":207,"crate_id":0,"name":"debug_assert_count_lt","span":{"filename":"src/assert_count/assert_count_lt.rs","begin":[338,0],"end":[344,1]},"visibility":"public","docs":"Assert a count is less than another.\n\nPseudocode:<br>\na.count() < b.count()\n\nThis macro provides the same statements as [`assert_count_lt`](macro.assert_count_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_lt`](macro@crate::assert_count_lt)\n* [`assert_count_lt`](macro@crate::assert_count_lt)\n* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)\n","links":{"macro@crate::assert_count_lt":205,"macro@crate::debug_assert_count_lt":207},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"811":{"id":811,"crate_id":0,"name":"assert_command_stdout_ge_x","span":{"filename":"src/assert_command/assert_command_stdout_ge_x.rs","begin":[1,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stdout_ge_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)\n* [`assert_command_stdout_ge_x_as_result`](macro@crate::assert_command_stdout_ge_x_as_result)\n* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)","links":{"macro@crate::assert_command_stdout_ge_x_as_result":809,"macro@crate::debug_assert_command_stdout_ge_x":810,"macro@crate::assert_command_stdout_ge_x":808},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"534":{"id":534,"crate_id":0,"name":"assert_fn_lt_as_result","span":{"filename":"src/assert_fn/assert_fn_lt.rs","begin":[41,0],"end":[113,1]},"visibility":"public","docs":"Assert a function output is less than another.\n\nPseudocode:<br>\na_function(a) < b_function(b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_lt`](macro@crate::assert_fn_lt)\n* [`assert_fn_lt_as_result`](macro@crate::assert_fn_lt_as_result)\n* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)\n","links":{"macro@crate::debug_assert_fn_lt":535,"macro@crate::assert_fn_lt":533,"macro@crate::assert_fn_lt_as_result":534},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_lt_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"257":{"id":257,"crate_id":0,"name":"assert_is_empty_as_result","span":{"filename":"src/assert_is_empty/assert_is_empty.rs","begin":[40,0],"end":[63,1]},"visibility":"public","docs":"Assert an expression (such as a regex) is a match for an expression (such as a string).\n\nPseudocode:<br>\na.is_empty()\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_is_empty`](macro@crate::assert_is_empty)\n* [`assert_is_empty_as_result`](macro@crate::assert_is_empty_as_result)\n* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)\n","links":{"macro@crate::assert_is_empty":256,"macro@crate::assert_is_empty_as_result":257,"macro@crate::debug_assert_is_empty":258},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_is_empty_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"1138":{"id":1138,"crate_id":0,"name":"debug_assert_io_read_to_string_matches","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_matches.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a ::std::io::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `debug_assert_io_read_to_string_matches` into `debug_assert_io_read_to_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_io_read_to_string_matches` into `debug_assert_io_read_to_string_is_match`."},"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_matches {\n    ($($arg:tt)*) => { ... };\n}"}},"861":{"id":861,"crate_id":0,"name":"debug_assert_command_stderr_eq_x","span":{"filename":"src/assert_command/assert_command_stderr_eq_x.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stderr string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_eq_x`](macro.assert_command_stderr_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)\n* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)\n* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)\n","links":{"macro@crate::debug_assert_command_stderr_eq_x":861,"macro@crate::assert_command_stderr_eq_x":859},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"584":{"id":584,"crate_id":0,"name":"debug_assert_fn_err_lt","span":{"filename":"src/assert_fn_err/assert_fn_err_lt.rs","begin":[576,0],"end":[582,1]},"visibility":"public","docs":"Assert a function error is less than another.\n\nThis macro provides the same statements as [`assert_fn_err_lt`](macro.assert_fn_err_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)\n* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)\n* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)\n","links":{"macro@crate::assert_fn_err_lt":582,"macro@crate::debug_assert_fn_err_lt":584},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"307":{"id":307,"crate_id":0,"name":"assert_len_gt_x_as_result","span":{"filename":"src/assert_len/assert_len_gt_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a length is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\n* If true, return Result `Ok((a.len(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)\n* [`assert_len_gt_x_as_result`](macro@crate::assert_len_gt_x_as_result)\n* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)\n","links":{"macro@crate::assert_len_gt_x":306,"macro@crate::assert_len_gt_x_as_result":307,"macro@crate::debug_assert_len_gt_x":308},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_gt_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"911":{"id":911,"crate_id":0,"name":"assert_program_args_stdout_le","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le.rs","begin":[1,0],"end":[472,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\"];\nassert_program_args_stdout_le!(a_program, a_args, b_program, b_args);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)\n* [`assert_program_args_stdout_le_as_result`](macro@crate::assert_program_args_stdout_le_as_result)\n* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)","links":{"macro@crate::assert_program_args_stdout_le_as_result":909,"macro@crate::debug_assert_program_args_stdout_le":910,"macro@crate::assert_program_args_stdout_le":908},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"30":{"id":30,"crate_id":0,"name":"assert_f32_eq","span":{"filename":"src/assert_f32/assert_f32_eq.rs","begin":[297,0],"end":[310,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na = b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333333;\nassert_f32_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_eq!(a, b);\n# });\n// assertion failed: `assert_f32_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f32_eq.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.3333336`,`\n//     diff: `-0.0000002682209`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f32_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f32_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333336`,\\n\",\n#     \"    diff: `-0.0000002682209`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f32_eq`](macro@crate::assert_f32_eq)\n* [`assert_f32_eq_as_result`](macro@crate::assert_f32_eq_as_result)\n* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)\n","links":{"macro@crate::assert_f32_eq":30,"macro@crate::debug_assert_f32_eq":32,"macro@crate::assert_f32_eq_as_result":31,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"634":{"id":634,"crate_id":0,"name":"assert_fn_ok_lt","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt.rs","begin":[1,0],"end":[589,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_lt!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)\n* [`assert_fn_ok_lt_as_result`](macro@crate::assert_fn_ok_lt_as_result)\n* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)","links":{"macro@crate::assert_fn_ok_lt_as_result":632,"macro@crate::debug_assert_fn_ok_lt":633,"macro@crate::assert_fn_ok_lt":631},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"357":{"id":357,"crate_id":0,"name":"assert_err_ne_x","span":{"filename":"src/assert_err/assert_err_ne_x.rs","begin":[267,0],"end":[280,1]},"visibility":"public","docs":"Assert an expression is Err and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) ≠ b\n\n* e, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Err(1);\nlet b: i8 = 2;\nassert_err_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Err(1);\nlet b: i8 = 1;\nassert_err_ne_x!(a, b);\n# });\n// assertion failed: `assert_err_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_err_ne_x.html\n//  a label: `a`,\n//  a debug: `Err(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_err_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_err_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Err(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)\n* [`assert_err_ne_x_as_result`](macro@crate::assert_err_ne_x_as_result)\n* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)\n","links":{"macro@crate::debug_assert_err_ne_x":359,"macro@crate::assert_err_ne_x":357,"macro@crate::assert_err_ne_x_as_result":358,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_ne_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"961":{"id":961,"crate_id":0,"name":"assert_program_args_stderr_ge","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge.rs","begin":[1,0],"end":[472,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"aa\"];\nassert_program_args_stderr_ge!(a_program, a_args, b_program, b_args);\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)\n* [`assert_program_args_stderr_ge_as_result`](macro@crate::assert_program_args_stderr_ge_as_result)\n* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)","links":{"macro@crate::debug_assert_program_args_stderr_ge":960,"macro@crate::assert_program_args_stderr_ge_as_result":959,"macro@crate::assert_program_args_stderr_ge":958},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"80":{"id":80,"crate_id":0,"name":"assert_abs_diff_eq_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq_x.rs","begin":[299,0],"end":[312,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nPseudocode:<br>\n|Δ| = x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 10;\nlet b = 13;\nlet x = 3;\nassert_abs_diff_eq_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_eq_x!(a, b, x);\n# });\n// assertion failed: `assert_abs_diff_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_abs_diff_eq_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `2`,\n//      |Δ|: `3`,\n//  |Δ| = x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_abs_diff_eq_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_abs_diff_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `2`,\\n\",\n#     \"     |Δ|: `3`,\\n\",\n#     \" |Δ| = x: false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)\n* [`assert_abs_diff_eq_x_as_result`](macro@crate::assert_abs_diff_eq_x_as_result)\n* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)\n","links":{"macro@crate::assert_abs_diff_eq_x":80,"macro@crate::assert_abs_diff_eq_x_as_result":81,"macro@crate::debug_assert_abs_diff_eq_x":82,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_eq_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"684":{"id":684,"crate_id":0,"name":"assert_fs_read_to_string_ne","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne.rs","begin":[279,0],"end":[292,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa.txt\";\nlet b = \"alfa.txt\";\nassert_fs_read_to_string_ne!(a, b);\n// assertion failed: `assert_fs_read_to_string_ne!(a_path, b_path)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_ne.html\n//  a_path label: `a`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_path label: `b`,\n//  b_path debug: `\\\"alfa.txt\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `\\\"alfa\\\\n\\\"`\n# });\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_ne!(a_path, b_path)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_ne.html\\n\",\n#     \" a_path label: `a`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_path label: `b`,\\n\",\n#     \" b_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `alfa\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)\n* [`assert_fs_read_to_string_ne_as_result`](macro@crate::assert_fs_read_to_string_ne_as_result)\n* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)\n","links":{"`panic!`":1081,"macro@crate::assert_fs_read_to_string_ne_as_result":685,"macro@crate::debug_assert_fs_read_to_string_ne":686,"macro@crate::assert_fs_read_to_string_ne":684},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ne {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };\n}"}},"407":{"id":407,"crate_id":0,"name":"assert_some_ne_as_result","span":{"filename":"src/assert_some/assert_some_ne.rs","begin":[44,0],"end":[91,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_some_ne`](macro.assert_some_ne.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_some_ne`](macro@crate::assert_some_ne)\n* [`assert_some_ne_as_result`](macro@crate::assert_some_ne_as_result)\n* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)\n","links":{"macro@crate::debug_assert_some_ne":408,"macro@crate::assert_some_ne_as_result":407,"macro@crate::assert_some_ne":406},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"130":{"id":130,"crate_id":0,"name":"debug_assert_diff_eq_x","span":{"filename":"src/assert_diff/assert_diff_eq_x.rs","begin":[463,0],"end":[469,1]},"visibility":"public","docs":"Assert a difference is equal to an expression.\n\nPseudocode:<br>\nΔ = x\n\nThis macro provides the same statements as [`assert_diff_eq_x`](macro.assert_diff_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)\n* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)\n* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)\n","links":{"macro@crate::assert_diff_eq_x":128,"macro@crate::debug_assert_diff_eq_x":130,"macro@crate::assert_diff_eq_x_as_result":129},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_diff_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1011":{"id":1011,"crate_id":0,"name":"assert_status_success","span":{"filename":"src/assert_status/assert_status_success.rs","begin":[180,0],"end":[193,1]},"visibility":"public","docs":"Assert a status is a success.\n\nPseudocode:<br>\na ⇒ status ⇒ success = true\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"0\");\nassert_status_success!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nassert_status_success!(a);\n# });\n// assertion failed: `assert_status_success!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_success.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_success!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_success.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_success`](macro@crate::assert_status_success)\n* [`assert_status_success_as_result`](macro@crate::assert_status_success_as_result)\n* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)\n","links":{"macro@crate::assert_status_success_as_result":1012,"macro@crate::debug_assert_status_success":1013,"macro@crate::assert_status_success":1011,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_success {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"734":{"id":734,"crate_id":0,"name":"assert_io_read_to_string_le","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le.rs","begin":[264,0],"end":[277,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\".as_bytes();\nlet b = \"aa\".as_bytes();\nassert_io_read_to_string_le!(a, b);\n# });\n// assertion failed: `assert_io_read_to_string_le!(a_reader, b_reader)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_le.html\n//  a label: `a`,\n//  a debug: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `[97, 97]`,\n//        a: `\\\"alfa\\\"`,\n//        b: `\\\"aa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_le!(a_reader, b_reader)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[97, 97]`,\\n\",\n#     \"       a: `\\\"alfa\\\"`,\\n\",\n#     \"       b: `\\\"aa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)\n* [`assert_io_read_to_string_le_as_result`](macro@crate::assert_io_read_to_string_le_as_result)\n* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_io_read_to_string_le":736,"macro@crate::assert_io_read_to_string_le":734,"macro@crate::assert_io_read_to_string_le_as_result":735},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_le {\n    ($a_reader:expr, $b:expr $(,)?) => { ... };\n    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"457":{"id":457,"crate_id":0,"name":"assert_bag_ne","span":{"filename":"src/assert_bag/assert_bag_ne.rs","begin":[1,0],"end":[352,1]},"visibility":"public","docs":"Assert a bag is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 1];\nlet b = [1, 1, 1];\nassert_bag_ne!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_ne`](macro@crate::assert_bag_ne)\n* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)\n* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)","links":{"macro@crate::assert_bag_ne_as_result":455,"macro@crate::debug_assert_bag_ne":456,"macro@crate::assert_bag_ne":454},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"180":{"id":180,"crate_id":0,"name":"assert_contains","span":{"filename":"src/assert_contains/assert_contains.rs","begin":[622,0],"end":[635,1]},"visibility":"public","docs":"Assert a container is a match for an expression.\n\nPseudocode:<br>\na.contains(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::collections::HashSet;\n# use std::panic;\n\n# fn main() {\n// String contains a substring\nlet a = \"alfa\";\nlet b = \"lf\";\nassert_contains!(a, b);\n\n// Range contains a value\nlet a = 1..3;\nlet b = 2;\nassert_contains!(a, &b);\n\n// Vector contains element\nlet a = vec![1, 2, 3];\nlet b = 2;\nassert_contains!(a, &b);\n\n// HashSet contains element.\n// Notice the &b because the macro calls HashSet.contains(&self, &value).\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b: String = String::from(\"1\");\nassert_contains!(a, &b);\n\n// HashSet contains element with automatic borrow optimization.\n// Notice the b because the value type &str is already a reference,\n// which HashSet.contains knows how to borrow to compare to String.\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b = \"1\";\nassert_contains!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\";\nlet b = \"xx\";\nassert_contains!(a, b);\n# });\n// assertion failed: `assert_contains!(container, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_contains.html\n//  container label: `a`,\n//  container debug: `\\\"alfa\\\"`,\n//  containee label: `b`,\n//  containee debug: `\\\"xx\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_contains!(container, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_contains.html\\n\",\n#     \" container label: `a`,\\n\",\n#     \" container debug: `\\\"alfa\\\"`,\\n\",\n#     \" containee label: `b`,\\n\",\n#     \" containee debug: `\\\"xx\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n* [`assert_contains`](macro@crate::assert_contains)\n* [`assert_contains_as_result`](macro@crate::assert_contains_as_result)\n* [`debug_assert_contains`](macro@crate::debug_assert_contains)\n","links":{"macro@crate::debug_assert_contains":182,"macro@crate::assert_contains":180,"macro@crate::assert_contains_as_result":181,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_contains {\n    ($container:expr, $containee:expr $(,)?) => { ... };\n    ($container:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"1061":{"id":1061,"crate_id":0,"name":"debug_assert_status_code_value_le_x","span":{"filename":"src/assert_status/assert_status_code_value_le_x.rs","begin":[379,0],"end":[385,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\nThis macro provides the same statements as [`assert_status_code_value_le_x`](macro.assert_status_code_value_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)\n* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)\n* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)\n","links":{"macro@crate::debug_assert_status_code_value_le_x":1061,"macro@crate::assert_status_code_value_le_x":1059},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"784":{"id":784,"crate_id":0,"name":"assert_command_stdout_ge","span":{"filename":"src/assert_command/assert_command_stdout_ge.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stdout_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_ge!(a, b);\n# });\n// assertion failed: `assert_command_stdout_ge!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_ge.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"zz\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_ge!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"zz\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_ge`](macro@crate::assert_command_stdout_ge)\n* [`assert_command_stdout_ge_as_result`](macro@crate::assert_command_stdout_ge_as_result)\n* [`debug_assert_command_stdout_ge`](macro@crate::debug_assert_command_stdout_ge)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_command_stdout_ge":786,"macro@crate::assert_command_stdout_ge_as_result":785,"macro@crate::assert_command_stdout_ge":784},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ge {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"507":{"id":507,"crate_id":0,"name":"assert_set_joint","span":{"filename":"src/assert_set/assert_set_joint.rs","begin":[1,0],"end":[303,1]},"visibility":"public","docs":"Assert a set is joint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [2, 3];\nassert_set_joint!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_joint`](macro@crate::assert_set_joint)\n* [`assert_set_joint_as_result`](macro@crate::assert_set_joint_as_result)\n* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)","links":{"macro@crate::debug_assert_set_joint":506,"macro@crate::assert_set_joint":504,"macro@crate::assert_set_joint_as_result":505},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"230":{"id":230,"crate_id":0,"name":"assert_count_lt_x_as_result","span":{"filename":"src/assert_count/assert_count_lt_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a count is less than an expression.\n\nPseudocode:<br>\na.count() < b\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)\n* [`assert_count_lt_x_as_result`](macro@crate::assert_count_lt_x_as_result)\n* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)\n","links":{"macro@crate::assert_count_lt_x":229,"macro@crate::assert_count_lt_x_as_result":230,"macro@crate::debug_assert_count_lt_x":231},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_lt_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1111":{"id":1111,"crate_id":0,"name":"assert_option_some","span":{"filename":"src/assert_option/assert_option_some.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert expression is Some.\n\nDeprecated. Please rename from `assert_option_some` into `assert_some` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_some` into `assert_some` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_some {\n    ($($arg:tt)*) => { ... };\n}"}},"834":{"id":834,"crate_id":0,"name":"assert_command_stdout_string_is_match","span":{"filename":"src/assert_command/assert_command_stdout_string_is_match.rs","begin":[1,0],"end":[333,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) is match (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\nuse regex::Regex;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_command_stdout_string_is_match!(command, matcher);\n```\n\n# Module macros\n\n* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)\n* [`assert_command_stdout_string_is_match_as_result`](macro@crate::assert_command_stdout_string_is_match_as_result)\n* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)","links":{"macro@crate::debug_assert_command_stdout_string_is_match":833,"macro@crate::assert_command_stdout_string_is_match":831,"macro@crate::assert_command_stdout_string_is_match_as_result":832},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"557":{"id":557,"crate_id":0,"name":"assert_fn_lt_x","span":{"filename":"src/assert_fn/assert_fn_lt_x.rs","begin":[284,0],"end":[318,1]},"visibility":"public","docs":"Assert a function output is less than an expression.\n\nPseudocode:<br>\na_function(a) < b\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_lt_x!(i8::abs, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_lt_x!(i8::abs, a, b);\n# });\n// assertion failed: `assert_fn_lt_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_lt_x.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-2`,\n//      b_expr label: `b`,\n//      b_expr debug: `1`,\n//                 a: `2`,\n//                 b: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_lt_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_lt_x.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-2`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `1`,\\n\",\n#     \"                a: `2`,\\n\",\n#     \"                b: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)\n* [`assert_fn_lt_x_as_result`](macro@crate::assert_fn_lt_x_as_result)\n* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)\n","links":{"macro@crate::assert_fn_lt_x_as_result":558,"macro@crate::assert_fn_lt_x":557,"macro@crate::debug_assert_fn_lt_x":559,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_lt_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"280":{"id":280,"crate_id":0,"name":"debug_assert_len_ge","span":{"filename":"src/assert_len/assert_len_ge.rs","begin":[339,0],"end":[345,1]},"visibility":"public","docs":"Assert a length is greater than or equal to another.\n\nPseudocode:<br>\na.len() ≥ b.len()\n\nThis macro provides the same statements as [`assert_len_ge`](macro.assert_len_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_ge`](macro@crate::assert_len_ge)\n* [`assert_len_ge`](macro@crate::assert_len_ge)\n* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)\n","links":{"macro@crate::assert_len_ge":278,"macro@crate::debug_assert_len_ge":280},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"1161":{"id":1161,"crate_id":0,"name":"assert_program_args_stderr_contains_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_contains.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nDeprecated. Please rename from `assert_program_args_stderr_contains_as_result` to `assert_program_args_stderr_string_contains_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stderr_contains_as_result` to `assert_program_args_stderr_string_contains_as_result`."},"inner":{"macro":"macro_rules! assert_program_args_stderr_contains_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"3":{"id":3,"crate_id":0,"name":"assert_eq","span":{"filename":"src/assert_eq.rs","begin":[1,0],"end":[229,1]},"visibility":"public","docs":"Assert an expression is equal to another.\n\nPseudocode:<br>\na = b\n\n# Module macro\n\n* [`assert_eq_as_result`](macro@crate::assert_eq_as_result)\n\n# Rust standard macros\n\n* [`assert_eq`](https://doc.rust-lang.org/std/macro.assert_eq.html)\n* [`debug_assert_eq`](https://doc.rust-lang.org/std/macro.debug_assert_eq.html)","links":{"macro@crate::assert_eq_as_result":2},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"884":{"id":884,"crate_id":0,"name":"assert_command_stderr_is_match","span":{"filename":"src/assert_command/assert_command_stderr_is_match.rs","begin":[1,0],"end":[46,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nDeprecated. Please rename from `assert_command_stderr_is_match` into `assert_command_stderr_string_is_match`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"607":{"id":607,"crate_id":0,"name":"assert_fn_err_lt_x_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_lt_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function error is less than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) < expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)\n* [`assert_fn_err_lt_x_as_result`](macro@crate::assert_fn_err_lt_x_as_result)\n* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)\n","links":{"macro@crate::assert_fn_err_lt_x":606,"macro@crate::debug_assert_fn_err_lt_x":608,"macro@crate::assert_fn_err_lt_x_as_result":607},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_lt_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"330":{"id":330,"crate_id":0,"name":"assert_not_matches","span":{"filename":"src/assert_matches/assert_not_matches.rs","begin":[1,0],"end":[292,1]},"visibility":"public","docs":"Assert expression matches a case.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 'a';\nassert_not_matches!(a, 'b'..='z');\n```\n\nNote: this implementation of `assert_not_matches` is relatively basic.\n\n* If you want more capabilities, consider the crate `assert_not_matches`.\n\n* If you're using Rust nightly, use the std lib macro `assert_not_matches`.\n\n# Module macros\n\n* [`assert_not_matches`](macro@crate::assert_not_matches)\n* [`assert_not_matches_as_result`](macro@crate::assert_not_matches_as_result)\n* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)","links":{"macro@crate::assert_not_matches":327,"macro@crate::assert_not_matches_as_result":328,"macro@crate::debug_assert_not_matches":329},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"53":{"id":53,"crate_id":0,"name":"assert_f32_ne","span":{"filename":"src/assert_f32/assert_f32_ne.rs","begin":[1,0],"end":[348,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is not equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_f32_ne`](macro@crate::assert_f32_ne)\n* [`assert_f32_ne_as_result`](macro@crate::assert_f32_ne_as_result)\n* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)\nAssert a floating point 32-bit number is not equal to another within f32::EPSILON.","links":{"macro@crate::debug_assert_f32_ne":52,"macro@crate::assert_f32_ne_as_result":51,"macro@crate::assert_f32_ne":50},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"934":{"id":934,"crate_id":0,"name":"debug_assert_program_args_stdout_le_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le_x.rs","begin":[411,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_le_x`](macro.assert_program_args_stdout_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)\n* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)\n* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)\n","links":{"macro@crate::assert_program_args_stdout_le_x":932,"macro@crate::debug_assert_program_args_stdout_le_x":934},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"657":{"id":657,"crate_id":0,"name":"debug_assert_fn_ok_lt_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt_x.rs","begin":[473,0],"end":[479,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr\n\nThis macro provides the same statements as [`assert_fn_ok_lt_x`](macro.assert_fn_ok_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)\n* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)\n* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)\n","links":{"macro@crate::assert_fn_ok_lt_x":655,"macro@crate::debug_assert_fn_ok_lt_x":657},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"380":{"id":380,"crate_id":0,"name":"debug_assert_ok_ne_x","span":{"filename":"src/assert_ok/assert_ok_ne_x.rs","begin":[384,0],"end":[390,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) ≠ b\n\nThis macro provides the same statements as [`assert_ok_ne_x`](macro.assert_ok_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)\n* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)\n* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)\n","links":{"macro@crate::assert_ok_ne_x":378,"macro@crate::debug_assert_ok_ne_x":380},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ok_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"103":{"id":103,"crate_id":0,"name":"assert_abs_diff_ne_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne_x.rs","begin":[1,0],"end":[475,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nPseudocode:<br>\n|Δ| ≠ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_ne_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)\n* [`assert_abs_diff_ne_x_as_result`](macro@crate::assert_abs_diff_ne_x_as_result)\n* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)","links":{"macro@crate::assert_abs_diff_ne_x_as_result":101,"macro@crate::assert_abs_diff_ne_x":100,"macro@crate::debug_assert_abs_diff_ne_x":102},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"984":{"id":984,"crate_id":0,"name":"assert_program_args_stderr_ge_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge_x.rs","begin":[1,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)\n\n# Examples\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stderr_ge_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)\n* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)\n* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)","links":{"macro@crate::debug_assert_program_args_stderr_ge_x":983,"macro@crate::assert_program_args_stderr_ge_x":982},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"707":{"id":707,"crate_id":0,"name":"assert_fs_read_to_string_lt_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt_x.rs","begin":[1,0],"end":[404,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) < expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_lt_x!(path, x);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)\n* [`assert_fs_read_to_string_lt_x_as_result`](macro@crate::assert_fs_read_to_string_lt_x_as_result)\n* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)","links":{"macro@crate::assert_fs_read_to_string_lt_x":704,"macro@crate::assert_fs_read_to_string_lt_x_as_result":705,"macro@crate::debug_assert_fs_read_to_string_lt_x":706},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"430":{"id":430,"crate_id":0,"name":"assert_ready_as_result","span":{"filename":"src/assert_ready/assert_ready.rs","begin":[42,0],"end":[60,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nPseudocode:<br>\na is Ready(a1)\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ready`](macro@crate::assert_ready)\n* [`assert_ready_as_result`](macro@crate::assert_ready_as_result)\n* [`debug_assert_ready`](macro@crate::debug_assert_ready)\n","links":{"macro@crate::assert_ready":429,"macro@crate::assert_ready_as_result":430,"macro@crate::debug_assert_ready":431},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"1034":{"id":1034,"crate_id":0,"name":"assert_status_code_value_gt","span":{"filename":"src/assert_status/assert_status_code_value_gt.rs","begin":[1,0],"end":[396,1]},"visibility":"public","docs":"Assert a status code value is greater than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)\n* [`assert_status_code_value_gt_as_result`](macro@crate::assert_status_code_value_gt_as_result)\n* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)","links":{"macro@crate::assert_status_code_value_gt":1031,"macro@crate::assert_status_code_value_gt_as_result":1032,"macro@crate::debug_assert_status_code_value_gt":1033},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"153":{"id":153,"crate_id":0,"name":"assert_in","span":{"filename":"src/assert_in/assert_in.rs","begin":[186,0],"end":[199,1]},"visibility":"public","docs":"Assert an item is in a container.\n\nPseudocode:<br>\na is in container\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 1;\nlet b = 0..2;\nassert_in!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 1;\nlet b = 2..4;\nassert_in!(a, b);\n# });\n// assertion failed: `assert_in!(a, container)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_in.html\n//  a label: `a`,\n//  a debug: `1`,\n//  container label: `b`,\n//  container debug: `2..4`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_in!(a, container)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_in.html\\n\",\n#     \"         a label: `a`,\\n\",\n#     \"         a debug: `1`,\\n\",\n#     \" container label: `b`,\\n\",\n#     \" container debug: `2..4`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_in`](macro@crate::assert_in)\n* [`assert_in_as_result`](macro@crate::assert_in_as_result)\n* [`debug_assert_in`](macro@crate::debug_assert_in)\n","links":{"`panic!`":1081,"macro@crate::assert_in_as_result":154,"macro@crate::debug_assert_in":155,"macro@crate::assert_in":153},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in {\n    ($a:expr, $container:expr $(,)?) => { ... };\n    ($a:expr, $container:expr, $($message:tt)+) => { ... };\n}"}},"757":{"id":757,"crate_id":0,"name":"assert_io_read_to_string_gt_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt_x.rs","begin":[1,0],"end":[371,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"aa\");\nassert_io_read_to_string_gt_x!(reader, x);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)\n* [`assert_io_read_to_string_gt_x_as_result`](macro@crate::assert_io_read_to_string_gt_x_as_result)\n* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)","links":{"macro@crate::assert_io_read_to_string_gt_x_as_result":755,"macro@crate::assert_io_read_to_string_gt_x":754,"macro@crate::debug_assert_io_read_to_string_gt_x":756},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"480":{"id":480,"crate_id":0,"name":"assert_iter_le_as_result","span":{"filename":"src/assert_iter/assert_iter_le.rs","begin":[45,0],"end":[74,1]},"visibility":"public","docs":"Assert an iterable is less than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≤ (collection2 into iter)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_le`](macro@crate::assert_iter_le)\n* [`assert_iter_le_as_result`](macro@crate::assert_iter_le_as_result)\n* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)\n","links":{"macro@crate::assert_iter_le_as_result":480,"macro@crate::assert_iter_le":479,"macro@crate::debug_assert_iter_le":481},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_le_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"1084":{"id":1084,"crate_id":0,"name":"debug_assert_abs_diff_eq","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq.rs","begin":[39,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nDeprecated. Please rename from `debug_assert_abs_diff_eq` into `debug_assert_abs_diff_eq_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_abs_diff_eq` into `debug_assert_abs_diff_eq_x`."},"inner":{"macro":"macro_rules! debug_assert_abs_diff_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"203":{"id":203,"crate_id":0,"name":"debug_assert_count_le","span":{"filename":"src/assert_count/assert_count_le.rs","begin":[339,0],"end":[345,1]},"visibility":"public","docs":"Assert a count is less than or equal to another.\n\nPseudocode:<br>\na.count() ≤ b.count()\n\nThis macro provides the same statements as [`assert_count_le`](macro.assert_count_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_le`](macro@crate::assert_count_le)\n* [`assert_count_le`](macro@crate::assert_count_le)\n* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)\n","links":{"macro@crate::assert_count_le":201,"macro@crate::debug_assert_count_le":203},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_le {\n    ($($arg:tt)*) => { ... };\n}"}},"807":{"id":807,"crate_id":0,"name":"assert_command_stdout_eq_x","span":{"filename":"src/assert_command/assert_command_stdout_eq_x.rs","begin":[1,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stdout string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_command_stdout_eq_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)\n* [`assert_command_stdout_eq_x_as_result`](macro@crate::assert_command_stdout_eq_x_as_result)\n* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)","links":{"macro@crate::assert_command_stdout_eq_x_as_result":805,"macro@crate::debug_assert_command_stdout_eq_x":806,"macro@crate::assert_command_stdout_eq_x":804},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"530":{"id":530,"crate_id":0,"name":"assert_fn_le_as_result","span":{"filename":"src/assert_fn/assert_fn_le.rs","begin":[43,0],"end":[115,1]},"visibility":"public","docs":"Assert a function output is less than or equal to another.\n\nPseudocode:<br>\na_function(a) ≤ b_function(b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\n# Examples\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_le`](macro@crate::assert_fn_le)\n* [`assert_fn_le_as_result`](macro@crate::assert_fn_le_as_result)\n* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)\n","links":{"macro@crate::debug_assert_fn_le":531,"macro@crate::assert_fn_le_as_result":530,"macro@crate::assert_fn_le":529},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_le_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"253":{"id":253,"crate_id":0,"name":"debug_assert_not_ends_with","span":{"filename":"src/assert_ends_with/assert_not_ends_with.rs","begin":[287,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not end with an expression (such as a string).\n\nPseudocode:<br>\n¬ a.ends_with(b)\n\nThis macro provides the same statements as [`assert_not_ends_with`](macro.assert_not_ends_with.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)\n* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)\n* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)\n","links":{"macro@crate::assert_not_ends_with":251,"macro@crate::debug_assert_not_ends_with":253},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_ends_with {\n    ($($arg:tt)*) => { ... };\n}"}},"1134":{"id":1134,"crate_id":0,"name":"assert_fs_read_to_string_matches","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_matches.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `assert_fs_read_to_string_matches` into `assert_fs_read_to_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_fs_read_to_string_matches` into `assert_fs_read_to_string_is_match`."},"inner":{"macro":"macro_rules! assert_fs_read_to_string_matches {\n    ($($arg:tt)*) => { ... };\n}"}},"857":{"id":857,"crate_id":0,"name":"debug_assert_command_stderr_ne","span":{"filename":"src/assert_command/assert_command_stderr_ne.rs","begin":[392,0],"end":[398,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to another.\n\nThis macro provides the same statements as [`assert_command_stderr_ne {`](macro.assert_command_stderr_ne {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_ne {`](macro@crate::assert_command_stderr_ne {)\n* [`assert_command_stderr_ne {`](macro@crate::assert_command_stderr_ne {)\n* [`debug_assert_command_stderr_ne {`](macro@crate::debug_assert_command_stderr_ne {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"580":{"id":580,"crate_id":0,"name":"debug_assert_fn_err_le","span":{"filename":"src/assert_fn_err/assert_fn_err_le.rs","begin":[527,0],"end":[533,1]},"visibility":"public","docs":"Assert a function error is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_err_le`](macro.assert_fn_err_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)\n* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)\n* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)\n","links":{"macro@crate::assert_fn_err_le":578,"macro@crate::debug_assert_fn_err_le":580},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_le {\n    ($($arg:tt)*) => { ... };\n}"}},"303":{"id":303,"crate_id":0,"name":"assert_len_ge_x_as_result","span":{"filename":"src/assert_len/assert_len_ge_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a length is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\n* If true, return Result `Ok((a.len(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)\n* [`assert_len_ge_x_as_result`](macro@crate::assert_len_ge_x_as_result)\n* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)\n","links":{"macro@crate::assert_len_ge_x":302,"macro@crate::debug_assert_len_ge_x":304,"macro@crate::assert_len_ge_x_as_result":303},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ge_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"907":{"id":907,"crate_id":0,"name":"assert_program_args_stdout_gt","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt.rs","begin":[1,0],"end":[449,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"a\", \"a\"];\nassert_program_args_stdout_gt!(a_program, a_args, b_program, b_args);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)\n* [`assert_program_args_stdout_gt_as_result`](macro@crate::assert_program_args_stdout_gt_as_result)\n* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)","links":{"macro@crate::assert_program_args_stdout_gt":904,"macro@crate::assert_program_args_stdout_gt_as_result":905,"macro@crate::debug_assert_program_args_stdout_gt":906},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"26":{"id":26,"crate_id":0,"name":"assert_eq_f64","span":{"filename":"src/assert_eq_f64.rs","begin":[303,0],"end":[316,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333335;\nassert_eq_f64!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_eq_f64!(a, b);\n# });\n// assertion failed: `assert_eq_f64!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_eq_f64.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333339`,`\n//     diff: `-0.0000000000000006106226635438361`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_eq_f64!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_eq_f64.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333339`,\\n\",\n#     \"    diff: `-0.0000000000000006106226635438361`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_eq_f64`](macro@crate::assert_eq_f64)\n* [`assert_eq_f64_as_result`](macro@crate::assert_eq_f64_as_result)\n* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)\n","links":{"macro@crate::assert_eq_f64":26,"macro@crate::debug_assert_eq_f64":28,"macro@crate::assert_eq_f64_as_result":27,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_eq_f64 {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"630":{"id":630,"crate_id":0,"name":"assert_fn_ok_le","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le.rs","begin":[1,0],"end":[533,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_le!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)\n* [`assert_fn_ok_le_as_result`](macro@crate::assert_fn_ok_le_as_result)\n* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)","links":{"macro@crate::debug_assert_fn_ok_le":629,"macro@crate::assert_fn_ok_le":627,"macro@crate::assert_fn_ok_le_as_result":628},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"353":{"id":353,"crate_id":0,"name":"assert_err_eq_x","span":{"filename":"src/assert_err/assert_err_eq_x.rs","begin":[226,0],"end":[239,1]},"visibility":"public","docs":"Assert an expression is Err and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Err(1);\nlet b: i8 = 1;\nassert_err_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Err(1);\nlet b: i8 = 2;\nassert_err_eq_x!(a, b);\n# });\n// assertion failed: `assert_err_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_err_eq_x.html\n//  a label: `a`,\n//  a debug: `Err(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_err_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_err_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Err(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)\n* [`assert_err_eq_x_as_result`](macro@crate::assert_err_eq_x_as_result)\n* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)\n","links":{"macro@crate::debug_assert_err_eq_x":355,"macro@crate::assert_err_eq_x":353,"macro@crate::assert_err_eq_x_as_result":354,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_eq_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"957":{"id":957,"crate_id":0,"name":"assert_program_args_stderr_eq","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq.rs","begin":[1,0],"end":[450,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"alfa\"];\nassert_program_args_stderr_eq!(a_program, a_args, b_program, b_args);\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)\n* [`assert_program_args_stderr_eq_as_result`](macro@crate::assert_program_args_stderr_eq_as_result)\n* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)","links":{"macro@crate::assert_program_args_stderr_eq":954,"macro@crate::assert_program_args_stderr_eq_as_result":955,"macro@crate::debug_assert_program_args_stderr_eq":956},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"76":{"id":76,"crate_id":0,"name":"assert_f64_ne_as_result","span":{"filename":"src/assert_f64/assert_f64_ne.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f64_ne`](macro@crate::assert_f64_ne)\n* [`assert_f64_ne_as_result`](macro@crate::assert_f64_ne_as_result)\n* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)\n","links":{"macro@crate::assert_f64_ne":75,"macro@crate::debug_assert_f64_ne":77,"macro@crate::assert_f64_ne_as_result":76},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"680":{"id":680,"crate_id":0,"name":"assert_fs_read_to_string_lt","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"bravo.txt\";\nlet b = \"alfa.txt\";\nassert_fs_read_to_string_lt!(a, b);\n# });\n// assertion failed: `assert_fs_read_to_string_lt!(a_path, b_path)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_lt.html\n//  a_path label: `a`,\n//  a_path debug: `\\\"bravo.txt\\\"`,\n//  b_path label: `b`,\n//  b_path debug: `\\\"alfa.txt\\\"`,\n//      a string: `\\\"bravo\\\\n\\\"`,\n//      b string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_lt!(a_path, b_path)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_lt.html\\n\",\n#     \" a_path label: `a`,\\n\",\n#     \" a_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \" b_path label: `b`,\\n\",\n#     \" b_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \"     a string: `bravo\\n`,\\n\",\n#     \"     b string: `alfa\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)\n* [`assert_fs_read_to_string_lt_as_result`](macro@crate::assert_fs_read_to_string_lt_as_result)\n* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fs_read_to_string_lt":682,"macro@crate::assert_fs_read_to_string_lt_as_result":681,"macro@crate::assert_fs_read_to_string_lt":680},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_lt {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };\n}"}},"403":{"id":403,"crate_id":0,"name":"assert_some_eq_as_result","span":{"filename":"src/assert_some/assert_some_eq.rs","begin":[44,0],"end":[91,1]},"visibility":"public","docs":"\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert_some_eq`](macro.assert_some_eq.html),\nexcept this macro returns a Option, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_some_eq`](macro@crate::assert_some_eq)\n* [`assert_some_eq_as_result`](macro@crate::assert_some_eq_as_result)\n* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)\n","links":{"macro@crate::assert_some_eq":402,"macro@crate::debug_assert_some_eq":404,"macro@crate::assert_some_eq_as_result":403},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1007":{"id":1007,"crate_id":0,"name":"assert_program_args_stderr_string_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_is_match.rs","begin":[254,0],"end":[267,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)\n\n* If true, return (a_program + a_args ⇒ command ⇒ stderr ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse regex::Regex;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_program_args_stderr_string_is_match!(program, args, matcher);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet matcher = Regex::new(r\"zz\").expect(\"regex\");\nassert_program_args_stderr_string_is_match!(program, args, matcher);\n# });\n// assertion failed: `assert_program_args_stderr_string_is_match!(a_program, b_matcher)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_string_is_match.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_matcher label: `matcher`,\n//  b_matcher debug: `Regex(\\\"zz\\\")`,\n//                a: `\\\"alfa\\\"`,\n//                b: `Regex(\\\"zz\\\")`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_string_is_match!(a_program, b_matcher)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_string_is_match.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_matcher label: `matcher`,\\n\",\n#     \" b_matcher debug: `Regex(\\\"zz\\\")`,\\n\",\n#     \"               a: `\\\"alfa\\\"`,\\n\",\n#     \"               b: `Regex(\\\"zz\\\")`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)\n* [`assert_program_args_stderr_string_is_match_as_result`](macro@crate::assert_program_args_stderr_string_is_match_as_result)\n* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)\n","links":{"macro@crate::assert_program_args_stderr_string_is_match_as_result":1008,"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_string_is_match":1009,"macro@crate::assert_program_args_stderr_string_is_match":1007},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_string_is_match {\n    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $matcher:expr, $($message:tt)+) => { ... };\n}"}},"126":{"id":126,"crate_id":0,"name":"assert_approx_ne","span":{"filename":"src/assert_approx/assert_approx_ne.rs","begin":[1,0],"end":[359,1]},"visibility":"public","docs":"Assert a number is approximately not equal to another.\n\nPseudocode:<br>\n| a - b | > 1e-6\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000012;\nassert_approx_ne!(a, b);\n```\n\n## Comparisons\n\nThis crate provides macro groups that test approximations and nearness:\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq) and\n  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate\n  equality within 1e-6. The macro name and the approximate value are chosen\n  to be similar to the longtime popular rust crate `assert_approx_eq`.\n\n* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error\n  (i.e. delta). This is the magnitude of the difference between the exact\n  value and the approximation.\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative\n  error (i.e. epsilon). This is the absolute error divided by the magnitude\n  of the exact value. This can be used to compare approximations of numbers\n  of wildly differing size.\n\nExamples:\n\n* Approximating the number 100 and 103 has an absolute error (approx) of 3\n  and a relative error (epsilon) of 0.03.\n\n* Approximating the number 1,000,000 and 1,000,003 has an absolute error\n  (approx) of 3, and a relative error (epsilon) of 0.000003.\n\n* For many kinds of applications, the relative error is more important than\n  the absolute error.\n\n## Thanks\n\n* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for\n  creating and maintaining the `assert_approx_eq` crate.\n\n* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for\n  creating and maintaining `assert_in_approx` and `assert_in_epsilon` code.\n\n# Module macros\n\n* [`assert_approx_ne`](macro@crate::assert_approx_ne)\n* [`assert_approx_ne_as_result`](macro@crate::assert_approx_ne_as_result)\n* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)","links":{"macro@crate::assert_in_delta":119,"macro@crate::assert_approx_eq":117,"macro@crate::assert_approx_ne":118,"macro@crate::assert_in_epsilon":120,"macro@crate::assert_approx_ne_as_result":124,"macro@crate::debug_assert_approx_ne":125},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"730":{"id":730,"crate_id":0,"name":"assert_io_read_to_string_gt","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt.rs","begin":[244,0],"end":[257,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa\".as_bytes();\nlet b = \"aa\".as_bytes();\nassert_io_read_to_string_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_gt!(a, b);\n# });\n// assertion failed: `assert_io_read_to_string_gt!(a_reader, b_reader)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_gt.html\n//  a label: `a`,\n//  a debug: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `[122, 122]`,\n//        a: `\\\"alfa\\\"`,\n//        b: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_gt!(a_reader, b_reader)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[122, 122]`,\\n\",\n#     \"       a: `\\\"alfa\\\"`,\\n\",\n#     \"       b: `\\\"zz\\\"`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)\n* [`assert_io_read_to_string_gt_as_result`](macro@crate::assert_io_read_to_string_gt_as_result)\n* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)\n","links":{"macro@crate::debug_assert_io_read_to_string_gt":732,"macro@crate::assert_io_read_to_string_gt_as_result":731,"macro@crate::assert_io_read_to_string_gt":730,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_gt {\n    ($a_reader:expr, $b:expr $(,)?) => { ... };\n    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"453":{"id":453,"crate_id":0,"name":"assert_bag_eq","span":{"filename":"src/assert_bag/assert_bag_eq.rs","begin":[1,0],"end":[306,1]},"visibility":"public","docs":"Assert a bag is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 1];\nlet b = [1, 1];\nassert_bag_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_bag_eq`](macro@crate::assert_bag_eq)\n* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)\n* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)","links":{"macro@crate::assert_bag_eq":450,"macro@crate::assert_bag_eq_as_result":451,"macro@crate::debug_assert_bag_eq":452},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"176":{"id":176,"crate_id":0,"name":"assert_infix","span":{"filename":"src/assert_infix.rs","begin":[219,0],"end":[232,1]},"visibility":"public","docs":"Assert a infix operator, such as assert_infix!(a == b).\n\nPseudocode:<br>\na infix b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 1;\nlet b = 1;\nassert_infix!(a == b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 1;\nlet b = 2;\nassert_infix!(a == b);\n# });\n// assertion failed: `assert_infix!(a == b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_infix.html\n//  a label: `a`,\n//  a debug: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_infix!(a == b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_infix.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Infix operators\n\nFor values:\n\n* `==`  equal\n* `!=`  not equal\n* `<`\tless than\n* `<=`\tless than or equal to\n* `>`\tgreater than\n* `>=`\tgreater than or equal to\n\nFor booleans:\n\n* `^`\tlogical XOR\n* `!`\tlogical NOT\n* `&`\tlogical AND\n* `|`\tlogical OR\n* `&&`\tlogical lazy AND\n* `||`\tlogical lazy OR\n\n# Module macros\n\n* [`assert_infix`](macro@crate::assert_infix)\n* [`assert_infix_as_result`](macro@crate::assert_infix_as_result)\n* [`debug_assert_infix`](macro@crate::debug_assert_infix)\n","links":{"macro@crate::assert_infix":176,"macro@crate::assert_infix_as_result":177,"macro@crate::debug_assert_infix":178,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_infix {\n    ($a:tt $infix:tt $b:tt) => { ... };\n    ($a:tt $infix:tt $b:tt, $($message:tt)+) => { ... };\n}"}},"1057":{"id":1057,"crate_id":0,"name":"debug_assert_status_code_value_gt_x","span":{"filename":"src/assert_status/assert_status_code_value_gt_x.rs","begin":[374,0],"end":[380,1]},"visibility":"public","docs":"Assert a status code value is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\nThis macro provides the same statements as [`assert_status_code_value_gt_x`](macro.assert_status_code_value_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)\n* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)\n* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)\n","links":{"macro@crate::assert_status_code_value_gt_x":1055,"macro@crate::debug_assert_status_code_value_gt_x":1057},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"780":{"id":780,"crate_id":0,"name":"assert_command_stdout_eq","span":{"filename":"src/assert_command/assert_command_stdout_eq.rs","begin":[262,0],"end":[275,1]},"visibility":"public","docs":"Assert a command stdout string is equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"alfa\"]);\nassert_command_stdout_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_eq!(a, b);\n# });\n// assertion failed: `assert_command_stdout_eq!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_eq.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"zz\\\"`,\n//  b value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_eq!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"zz\\\"`,\\n\",\n#     \" b value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_eq`](macro@crate::assert_command_stdout_eq)\n* [`assert_command_stdout_eq_as_result`](macro@crate::assert_command_stdout_eq_as_result)\n* [`debug_assert_command_stdout_eq`](macro@crate::debug_assert_command_stdout_eq)\n","links":{"macro@crate::debug_assert_command_stdout_eq":782,"macro@crate::assert_command_stdout_eq_as_result":781,"macro@crate::assert_command_stdout_eq":780,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_eq {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"503":{"id":503,"crate_id":0,"name":"assert_set_disjoint","span":{"filename":"src/assert_set/assert_set_disjoint.rs","begin":[1,0],"end":[303,1]},"visibility":"public","docs":"Assert a set is disjoint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [3, 4];\nassert_set_disjoint!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)\n* [`assert_set_disjoint_as_result`](macro@crate::assert_set_disjoint_as_result)\n* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)","links":{"macro@crate::assert_set_disjoint_as_result":501,"macro@crate::debug_assert_set_disjoint":502,"macro@crate::assert_set_disjoint":500},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"226":{"id":226,"crate_id":0,"name":"assert_count_le_x_as_result","span":{"filename":"src/assert_count/assert_count_le_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a count is less than or equal to an expression.\n\nPseudocode:<br>\na.count() ≤ b\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_le_x`](macro@crate::assert_count_le_x)\n* [`assert_count_le_x_as_result`](macro@crate::assert_count_le_x_as_result)\n* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)\n","links":{"macro@crate::assert_count_le_x":225,"macro@crate::assert_count_le_x_as_result":226,"macro@crate::debug_assert_count_le_x":227},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_le_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1107":{"id":1107,"crate_id":0,"name":"assert_option_none_as_result","span":{"filename":"src/assert_option/assert_option_none.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert expression is None.\n\nDeprecated. Please rename from `assert_option_none_as_result` into `assert_none_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_none_as_result` into `assert_none_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_none_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"830":{"id":830,"crate_id":0,"name":"assert_command_stdout_string_contains","span":{"filename":"src/assert_command/assert_command_stdout_string_contains.rs","begin":[1,0],"end":[334,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) contains (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet containee = \"lf\";\nassert_command_stdout_string_contains!(command, containee);\n```\n\n# Module macros\n\n* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)\n* [`assert_command_stdout_string_contains_as_result`](macro@crate::assert_command_stdout_string_contains_as_result)\n* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)","links":{"macro@crate::debug_assert_command_stdout_string_contains":829,"macro@crate::assert_command_stdout_string_contains":827,"macro@crate::assert_command_stdout_string_contains_as_result":828},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"553":{"id":553,"crate_id":0,"name":"assert_fn_le_x","span":{"filename":"src/assert_fn/assert_fn_le_x.rs","begin":[267,0],"end":[301,1]},"visibility":"public","docs":"Assert a function output is less than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≤ b\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_le_x!(i8::abs, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_le_x!(i8::abs, a, b);\n# });\n// assertion failed: `assert_fn_le_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_le_x.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-2`,\n//      b_expr label: `b`,\n//      b_expr debug: `1`,\n//                 a: `2`,\n//                 b: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_le_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_le_x.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-2`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `1`,\\n\",\n#     \"                a: `2`,\\n\",\n#     \"                b: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)\n* [`assert_fn_le_x_as_result`](macro@crate::assert_fn_le_x_as_result)\n* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)\n","links":{"macro@crate::assert_fn_le_x_as_result":554,"macro@crate::assert_fn_le_x":553,"macro@crate::debug_assert_fn_le_x":555,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_le_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"276":{"id":276,"crate_id":0,"name":"debug_assert_len_eq","span":{"filename":"src/assert_len/assert_len_eq.rs","begin":[338,0],"end":[344,1]},"visibility":"public","docs":"Assert a length is equal to another.\n\nPseudocode:<br>\na.len() = b.len()\n\nThis macro provides the same statements as [`assert_len_eq`](macro.assert_len_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_eq`](macro@crate::assert_len_eq)\n* [`assert_len_eq`](macro@crate::assert_len_eq)\n* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)\n","links":{"macro@crate::assert_len_eq":274,"macro@crate::debug_assert_len_eq":276},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"1157":{"id":1157,"crate_id":0,"name":"assert_program_args_stdout_is_match_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_is_match.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nDeprecated. Please rename from `assert_program_args_stdout_is_match_as_result` to `assert_program_args_stdout_string_is_match_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stdout_is_match_as_result` to `assert_program_args_stdout_string_is_match_as_result`."},"inner":{"macro":"macro_rules! assert_program_args_stdout_is_match_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"880":{"id":880,"crate_id":0,"name":"assert_command_stderr_ne_x_as_result","span":{"filename":"src/assert_command/assert_command_stderr_ne_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)\n* [`assert_command_stderr_ne_x_as_result`](macro@crate::assert_command_stderr_ne_x_as_result)\n* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)\n","links":{"macro@crate::debug_assert_command_stderr_ne_x":881,"macro@crate::assert_command_stderr_ne_x":879,"macro@crate::assert_command_stderr_ne_x_as_result":880},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ne_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"603":{"id":603,"crate_id":0,"name":"assert_fn_err_le_x_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_le_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function error is less than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≤ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)\n* [`assert_fn_err_le_x_as_result`](macro@crate::assert_fn_err_le_x_as_result)\n* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)\n","links":{"macro@crate::assert_fn_err_le_x":602,"macro@crate::assert_fn_err_le_x_as_result":603,"macro@crate::debug_assert_fn_err_le_x":604},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_le_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"326":{"id":326,"crate_id":0,"name":"assert_matches","span":{"filename":"src/assert_matches/assert_matches.rs","begin":[1,0],"end":[292,1]},"visibility":"public","docs":"Assert expression matches a case.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 'a';\nassert_matches!(a, 'a'..='z');\n```\n\nNote: this implementation of `assert_matches` is relatively basic.\n\n* If you want more capabilities, consider the crate `assert_matches`.\n\n* If you're using Rust nightly, use the std lib macro `assert_matches`.\n\n# Module macros\n\n* [`assert_matches`](macro@crate::assert_matches)\n* [`assert_matches_as_result`](macro@crate::assert_matches_as_result)\n* [`debug_assert_matches`](macro@crate::debug_assert_matches)","links":{"macro@crate::assert_matches_as_result":324,"macro@crate::assert_matches":323,"macro@crate::debug_assert_matches":325},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"930":{"id":930,"crate_id":0,"name":"debug_assert_program_args_stdout_gt_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt_x.rs","begin":[402,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_gt_x`](macro.assert_program_args_stdout_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)\n* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)\n* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)\n","links":{"macro@crate::debug_assert_program_args_stdout_gt_x":930,"macro@crate::assert_program_args_stdout_gt_x":928},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"49":{"id":49,"crate_id":0,"name":"assert_f32_lt","span":{"filename":"src/assert_f32/assert_f32_lt.rs","begin":[1,0],"end":[328,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na < b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_f32_lt`](macro@crate::assert_f32_lt)\n* [`assert_f32_lt_as_result`](macro@crate::assert_f32_lt_as_result)\n* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)\nAssert a floating point 32-bit number is equal to another within f32::EPSILON.","links":{"macro@crate::assert_f32_lt":46,"macro@crate::assert_f32_lt_as_result":47,"macro@crate::debug_assert_f32_lt":48},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"653":{"id":653,"crate_id":0,"name":"debug_assert_fn_ok_le_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le_x.rs","begin":[509,0],"end":[515,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr\n\nThis macro provides the same statements as [`assert_fn_ok_le_x`](macro.assert_fn_ok_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)\n* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)\n* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)\n","links":{"macro@crate::debug_assert_fn_ok_le_x":653,"macro@crate::assert_fn_ok_le_x":651},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"376":{"id":376,"crate_id":0,"name":"debug_assert_ok_eq_x","span":{"filename":"src/assert_ok/assert_ok_eq_x.rs","begin":[344,0],"end":[350,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = b\n\nThis macro provides the same statements as [`assert_ok_eq_x`](macro.assert_ok_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)\n* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)\n* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)\n","links":{"macro@crate::assert_ok_eq_x":374,"macro@crate::debug_assert_ok_eq_x":376},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ok_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"980":{"id":980,"crate_id":0,"name":"debug_assert_program_args_stderr_eq_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq_x.rs","begin":[402,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_eq_x`](macro.assert_program_args_stderr_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)\n* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)\n* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)\n","links":{"macro@crate::assert_program_args_stderr_eq_x":978,"macro@crate::debug_assert_program_args_stderr_eq_x":980},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"99":{"id":99,"crate_id":0,"name":"assert_abs_diff_lt_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt_x.rs","begin":[1,0],"end":[466,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nPseudocode:<br>\n|Δ| < x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 4;\nassert_abs_diff_lt_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)\n* [`assert_abs_diff_lt_x_as_result`](macro@crate::assert_abs_diff_lt_x_as_result)\n* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)","links":{"macro@crate::assert_abs_diff_lt_x_as_result":97,"macro@crate::assert_abs_diff_lt_x":96,"macro@crate::debug_assert_abs_diff_lt_x":98},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"703":{"id":703,"crate_id":0,"name":"assert_fs_read_to_string_le_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le_x.rs","begin":[1,0],"end":[399,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≤ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_le_x!(path, x);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)\n* [`assert_fs_read_to_string_le_x_as_result`](macro@crate::assert_fs_read_to_string_le_x_as_result)\n* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)","links":{"macro@crate::assert_fs_read_to_string_le_x_as_result":701,"macro@crate::assert_fs_read_to_string_le_x":700,"macro@crate::debug_assert_fs_read_to_string_le_x":702},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"426":{"id":426,"crate_id":0,"name":"assert_poll_ready_eq","span":{"filename":"src/assert_poll/assert_poll_ready_eq.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are equal.\n\nDeprecated. Please rename from `assert_poll_ready_eq` into `assert_ready_eq` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1030":{"id":1030,"crate_id":0,"name":"assert_status_code_value_ge","span":{"filename":"src/assert_status/assert_status_code_value_ge.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)\n* [`assert_status_code_value_ge_as_result`](macro@crate::assert_status_code_value_ge_as_result)\n* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)","links":{"macro@crate::assert_status_code_value_ge_as_result":1028,"macro@crate::debug_assert_status_code_value_ge":1029,"macro@crate::assert_status_code_value_ge":1027},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"149":{"id":149,"crate_id":0,"name":"assert_diff_ne_x_as_result","span":{"filename":"src/assert_diff/assert_diff_ne_x.rs","begin":[46,0],"end":[108,1]},"visibility":"public","docs":"Assert a difference is not equal to an expression.\n\nPseudocode:<br>\nΔ ≠ x\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)\n* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)\n* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)\n","links":{"macro@crate::assert_diff_ne_x_as_result":149,"`Err`":1082,"macro@crate::assert_diff_ne_x":148,"macro@crate::debug_assert_diff_ne_x":150},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_ne_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"753":{"id":753,"crate_id":0,"name":"assert_io_read_to_string_ge_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge_x.rs","begin":[1,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"aa\");\nassert_io_read_to_string_ge_x!(reader, x);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)\n* [`assert_io_read_to_string_ge_x_as_result`](macro@crate::assert_io_read_to_string_ge_x_as_result)\n* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)","links":{"macro@crate::assert_io_read_to_string_ge_x":750,"macro@crate::assert_io_read_to_string_ge_x_as_result":751,"macro@crate::debug_assert_io_read_to_string_ge_x":752},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"476":{"id":476,"crate_id":0,"name":"assert_iter_gt_as_result","span":{"filename":"src/assert_iter/assert_iter_gt.rs","begin":[45,0],"end":[74,1]},"visibility":"public","docs":"Assert an iterable is greater than another.\n\nPseudocode:<br>\n(collection1 into iter) > (collection2 into iter)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_gt`](macro@crate::assert_iter_gt)\n* [`assert_iter_gt_as_result`](macro@crate::assert_iter_gt_as_result)\n* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)\n","links":{"macro@crate::debug_assert_iter_gt":477,"macro@crate::assert_iter_gt_as_result":476,"macro@crate::assert_iter_gt":475},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_gt_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"1080":{"id":1080,"crate_id":0,"name":"assert_as_result","span":{"filename":"src/assert.rs","begin":[37,0],"end":[60,1]},"visibility":"public","docs":"Assert a condition is true.\n\nPseudocode:<br>\ncondition\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_as_result`](macro.assert_as_result.html)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"199":{"id":199,"crate_id":0,"name":"debug_assert_count_gt","span":{"filename":"src/assert_count/assert_count_gt.rs","begin":[338,0],"end":[344,1]},"visibility":"public","docs":"Assert a count is greater than another.\n\nPseudocode:<br>\na.count() > b.count()\n\nThis macro provides the same statements as [`assert_count_gt`](macro.assert_count_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_gt`](macro@crate::assert_count_gt)\n* [`assert_count_gt`](macro@crate::assert_count_gt)\n* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)\n","links":{"macro@crate::assert_count_gt":197,"macro@crate::debug_assert_count_gt":199},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"803":{"id":803,"crate_id":0,"name":"assert_command_stdout_ne","span":{"filename":"src/assert_command/assert_command_stdout_ne.rs","begin":[1,0],"end":[398,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stdout_ne`](macro@crate::assert_command_stdout_ne)\n* [`assert_command_stdout_ne_as_result`](macro@crate::assert_command_stdout_ne_as_result)\n* [`debug_assert_command_stdout_ne`](macro@crate::debug_assert_command_stdout_ne)","links":{"macro@crate::assert_command_stdout_ne_as_result":801,"macro@crate::assert_command_stdout_ne":800,"macro@crate::debug_assert_command_stdout_ne":802},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"526":{"id":526,"crate_id":0,"name":"assert_fn_gt_as_result","span":{"filename":"src/assert_fn/assert_fn_gt.rs","begin":[41,0],"end":[113,1]},"visibility":"public","docs":"Assert a function output is greater than another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_gt`](macro@crate::assert_fn_gt)\n* [`assert_fn_gt_as_result`](macro@crate::assert_fn_gt_as_result)\n* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)\n","links":{"macro@crate::assert_fn_gt":525,"macro@crate::assert_fn_gt_as_result":526,"macro@crate::debug_assert_fn_gt":527},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_gt_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"1130":{"id":1130,"crate_id":0,"name":"debug_assert_poll_ready_ne","span":{"filename":"src/assert_poll/assert_poll_ready_ne.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are not equal.\n\nDeprecated. Please rename from `debug_assert_poll_ready_ne` into `debug_assert_ready_ne` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_poll_ready_ne` into `debug_assert_ready_ne` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_poll_ready_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"249":{"id":249,"crate_id":0,"name":"debug_assert_ends_with","span":{"filename":"src/assert_ends_with/assert_ends_with.rs","begin":[287,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) ends with an expression (such as a string).\n\nPseudocode:<br>\na.ends_with(b)\n\nThis macro provides the same statements as [`assert_ends_with`](macro.assert_ends_with.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ends_with`](macro@crate::assert_ends_with)\n* [`assert_ends_with`](macro@crate::assert_ends_with)\n* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)\n","links":{"macro@crate::assert_ends_with":247,"macro@crate::debug_assert_ends_with":249},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ends_with {\n    ($($arg:tt)*) => { ... };\n}"}},"853":{"id":853,"crate_id":0,"name":"debug_assert_command_stderr_lt","span":{"filename":"src/assert_command/assert_command_stderr_lt.rs","begin":[384,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stderr string is less than another.\n\nThis macro provides the same statements as [`assert_command_stderr_lt {`](macro.assert_command_stderr_lt {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_lt {`](macro@crate::assert_command_stderr_lt {)\n* [`assert_command_stderr_lt {`](macro@crate::assert_command_stderr_lt {)\n* [`debug_assert_command_stderr_lt {`](macro@crate::debug_assert_command_stderr_lt {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"576":{"id":576,"crate_id":0,"name":"debug_assert_fn_err_gt","span":{"filename":"src/assert_fn_err/assert_fn_err_gt.rs","begin":[585,0],"end":[591,1]},"visibility":"public","docs":"Assert a function error is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_err_gt`](macro.assert_fn_err_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)\n* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)\n* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)\n","links":{"macro@crate::assert_fn_err_gt":574,"macro@crate::debug_assert_fn_err_gt":576},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"299":{"id":299,"crate_id":0,"name":"assert_len_eq_x_as_result","span":{"filename":"src/assert_len/assert_len_eq_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a length is equal to an expression.\n\nPseudocode:<br>\na.len() = b\n\n* If true, return Result `Ok((a.len(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)\n* [`assert_len_eq_x_as_result`](macro@crate::assert_len_eq_x_as_result)\n* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)\n","links":{"macro@crate::assert_len_eq_x_as_result":299,"macro@crate::assert_len_eq_x":298,"macro@crate::debug_assert_len_eq_x":300},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_eq_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"903":{"id":903,"crate_id":0,"name":"assert_program_args_stdout_ge","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge.rs","begin":[1,0],"end":[472,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"a\", \"a\"];\nassert_program_args_stdout_ge!(a_program, a_args, b_program, b_args);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)\n* [`assert_program_args_stdout_ge_as_result`](macro@crate::assert_program_args_stdout_ge_as_result)\n* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)","links":{"macro@crate::assert_program_args_stdout_ge":900,"macro@crate::debug_assert_program_args_stdout_ge":902,"macro@crate::assert_program_args_stdout_ge_as_result":901},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"22":{"id":22,"crate_id":0,"name":"assert_eq_f32","span":{"filename":"src/assert_eq_f32.rs","begin":[303,0],"end":[316,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na = b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333333;\nassert_eq_f32!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_eq_f32!(a, b);\n# });\n// assertion failed: `assert_eq_f32!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_eq_f32.html\n//  a label: `a`,\n//  a debug: `0.33333334`,\n//  b label: `b`,\n//  b debug: `0.3333336`,`\n//     diff: `-0.0000002682209`,\n//        ε: `0.00000011920929`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_eq_f32!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_eq_f32.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.33333334`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333336`,\\n\",\n#     \"    diff: `-0.0000002682209`,\\n\",\n#     \"       ε: `0.00000011920929`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_eq_f32`](macro@crate::assert_eq_f32)\n* [`assert_eq_f32_as_result`](macro@crate::assert_eq_f32_as_result)\n* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_eq_f32":24,"macro@crate::assert_eq_f32_as_result":23,"macro@crate::assert_eq_f32":22},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_eq_f32 {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"626":{"id":626,"crate_id":0,"name":"assert_fn_ok_gt","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt.rs","begin":[1,0],"end":[591,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 2;\nlet b: i8 = 1;\nassert_fn_ok_gt!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)\n* [`assert_fn_ok_gt_as_result`](macro@crate::assert_fn_ok_gt_as_result)\n* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)","links":{"macro@crate::assert_fn_ok_gt":623,"macro@crate::debug_assert_fn_ok_gt":625,"macro@crate::assert_fn_ok_gt_as_result":624},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"349":{"id":349,"crate_id":0,"name":"assert_err_ne","span":{"filename":"src/assert_err/assert_err_ne.rs","begin":[272,0],"end":[285,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Err(1);\nlet b: Result<i8, i8> = Err(2);\nassert_err_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Err(1);\nlet b: Result<i8, i8> = Err(1);\nassert_err_ne!(a, b);\n# });\n// assertion failed: `assert_err_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_err_ne.html\n//  a label: `a`,\n//  a debug: `Err(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Err(1)`,\n//  b inner: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_err_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_err_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Err(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Err(1)`,\\n\",\n#     \" b inner: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_err_ne`](macro@crate::assert_err_ne)\n* [`assert_err_ne_as_result`](macro@crate::assert_err_ne_as_result)\n* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)\n","links":{"macro@crate::debug_assert_err_ne":351,"macro@crate::assert_err_ne":349,"macro@crate::assert_err_ne_as_result":350,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"953":{"id":953,"crate_id":0,"name":"assert_program_args_stdout_string_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_is_match.rs","begin":[1,0],"end":[354,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_program_args_stdout_string_is_match!(program, args, matcher);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)\n* [`assert_program_args_stdout_string_is_match_as_result`](macro@crate::assert_program_args_stdout_string_is_match_as_result)\n* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)","links":{"macro@crate::debug_assert_program_args_stdout_string_is_match":952,"macro@crate::assert_program_args_stdout_string_is_match":950,"macro@crate::assert_program_args_stdout_string_is_match_as_result":951},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"72":{"id":72,"crate_id":0,"name":"assert_f64_lt_as_result","span":{"filename":"src/assert_f64/assert_f64_lt.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na < b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f64_lt`](macro@crate::assert_f64_lt)\n* [`assert_f64_lt_as_result`](macro@crate::assert_f64_lt_as_result)\n* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)\n","links":{"macro@crate::assert_f64_lt_as_result":72,"macro@crate::debug_assert_f64_lt":73,"macro@crate::assert_f64_lt":71},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_lt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"676":{"id":676,"crate_id":0,"name":"assert_fs_read_to_string_le","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le.rs","begin":[279,0],"end":[292,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"bravo.txt\";\nlet b = \"alfa.txt\";\nassert_fs_read_to_string_le!(a, b);\n# });\n// assertion failed: `assert_fs_read_to_string_le!(a_path, b_path)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_le.html\n//  a_path label: `a`,\n//  a_path debug: `\\\"bravo.txt\\\"`,\n//  b_path label: `b`,\n//  b_path debug: `\\\"alfa.txt\\\"`,\n//      a string: `\\\"bravo\\\\n\\\"`,\n//      b string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_le!(a_path, b_path)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_le.html\\n\",\n#     \" a_path label: `a`,\\n\",\n#     \" a_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \" b_path label: `b`,\\n\",\n#     \" b_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \"     a string: `bravo\\n`,\\n\",\n#     \"     b string: `alfa\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)\n* [`assert_fs_read_to_string_le_as_result`](macro@crate::assert_fs_read_to_string_le_as_result)\n* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fs_read_to_string_le":678,"macro@crate::assert_fs_read_to_string_le":676,"macro@crate::assert_fs_read_to_string_le_as_result":677},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_le {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };\n}"}},"399":{"id":399,"crate_id":0,"name":"assert_some_as_result","span":{"filename":"src/assert_some/assert_some.rs","begin":[40,0],"end":[58,1]},"visibility":"public","docs":"Assert an expression.is_some() is true.\n\nPseudocode:<br>\na is Some(a1)\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_some`](macro@crate::assert_some)\n* [`assert_some_as_result`](macro@crate::assert_some_as_result)\n* [`debug_assert_some`](macro@crate::debug_assert_some)\n","links":{"macro@crate::assert_some_as_result":399,"macro@crate::assert_some":398,"macro@crate::debug_assert_some":400},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"122":{"id":122,"crate_id":0,"name":"debug_assert_approx_eq","span":{"filename":"src/assert_approx/assert_approx_eq.rs","begin":[353,0],"end":[359,1]},"visibility":"public","docs":"Assert a number is approximately equal to another.\n\nPseudocode:<br>\n| a - b | ≤ 1e-6\n\nThis macro provides the same statements as [`assert_approx_eq`](macro.assert_approx_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq)\n* [`assert_approx_eq`](macro@crate::assert_approx_eq)\n* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)\n","links":{"macro@crate::debug_assert_approx_eq":122,"macro@crate::assert_approx_eq":117},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_approx_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"1003":{"id":1003,"crate_id":0,"name":"assert_program_args_stderr_string_contains","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_contains.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)\n\n* If true, return (a_program + a_args ⇒ command ⇒ stderr ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\nThis uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.\n\n* The containee can be a &str, char, a slice of chars, or a function or\nclosure that determines if a character contains.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet containee = \"lf\";\nassert_program_args_stderr_string_contains!(program, args, containee);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet containee = \"zz\";\nassert_program_args_stderr_string_contains!(program, args, containee);\n# });\n// assertion failed: `assert_program_args_stderr_string_contains!(a_program, a_args, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_string_contains.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  containee label: `containee`,\n//  containee debug: `\\\"zz\\\"`,\n//                a: `\\\"alfa\\\"`,\n//        containee: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_string_contains!(a_program, a_args, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_string_contains.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" containee label: `containee`,\\n\",\n#     \" containee debug: `\\\"zz\\\"`,\\n\",\n#     \"               a: `\\\"alfa\\\"`,\\n\",\n#     \"       containee: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)\n* [`assert_program_args_stderr_string_contains_as_result`](macro@crate::assert_program_args_stderr_string_contains_as_result)\n* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)\n","links":{"macro@crate::debug_assert_program_args_stderr_string_contains":1005,"macro@crate::assert_program_args_stderr_string_contains_as_result":1004,"macro@crate::assert_program_args_stderr_string_contains":1003,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_string_contains {\n    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"726":{"id":726,"crate_id":0,"name":"assert_io_read_to_string_ge","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge.rs","begin":[264,0],"end":[277,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa\".as_bytes();\nlet b = \"aa\".as_bytes();\nassert_io_read_to_string_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_ge!(a, b);\n# });\n// assertion failed: `assert_io_read_to_string_ge!(a_reader, b_reader)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_ge.html\n//  a label: `a`,\n//  a debug: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `[122, 122]`,\n//        a: `\\\"alfa\\\"`,\n//        b: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_ge!(a_reader, b_reader)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[122, 122]`,\\n\",\n#     \"       a: `\\\"alfa\\\"`,\\n\",\n#     \"       b: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)\n* [`assert_io_read_to_string_ge_as_result`](macro@crate::assert_io_read_to_string_ge_as_result)\n* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_io_read_to_string_ge":728,"macro@crate::assert_io_read_to_string_ge":726,"macro@crate::assert_io_read_to_string_ge_as_result":727},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ge {\n    ($a_reader:expr, $b:expr $(,)?) => { ... };\n    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"449":{"id":449,"crate_id":0,"name":"assert_ready","span":{"filename":"src/assert_ready/mod.rs","begin":[1,0],"end":[41,26]},"visibility":"public","docs":"Assert for Ready(_) items.\n\nThese macros help compare Ready(…) items, such as `::std::Ready::Ready` or similar.\n\nAssert expression is Ready:\n\n* [`assert_ready!(a)`](macro@crate::assert_ready)\n  ≈ a is Ready\n\nCompare Ready(…) to another Ready(…):\n\n* [`assert_ready_eq!(a, b)`](macro@crate::assert_ready_eq) ≈ (a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)\n* [`assert_ready_ne!(a, b)`](macro@crate::assert_ready_ne) ≈ (a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)\n\nCompare Ready(…) to an expression:\n\n* [`assert_ready_eq_x!(a, expr)`](macro@crate::assert_ready_eq_x) ≈ (a ⇒ Ready(a1) ⇒ a1) = expr\n* [`assert_ready_ne_x!(a, expr)`](macro@crate::assert_ready_ne_x) ≈ (a ⇒ Ready(a1) ⇒ a1) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\n\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(1);\nassert_ready_eq!(a, b);\n```","links":{"macro@crate::assert_ready_eq":433,"macro@crate::assert_ready_eq_x":441,"macro@crate::assert_ready":429,"macro@crate::assert_ready_ne":437,"macro@crate::assert_ready_ne_x":445},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[432,436,440,444,448],"is_stripped":false}}},"172":{"id":172,"crate_id":0,"name":"assert_any","span":{"filename":"src/assert_any.rs","begin":[170,0],"end":[183,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2, 3];\nassert_any!(a.into_iter(), |x: i8| x > 0);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2, 3];\nassert_any!(a.into_iter(), |x: i8| x > 3);\n# });\n// assertion failed: `assert_any!(collection, predicate)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_any.html\n//  collection label: `a.into_iter()`,\n//  collection debug: `IntoIter([1, 2, 3])`,\n//         predicate: `|x: i8| x > 3`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_any!(collection, predicate)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_any.html\\n\",\n#     \" collection label: `a.into_iter()`,\\n\",\n#     \" collection debug: `IntoIter([1, 2, 3])`,\\n\",\n#     \"        predicate: `|x: i8| x > 3`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_any`](macro@crate::assert_any)\n* [`assert_any_as_result`](macro@crate::assert_any_as_result)\n* [`debug_assert_any`](macro@crate::debug_assert_any)\n","links":{"macro@crate::debug_assert_any":174,"macro@crate::assert_any_as_result":173,"macro@crate::assert_any":172,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_any {\n    ($collection:expr, $predicate:expr $(,)?) => { ... };\n    ($collection:expr, $predicate:expr, $($message:tt)+) => { ... };\n}"}},"1053":{"id":1053,"crate_id":0,"name":"debug_assert_status_code_value_ge_x","span":{"filename":"src/assert_status/assert_status_code_value_ge_x.rs","begin":[379,0],"end":[385,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\nThis macro provides the same statements as [`assert_status_code_value_ge_x`](macro.assert_status_code_value_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)\n* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)\n* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)\n","links":{"macro@crate::assert_status_code_value_ge_x":1051,"macro@crate::debug_assert_status_code_value_ge_x":1053},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"776":{"id":776,"crate_id":0,"name":"debug_assert_io_read_to_string_is_match","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_is_match.rs","begin":[309,0],"end":[315,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is a match to a regex.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) matches matcher\n\nThis macro provides the same statements as [`assert_io_read_to_string_is_match`](macro.assert_io_read_to_string_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)\n* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)\n* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)\n","links":{"macro@crate::debug_assert_io_read_to_string_is_match":776,"macro@crate::assert_io_read_to_string_is_match":774},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"499":{"id":499,"crate_id":0,"name":"assert_set_ne","span":{"filename":"src/assert_set/assert_set_ne.rs","begin":[1,0],"end":[303,1]},"visibility":"public","docs":"Assert a set is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [3, 4];\nassert_set_ne!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_ne`](macro@crate::assert_set_ne)\n* [`assert_set_ne_as_result`](macro@crate::assert_set_ne_as_result)\n* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)","links":{"macro@crate::assert_set_ne_as_result":497,"macro@crate::assert_set_ne":496,"macro@crate::debug_assert_set_ne":498},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1103":{"id":1103,"crate_id":0,"name":"debug_assert_result_ok_eq","span":{"filename":"src/assert_result/assert_result_ok_eq.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nDeprecated. Please rename from `debug_assert_result_ok_eq` into `debug_assert_ok_eq` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_result_ok_eq` into `debug_assert_ok_eq` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_result_ok_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"222":{"id":222,"crate_id":0,"name":"assert_count_gt_x_as_result","span":{"filename":"src/assert_count/assert_count_gt_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a count is greater than an expression.\n\nPseudocode:<br>\na.count() > b\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)\n* [`assert_count_gt_x_as_result`](macro@crate::assert_count_gt_x_as_result)\n* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)\n","links":{"macro@crate::assert_count_gt_x_as_result":222,"macro@crate::debug_assert_count_gt_x":223,"macro@crate::assert_count_gt_x":221},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_gt_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"826":{"id":826,"crate_id":0,"name":"assert_command_stdout_is_match","span":{"filename":"src/assert_command/assert_command_stdout_is_match.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nDeprecated. Please rename from `assert_command_stdout_is_match` into `assert_command_stdout_string_is_match`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"549":{"id":549,"crate_id":0,"name":"assert_fn_gt_x","span":{"filename":"src/assert_fn/assert_fn_gt_x.rs","begin":[284,0],"end":[318,1]},"visibility":"public","docs":"Assert a function output is greater than an expression.\n\nPseudocode:<br>\nfunction(a) > b\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_gt_x!(i8::abs, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_gt_x!(i8::abs, a, b);\n# });\n// assertion failed: `assert_fn_gt_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_gt_x.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-1`,\n//      b_expr label: `b`,\n//      b_expr debug: `2`,\n//                 a: `1`,\n//                 b: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_gt_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_gt_x.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `2`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)\n* [`assert_fn_gt_x_as_result`](macro@crate::assert_fn_gt_x_as_result)\n* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)\n","links":{"macro@crate::assert_fn_gt_x":549,"macro@crate::assert_fn_gt_x_as_result":550,"macro@crate::debug_assert_fn_gt_x":551,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_gt_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"1153":{"id":1153,"crate_id":0,"name":"assert_program_args_impl_prep","span":{"filename":"src/assert_program_args/mod.rs","begin":[121,0],"end":[127,1]},"visibility":"public","docs":"Assert program args implementation preparation.","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_impl_prep {\n    ($program:expr, $args:expr $(,)?) => { ... };\n}"}},"272":{"id":272,"crate_id":0,"name":"assert_not_match","span":{"filename":"src/assert_is_match/assert_not_match.rs","begin":[1,0],"end":[285,1]},"visibility":"public","docs":"Assert an expression (such as a regex) is not a match for an expression (such as a string).\n\nPseudocode:<br>\n¬ a.is_match(b)\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet a = Regex::new(r\"xx\").expect(\"regex\");\nlet b = \"alfa\";\nassert_not_match!(a, b);\n```\n\n# Module macros\n\n* [`assert_not_match`](macro@crate::assert_not_match)\n* [`assert_not_match_as_result`](macro@crate::assert_not_match_as_result)\n* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)","links":{"macro@crate::assert_not_match":269,"macro@crate::debug_assert_not_match":271,"macro@crate::assert_not_match_as_result":270},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"876":{"id":876,"crate_id":0,"name":"assert_command_stderr_lt_x_as_result","span":{"filename":"src/assert_command/assert_command_stderr_lt_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stderr string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)\n* [`assert_command_stderr_lt_x_as_result`](macro@crate::assert_command_stderr_lt_x_as_result)\n* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)\n","links":{"macro@crate::debug_assert_command_stderr_lt_x":877,"macro@crate::assert_command_stderr_lt_x":875,"macro@crate::assert_command_stderr_lt_x_as_result":876},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_lt_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"599":{"id":599,"crate_id":0,"name":"assert_fn_err_gt_x_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_gt_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function error is greater than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) > expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)\n* [`assert_fn_err_gt_x_as_result`](macro@crate::assert_fn_err_gt_x_as_result)\n* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)\n","links":{"macro@crate::assert_fn_err_gt_x_as_result":599,"macro@crate::assert_fn_err_gt_x":598,"macro@crate::debug_assert_fn_err_gt_x":600},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_gt_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"322":{"id":322,"crate_id":0,"name":"assert_len","span":{"filename":"src/assert_len/mod.rs","begin":[1,0],"end":[48,24]},"visibility":"public","docs":"Assert for comparing lengths.\n\nThese macros help with collection lengths, such as for strings, arrays,\nvectors, iterators, and anything that has a typical `.len()` method.\n\nCompare a length with another length:\n\n* [`assert_len_eq!(a, b)`](macro@crate::assert_len_eq) ≈ a.len() = b.len()\n* [`assert_len_ne!(a, b)`](macro@crate::assert_len_ne) ≈ a.len() ≠ b.len()\n* [`assert_len_lt!(a, b)`](macro@crate::assert_len_lt) ≈ a.len() < b.len()\n* [`assert_len_le!(a, b)`](macro@crate::assert_len_le) ≈ a.len() ≤ b.len()\n* [`assert_len_gt!(a, b)`](macro@crate::assert_len_gt) ≈ a.len() > b.len()\n* [`assert_len_ge!(a, b)`](macro@crate::assert_len_ge) ≈ a.len() ≥ b.len()\n\nCompare a length with an expression:\n\n* [`assert_len_eq_x!(a, expr)`](macro@crate::assert_len_eq_x) ≈ a.len() = expr\n* [`assert_len_ne_x!(a, expr)`](macro@crate::assert_len_ne_x) ≈ a.len() ≠ expr\n* [`assert_len_lt_x!(a, expr)`](macro@crate::assert_len_lt_x) ≈ a.len() < expr\n* [`assert_len_le_x!(a, expr)`](macro@crate::assert_len_le_x) ≈ a.len() ≤ expr\n* [`assert_len_gt_x!(a, expr)`](macro@crate::assert_len_gt_x) ≈ a.len() > expr\n* [`assert_len_ge_x!(a, expr)`](macro@crate::assert_len_ge_x) ≈ a.len() ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = \"x\";\nassert_len_eq!(a, b);\n```","links":{"macro@crate::assert_len_le_x":310,"macro@crate::assert_len_eq_x":298,"macro@crate::assert_len_le":286,"macro@crate::assert_len_ge_x":302,"macro@crate::assert_len_eq":274,"macro@crate::assert_len_gt_x":306,"macro@crate::assert_len_lt":290,"macro@crate::assert_len_ne":294,"macro@crate::assert_len_gt":282,"macro@crate::assert_len_lt_x":314,"macro@crate::assert_len_ge":278,"macro@crate::assert_len_ne_x":318},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[277,281,285,289,293,297,301,305,309,313,317,321],"is_stripped":false}}},"45":{"id":45,"crate_id":0,"name":"assert_f32_le","span":{"filename":"src/assert_f32/assert_f32_le.rs","begin":[1,0],"end":[388,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_f32_le`](macro@crate::assert_f32_le)\n* [`assert_f32_le_as_result`](macro@crate::assert_f32_le_as_result)\n* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)\nAssert a floating point 32-bit number is less than or equal to another within f32::EPSILON.","links":{"macro@crate::debug_assert_f32_le":44,"macro@crate::assert_f32_le":42,"macro@crate::assert_f32_le_as_result":43},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"926":{"id":926,"crate_id":0,"name":"debug_assert_program_args_stdout_ge_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge_x.rs","begin":[411,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_ge_x`](macro.assert_program_args_stdout_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)\n* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)\n* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)\n","links":{"macro@crate::assert_program_args_stdout_ge_x":924,"macro@crate::debug_assert_program_args_stdout_ge_x":926},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"649":{"id":649,"crate_id":0,"name":"debug_assert_fn_ok_gt_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt_x.rs","begin":[567,0],"end":[573,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr\n\nThis macro provides the same statements as [`assert_fn_ok_gt_x`](macro.assert_fn_ok_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)\n* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)\n* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)\n","links":{"macro@crate::debug_assert_fn_ok_gt_x":649,"macro@crate::assert_fn_ok_gt_x":647},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"372":{"id":372,"crate_id":0,"name":"debug_assert_ok_ne","span":{"filename":"src/assert_ok/assert_ok_ne.rs","begin":[387,0],"end":[393,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nThis macro provides the same statements as [`assert_ok_ne`](macro.assert_ok_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ok_ne`](macro@crate::assert_ok_ne)\n* [`assert_ok_ne`](macro@crate::assert_ok_ne)\n* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)\n","links":{"macro@crate::debug_assert_ok_ne":372,"macro@crate::assert_ok_ne":370},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ok_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"95":{"id":95,"crate_id":0,"name":"assert_abs_diff_le_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le_x.rs","begin":[1,0],"end":[475,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≤ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 4;\nassert_abs_diff_le_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)\n* [`assert_abs_diff_le_x_as_result`](macro@crate::assert_abs_diff_le_x_as_result)\n* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)","links":{"macro@crate::debug_assert_abs_diff_le_x":94,"macro@crate::assert_abs_diff_le_x_as_result":93,"macro@crate::assert_abs_diff_le_x":92},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"976":{"id":976,"crate_id":0,"name":"debug_assert_program_args_stderr_ne","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne.rs","begin":[464,0],"end":[470,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)\n\nThis macro provides the same statements as [`assert_program_args_stderr_ne`](macro.assert_program_args_stderr_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)\n* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)\n* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)\n","links":{"macro@crate::assert_program_args_stderr_ne":974,"macro@crate::debug_assert_program_args_stderr_ne":976},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"699":{"id":699,"crate_id":0,"name":"assert_fs_read_to_string_gt_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt_x.rs","begin":[1,0],"end":[404,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) > expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"bravo.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_gt_x!(path, x);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)\n* [`assert_fs_read_to_string_gt_x_as_result`](macro@crate::assert_fs_read_to_string_gt_x_as_result)\n* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)","links":{"macro@crate::assert_fs_read_to_string_gt_x_as_result":697,"macro@crate::debug_assert_fs_read_to_string_gt_x":698,"macro@crate::assert_fs_read_to_string_gt_x":696},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"422":{"id":422,"crate_id":0,"name":"assert_pending","span":{"filename":"src/assert_pending/assert_pending.rs","begin":[1,0],"end":[254,1]},"visibility":"public","docs":"Assert an expression is Pending.\n\nPseudocode:<br>\na is Pending\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\n\nlet a: Poll<i8> = Pending;\nassert_pending!(a);\n```\n\n# Module macros\n\n* [`assert_pending`](macro@crate::assert_pending)\n* [`assert_pending_as_result`](macro@crate::assert_pending_as_result)\n* [`debug_assert_pending`](macro@crate::debug_assert_pending)","links":{"macro@crate::debug_assert_pending":421,"macro@crate::assert_pending_as_result":420,"macro@crate::assert_pending":419},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1026":{"id":1026,"crate_id":0,"name":"assert_status_code_value_eq","span":{"filename":"src/assert_status/assert_status_code_value_eq.rs","begin":[1,0],"end":[396,1]},"visibility":"public","docs":"Assert a status code value is equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)\n* [`assert_status_code_value_eq_as_result`](macro@crate::assert_status_code_value_eq_as_result)\n* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)","links":{"macro@crate::assert_status_code_value_eq_as_result":1024,"macro@crate::debug_assert_status_code_value_eq":1025,"macro@crate::assert_status_code_value_eq":1023},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"145":{"id":145,"crate_id":0,"name":"assert_diff_lt_x_as_result","span":{"filename":"src/assert_diff/assert_diff_lt_x.rs","begin":[46,0],"end":[108,1]},"visibility":"public","docs":"Assert a difference is less than an expression.\n\nPseudocode:<br>\nΔ < x\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)\n* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)\n* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)\n","links":{"macro@crate::assert_diff_lt_x":144,"macro@crate::assert_diff_lt_x_as_result":145,"macro@crate::debug_assert_diff_lt_x":146,"`Err`":1082},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_lt_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"749":{"id":749,"crate_id":0,"name":"assert_io_read_to_string_eq_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq_x.rs","begin":[1,0],"end":[363,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) = expr\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"alfa\");\nassert_io_read_to_string_eq_x!(reader, x);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)\n* [`assert_io_read_to_string_eq_x_as_result`](macro@crate::assert_io_read_to_string_eq_x_as_result)\n* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)","links":{"macro@crate::assert_io_read_to_string_eq_x_as_result":747,"macro@crate::assert_io_read_to_string_eq_x":746,"macro@crate::debug_assert_io_read_to_string_eq_x":748},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"472":{"id":472,"crate_id":0,"name":"assert_iter_ge_as_result","span":{"filename":"src/assert_iter/assert_iter_ge.rs","begin":[45,0],"end":[74,1]},"visibility":"public","docs":"Assert an iterable is greater than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≥ (collection2 into iter)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_ge`](macro@crate::assert_iter_ge)\n* [`assert_iter_ge_as_result`](macro@crate::assert_iter_ge_as_result)\n* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)\n","links":{"macro@crate::debug_assert_iter_ge":473,"macro@crate::assert_iter_ge":471,"macro@crate::assert_iter_ge_as_result":472},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_ge_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"195":{"id":195,"crate_id":0,"name":"debug_assert_count_ge","span":{"filename":"src/assert_count/assert_count_ge.rs","begin":[339,0],"end":[345,1]},"visibility":"public","docs":"Assert a count is greater than or equal to another.\n\nPseudocode:<br>\na.count() ≥ b.count()\n\nThis macro provides the same statements as [`assert_count_ge`](macro.assert_count_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_ge`](macro@crate::assert_count_ge)\n* [`assert_count_ge`](macro@crate::assert_count_ge)\n* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)\n","links":{"macro@crate::debug_assert_count_ge":195,"macro@crate::assert_count_ge":193},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"1076":{"id":1076,"crate_id":0,"name":"assert_success_false_as_result","span":{"filename":"src/assert_success/assert_success_false.rs","begin":[43,0],"end":[62,1]},"visibility":"public","docs":"Assert a failure method is true.\n\nPseudocode:<br>\na.success() = false\n\n* If true, return Result `Ok(true)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_success_false`](macro@crate::assert_success_false)\n* [`assert_success_false_as_result`](macro@crate::assert_success_false_as_result)\n* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)\n","links":{"macro@crate::assert_success_false":1075,"macro@crate::assert_success_false_as_result":1076,"macro@crate::debug_assert_success_false":1077},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_success_false_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"799":{"id":799,"crate_id":0,"name":"assert_command_stdout_lt","span":{"filename":"src/assert_command/assert_command_stdout_lt.rs","begin":[1,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stdout string is less than another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stdout_lt`](macro@crate::assert_command_stdout_lt)\n* [`assert_command_stdout_lt_as_result`](macro@crate::assert_command_stdout_lt_as_result)\n* [`debug_assert_command_stdout_lt`](macro@crate::debug_assert_command_stdout_lt)","links":{"macro@crate::assert_command_stdout_lt_as_result":797,"macro@crate::debug_assert_command_stdout_lt":798,"macro@crate::assert_command_stdout_lt":796},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"522":{"id":522,"crate_id":0,"name":"assert_fn_ge_as_result","span":{"filename":"src/assert_fn/assert_fn_ge.rs","begin":[41,0],"end":[113,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ge`](macro@crate::assert_fn_ge)\n* [`assert_fn_ge_as_result`](macro@crate::assert_fn_ge_as_result)\n* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)\n","links":{"macro@crate::assert_fn_ge":521,"macro@crate::debug_assert_fn_ge":523,"macro@crate::assert_fn_ge_as_result":522},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ge_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path $(,)?) => { ... };\n}"}},"245":{"id":245,"crate_id":0,"name":"assert_not_email_address","span":{"filename":"src/assert_email_address/assert_not_email_address.rs","begin":[1,0],"end":[424,1]},"visibility":"public","docs":"Assert expression is possibly not an email address.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"hello*example.com\";\nassert_not_email_address!(a);\n```\n\nNote: this implementation is relatively basic.\n\n* If you want more capabilities, then use an email address parser.\n\n* If you want to know for sure, then send an email to the address.\n\n# Module macros\n\n* [`assert_not_email_address`](macro@crate::assert_not_email_address)\n* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)\n* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)","links":{"macro@crate::debug_assert_not_email_address":244,"macro@crate::assert_not_email_address_as_result":243,"macro@crate::assert_not_email_address":242},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1126":{"id":1126,"crate_id":0,"name":"assert_poll_ready_eq","span":{"filename":"src/assert_poll/assert_poll_ready_eq.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are equal.\n\nDeprecated. Please rename from `assert_poll_ready_eq` into `assert_ready_eq` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_ready_eq` into `assert_ready_eq` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_ready_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"849":{"id":849,"crate_id":0,"name":"debug_assert_command_stderr_le","span":{"filename":"src/assert_command/assert_command_stderr_le.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to another.\n\nThis macro provides the same statements as [`assert_command_stderr_le {`](macro.assert_command_stderr_le {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_le {`](macro@crate::assert_command_stderr_le {)\n* [`assert_command_stderr_le {`](macro@crate::assert_command_stderr_le {)\n* [`debug_assert_command_stderr_le {`](macro@crate::debug_assert_command_stderr_le {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_le {\n    ($($arg:tt)*) => { ... };\n}"}},"572":{"id":572,"crate_id":0,"name":"debug_assert_fn_err_ge","span":{"filename":"src/assert_fn_err/assert_fn_err_ge.rs","begin":[527,0],"end":[533,1]},"visibility":"public","docs":"Assert a function error is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_err_ge`](macro.assert_fn_err_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)\n* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)\n* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)\n","links":{"macro@crate::debug_assert_fn_err_ge":572,"macro@crate::assert_fn_err_ge":570},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"295":{"id":295,"crate_id":0,"name":"assert_len_ne_as_result","span":{"filename":"src/assert_len/assert_len_ne.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a length is not equal to another.\n\nPseudocode:<br>\na.len() ≠ b.len()\n\n* If true, return Result `Ok((a.len(), b.len()))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_ne`](macro@crate::assert_len_ne)\n* [`assert_len_ne_as_result`](macro@crate::assert_len_ne_as_result)\n* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)\n","links":{"macro@crate::debug_assert_len_ne":296,"macro@crate::assert_len_ne_as_result":295,"macro@crate::assert_len_ne":294},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"899":{"id":899,"crate_id":0,"name":"assert_program_args_stdout_eq","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq.rs","begin":[1,0],"end":[450,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"];\nassert_program_args_stdout_eq!(a_program, a_args, b_program, b_args);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)\n* [`assert_program_args_stdout_eq_as_result`](macro@crate::assert_program_args_stdout_eq_as_result)\n* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)","links":{"macro@crate::assert_program_args_stdout_eq":896,"macro@crate::debug_assert_program_args_stdout_eq":898,"macro@crate::assert_program_args_stdout_eq_as_result":897},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"18":{"id":18,"crate_id":0,"name":"debug_assert_lt","span":{"filename":"src/assert_lt.rs","begin":[477,0],"end":[483,1]},"visibility":"public","docs":"Assert an expression is less than another.\n\nPseudocode:<br>\na < b\n\nThis macro provides the same statements as [`assert_lt`](macro.assert_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_lt`](macro@crate::assert_lt)\n* [`assert_lt`](macro@crate::assert_lt)\n* [`debug_assert_lt`](macro@crate::debug_assert_lt)\n","links":{"macro@crate::debug_assert_lt":18,"macro@crate::assert_lt":16},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"622":{"id":622,"crate_id":0,"name":"assert_fn_ok_ge","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge.rs","begin":[1,0],"end":[533,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 2;\nlet b: i8 = 1;\nassert_fn_ok_ge!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)\n* [`assert_fn_ok_ge_as_result`](macro@crate::assert_fn_ok_ge_as_result)\n* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)","links":{"macro@crate::assert_fn_ok_ge_as_result":620,"macro@crate::debug_assert_fn_ok_ge":621,"macro@crate::assert_fn_ok_ge":619},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"345":{"id":345,"crate_id":0,"name":"assert_err_eq","span":{"filename":"src/assert_err/assert_err_eq.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Err(1);\nlet b: Result<i8, i8> = Err(1);\nassert_err_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Err(1);\nlet b: Result<i8, i8> = Err(2);\nassert_err_eq!(a, b);\n# });\n// assertion failed: `assert_err_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_err_eq.html\n//  a label: `a`,\n//  a debug: `Err(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Err(2)`,\n//  b inner: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_err_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_err_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Err(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Err(2)`,\\n\",\n#     \" b inner: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_err_eq`](macro@crate::assert_err_eq)\n* [`assert_err_eq_as_result`](macro@crate::assert_err_eq_as_result)\n* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)\n","links":{"macro@crate::assert_err_eq":345,"macro@crate::assert_err_eq_as_result":346,"macro@crate::debug_assert_err_eq":347,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"949":{"id":949,"crate_id":0,"name":"assert_program_args_stdout_string_contains","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_contains.rs","begin":[1,0],"end":[357,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) contains (expr into string)\n\nThis uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.\n\n* The containee can be a &str, char, a slice of chars, or a function or\nclosure that determines if a character contains.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet containee = \"lf\";\nassert_program_args_stdout_string_contains!(program, args, containee);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)\n* [`assert_program_args_stdout_string_contains_as_result`](macro@crate::assert_program_args_stdout_string_contains_as_result)\n* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)","links":{"macro@crate::assert_program_args_stdout_string_contains":946,"macro@crate::assert_program_args_stdout_string_contains_as_result":947,"macro@crate::debug_assert_program_args_stdout_string_contains":948},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"68":{"id":68,"crate_id":0,"name":"assert_f64_le_as_result","span":{"filename":"src/assert_f64/assert_f64_le.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f64_le`](macro@crate::assert_f64_le)\n* [`assert_f64_le_as_result`](macro@crate::assert_f64_le_as_result)\n* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)\n","links":{"macro@crate::assert_f64_le":67,"macro@crate::debug_assert_f64_le":69,"macro@crate::assert_f64_le_as_result":68},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_le_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"672":{"id":672,"crate_id":0,"name":"assert_fs_read_to_string_gt","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt.rs","begin":[262,0],"end":[275,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_gt!(&b, &a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_gt!(a, b);\n# });\n// assertion failed: `assert_fs_read_to_string_gt!(a_path, b_path)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_gt.html\n//  a_path label: `a`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_path label: `b`,\n//  b_path debug: `\\\"bravo.txt\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `bravo\\\\n`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_gt!(a_path, b_path)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_gt.html\\n\",\n#     \" a_path label: `a`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_path label: `b`,\\n\",\n#     \" b_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `bravo\\n`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)\n* [`assert_fs_read_to_string_gt_as_result`](macro@crate::assert_fs_read_to_string_gt_as_result)\n* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)\n","links":{"`panic!`":1081,"macro@crate::assert_fs_read_to_string_gt":672,"macro@crate::debug_assert_fs_read_to_string_gt":674,"macro@crate::assert_fs_read_to_string_gt_as_result":673},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_gt {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };\n}"}},"395":{"id":395,"crate_id":0,"name":"assert_option_some_eq","span":{"filename":"src/assert_option/assert_option_some_eq.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nDeprecated. Please rename from `assert_option_some_eq` into `assert_some_eq` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"118":{"id":118,"crate_id":0,"name":"assert_approx_ne","span":{"filename":"src/assert_approx/assert_approx_ne.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a number is approximately not equal to another.\n\nPseudocode:<br>\n| a - b | > 1e-6\n\n* If true, return `(diff, approx)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000012;\nassert_approx_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000011;\nassert_approx_ne!(a, b);\n# });\n// assertion failed: `assert_approx_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_approx_ne.html\n//             a label: `a`,\n//             a debug: `1.0000001`,\n//             b label: `b`,\n//             b debug: `1.0000011`,\n//           | a - b |: `9.536743e-7`,\n//              approx: `1e-6`,\n//  | a - b | > approx: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_approx_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_approx_ne.html\\n\",\n#     \"            a label: `a`,\\n\",\n#     \"            a debug: `1.0000001`,\\n\",\n#     \"            b label: `b`,\\n\",\n#     \"            b debug: `1.0000011`,\\n\",\n#     \"          | a - b |: `9.536743e-7`,\\n\",\n#     \"             approx: `1e-6`,\\n\",\n#     \" | a - b | > approx: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThe macros `assert_approx_ne` and `assert_in_epsilon` can test\napproximations:\n\n* For an approximation, the absolute error (i.e. approx) is the magnitude of\n  the difference between the exact value and the approximation. For this,\n use the macro\n\n* For an approximation, the relative error (i.e. epsilon) is the absolute\n  error divided by the magnitude of the exact value. This can be used to\n  compare approximations of numbers of wildly differing size.\n\n* For example, approximating the number 1,000 with an absolute error of 3\n  is, in most applications, much worse than approximating the number\n  1,000,000 with an absolute error of 3; in the first case the relative\n  error is 0.003 and in the second it is only 0.000003.\n\n* Thanks to Ruby minitest for the example and documentation.\n\n# Module macros\n\n* [`assert_approx_ne`](macro@crate::assert_approx_ne)\n* [`assert_approx_ne_as_result`](macro@crate::assert_approx_ne_as_result)\n* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)\n","links":{"macro@crate::debug_assert_approx_ne":125,"macro@crate::assert_approx_ne":118,"macro@crate::assert_approx_ne_as_result":124,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_approx_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"999":{"id":999,"crate_id":0,"name":"debug_assert_program_args_stderr_ne_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne_x.rs","begin":[400,0],"end":[406,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_ne_x`](macro.assert_program_args_stderr_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)\n* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)\n* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)\n","links":{"macro@crate::assert_program_args_stderr_ne_x":997,"macro@crate::debug_assert_program_args_stderr_ne_x":999},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"722":{"id":722,"crate_id":0,"name":"assert_io_read_to_string_eq","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq.rs","begin":[245,0],"end":[258,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa\".as_bytes();\nlet b = \"alfa\".as_bytes();\nassert_io_read_to_string_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_eq!(a, b);\n# });\n// assertion failed: `assert_io_read_to_string_eq!(a_reader, b_reader)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_eq.html\n//  a label: `a`,\n//  a debug: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `[122, 122]`,\n//        a: `\\\"alfa\\\"`,\n//        b: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_eq!(a_reader, b_reader)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[122, 122]`,\\n\",\n#     \"       a: `\\\"alfa\\\"`,\\n\",\n#     \"       b: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)\n* [`assert_io_read_to_string_eq_as_result`](macro@crate::assert_io_read_to_string_eq_as_result)\n* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)\n","links":{"macro@crate::assert_io_read_to_string_eq":722,"macro@crate::assert_io_read_to_string_eq_as_result":723,"macro@crate::debug_assert_io_read_to_string_eq":724,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_eq {\n    ($a_reader:expr, $b:expr $(,)?) => { ... };\n    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"445":{"id":445,"crate_id":0,"name":"assert_ready_ne_x","span":{"filename":"src/assert_ready/assert_ready_ne_x.rs","begin":[202,0],"end":[215,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::task::Poll;\nuse std::task::Poll::*;\n# fn main() {\nlet a: Poll<i8> = Ready(1);\nlet b: i8 = 2;\nassert_ready_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Poll<i8> = Ready(1);\nlet b: i8 = 1;\nassert_ready_ne_x!(a, b);\n# });\n// assertion failed: `assert_ready_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ready_ne_x.html\n//  a label: `a`,\n//  a debug: `Ready(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ready_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ready_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ready(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)\n* [`assert_ready_ne_x_as_result`](macro@crate::assert_ready_ne_x_as_result)\n* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)\n","links":{"macro@crate::debug_assert_ready_ne_x":447,"macro@crate::assert_ready_ne_x":445,"macro@crate::assert_ready_ne_x_as_result":446,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_ne_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"168":{"id":168,"crate_id":0,"name":"assert_all","span":{"filename":"src/assert_all.rs","begin":[169,0],"end":[182,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2, 3];\nassert_all!(a.into_iter(), |x: i8| x > 0);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, -2, 3];\nassert_all!(a.into_iter(), |x: i8| x > 0);\n# });\n// assertion failed: `assert_all!(collection, predicate)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_all.html\n//  collection label: `a.into_iter()`,\n//  collection debug: `IntoIter([1, -2, 3])`,\n//         predicate: `|x: i8| x > 0`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_all!(collection, predicate)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_all.html\\n\",\n#     \" collection label: `a.into_iter()`,\\n\",\n#     \" collection debug: `IntoIter([1, -2, 3])`,\\n\",\n#     \"        predicate: `|x: i8| x > 0`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_all`](macro@crate::assert_all)\n* [`assert_all_as_result`](macro@crate::assert_all_as_result)\n* [`debug_assert_all`](macro@crate::debug_assert_all)\n","links":{"macro@crate::debug_assert_all":170,"macro@crate::assert_all_as_result":169,"macro@crate::assert_all":168,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_all {\n    ($collection:expr, $predicate:expr $(,)?) => { ... };\n    ($collection:expr, $predicate:expr, $($message:tt)+) => { ... };\n}"}},"1049":{"id":1049,"crate_id":0,"name":"debug_assert_status_code_value_eq_x","span":{"filename":"src/assert_status/assert_status_code_value_eq_x.rs","begin":[374,0],"end":[380,1]},"visibility":"public","docs":"Assert a status code value is equal to an expression.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b\n\nThis macro provides the same statements as [`assert_status_code_value_eq_x`](macro.assert_status_code_value_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)\n* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)\n* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)\n","links":{"macro@crate::assert_status_code_value_eq_x":1047,"macro@crate::debug_assert_status_code_value_eq_x":1049},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"772":{"id":772,"crate_id":0,"name":"debug_assert_io_read_to_string_contains","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_contains.rs","begin":[310,0],"end":[316,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() contains a pattern.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) contains (expr ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_contains`](macro.assert_io_read_to_string_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)\n* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)\n* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)\n","links":{"macro@crate::debug_assert_io_read_to_string_contains":772,"macro@crate::assert_io_read_to_string_contains":770},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"495":{"id":495,"crate_id":0,"name":"assert_set_eq","span":{"filename":"src/assert_set/assert_set_eq.rs","begin":[1,0],"end":[305,1]},"visibility":"public","docs":"Assert a set is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) = (b_collection ⇒ b_set)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [2, 1];\nassert_set_eq!(a, b);\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_eq`](macro@crate::assert_set_eq)\n* [`assert_set_eq_as_result`](macro@crate::assert_set_eq_as_result)\n* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)","links":{"macro@crate::debug_assert_set_eq":494,"macro@crate::assert_set_eq":492,"macro@crate::assert_set_eq_as_result":493},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"218":{"id":218,"crate_id":0,"name":"assert_count_ge_x_as_result","span":{"filename":"src/assert_count/assert_count_ge_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a count is greater than or equal to an expression.\n\nPseudocode:<br>\na.count() ≥ b\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)\n* [`assert_count_ge_x_as_result`](macro@crate::assert_count_ge_x_as_result)\n* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)\n","links":{"macro@crate::assert_count_ge_x":217,"macro@crate::assert_count_ge_x_as_result":218,"macro@crate::debug_assert_count_ge_x":219},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ge_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1099":{"id":1099,"crate_id":0,"name":"assert_result_ok","span":{"filename":"src/assert_result/assert_result_ok.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nDeprecated. Please rename from `assert_result_ok` into `assert_ok` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_ok` into `assert_ok` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_ok {\n    ($($arg:tt)*) => { ... };\n}"}},"822":{"id":822,"crate_id":0,"name":"debug_assert_command_stdout_lt_x","span":{"filename":"src/assert_command/assert_command_stdout_lt_x.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stdout string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_lt_x`](macro.assert_command_stdout_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)\n* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)\n* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)\n","links":{"macro@crate::assert_command_stdout_lt_x":820,"macro@crate::debug_assert_command_stdout_lt_x":822},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"545":{"id":545,"crate_id":0,"name":"assert_fn_ge_x","span":{"filename":"src/assert_fn/assert_fn_ge_x.rs","begin":[268,0],"end":[302,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≥ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_ge_x!(i8::abs, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_ge_x!(i8::abs, a, b);\n# });\n// assertion failed: `assert_fn_ge_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ge_x.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-1`,\n//      b_expr label: `b`,\n//      b_expr debug: `2`,\n//                 a: `1`,\n//                 b: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ge_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ge_x.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `2`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)\n* [`assert_fn_ge_x_as_result`](macro@crate::assert_fn_ge_x_as_result)\n* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)\n","links":{"`panic!`":1081,"macro@crate::assert_fn_ge_x_as_result":546,"macro@crate::debug_assert_fn_ge_x":547,"macro@crate::assert_fn_ge_x":545},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ge_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"268":{"id":268,"crate_id":0,"name":"assert_is_match","span":{"filename":"src/assert_is_match/assert_is_match.rs","begin":[1,0],"end":[285,1]},"visibility":"public","docs":"Assert a matcher is a match for an expression.\n\nPseudocode:<br>\na.is_match(b)\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet a = Regex::new(r\"lf\").expect(\"regex\");\nlet b = \"alfa\";\nassert_is_match!(a, b);\n```\n\n# Module macros\n\n* [`assert_is_match`](macro@crate::assert_is_match)\n* [`assert_is_match_as_result`](macro@crate::assert_is_match_as_result)\n* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)","links":{"macro@crate::assert_is_match":265,"macro@crate::debug_assert_is_match":267,"macro@crate::assert_is_match_as_result":266},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1149":{"id":1149,"crate_id":0,"name":"debug_assert_command_stderr_contains","span":{"filename":"src/assert_command/assert_command_stderr_contains.rs","begin":[45,0],"end":[49,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nDeprecated. Please rename from `debug_assert_command_stderr_contains` into\n`debug_assert_command_stderr_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_command_stderr_contains` into `debug_assert_command_stderr_string_contains`."},"inner":{"macro":"macro_rules! debug_assert_command_stderr_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"872":{"id":872,"crate_id":0,"name":"assert_command_stderr_le_x_as_result","span":{"filename":"src/assert_command/assert_command_stderr_le_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)\n* [`assert_command_stderr_le_x_as_result`](macro@crate::assert_command_stderr_le_x_as_result)\n* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)\n","links":{"macro@crate::assert_command_stderr_le_x_as_result":872,"macro@crate::assert_command_stderr_le_x":871,"macro@crate::debug_assert_command_stderr_le_x":873},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_le_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"595":{"id":595,"crate_id":0,"name":"assert_fn_err_ge_x_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_ge_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function error is greater than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≥ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)\n* [`assert_fn_err_ge_x_as_result`](macro@crate::assert_fn_err_ge_x_as_result)\n* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)\n","links":{"macro@crate::assert_fn_err_ge_x_as_result":595,"macro@crate::debug_assert_fn_err_ge_x":596,"macro@crate::assert_fn_err_ge_x":594},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ge_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"318":{"id":318,"crate_id":0,"name":"assert_len_ne_x","span":{"filename":"src/assert_len/assert_len_ne_x.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a length is not equal to an expression.\n\nPseudocode:<br>\na.len() ≠ b\n\n* If true, return `(a.len(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = 2;\nassert_len_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = 1;\nassert_len_ne_x!(a, b);\n# });\n// assertion failed: `assert_len_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_ne_x.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)\n* [`assert_len_ne_x_as_result`](macro@crate::assert_len_ne_x_as_result)\n* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_len_ne_x":320,"macro@crate::assert_len_ne_x_as_result":319,"macro@crate::assert_len_ne_x":318},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ne_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"922":{"id":922,"crate_id":0,"name":"debug_assert_program_args_stdout_eq_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq_x.rs","begin":[403,0],"end":[409,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_eq_x`](macro.assert_program_args_stdout_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)\n* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)\n* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)\n","links":{"macro@crate::assert_program_args_stdout_eq_x":920,"macro@crate::debug_assert_program_args_stdout_eq_x":922},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"41":{"id":41,"crate_id":0,"name":"assert_f32_gt","span":{"filename":"src/assert_f32/assert_f32_gt.rs","begin":[1,0],"end":[327,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is greater than another within f32::EPSILON.\n\nPseudocode:<br>\na > b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333331;\nassert_f32_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_f32_gt`](macro@crate::assert_f32_gt)\n* [`assert_f32_gt_as_result`](macro@crate::assert_f32_gt_as_result)\n* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)\nAssert a floating point 32-bit number is greater than another within f32::EPSILON.","links":{"macro@crate::assert_f32_gt":38,"macro@crate::debug_assert_f32_gt":40,"macro@crate::assert_f32_gt_as_result":39},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"645":{"id":645,"crate_id":0,"name":"debug_assert_fn_ok_ge_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge_x.rs","begin":[509,0],"end":[515,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr\n\nThis macro provides the same statements as [`assert_fn_ok_ge_x`](macro.assert_fn_ok_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)\n* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)\n* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)\n","links":{"macro@crate::assert_fn_ok_ge_x":643,"macro@crate::debug_assert_fn_ok_ge_x":645},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"368":{"id":368,"crate_id":0,"name":"debug_assert_ok_eq","span":{"filename":"src/assert_ok/assert_ok_eq.rs","begin":[350,0],"end":[356,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)\n\nThis macro provides the same statements as [`assert_ok_eq`](macro.assert_ok_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ok_eq`](macro@crate::assert_ok_eq)\n* [`assert_ok_eq`](macro@crate::assert_ok_eq)\n* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)\n","links":{"macro@crate::assert_ok_eq":366,"macro@crate::debug_assert_ok_eq":368},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ok_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"91":{"id":91,"crate_id":0,"name":"assert_abs_diff_gt_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt_x.rs","begin":[1,0],"end":[466,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nPseudocode:<br>\n|Δ| > x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_gt_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)\n* [`assert_abs_diff_gt_x_as_result`](macro@crate::assert_abs_diff_gt_x_as_result)\n* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)","links":{"macro@crate::debug_assert_abs_diff_gt_x":90,"macro@crate::assert_abs_diff_gt_x":88,"macro@crate::assert_abs_diff_gt_x_as_result":89},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"972":{"id":972,"crate_id":0,"name":"debug_assert_program_args_stderr_lt","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt.rs","begin":[442,0],"end":[448,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)\n\nThis macro provides the same statements as [`assert_program_args_stderr_lt`](macro.assert_program_args_stderr_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)\n* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)\n* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)\n","links":{"macro@crate::debug_assert_program_args_stderr_lt":972,"macro@crate::assert_program_args_stderr_lt":970},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"695":{"id":695,"crate_id":0,"name":"assert_fs_read_to_string_ge_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge_x.rs","begin":[1,0],"end":[399,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"bravo.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_ge_x!(path, x);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)\n* [`assert_fs_read_to_string_ge_x_as_result`](macro@crate::assert_fs_read_to_string_ge_x_as_result)\n* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)","links":{"macro@crate::assert_fs_read_to_string_ge_x":692,"macro@crate::debug_assert_fs_read_to_string_ge_x":694,"macro@crate::assert_fs_read_to_string_ge_x_as_result":693},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"418":{"id":418,"crate_id":0,"name":"assert_some","span":{"filename":"src/assert_some/mod.rs","begin":[1,0],"end":[38,25]},"visibility":"public","docs":"Assert for Some(_) items.\n\nThese macros help compare Some(…) items, such as `::std::Option::Some` or similar.\n\nAssert expression is Some:\n\n* [`assert_some!(a)`](macro@crate::assert_some)\n  ≈ a is Some\n\nCompare Some(…) to another Some(…):\n\n* [`assert_some_eq!(a, b)`](macro@crate::assert_some_eq) ≈ (a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)\n* [`assert_some_ne!(a, b)`](macro@crate::assert_some_ne) ≈ (a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)\n\nCompare Some(…) to an expression:\n\n* [`assert_some_eq_x!(a, expr)`](macro@crate::assert_some_eq_x) ≈ (a ⇒ Some(a1) ⇒ a1) = expr\n* [`assert_some_ne_x!(a, expr)`](macro@crate::assert_some_ne_x) ≈ (a ⇒ Some(a1) ⇒ a1) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::Some(1);\nassert_some!(a);\n```","links":{"macro@crate::assert_some":398,"macro@crate::assert_some_eq":402,"macro@crate::assert_some_ne":406,"macro@crate::assert_some_ne_x":414,"macro@crate::assert_some_eq_x":410},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[401,405,409,413,417],"is_stripped":false}}},"1022":{"id":1022,"crate_id":0,"name":"assert_status_failure","span":{"filename":"src/assert_status/assert_status_failure.rs","begin":[1,0],"end":[274,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nassert_status_failure!(a);\n```\n\n# Module macros\n\n* [`assert_status_failure`](macro@crate::assert_status_failure)\n* [`assert_status_failure_as_result`](macro@crate::assert_status_failure_as_result)\n* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)","links":{"macro@crate::assert_status_failure_as_result":1020,"macro@crate::assert_status_failure":1019,"macro@crate::debug_assert_status_failure":1021},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"141":{"id":141,"crate_id":0,"name":"assert_diff_le_x_as_result","span":{"filename":"src/assert_diff/assert_diff_le_x.rs","begin":[46,0],"end":[108,1]},"visibility":"public","docs":"Assert a difference is less than or equal to an expression.\n\nPseudocode:<br>\nΔ ≤ x\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)\n* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)\n* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)\n","links":{"macro@crate::assert_diff_le_x_as_result":141,"`Err`":1082,"macro@crate::debug_assert_diff_le_x":142,"macro@crate::assert_diff_le_x":140},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_le_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"745":{"id":745,"crate_id":0,"name":"assert_io_read_to_string_ne","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne.rs","begin":[1,0],"end":[369,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)\n* [`assert_io_read_to_string_ne_as_result`](macro@crate::assert_io_read_to_string_ne_as_result)\n* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)","links":{"macro@crate::debug_assert_io_read_to_string_ne":744,"macro@crate::assert_io_read_to_string_ne_as_result":743,"macro@crate::assert_io_read_to_string_ne":742},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"468":{"id":468,"crate_id":0,"name":"assert_iter_eq_as_result","span":{"filename":"src/assert_iter/assert_iter_eq.rs","begin":[45,0],"end":[74,1]},"visibility":"public","docs":"Assert an iterable is equal to another.\n\nPseudocode:<br>\n(collection1 into iter) = (collection2 into iter)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_eq`](macro@crate::assert_iter_eq)\n* [`assert_iter_eq_as_result`](macro@crate::assert_iter_eq_as_result)\n* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)\n","links":{"macro@crate::debug_assert_iter_eq":469,"macro@crate::assert_iter_eq_as_result":468,"macro@crate::assert_iter_eq":467},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_eq_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"191":{"id":191,"crate_id":0,"name":"debug_assert_count_eq","span":{"filename":"src/assert_count/assert_count_eq.rs","begin":[338,0],"end":[344,1]},"visibility":"public","docs":"Assert a count is equal to another.\n\nPseudocode:<br>\na.count() = b.count()\n\nThis macro provides the same statements as [`assert_count_eq`](macro.assert_count_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_eq`](macro@crate::assert_count_eq)\n* [`assert_count_eq`](macro@crate::assert_count_eq)\n* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)\n","links":{"macro@crate::debug_assert_count_eq":191,"macro@crate::assert_count_eq":189},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"1072":{"id":1072,"crate_id":0,"name":"assert_success_as_result","span":{"filename":"src/assert_success/assert_success.rs","begin":[43,0],"end":[62,1]},"visibility":"public","docs":"Assert a success method is true.\n\nPseudocode:<br>\na.success() = true\n\n* If true, return Result `Ok(true)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_success`](macro@crate::assert_success)\n* [`assert_success_as_result`](macro@crate::assert_success_as_result)\n* [`debug_assert_success`](macro@crate::debug_assert_success)\n","links":{"macro@crate::assert_success_as_result":1072,"macro@crate::assert_success":1071,"macro@crate::debug_assert_success":1073},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_success_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"795":{"id":795,"crate_id":0,"name":"assert_command_stdout_le","span":{"filename":"src/assert_command/assert_command_stdout_le.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stdout_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stdout_le`](macro@crate::assert_command_stdout_le)\n* [`assert_command_stdout_le_as_result`](macro@crate::assert_command_stdout_le_as_result)\n* [`debug_assert_command_stdout_le`](macro@crate::debug_assert_command_stdout_le)","links":{"macro@crate::assert_command_stdout_le_as_result":793,"macro@crate::debug_assert_command_stdout_le":794,"macro@crate::assert_command_stdout_le":792},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"518":{"id":518,"crate_id":0,"name":"assert_fn_eq_as_result","span":{"filename":"src/assert_fn/assert_fn_eq.rs","begin":[41,0],"end":[113,1]},"visibility":"public","docs":"Assert a function output is equal to another.\n\nPseudocode:<br>\na_function(a) == b_function(b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_eq`](macro@crate::assert_fn_eq)\n* [`assert_fn_eq_as_result`](macro@crate::assert_fn_eq_as_result)\n* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)\n","links":{"macro@crate::assert_fn_eq":517,"macro@crate::assert_fn_eq_as_result":518,"macro@crate::debug_assert_fn_eq":519},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_eq_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"241":{"id":241,"crate_id":0,"name":"assert_email_address","span":{"filename":"src/assert_email_address/assert_email_address.rs","begin":[1,0],"end":[533,1]},"visibility":"public","docs":"Assert expression is possibly an email address.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"hello@example.com\";\nassert_email_address!(a);\n```\n\nNote: this implementation is relatively basic.\n\n* If you want more capabilities, then use an email address parser.\n\n* If you want to know for sure, then send an email to the address.\n\n# Module macros\n\n* [`assert_email_address`](macro@crate::assert_email_address)\n* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)\n* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)","links":{"macro@crate::assert_email_address":238,"macro@crate::assert_email_address_as_result":239,"macro@crate::debug_assert_email_address":240},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1122":{"id":1122,"crate_id":0,"name":"assert_poll_ready_as_result","span":{"filename":"src/assert_poll/assert_poll_ready.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nDeprecated. Please rename from `assert_poll_ready_as_result` into `assert_ready_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_ready_as_result` into `assert_ready_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_ready_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"845":{"id":845,"crate_id":0,"name":"debug_assert_command_stderr_gt","span":{"filename":"src/assert_command/assert_command_stderr_gt.rs","begin":[384,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stderr string is greater than another.\n\nThis macro provides the same statements as [`assert_command_stderr_gt {`](macro.assert_command_stderr_gt {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_gt {`](macro@crate::assert_command_stderr_gt {)\n* [`assert_command_stderr_gt {`](macro@crate::assert_command_stderr_gt {)\n* [`debug_assert_command_stderr_gt {`](macro@crate::debug_assert_command_stderr_gt {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"568":{"id":568,"crate_id":0,"name":"debug_assert_fn_err_eq","span":{"filename":"src/assert_fn_err/assert_fn_err_eq.rs","begin":[492,0],"end":[498,1]},"visibility":"public","docs":"Assert a function error is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_err_eq`](macro.assert_fn_err_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)\n* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)\n* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)\n","links":{"macro@crate::assert_fn_err_eq":566,"macro@crate::debug_assert_fn_err_eq":568},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"291":{"id":291,"crate_id":0,"name":"assert_len_lt_as_result","span":{"filename":"src/assert_len/assert_len_lt.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a length is less than another.\n\nPseudocode:<br>\na.len() < b.len()\n\n* If true, return Result `Ok((a.len(), b.len()))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_lt`](macro@crate::assert_len_lt)\n* [`assert_len_lt_as_result`](macro@crate::assert_len_lt_as_result)\n* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)\n","links":{"macro@crate::assert_len_lt":290,"macro@crate::debug_assert_len_lt":292,"macro@crate::assert_len_lt_as_result":291},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_lt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"895":{"id":895,"crate_id":0,"name":"assert_command","span":{"filename":"src/assert_command/mod.rs","begin":[1,0],"end":[153,46]},"visibility":"public","docs":"Assert for comparing commands and their stdout & stderr.\n\nThese macros help with calling external commands, then capturing the\nstandard output stream and standard error stream.\nSee tutorial below.\n\nThese macros have corresponding the macros in the module [`assert_program_args`](module@crate::assert_program_args).\n\n## Macros for command standard output\n\nCompare command standard output to another command standard output:\n\n* [`assert_command_stdout_eq!(a_command, b_command)`](macro@crate::assert_command_stdout_eq) ≈ a_command stdout = b_command stdout\n* [`assert_command_stdout_ne!(a_command, b_command)`](macro@crate::assert_command_stdout_ne) ≈ a_command stdout ≠ b_command stdout\n* [`assert_command_stdout_lt!(a_command, b_command)`](macro@crate::assert_command_stdout_lt) ≈ a_command stdout < b_command stdout\n* [`assert_command_stdout_le!(a_command, b_command)`](macro@crate::assert_command_stdout_le) ≈ a_command stdout ≤ b_command stdout\n* [`assert_command_stdout_gt!(a_command, b_command)`](macro@crate::assert_command_stdout_gt) ≈ a_command stdout > b_command stdout\n* [`assert_command_stdout_ge!(a_command, b_command)`](macro@crate::assert_command_stdout_ge) ≈ a_command stdout ≥ b_command stdout\n\nCompare command standard output to an expression:\n\n* [`assert_command_stdout_eq_x!(command, expr)`](macro@crate::assert_command_stdout_eq_x) ≈ command stdout = expr\n* [`assert_command_stdout_ne_x!(command, expr)`](macro@crate::assert_command_stdout_ne_x) ≈ command stdout ≠ expr\n* [`assert_command_stdout_lt_x!(command, expr)`](macro@crate::assert_command_stdout_lt_x) ≈ command stdout < expr\n* [`assert_command_stdout_le_x!(command, expr)`](macro@crate::assert_command_stdout_le_x) ≈ command stdout ≤ expr\n* [`assert_command_stdout_gt_x!(command, expr)`](macro@crate::assert_command_stdout_gt_x) ≈ command stdout > expr\n* [`assert_command_stdout_ge_x!(command, expr)`](macro@crate::assert_command_stdout_ge_x) ≈ command stdout ≥ expr\n\nAssert command standard output as a string:\n\n* [`assert_command_stdout_string_contains!(command, containee)`](macro@crate::assert_command_stdout_string_contains) ≈ command stdout string contains containee\n* [`assert_command_stdout_string_is_match!(command, matcher)`](macro@crate::assert_command_stdout_string_is_match) ≈ command stdout string is a matcher match\n\n## Macros for command standard error\n\nCompare command standard error to another command standard error:\n\n* [`assert_command_stderr_eq!(a_command, b_command)`](macro@crate::assert_command_stderr_eq) ≈ a_command stderr = b_command stderr\n* [`assert_command_stderr_ne!(a_command, b_command)`](macro@crate::assert_command_stderr_ne) ≈ a_command stderr ≠ b_command stderr\n* [`assert_command_stderr_lt!(a_command, b_command)`](macro@crate::assert_command_stderr_lt) ≈ a_command stderr < b_command stderr\n* [`assert_command_stderr_le!(a_command, b_command)`](macro@crate::assert_command_stderr_le) ≈ a_command stderr ≤ b_command stderr\n* [`assert_command_stderr_gt!(a_command, b_command)`](macro@crate::assert_command_stderr_gt) ≈ a_command stderr > b_command stderr\n* [`assert_command_stderr_ge!(a_command, b_command)`](macro@crate::assert_command_stderr_ge) ≈ a_command stderr ≥ b_command stderr\n\nCompare command standard error to an expression:\n\n* [`assert_command_stderr_eq_x!(command, expr)`](macro@crate::assert_command_stderr_eq_x) ≈ command stderr = expr\n* [`assert_command_stderr_ne_x!(command, expr)`](macro@crate::assert_command_stderr_ne_x) ≈ command stderr ≠ expr\n* [`assert_command_stderr_lt_x!(command, expr)`](macro@crate::assert_command_stderr_lt_x) ≈ command stderr < expr\n* [`assert_command_stderr_le_x!(command, expr)`](macro@crate::assert_command_stderr_le_x) ≈ command stderr ≤ expr\n* [`assert_command_stderr_gt_x!(command, expr)`](macro@crate::assert_command_stderr_gt_x) ≈ command stderr > expr\n* [`assert_command_stderr_ge_x!(command, expr)`](macro@crate::assert_command_stderr_ge_x) ≈ command stderr ≥ expr\n\nAssert standard error as a string:\n\n* [`assert_command_stderr_string_contains!(command, containee)`](macro@crate::assert_command_stderr_string_contains) ≈ command stderr string contains containee\n* [`assert_command_stderr_string_is_match!(command, matcher)`](macro@crate::assert_command_stderr_string_is_match) ≈ command stderr string is a matcher match\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"]);\nassert_command_stdout_eq!(a, b);\n```\n\n## Tutorial\n\nRust programs can call system commands.\n\nFor example this system command will print the word hello:\n\n```sh\nprintf %s hello\n```\n\nRust can create a system command then capture its standard output, by using:\n\n```rust\n# use std::process::Command;\nlet mut command = Command::new(\"printf\"); command.args([\"%s\", \"hello\"]);\nlet stdout = command.output().unwrap().stdout;\n```\n\nRust can compare a command's standard output to another command's standard output, by using:\n\n```rust\n# use std::process::Command;\nlet mut a_command = Command::new(\"printf\"); a_command.args([\"%s\", \"hello\"]);\nlet mut b_command = Command::new(\"printf\"); a_command.args([\"%s\", \"world\"]);\nlet a_stdout = a_command.output().unwrap().stdout;\nlet b_stdout = b_command.output().unwrap().stdout;\nassert_ne!(a_stdout, b_stdout);\n```\n\nThe `assertables` crate provides macros that do the same kind of processing, by automatically converting each command into standard output:\n\n```rust\n# use std::process::Command;\n# use assertables::*;\nlet mut a_command = Command::new(\"printf\"); a_command.args([\"%s\", \"hello\"]);\nlet mut b_command = Command::new(\"printf\"); a_command.args([\"%s\", \"world\"]);\nassert_command_stdout_ne!(a_command, b_command);\n```","links":{"macro@crate::assert_command_stdout_lt_x":820,"macro@crate::assert_command_stdout_lt":796,"macro@crate::assert_command_stdout_le":792,"macro@crate::assert_command_stderr_string_is_match":889,"macro@crate::assert_command_stdout_ge":784,"macro@crate::assert_command_stderr_ge_x":863,"macro@crate::assert_command_stderr_ne_x":879,"macro@crate::assert_command_stdout_eq_x":804,"macro@crate::assert_command_stderr_ge":839,"macro@crate::assert_command_stderr_le_x":871,"macro@crate::assert_command_stdout_ge_x":808,"macro@crate::assert_command_stderr_lt_x":875,"module@crate::assert_program_args":893,"macro@crate::assert_command_stderr_gt":843,"macro@crate::assert_command_stderr_lt":851,"macro@crate::assert_command_stdout_gt":788,"macro@crate::assert_command_stdout_ne":800,"macro@crate::assert_command_stdout_string_contains":827,"macro@crate::assert_command_stderr_eq":835,"macro@crate::assert_command_stderr_ne":855,"macro@crate::assert_command_stdout_le_x":816,"macro@crate::assert_command_stdout_ne_x":894,"macro@crate::assert_command_stderr_le":847,"macro@crate::assert_command_stderr_eq_x":859,"macro@crate::assert_command_stderr_gt_x":867,"macro@crate::assert_command_stdout_string_is_match":831,"macro@crate::assert_command_stderr_string_contains":885,"macro@crate::assert_command_stdout_gt_x":812,"macro@crate::assert_command_stdout_eq":780},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[783,787,791,795,799,803,807,811,815,819,823,824,825,826,830,834,838,842,846,850,854,858,862,866,870,874,878,882,883,884,888,892],"is_stripped":false}}},"14":{"id":14,"crate_id":0,"name":"debug_assert_le","span":{"filename":"src/assert_le.rs","begin":[485,0],"end":[491,1]},"visibility":"public","docs":"Assert an expression is less than or equal to another.\n\nPseudocode:<br>\na ≤ b\n\nThis macro provides the same statements as [`assert_le`](macro.assert_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_le`](macro@crate::assert_le)\n* [`assert_le`](macro@crate::assert_le)\n* [`debug_assert_le`](macro@crate::debug_assert_le)\n","links":{"macro@crate::assert_le":12,"macro@crate::debug_assert_le":14},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_le {\n    ($($arg:tt)*) => { ... };\n}"}},"618":{"id":618,"crate_id":0,"name":"assert_fn_ok_eq","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq.rs","begin":[1,0],"end":[497,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b: i8 = 1;\nassert_fn_ok_eq!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)\n* [`assert_fn_ok_eq_as_result`](macro@crate::assert_fn_ok_eq_as_result)\n* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)","links":{"macro@crate::assert_fn_ok_eq":615,"macro@crate::assert_fn_ok_eq_as_result":616,"macro@crate::debug_assert_fn_ok_eq":617},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"341":{"id":341,"crate_id":0,"name":"assert_err","span":{"filename":"src/assert_err/assert_err.rs","begin":[156,0],"end":[169,1]},"visibility":"public","docs":"Assert expression is Err.\n\nPseudocode:<br>\na is Err(a1)\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Err(1);\nassert_err!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Ok(1);\nassert_err!(a);\n# });\n// assertion failed: `assert_err!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_err.html\n//  a label: `a`,\n//  a debug: `Ok(1)`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_err!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_err.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ok(1)`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_err`](macro@crate::assert_err)\n* [`assert_err_as_result`](macro@crate::assert_err_as_result)\n* [`debug_assert_err`](macro@crate::debug_assert_err)\n","links":{"macro@crate::assert_err_as_result":342,"macro@crate::debug_assert_err":343,"macro@crate::assert_err":341,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"945":{"id":945,"crate_id":0,"name":"assert_program_args_stdout_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stdout_is_match.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nDeprecated. Please rename from `assert_program_args_stdout_is_match` to `assert_program_args_stdout_string_is_match`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"64":{"id":64,"crate_id":0,"name":"assert_f64_gt_as_result","span":{"filename":"src/assert_f64/assert_f64_gt.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na > b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f64_gt`](macro@crate::assert_f64_gt)\n* [`assert_f64_gt_as_result`](macro@crate::assert_f64_gt_as_result)\n* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)\n","links":{"macro@crate::assert_f64_gt":63,"macro@crate::assert_f64_gt_as_result":64,"macro@crate::debug_assert_f64_gt":65},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_gt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"668":{"id":668,"crate_id":0,"name":"assert_fs_read_to_string_ge","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge.rs","begin":[280,0],"end":[293,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_ge!(&b, &a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_ge!(a, b);\n# });\n// assertion failed: `assert_fs_read_to_string_ge!(a_path, b_path)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_ge.html\n//  a_path label: `a`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_path label: `b`,\n//  b_path debug: `\\\"bravo.txt\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `bravo\\\\n`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_ge!(a_path, b_path)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_ge.html\\n\",\n#     \" a_path label: `a`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_path label: `b`,\\n\",\n#     \" b_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `bravo\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)\n* [`assert_fs_read_to_string_ge_as_result`](macro@crate::assert_fs_read_to_string_ge_as_result)\n* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)\n","links":{"macro@crate::assert_fs_read_to_string_ge_as_result":669,"macro@crate::debug_assert_fs_read_to_string_ge":670,"macro@crate::assert_fs_read_to_string_ge":668,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ge {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };\n}"}},"391":{"id":391,"crate_id":0,"name":"assert_none","span":{"filename":"src/assert_none/assert_none.rs","begin":[1,0],"end":[247,1]},"visibility":"public","docs":"Assert expression is None.\n\nPseudocode:<br>\na is None\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::None;\nassert_none!(a);\n```\n\n# Module macros\n\n* [`assert_none`](macro@crate::assert_none)\n* [`assert_none_as_result`](macro@crate::assert_none_as_result)\n* [`debug_assert_none`](macro@crate::debug_assert_none)","links":{"macro@crate::debug_assert_none":390,"macro@crate::assert_none":388,"macro@crate::assert_none_as_result":389},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"995":{"id":995,"crate_id":0,"name":"debug_assert_program_args_stderr_lt_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt_x.rs","begin":[402,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_lt_x`](macro.assert_program_args_stderr_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)\n* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)\n* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_lt_x":995,"macro@crate::assert_program_args_stderr_lt_x":993},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"114":{"id":114,"crate_id":0,"name":"assert_abs_diff_gt","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt.rs","begin":[25,0],"end":[29,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nDeprecated. Please rename from `assert_abs_diff_gt` into `assert_abs_diff_gt_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_gt` into `assert_abs_diff_gt_x`."},"inner":{"macro":"macro_rules! assert_abs_diff_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"718":{"id":718,"crate_id":0,"name":"debug_assert_fs_read_to_string_is_match","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_is_match.rs","begin":[336,0],"end":[342,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) matches expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_is_match`](macro.assert_fs_read_to_string_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)\n* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)\n* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)\n","links":{"macro@crate::debug_assert_fs_read_to_string_is_match":718,"macro@crate::assert_fs_read_to_string_is_match":716},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"441":{"id":441,"crate_id":0,"name":"assert_ready_eq_x","span":{"filename":"src/assert_ready/assert_ready_eq_x.rs","begin":[202,0],"end":[215,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::task::Poll;\nuse std::task::Poll::*;\n# fn main() {\nlet a: Poll<i8> = Ready(1);\nlet b: i8 = 1;\nassert_ready_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Poll<i8> = Ready(1);\nlet b: i8 = 2;\nassert_ready_eq_x!(a, b);\n# });\n// assertion failed: `assert_ready_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ready_eq_x.html\n//  a label: `a`,\n//  a debug: `Ready(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ready_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ready_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ready(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)\n* [`assert_ready_eq_x_as_result`](macro@crate::assert_ready_eq_x_as_result)\n* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)\n","links":{"macro@crate::debug_assert_ready_eq_x":443,"macro@crate::assert_ready_eq_x_as_result":442,"macro@crate::assert_ready_eq_x":441,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_eq_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1045":{"id":1045,"crate_id":0,"name":"debug_assert_status_code_value_ne","span":{"filename":"src/assert_status/assert_status_code_value_ne.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_ne`](macro.assert_status_code_value_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)\n","links":{"macro@crate::assert_status_code_value_ne":1043,"macro@crate::debug_assert_status_code_value_ne":1045},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"164":{"id":164,"crate_id":0,"name":"assert_in_range_as_result","span":{"filename":"src/assert_in/assert_in_range.rs","begin":[41,0],"end":[68,1]},"visibility":"public","docs":"Assert an item is in a range.\n\nPseudocode:<br>\na is in range\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_in_range`](macro@crate::assert_in_range)\n* [`assert_in_range_as_result`](macro@crate::assert_in_range_as_result)\n* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)\n","links":{"macro@crate::assert_in_range":163,"macro@crate::assert_in_range_as_result":164,"macro@crate::debug_assert_in_range":165},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_range_as_result {\n    ($a:expr, $range:expr $(,)?) => { ... };\n}"}},"768":{"id":768,"crate_id":0,"name":"debug_assert_io_read_to_string_ne_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne_x.rs","begin":[356,0],"end":[362,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_ne_x`](macro.assert_io_read_to_string_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)\n* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)\n* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)\n","links":{"macro@crate::assert_io_read_to_string_ne_x":766,"macro@crate::debug_assert_io_read_to_string_ne_x":768},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"491":{"id":491,"crate_id":0,"name":"assert_iter","span":{"filename":"src/assert_iter/mod.rs","begin":[1,0],"end":[29,23]},"visibility":"public","docs":"Assert for comparing iter collections.\n\nThese macros help with comparison of iter parameters, such as two arrays or\ntwo vectors. These macros convert each input using the std::iter::Iterator trait.\n\n* [`assert_iter_eq!(collection1, collection2)`](macro@crate::assert_iter_eq) ≈ iter a = iter b\n* [`assert_iter_ne!(collection1, collection2)`](macro@crate::assert_iter_ne) ≈ iter a ≠ iter b\n* [`assert_iter_lt!(collection1, collection2)`](macro@crate::assert_iter_gt) ≈ iter a < iter b\n* [`assert_iter_le!(collection1, collection2)`](macro@crate::assert_iter_gt) ≈ iter a ≤ iter b\n* [`assert_iter_gt!(collection1, collection2)`](macro@crate::assert_iter_gt) ≈ iter a > iter b\n* [`assert_iter_ge!(collection1, collection2)`](macro@crate::assert_iter_ge) ≈ iter a ≥ iter b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [1, 2];\nassert_iter_eq!(&a, &b);\n```","links":{"macro@crate::assert_iter_eq":467,"macro@crate::assert_iter_ne":487,"macro@crate::assert_iter_ge":471,"macro@crate::assert_iter_gt":475},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[470,474,478,482,486,490],"is_stripped":false}}},"1095":{"id":1095,"crate_id":0,"name":"assert_result_err_as_result","span":{"filename":"src/assert_result/assert_result_err.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert expression is Err.\n\nDeprecated. Please rename from `assert_result_err_as_result` into `assert_err_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_err_as_result` into `assert_err_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_err_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"214":{"id":214,"crate_id":0,"name":"assert_count_eq_x_as_result","span":{"filename":"src/assert_count/assert_count_eq_x.rs","begin":[41,0],"end":[71,1]},"visibility":"public","docs":"Assert a count is equal to an expression.\n\nPseudocode:<br>\na.count() = b\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)\n* [`assert_count_eq_x_as_result`](macro@crate::assert_count_eq_x_as_result)\n* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)\n","links":{"macro@crate::debug_assert_count_eq_x":215,"macro@crate::assert_count_eq_x_as_result":214,"macro@crate::assert_count_eq_x":213},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_eq_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"818":{"id":818,"crate_id":0,"name":"debug_assert_command_stdout_le_x","span":{"filename":"src/assert_command/assert_command_stdout_le_x.rs","begin":[375,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_le_x`](macro.assert_command_stdout_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)\n* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)\n* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)\n","links":{"macro@crate::assert_command_stdout_le_x":816,"macro@crate::debug_assert_command_stdout_le_x":818},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"541":{"id":541,"crate_id":0,"name":"assert_fn_eq_x","span":{"filename":"src/assert_fn/assert_fn_eq_x.rs","begin":[245,0],"end":[279,1]},"visibility":"public","docs":"Assert a function output is equal to an expression.\n\nPseudocode:<br>\nfunction(a) = b\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_eq_x!(i8::abs, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_eq_x!(i8::abs, a, b);\n# });\n// assertion failed: `assert_fn_eq_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_eq_x.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-1`,\n//      b_expr label: `b`,\n//      b_expr debug: `2`,\n//                 a: `1`,\n//                 b: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_eq_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_eq_x.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `2`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)\n* [`assert_fn_eq_x_as_result`](macro@crate::assert_fn_eq_x_as_result)\n* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)\n","links":{"macro@crate::assert_fn_eq_x":541,"`panic!`":1081,"macro@crate::debug_assert_fn_eq_x":543,"macro@crate::assert_fn_eq_x_as_result":542},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_eq_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"264":{"id":264,"crate_id":0,"name":"assert_is_empty","span":{"filename":"src/assert_is_empty/mod.rs","begin":[1,0],"end":[19,25]},"visibility":"public","docs":"Assert for method is_empty().\n\nThese macros help with any item that implements self.is_empty().\n\n* [`assert_is_empty!(collection)`](macro@crate::assert_is_empty) ≈ collection.is_empty()\n\n* [`assert_not_empty!(collection)`](macro@crate::assert_not_empty) ≈ !collection.is_empty()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"\";\nassert_is_empty!(a);\n```","links":{"macro@crate::assert_is_empty":256,"macro@crate::assert_not_empty":260},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[259,263],"is_stripped":false}}},"1145":{"id":1145,"crate_id":0,"name":"assert_command_stdout_is_match","span":{"filename":"src/assert_command/assert_command_stdout_is_match.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nDeprecated. Please rename from `assert_command_stdout_is_match` into `assert_command_stdout_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stdout_is_match` into `assert_command_stdout_string_is_match`."},"inner":{"macro":"macro_rules! assert_command_stdout_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"868":{"id":868,"crate_id":0,"name":"assert_command_stderr_gt_x_as_result","span":{"filename":"src/assert_command/assert_command_stderr_gt_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stderr string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)\n* [`assert_command_stderr_gt_x_as_result`](macro@crate::assert_command_stderr_gt_x_as_result)\n* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)\n","links":{"macro@crate::debug_assert_command_stderr_gt_x":869,"macro@crate::assert_command_stderr_gt_x":867,"macro@crate::assert_command_stderr_gt_x_as_result":868},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_gt_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"591":{"id":591,"crate_id":0,"name":"assert_fn_err_eq_x_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_eq_x.rs","begin":[43,0],"end":[158,1]},"visibility":"public","docs":"Assert a function error is equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) = expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)\n* [`assert_fn_err_eq_x_as_result`](macro@crate::assert_fn_err_eq_x_as_result)\n* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)\n","links":{"macro@crate::assert_fn_err_eq_x":590,"macro@crate::debug_assert_fn_err_eq_x":592,"macro@crate::assert_fn_err_eq_x_as_result":591},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_eq_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"314":{"id":314,"crate_id":0,"name":"assert_len_lt_x","span":{"filename":"src/assert_len/assert_len_lt_x.rs","begin":[211,0],"end":[224,1]},"visibility":"public","docs":"Assert a length is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\n* If true, return `(a.len(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = 2;\nassert_len_lt_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\";\nlet b = 1;\nassert_len_lt_x!(a, b);\n# });\n// assertion failed: `assert_len_lt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_lt_x.html\n//  a label: `a`,\n//  a debug: `\\\"xx\\\"`,\n//  a.len(): `2`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_lt_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_lt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"xx\\\"`,\\n\",\n#     \" a.len(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)\n* [`assert_len_lt_x_as_result`](macro@crate::assert_len_lt_x_as_result)\n* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)\n","links":{"macro@crate::debug_assert_len_lt_x":316,"macro@crate::assert_len_lt_x":314,"macro@crate::assert_len_lt_x_as_result":315,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_lt_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"37":{"id":37,"crate_id":0,"name":"assert_f32_ge","span":{"filename":"src/assert_f32/assert_f32_ge.rs","begin":[1,0],"end":[388,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333331;\nassert_f32_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_f32_ge`](macro@crate::assert_f32_ge)\n* [`assert_f32_ge_as_result`](macro@crate::assert_f32_ge_as_result)\n* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)\nAssert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.","links":{"macro@crate::assert_f32_ge":34,"macro@crate::assert_f32_ge_as_result":35,"macro@crate::debug_assert_f32_ge":36},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"918":{"id":918,"crate_id":0,"name":"debug_assert_program_args_stdout_ne","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne.rs","begin":[462,0],"end":[468,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to another.\n\nThis macro provides the same statements as [`assert_program_args_stdout_ne`](macro.assert_program_args_stdout_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)\n* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)\n* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)\n","links":{"macro@crate::assert_program_args_stdout_ne":916,"macro@crate::debug_assert_program_args_stdout_ne":918},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"641":{"id":641,"crate_id":0,"name":"debug_assert_fn_ok_eq_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq_x.rs","begin":[471,0],"end":[477,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr\n\nThis macro provides the same statements as [`assert_fn_ok_eq_x`](macro.assert_fn_ok_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)\n* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)\n* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)\n","links":{"macro@crate::debug_assert_fn_ok_eq_x":641,"macro@crate::assert_fn_ok_eq_x":639},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"364":{"id":364,"crate_id":0,"name":"debug_assert_ok","span":{"filename":"src/assert_ok/assert_ok.rs","begin":[241,0],"end":[247,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nPseudocode:<br>\na is Ok.\n\nThis macro provides the same statements as [`assert_ok`](macro.assert_ok.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ok`](macro@crate::assert_ok)\n* [`assert_ok`](macro@crate::assert_ok)\n* [`debug_assert_ok`](macro@crate::debug_assert_ok)\n","links":{"macro@crate::assert_ok":362,"macro@crate::debug_assert_ok":364},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ok {\n    ($($arg:tt)*) => { ... };\n}"}},"968":{"id":968,"crate_id":0,"name":"debug_assert_program_args_stderr_le","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le.rs","begin":[465,0],"end":[471,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)\n\nThis macro provides the same statements as [`assert_program_args_stderr_le`](macro.assert_program_args_stderr_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)\n* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)\n* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)\n","links":{"macro@crate::assert_program_args_stderr_le":966,"macro@crate::debug_assert_program_args_stderr_le":968},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_le {\n    ($($arg:tt)*) => { ... };\n}"}},"87":{"id":87,"crate_id":0,"name":"assert_abs_diff_ge_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge_x.rs","begin":[1,0],"end":[485,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≥ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 2;\nassert_abs_diff_ge_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)\n* [`assert_abs_diff_ge_x_as_result`](macro@crate::assert_abs_diff_ge_x_as_result)\n* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)","links":{"macro@crate::assert_abs_diff_ge_x":84,"macro@crate::assert_abs_diff_ge_x_as_result":85,"macro@crate::debug_assert_abs_diff_ge_x":86},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"691":{"id":691,"crate_id":0,"name":"assert_fs_read_to_string_eq_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq_x.rs","begin":[1,0],"end":[404,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) = expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet path = \"alfa.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_eq_x!(path, x);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)\n* [`assert_fs_read_to_string_eq_x_as_result`](macro@crate::assert_fs_read_to_string_eq_x_as_result)\n* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)","links":{"macro@crate::assert_fs_read_to_string_eq_x_as_result":689,"macro@crate::assert_fs_read_to_string_eq_x":688,"macro@crate::debug_assert_fs_read_to_string_eq_x":690},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"414":{"id":414,"crate_id":0,"name":"assert_some_ne_x","span":{"filename":"src/assert_some/assert_some_ne_x.rs","begin":[268,0],"end":[281,1]},"visibility":"public","docs":"Assert an expression is Some and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Option<i8> = Option::Some(1);\nlet b: i8 = 2;\nassert_some_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Option<i8> = Option::Some(1);\nlet b: i8 = 1;\nassert_some_ne_x!(a, b);\n# });\n// assertion failed: `assert_some_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_some_ne_x.html\n//  a label: `a`,\n//  a debug: `Some(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_some_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_some_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Some(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)\n* [`assert_some_ne_x_as_result`](macro@crate::assert_some_ne_x_as_result)\n* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)\n","links":{"macro@crate::assert_some_ne_x_as_result":415,"macro@crate::assert_some_ne_x":414,"macro@crate::debug_assert_some_ne_x":416,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_ne_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1018":{"id":1018,"crate_id":0,"name":"assert_status_success_false","span":{"filename":"src/assert_status/assert_status_success_false.rs","begin":[1,0],"end":[274,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nassert_status_success_false!(a);\n```\n\n# Module macros\n\n* [`assert_status_success_false`](macro@crate::assert_status_success_false)\n* [`assert_status_success_false_as_result`](macro@crate::assert_status_success_false_as_result)\n* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)","links":{"macro@crate::debug_assert_status_success_false":1017,"macro@crate::assert_status_success_false_as_result":1016,"macro@crate::assert_status_success_false":1015},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"137":{"id":137,"crate_id":0,"name":"assert_diff_gt_x_as_result","span":{"filename":"src/assert_diff/assert_diff_gt_x.rs","begin":[46,0],"end":[108,1]},"visibility":"public","docs":"Assert a difference is greater than an expression.\n\nPseudocode:<br>\nΔ > x\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)\n* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)\n* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)\n","links":{"macro@crate::assert_diff_gt_x":136,"`Err`":1082,"macro@crate::assert_diff_gt_x_as_result":137,"macro@crate::debug_assert_diff_gt_x":138},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_gt_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"741":{"id":741,"crate_id":0,"name":"assert_io_read_to_string_lt","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt.rs","begin":[1,0],"end":[341,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)\n* [`assert_io_read_to_string_lt_as_result`](macro@crate::assert_io_read_to_string_lt_as_result)\n* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)","links":{"macro@crate::assert_io_read_to_string_lt":738,"macro@crate::assert_io_read_to_string_lt_as_result":739,"macro@crate::debug_assert_io_read_to_string_lt":740},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"464":{"id":464,"crate_id":0,"name":"debug_assert_bag_superbag","span":{"filename":"src/assert_bag/assert_bag_superbag.rs","begin":[355,0],"end":[361,1]},"visibility":"public","docs":"Assert a bag is a superbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)\n\nThis macro provides the same statements as [`assert_bag_superbag`](macro.assert_bag_superbag.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)\n* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)\n* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)\n","links":{"macro@crate::assert_bag_superbag_as_result":463,"macro@crate::debug_assert_bag_superbag":464,"macro@crate::assert_bag_superbag":462},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_bag_superbag {\n    ($($arg:tt)*) => { ... };\n}"}},"1068":{"id":1068,"crate_id":0,"name":"assert_status_code_value_ne_x","span":{"filename":"src/assert_status/assert_status_code_value_ne_x.rs","begin":[1,0],"end":[385,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne_x_as_result`](macro@crate::assert_status_code_value_ne_x_as_result)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)","links":{"macro@crate::assert_status_code_value_ne_x_as_result":1067,"macro@crate::assert_status_code_value_ne":1043,"macro@crate::debug_assert_status_code_value_ne":1045},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"187":{"id":187,"crate_id":0,"name":"assert_not_contains","span":{"filename":"src/assert_contains/assert_not_contains.rs","begin":[1,0],"end":[968,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not contain an expression (such as a substring).\n\nPseudocode:<br>\n¬ a.contains(b)\n\nThese macros work with many kinds of Rust types, such as String, Vec, Range, HashSet.\nThe specifics depend on each type's implementation of a method `contains`, and some types\nrequire the second argument to be borrowable, so be sure to check the Rust documentation.\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::collections::HashSet;\n\n// String does not contain substring.\nlet a = \"alfa\";\nlet b = \"xx\";\nassert_not_contains!(a, b);\n\n// Range does not contain value.\n// Notice the &b because the macro calls Range.contains(&self, &value).\nlet a = 1..3;\nlet b = 4;\nassert_not_contains!(a, &b);\n\n// Vector does not contain element.\n// Notice the &b because the macro calls Vec.contains(&self, &value).\nlet a = vec![1, 2, 3];\nlet b = 4;\nassert_not_contains!(a, &b);\n\n// HashSet does not contain element.\n// Notice the &b because the macro calls HashSet.contains(&self, &value).\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b: String = String::from(\"2\");\nassert_not_contains!(a, &b);\n\n// HashSet does not contain element with automatic borrow optimization.\n// Notice the b because the value type &str is already a reference,\n// which HashSet.contains knows how to borrow to compare to String.\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b = \"2\";\nassert_not_contains!(a, b);\n```\n\n# Module macros\n\n* [`assert_not_contains`](macro@crate::assert_not_contains)\n* [`assert_not_contains_as_result`](macro@crate::assert_not_contains_as_result)\n* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)","links":{"macro@crate::assert_not_contains":184,"macro@crate::assert_not_contains_as_result":185,"macro@crate::debug_assert_not_contains":186},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"791":{"id":791,"crate_id":0,"name":"assert_command_stdout_gt","span":{"filename":"src/assert_command/assert_command_stdout_gt.rs","begin":[1,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stdout string is greater than another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stdout_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stdout_gt`](macro@crate::assert_command_stdout_gt)\n* [`assert_command_stdout_gt_as_result`](macro@crate::assert_command_stdout_gt_as_result)\n* [`debug_assert_command_stdout_gt`](macro@crate::debug_assert_command_stdout_gt)","links":{"macro@crate::assert_command_stdout_gt_as_result":789,"macro@crate::assert_command_stdout_gt":788,"macro@crate::debug_assert_command_stdout_gt":790},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"514":{"id":514,"crate_id":0,"name":"debug_assert_set_superset","span":{"filename":"src/assert_set/assert_set_superset.rs","begin":[300,0],"end":[306,1]},"visibility":"public","docs":"Assert a set is a superset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)\n\nThis macro provides the same statements as [`assert_set_superset`](macro.assert_set_superset.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_set_superset`](macro@crate::assert_set_superset)\n* [`assert_set_superset`](macro@crate::assert_set_superset)\n* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)\n","links":{"macro@crate::debug_assert_set_superset":514,"macro@crate::assert_set_superset":512},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_set_superset {\n    ($($arg:tt)*) => { ... };\n}"}},"1118":{"id":1118,"crate_id":0,"name":"debug_assert_option_some_ne","span":{"filename":"src/assert_option/assert_option_some_ne.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nPlease rename from `debug_assert_option_some_ne` into `debug_assert_some_ne` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_option_some_ne` into `debug_assert_some_ne` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_option_some_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"237":{"id":237,"crate_id":0,"name":"assert_count","span":{"filename":"src/assert_count/mod.rs","begin":[1,0],"end":[48,26]},"visibility":"public","docs":"Assert for comparing counts.\n\nThese macros help with collection counts, such as for strings, arrays,\nvectors, iterators, and anything that has a typical `.count()` method.\n\nCompare a count with another count:\n\n* [`assert_count_eq!(a, b)`](macro@crate::assert_count_eq) ≈ a.count() = b.count()\n* [`assert_count_ne!(a, b)`](macro@crate::assert_count_ne) ≈ a.count() ≠ b.count()\n* [`assert_count_lt!(a, b)`](macro@crate::assert_count_lt) ≈ a.count() < b.count()\n* [`assert_count_le!(a, b)`](macro@crate::assert_count_le) ≈ a.count() ≤ b.count()\n* [`assert_count_gt!(a, b)`](macro@crate::assert_count_gt) ≈ a.count() > b.count()\n* [`assert_count_ge!(a, b)`](macro@crate::assert_count_ge) ≈ a.count() ≥ b.count()\n\nCompare a count with an expression:\n\n* [`assert_count_eq_x!(a, expr)`](macro@crate::assert_count_eq_x) ≈ a.count() = expr\n* [`assert_count_ne_x!(a, expr)`](macro@crate::assert_count_ne_x) ≈ a.count() ≠ expr\n* [`assert_count_lt_x!(a, expr)`](macro@crate::assert_count_lt_x) ≈ a.count() < expr\n* [`assert_count_le_x!(a, expr)`](macro@crate::assert_count_le_x) ≈ a.count() ≤ expr\n* [`assert_count_gt_x!(a, expr)`](macro@crate::assert_count_gt_x) ≈ a.count() > expr\n* [`assert_count_ge_x!(a, expr)`](macro@crate::assert_count_ge_x) ≈ a.count() ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = \"x\".chars();\nassert_count_eq!(a, b);\n```","links":{"macro@crate::assert_count_le":201,"macro@crate::assert_count_le_x":225,"macro@crate::assert_count_ge":193,"macro@crate::assert_count_gt_x":221,"macro@crate::assert_count_lt":205,"macro@crate::assert_count_lt_x":229,"macro@crate::assert_count_ne_x":233,"macro@crate::assert_count_eq_x":213,"macro@crate::assert_count_gt":197,"macro@crate::assert_count_ne":209,"macro@crate::assert_count_ge_x":217,"macro@crate::assert_count_eq":189},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[192,196,200,204,208,212,216,220,224,228,232,236],"is_stripped":false}}},"841":{"id":841,"crate_id":0,"name":"debug_assert_command_stderr_ge","span":{"filename":"src/assert_command/assert_command_stderr_ge.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to another.\n\nThis macro provides the same statements as [`assert_command_stderr_ge {`](macro.assert_command_stderr_ge {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_ge {`](macro@crate::assert_command_stderr_ge {)\n* [`assert_command_stderr_ge {`](macro@crate::assert_command_stderr_ge {)\n* [`debug_assert_command_stderr_ge {`](macro@crate::debug_assert_command_stderr_ge {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"564":{"id":564,"crate_id":0,"name":"assert_fn_ne_x","span":{"filename":"src/assert_fn/assert_fn_ne_x.rs","begin":[1,0],"end":[414,1]},"visibility":"public","docs":"Assert a function output is not equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_ne_x!(i8::abs, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)\n* [`assert_fn_ne_x_as_result`](macro@crate::assert_fn_ne_x_as_result)\n* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)","links":{"macro@crate::assert_fn_ne_x":561,"macro@crate::assert_fn_ne_x_as_result":562,"macro@crate::debug_assert_fn_ne_x":563},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1168":{"id":1168,"crate_id":0,"name":"assertables","span":{"filename":"src/lib.rs","begin":[1,0],"end":[346,23]},"visibility":"public","docs":"# Assertables: assert macros for better testing\n\nAssertables is a Rust crate that provides many assert macros\nto improve your compile-time tests and run-time reliability.\n\n**[documentation](https://docs.rs/assertables/)**\n•\n**[source](https://github.com/sixarm/assertables-rust-crate/)**\n•\n**[llms.txt](https://raw.githubusercontent.com/sixarm/assertables-rust-crate/refs/heads/main/llms.txt)**\n•\n**[crate](https://crates.io/crates/assertables)**\n•\n**[email](mailto:joel@joelparkerhenderson.com)**\n\n## Introduction\n\nThe Assertables Rust crate provides many assert macros\nthat can help you develop, test, and debug.\n\n* Test values with\n  [assert_lt](module@crate::assert_lt),\n  [assert_gt](module@crate::assert_gt),\n  [assert_in](module@crate::assert_in),\n  […](https://docs.rs/assertables)\n* Test groups with\n  [assert_all](module@crate::assert_all),\n  [assert_any](module@crate::assert_any),\n  [assert_iter](module@crate::assert_iter),\n  […](https://docs.rs/assertables)\n* Test wrappers with\n  [assert_ok](module@crate::assert_ok),\n  [assert_some](module@crate::assert_some),\n  [assert_ready](module@crate::assert_ready),\n  […](https://docs.rs/assertables)\n* Test matching with\n  [assert_matches](module@crate::assert_matches),\n  [assert_is_match](module@crate::assert_is_match),\n  […](https://docs.rs/assertables)\n* Test nearness with\n  [assert_approx](module@crate::assert_approx),\n  [assert_abs_diff](module@crate::assert_abs_diff),\n  […](https://docs.rs/assertables/)\n* Test programs with\n  [assert_command](module@crate::assert_command),\n  [assert_status](module@crate::assert_status),\n  […](https://docs.rs/assertables)\n* Many more below.\n\nTo use this crate, add it to your file `Cargo.toml`:\n\n```toml\nassertables = \"9.8.0\"\n```\n\nBenefits:\n\n* You will write better tests to improve reliability and maintainability.\n* You will handle more corner cases without needing to write custom code.\n* You will troubleshoot faster because error messages show more detail.\n\nLearning:\n[FAQ](https://github.com/SixArm/assertables-rust-crate/tree/main/help/faq),\n[docs](https://docs.rs/assertables/),\n[examples](https://github.com/SixArm/assertables-rust-crate/blob/main/tests/examples/),\n[changes](https://github.com/SixArm/assertables-rust-crate/tree/main/CHANGES.md),\n[upgrades](https://github.com/SixArm/assertables-rust-crate/tree/main/help/upgrades/upgrade-from-version-8-to-9),\n[developing](https://github.com/SixArm/assertables-rust-crate/tree/main/help/developing/).\n\nComparisons:\n[more_asserts](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/more_asserts),\n[cool_asserts](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/cool_asserts),\n[assert2](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/assert2),\n[claims](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/claims),\n[etc.](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons)\n\n## Examples\n\nExamples with numbers:\n\n```rust\n# use assertables::*;\nlet i = 1;\nassert_lt!(i, 5);\nassert_diff_eq_x!(i, 5, 4);\nassert_in_range!(i, 1..5);\n```\n\nExamples with strings:\n\n```rust\n# use assertables::*;\n# use regex::Regex;\nlet s = \"hello\";\nassert_starts_with!(s, \"h\");\nassert_contains!(s, \"e\");\nassert_is_match!(Regex::new(r\"h.*o\").unwrap(), s);\n```\n\nExamples with arrays:\n\n```rust\n# use assertables::*;\nlet a = [1, 2, 3];\nassert_not_empty!(a);\nassert_len_eq_x!(a, 3);\nassert_all!(a.into_iter(), |i: i32| i < 4);\n```\n\n## Highlights\n\nValues:\n\n* [`assert_eq!(a, b)`](module@crate::assert_eq)\n* [`assert_ne!(a, b)`](module@crate::assert_ne)\n* [`assert_ge!(a, b)`](module@crate::assert_ge)\n* [`assert_gt!(a, b)`](module@crate::assert_gt)\n* [`assert_le!(a, b)`](module@crate::assert_le)\n* [`assert_lt!(a, b)`](module@crate::assert_lt)\n\nFloats:\n \n* [`assert_f32_eq!(a, b)`](module@crate::assert_f32::assert_f32_eq)\n* [`assert_f64_eq!(a, b)`](module@crate::assert_f64::assert_f64_eq)\n\nNearness:\n\n* [`assert_approx_eq!(a, b)`](module@crate::assert_approx::assert_approx_eq)\n* [`assert_in_delta!(a, b, delta)`](module@crate::assert_in::assert_in_delta)\n* [`assert_in_epsilon!(a, b, epsilon)`](module@crate::assert_in::assert_in_epsilon)\n* [`assert_in_range!(a, range)`](module@crate::assert_in::assert_in_range)\n* [`assert_diff_eq_x!(a, b, x)`](module@crate::assert_diff::assert_diff_eq_x)\n* [`assert_abs_diff_eq_x!(a, b, x)`](module@crate::assert_abs_diff::assert_abs_diff_eq_x)\n\nGroups:\n\n* [`assert_all!(group, predicate)`](module@crate::assert_all)\n* [`assert_any!(group, predicate)`](module@crate::assert_any)\n* [`assert_is_empty!(group)`](module@crate::assert_is_empty::assert_is_empty)\n* [`assert_len_eq!(a, b)`](module@crate::assert_len::assert_len_eq)\n* [`assert_count_eq!(a, b)`](module@crate::assert_count::assert_count_eq)\n\nMatching:\n\n* [`assert_starts_with!(sequence, x)`](module@crate::assert_starts_with)\n* [`assert_ends_with!(sequence, x)`](module@crate::assert_ends_with)\n* [`assert_contains!(container, x)`](module@crate::assert_contains)\n* [`assert_is_match!(matcher, x)`](module@crate::assert_is_match)\n* [`assert_matches!(expr, pattern)`](module@crate::assert_matches)\n* [`assert_email_address!(string)`](module@crate::assert_email_address)\n\nResults:\n\n* [`assert_ok!(result)`](module@crate::assert_ok)\n* [`assert_ok_eq_x!(result, x)`](module@crate::assert_ok::assert_ok_eq_x)\n* [`assert_ok_ne_x!(result, x)`](module@crate::assert_ok::assert_ok_ne_x)\n* [`assert_err!(result)`](module@crate::assert_err)\n\nOptions:\n\n* [`assert_some!(option)`](module@crate::assert_some)\n* [`assert_some_eq_x!(option, x)`](module@crate::assert_some::assert_some_eq_x)\n* [`assert_some_ne_x!(option, x)`](module@crate::assert_some::assert_some_ne_x)\n* [`assert_none!(option)`](module@crate::assert_none)\n\nPolls:\n\n* [`assert_ready!(poll)`](module@crate::assert_ready)\n* [`assert_ready_eq_x!(poll, x)`](module@crate::assert_ready::assert_ready_eq_x)\n* [`assert_ready_ne_x!(poll, x)`](module@crate::assert_ready::assert_ready_ne_x)\n* [`assert_pending!(poll)`](module@crate::assert_pending)\n\nIterators:\n\n* [`assert_iter_eq!(a, b)`](module@crate::assert_iter::assert_iter_eq)\n* [`assert_iter_ne!(a, b)`](module@crate::assert_iter::assert_iter_ne)\n* [`assert_iter_ge!(a, b)`](module@crate::assert_iter::assert_iter_ge)\n* [`assert_iter_gt!(a, b)`](module@crate::assert_iter::assert_iter_gt)\n* [`assert_iter_le!(a, b)`](module@crate::assert_iter::assert_iter_le)\n* [`assert_iter_lt!(a, b)`](module@crate::assert_iter::assert_iter_lt)\n \nSets:\n\n* [`assert_set_eq!(a, b)`](module@crate::assert_set::assert_set_eq)\n* [`assert_set_ne!(a, b)`](module@crate::assert_set::assert_set_ne)\n* [`assert_set_subset!(a, b)`](module@crate::assert_set::assert_set_subset)\n* [`assert_set_superset!(a, b)`](module@crate::assert_set::assert_set_superset)\n\nBags:\n\n* [`assert_bag_eq!(a, b)`](module@crate::assert_bag::assert_bag_eq)\n* [`assert_bag_ne!(a, b)`](module@crate::assert_bag::assert_bag_ne)\n* [`assert_bag_subbag!(a, b)`](module@crate::assert_bag::assert_bag_subbag)\n* [`assert_bag_superbag!(a, b)`](module@crate::assert_bag::assert_bag_superbag)\n \nReaders:\n\n* [`assert_fs_read_to_string_eq_x!(path, x)`](module@crate::assert_fs_read_to_string)\n* [`assert_io_read_to_string_eq_x!(reader, x)`](module@crate::assert_io_read_to_string)\n\nCommands:\n\n* [`assert_command_stdout_eq_x!(command, x)`](module@crate::assert_command) `// command ⇒ stdout == x`\n* [`assert_program_args_stdout_eq_x!(program, args, x)`](module@crate::assert_program_args) `// program.args ⇒ stdout == x`\n\nStatus:\n\n* [`assert_status_success!(a)`](module@crate::assert_status::assert_status_success)\n* [`assert_status_code_value_eq_x!(a, x)`](module@crate::assert_status::assert_status_code_value_eq_x)\n* [`assert_status_code_value_ne_x!(a, x)`](module@crate::assert_status::assert_status_code_value_ne_x)\n* [`assert_status_failure!(a)`](module@crate::assert_status::assert_status_failure)\n\nInfix values:\n \n* [`assert_infix!(a == b)`](module@crate::assert_infix)\n* [`assert_infix!(a != b)`](module@crate::assert_infix)\n* [`assert_infix!(a < b)`](module@crate::assert_infix)\n* [`assert_infix!(a <= b)`](module@crate::assert_infix)\n* [`assert_infix!(a > b)`](module@crate::assert_infix)\n* [`assert_infix!(a >= b)`](module@crate::assert_infix)\n \nInfix logic:\n \n* [`assert_infix!(a & b)`](module@crate::assert_infix)\n* [`assert_infix!(a | b)`](module@crate::assert_infix)\n* [`assert_infix!(a ^ b)`](module@crate::assert_infix)\n* [`assert_infix!(a && b)`](module@crate::assert_infix)\n* [`assert_infix!(a || b)`](module@crate::assert_infix)\n\nFor a complete list of modules and macros, see the\n[docs](https://docs.rs/assertables/).\n\n## Forms\n\nThe Assertables macros have a variety of forms to help you write the tests that matter most to you.\n\nAll the macros have forms for an optional message:\n\n* [`assert_gt!(a, b)`](module@crate::assert_gt) `// default message`\n* [`assert_gt!(a, b, \"your text\")`](module@crate::assert_gt) `// custom message`\n\nAll the macros have forms for different outcomes:\n\n* [`assert_gt!(1, 2)`](macro@crate::assert_gt) `// panic`\n* [`assert_gt_as_result!(1, 2)`](macro@crate::assert_gt_as_result) `// return Result`\n* [`debug_assert_gt!(1, 2)`](macro@crate::debug_assert_gt) `// panic in debug mode`\n\nMany of the macros have a form \"compare left item to right item\" that compares\nitems of the same kind, and a form \"compare left item to right expression\" that\ncompares one item to any arbitrary expression:\n\n* [`assert_len_eq!(a, b)`](module@crate::assert_ok::assert_ok_eq) `// a.len() = b.len()`\n* [`assert_len_eq_x!(a, x)`](module@crate::assert_ok::assert_ok_eq_x)) `// a.len() = x`\n\nMany of the macros has a \"success return\", which means the macro returns data that you can optionally use for more testing.\n\n* [`let inner = assert_ok!(result)`](module@crate::assert_ok::assert_ok)\n* [`let string = assert_fs_read_to_string_ne!(\"alfa.txt\", \"\")`](module@crate::assert_fs_read_to_string::assert_fs_read_to_string_ne)\n* [`let stdout = assert_command_stdout_gt!(\"ls\", vec![b' '])`](module@crate::assert_command::assert_command_stdout_gt)\n\n## Tracking\n\n* Package: assertables-rust-crate\n* Version: 9.8.0\n* Created: 2021-03-30T15:47:49Z\n* Updated: 2025-06-21T22:20:00Z\n* License: MIT or Apache-2.0 or GPL-2.0 or GPL-3.0 or contact us for more\n* Contact: Joel Parker Henderson (joel@joelparkerhenderson.com)","links":{"module@crate::assert_pending":423,"module@crate::assert_status::assert_status_code_value_eq_x":1050,"module@crate::assert_iter::assert_iter_ne":490,"module@crate::assert_all":171,"module@crate::assert_status::assert_status_failure":1022,"module@crate::assert_ok::assert_ok":365,"module@crate::assert_status":1070,"module@crate::assert_abs_diff":116,"module@crate::assert_ok::assert_ok_eq":369,"module@crate::assert_eq":3,"module@crate::assert_ready::assert_ready_eq_x":444,"module@crate::assert_matches":331,"module@crate::assert_ends_with":255,"module@crate::assert_in::assert_in_delta":159,"module@crate::assert_count::assert_count_eq":192,"module@crate::assert_email_address":246,"module@crate::assert_ok::assert_ok_eq_x":377,"module@crate::assert_bag::assert_bag_superbag":465,"module@crate::assert_infix":179,"module@crate::assert_bag::assert_bag_subbag":461,"module@crate::assert_len::assert_len_eq":277,"module@crate::assert_iter":491,"module@crate::assert_command::assert_command_stdout_gt":791,"module@crate::assert_ge":7,"module@crate::assert_f32::assert_f32_eq":33,"module@crate::assert_some::assert_some_ne_x":417,"module@crate::assert_bag::assert_bag_ne":457,"module@crate::assert_set::assert_set_eq":495,"module@crate::assert_bag::assert_bag_eq":453,"module@crate::assert_err":361,"module@crate::assert_gt":11,"module@crate::assert_ready::assert_ready_ne_x":448,"module@crate::assert_iter::assert_iter_lt":486,"module@crate::assert_approx::assert_approx_eq":123,"module@crate::assert_any":175,"module@crate::assert_f64::assert_f64_eq":58,"module@crate::assert_abs_diff::assert_abs_diff_eq_x":83,"module@crate::assert_ok::assert_ok_ne_x":381,"module@crate::assert_is_empty::assert_is_empty":259,"module@crate::assert_set::assert_set_superset":515,"module@crate::assert_is_match":273,"module@crate::assert_in::assert_in_range":166,"module@crate::assert_ne":21,"module@crate::assert_some::assert_some_eq_x":413,"module@crate::assert_status::assert_status_success":1014,"module@crate::assert_io_read_to_string":779,"module@crate::assert_iter::assert_iter_le":482,"module@crate::assert_approx":127,"module@crate::assert_in":167,"module@crate::assert_ready":449,"module@crate::assert_le":15,"module@crate::assert_iter::assert_iter_gt":478,"module@crate::assert_none":392,"module@crate::assert_in::assert_in_epsilon":162,"module@crate::assert_some":418,"module@crate::assert_set::assert_set_ne":499,"module@crate::assert_fs_read_to_string":721,"module@crate::assert_lt":19,"module@crate::assert_starts_with":340,"module@crate::assert_command":895,"module@crate::assert_ok":382,"module@crate::assert_diff::assert_diff_eq_x":131,"module@crate::assert_contains":188,"module@crate::assert_iter::assert_iter_ge":474,"module@crate::assert_set::assert_set_subset":511,"module@crate::assert_program_args":893,"macro@crate::assert_gt_as_result":9,"module@crate::assert_fs_read_to_string::assert_fs_read_to_string_ne":687,"macro@crate::debug_assert_gt":10,"module@crate::assert_iter::assert_iter_eq":470,"macro@crate::assert_gt":8,"module@crate::assert_status::assert_status_code_value_ne_x":1068},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":true,"items":[1,3,7,11,15,19,21,25,29,54,79,116,127,152,167,171,175,179,188,237,246,255,264,273,322,331,340,361,382,387,392,397,418,423,428,449,466,491,516,565,614,663,721,779,895,893,1070,1079,1080,2,5,4,6,9,8,10,13,12,14,17,16,18,20,23,22,24,27,26,28,31,30,32,35,34,36,39,38,40,43,42,44,47,46,48,51,50,52,56,55,57,60,59,61,64,63,65,68,67,69,72,71,73,76,75,77,81,80,82,85,84,86,89,88,90,93,92,94,97,96,98,101,100,102,1083,110,1084,1085,115,1086,1087,114,1088,1089,113,1090,1091,112,1092,1093,111,1094,121,117,122,124,118,125,129,128,130,133,132,134,137,136,138,141,140,142,145,144,146,149,148,150,154,153,155,157,119,158,160,120,161,164,163,165,169,168,170,173,172,174,177,176,178,181,180,182,185,184,186,190,189,191,194,193,195,198,197,199,202,201,203,206,205,207,210,209,211,214,213,215,218,217,219,222,221,223,226,225,227,230,229,231,234,233,235,239,238,240,243,242,244,248,247,249,252,251,253,257,256,258,261,260,262,266,265,267,270,269,271,275,274,276,279,278,280,283,282,284,287,286,288,291,290,292,295,294,296,299,298,300,303,302,304,307,306,308,311,310,312,315,314,316,319,318,320,324,323,325,328,327,329,333,332,334,337,336,338,342,341,343,346,345,347,350,349,351,354,353,355,358,357,359,363,362,364,367,366,368,371,370,372,375,374,376,379,378,380,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,389,388,390,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,399,398,400,403,402,404,407,406,408,411,410,412,415,414,416,420,419,421,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,430,429,431,434,433,435,438,437,439,442,441,443,446,445,447,1131,451,450,452,455,454,456,459,458,460,463,462,464,468,467,469,472,471,473,476,475,477,480,479,481,484,483,485,488,487,489,1132,493,492,494,497,496,498,501,500,502,505,504,506,509,508,510,513,512,514,518,517,519,522,521,523,526,525,527,530,529,531,534,533,535,538,537,539,542,541,543,546,545,547,550,549,551,554,553,555,558,557,559,562,561,563,567,566,568,571,570,572,575,574,576,579,578,580,583,582,584,587,586,588,591,590,592,595,594,596,599,598,600,603,602,604,607,606,608,611,610,612,616,615,617,620,619,621,624,623,625,628,627,629,632,631,633,636,635,637,640,639,641,644,643,645,648,647,649,652,651,653,656,655,657,660,659,661,665,664,666,669,668,670,673,672,674,677,676,678,681,680,682,685,684,686,689,688,690,693,692,694,697,696,698,701,700,702,705,704,706,709,708,710,713,712,714,717,716,718,1133,1134,1135,723,722,724,727,726,728,731,730,732,735,734,736,739,738,740,743,742,744,747,746,748,751,750,752,755,754,756,759,758,760,763,762,764,767,766,768,771,770,772,775,774,776,1136,1137,1138,781,780,782,785,784,786,789,788,790,793,792,794,797,796,798,801,800,802,805,804,806,809,808,810,813,812,814,817,816,818,821,820,822,1139,894,1140,1141,1142,1143,1144,1145,1146,828,827,829,832,831,833,836,835,837,840,839,841,844,843,845,848,847,849,852,851,853,856,855,857,860,859,861,864,863,865,868,867,869,872,871,873,876,875,877,880,879,881,1147,1148,1149,1150,1151,1152,886,885,887,890,889,891,1153,897,896,898,901,900,902,905,904,906,909,908,910,913,912,914,917,916,918,921,920,922,925,924,926,929,928,930,933,932,934,937,936,938,941,940,942,1154,1155,1156,1157,1158,1159,947,946,948,951,950,952,955,954,956,959,958,960,963,962,964,967,966,968,971,970,972,975,974,976,979,978,980,1160,982,983,986,985,987,990,989,991,994,993,995,998,997,999,1161,1162,1163,1164,1165,1166,1004,1003,1005,1008,1007,1009,1012,1011,1013,1016,1015,1017,1020,1019,1021,1024,1023,1025,1028,1027,1029,1032,1031,1033,1036,1035,1037,1040,1039,1041,1044,1043,1045,1048,1047,1049,1052,1051,1053,1056,1055,1057,1060,1059,1061,1064,1063,1065,1067,1069,1167,1072,1071,1073,1076,1075,1077],"is_stripped":false}}},"287":{"id":287,"crate_id":0,"name":"assert_len_le_as_result","span":{"filename":"src/assert_len/assert_len_le.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a length is less than or equal to another.\n\nPseudocode:<br>\na.len() ≤ b.len()\n\n* If true, return Result `Ok((a.len(), b.len()))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_le`](macro@crate::assert_len_le)\n* [`assert_len_le_as_result`](macro@crate::assert_len_le_as_result)\n* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)\n","links":{"macro@crate::assert_len_le_as_result":287,"macro@crate::debug_assert_len_le":288,"macro@crate::assert_len_le":286},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_le_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"10":{"id":10,"crate_id":0,"name":"debug_assert_gt","span":{"filename":"src/assert_gt.rs","begin":[475,0],"end":[481,1]},"visibility":"public","docs":"Assert an expression is greater than another.\n\nPseudocode:<br>\na > b\n\nThis macro provides the same statements as [`assert_gt`](macro.assert_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_gt`](macro@crate::assert_gt)\n* [`assert_gt`](macro@crate::assert_gt)\n* [`debug_assert_gt`](macro@crate::debug_assert_gt)\n","links":{"macro@crate::debug_assert_gt":10,"macro@crate::assert_gt":8},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"891":{"id":891,"crate_id":0,"name":"debug_assert_command_stderr_string_is_match","span":{"filename":"src/assert_command/assert_command_stderr_string_is_match.rs","begin":[327,0],"end":[333,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) is match (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_string_is_match`](macro.assert_command_stderr_string_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)\n* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)\n* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)\n","links":{"macro@crate::assert_command_stderr_string_is_match":889,"macro@crate::debug_assert_command_stderr_string_is_match":891},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_string_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"614":{"id":614,"crate_id":0,"name":"assert_fn_err","span":{"filename":"src/assert_fn_err/mod.rs","begin":[1,0],"end":[60,27]},"visibility":"public","docs":"Assert for comparing functions that return errors.\n\nThese macros help compare functions that return results that are errors,\nsuch as `::std::Result::Err` or similar.\n\nThe macros use these capabilities:\n\n* implements `.is_err() -> bool`\n\n* implements `.unwrap_err() -> comparable`\n\nCompare a function Err() with another function Err():\n\n* [`assert_fn_err_eq!(a_function, b_function)`](macro@crate::assert_fn_err_eq) ≈ a_function().unwrap_err() = b_function().unwrap_err()\n* [`assert_fn_err_ne!(a_function, b_function)`](macro@crate::assert_fn_err_ne) ≈ a_function().unwrap_err() ≠ b_function().unwrap_err()\n* [`assert_fn_err_ge!(a_function, b_function)`](macro@crate::assert_fn_err_ge) ≈ a_function().unwrap_err() ≥ b_function().unwrap_err()\n* [`assert_fn_err_gt!(a_function, b_function)`](macro@crate::assert_fn_err_gt) ≈ a_function().unwrap_err() > b_function().unwrap_err()\n* [`assert_fn_err_le!(a_function, b_function)`](macro@crate::assert_fn_err_le) ≈ a_function().unwrap_err() ≤ b_function().unwrap_err()\n* [`assert_fn_err_lt!(a_function, b_function)`](macro@crate::assert_fn_err_lt) ≈ a_function().unwrap_err() < b_function().unwrap_err()\n\nCompare a function Err() with an expression:\n\n* [`assert_fn_err_eq_x!(function, expr)`](macro@crate::assert_fn_err_eq_x) ≈ function().unwrap_err() = expr\n* [`assert_fn_err_ne_x!(function, expr)`](macro@crate::assert_fn_err_ne_x) ≈ function().unwrap_err() ≠ expr\n* [`assert_fn_err_ge_x!(function, expr)`](macro@crate::assert_fn_err_ge_x) ≈ function().unwrap_err() ≥ expr\n* [`assert_fn_err_gt_x!(function, expr)`](macro@crate::assert_fn_err_gt_x) ≈ function().unwrap_err() > expr\n* [`assert_fn_err_le_x!(function, expr)`](macro@crate::assert_fn_err_le_x) ≈ function().unwrap_err() ≤ expr\n* [`assert_fn_err_lt_x!(function, expr)`](macro@crate::assert_fn_err_lt_x) ≈ function().unwrap_err() < expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b: i8 = 10;\nassert_fn_err_eq!(f, a, f, b);\n```","links":{"macro@crate::assert_fn_err_le":578,"macro@crate::assert_fn_err_lt":582,"macro@crate::assert_fn_err_gt_x":598,"macro@crate::assert_fn_err_lt_x":606,"macro@crate::assert_fn_err_le_x":602,"macro@crate::assert_fn_err_eq":566,"macro@crate::assert_fn_err_eq_x":590,"macro@crate::assert_fn_err_ge_x":594,"macro@crate::assert_fn_err_ne_x":610,"macro@crate::assert_fn_err_ne":586,"macro@crate::assert_fn_err_gt":574,"macro@crate::assert_fn_err_ge":570},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[569,573,577,581,585,589,593,597,601,605,609,613],"is_stripped":false}}},"337":{"id":337,"crate_id":0,"name":"assert_starts_with_as_result","span":{"filename":"src/assert_starts_with/assert_starts_with.rs","begin":[47,0],"end":[74,1]},"visibility":"public","docs":"Assert an expression (such as a string) starts with an expression (such as a substring).\n\nPseudocode:<br>\na.starts_with(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_starts_with`](macro@crate::assert_starts_with)\n* [`assert_starts_with_as_result`](macro@crate::assert_starts_with_as_result)\n* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)\n","links":{"macro@crate::assert_starts_with_as_result":337,"macro@crate::assert_starts_with":336,"macro@crate::debug_assert_starts_with":338},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_starts_with_as_result {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n}"}},"60":{"id":60,"crate_id":0,"name":"assert_f64_ge_as_result","span":{"filename":"src/assert_f64/assert_f64_ge.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f64_ge`](macro@crate::assert_f64_ge)\n* [`assert_f64_ge_as_result`](macro@crate::assert_f64_ge_as_result)\n* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)\n","links":{"macro@crate::assert_f64_ge":59,"macro@crate::assert_f64_ge_as_result":60,"macro@crate::debug_assert_f64_ge":61},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_ge_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"941":{"id":941,"crate_id":0,"name":"assert_program_args_stdout_ne_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)\n* [`assert_program_args_stdout_ne_x_as_result`](macro@crate::assert_program_args_stdout_ne_x_as_result)\n* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)\n","links":{"macro@crate::assert_program_args_stdout_ne_x":940,"macro@crate::debug_assert_program_args_stdout_ne_x":942,"macro@crate::assert_program_args_stdout_ne_x_as_result":941},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ne_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"664":{"id":664,"crate_id":0,"name":"assert_fs_read_to_string_eq","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)\n\n* If true, return (a_path_into_string, b_path_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet a = \"alfa.txt\";\nlet b = \"alfa.txt\";\nassert_fs_read_to_string_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa.txt\";\nlet b = \"bravo.txt\";\nassert_fs_read_to_string_eq!(a, b);\n# });\n// assertion failed: `assert_fs_read_to_string_eq!(a_path, b_path)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_eq.html\n//  a_path label: `a`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_path label: `b`,\n//  b_path debug: `\\\"bravo.txt\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `bravo\\\\n`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_eq!(a_path, b_path)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_eq.html\\n\",\n#     \" a_path label: `a`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_path label: `b`,\\n\",\n#     \" b_path debug: `\\\"bravo.txt\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `bravo\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)\n* [`assert_fs_read_to_string_eq_as_result`](macro@crate::assert_fs_read_to_string_eq_as_result)\n* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)\n","links":{"macro@crate::debug_assert_fs_read_to_string_eq":666,"macro@crate::assert_fs_read_to_string_eq_as_result":665,"macro@crate::assert_fs_read_to_string_eq":664,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_eq {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };\n}"}},"387":{"id":387,"crate_id":0,"name":"assert_result","span":{"filename":"src/assert_result/mod.rs","begin":[1,0],"end":[13,28]},"visibility":"public","docs":"Assert for `Result` {`Ok`, `Err`}\n\nDeprecated.\n\nPlease rename from `assert_result_ok*` into `assert_ok*`.\n\nPlease rename from `assert_result_err` into `assert_err`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[383,384,385,386],"is_stripped":false}}},"110":{"id":110,"crate_id":0,"name":"assert_abs_diff_eq","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq.rs","begin":[25,0],"end":[29,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_eq` into `assert_abs_diff_eq_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_eq` into `assert_abs_diff_eq_x`."},"inner":{"macro":"macro_rules! assert_abs_diff_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"991":{"id":991,"crate_id":0,"name":"debug_assert_program_args_stderr_le_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le_x.rs","begin":[411,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_le_x`](macro.assert_program_args_stderr_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)\n* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)\n* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_le_x":991,"macro@crate::assert_program_args_stderr_le_x":989},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"714":{"id":714,"crate_id":0,"name":"debug_assert_fs_read_to_string_contains","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_contains.rs","begin":[336,0],"end":[342,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) contains a pattern.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) contains expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_contains`](macro.assert_fs_read_to_string_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)\n* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)\n* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)\n","links":{"macro@crate::debug_assert_fs_read_to_string_contains":714,"macro@crate::assert_fs_read_to_string_contains":712},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"437":{"id":437,"crate_id":0,"name":"assert_ready_ne","span":{"filename":"src/assert_ready/assert_ready_ne.rs","begin":[207,0],"end":[220,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::task::Poll;\nuse std::task::Poll::*;\n# fn main() {\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(2);\nassert_ready_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(1);\nassert_ready_ne!(a, b);\n# });\n// assertion failed: `assert_ready_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ready_ne.html\n//  a label: `a`,\n//  a debug: `Ready(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Ready(1)`,\n//  b inner: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ready_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ready_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ready(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Ready(1)`,\\n\",\n#     \" b inner: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ready_ne`](macro@crate::assert_ready_ne)\n* [`assert_ready_ne_as_result`](macro@crate::assert_ready_ne_as_result)\n* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)\n","links":{"macro@crate::debug_assert_ready_ne":439,"macro@crate::assert_ready_ne_as_result":438,"macro@crate::assert_ready_ne":437,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"160":{"id":160,"crate_id":0,"name":"assert_in_epsilon_as_result","span":{"filename":"src/assert_in/assert_in_epsilon.rs","begin":[80,0],"end":[120,1]},"visibility":"public","docs":"Assert a number is within epsilon of another.\n\nPseudocode:<br>\n| a - b | ≤ ε * min(a, b)\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)\n* [`assert_in_epsilon_as_result`](macro@crate::assert_in_epsilon_as_result)\n* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)\n","links":{"macro@crate::assert_in_epsilon_as_result":160,"macro@crate::debug_assert_in_epsilon":161,"`Err`":1082,"macro@crate::assert_in_epsilon":120},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_epsilon_as_result {\n    ($a:expr, $b:expr, $epsilon:expr $(,)?) => { ... };\n}"}},"1041":{"id":1041,"crate_id":0,"name":"debug_assert_status_code_value_lt","span":{"filename":"src/assert_status/assert_status_code_value_lt.rs","begin":[390,0],"end":[396,1]},"visibility":"public","docs":"Assert a status code value is less than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_lt`](macro.assert_status_code_value_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)\n* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)\n* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)\n","links":{"macro@crate::assert_status_code_value_lt":1039,"macro@crate::debug_assert_status_code_value_lt":1041},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"764":{"id":764,"crate_id":0,"name":"debug_assert_io_read_to_string_lt_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt_x.rs","begin":[365,0],"end":[371,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_lt_x`](macro.assert_io_read_to_string_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)\n* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)\n* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)\n","links":{"macro@crate::assert_io_read_to_string_lt_x":762,"macro@crate::debug_assert_io_read_to_string_lt_x":764},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"487":{"id":487,"crate_id":0,"name":"assert_iter_ne","span":{"filename":"src/assert_iter/assert_iter_ne.rs","begin":[164,0],"end":[177,1]},"visibility":"public","docs":"Assert an iterable is not equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≠ (collection2 into iter)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_ne!(&a, &b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [1, 2];\nassert_iter_ne!(&a, &b);\n# });\n// assertion failed: `assert_iter_ne!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_iter_ne.html\n//  a label: `&a`,\n//  a debug: `[1, 2]`,\n//  b label: `&b`,\n//  b debug: `[1, 2]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_iter_ne!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_iter_ne.html\\n\",\n#     \" a label: `&a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `&b`,\\n\",\n#     \" b debug: `[1, 2]`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_ne`](macro@crate::assert_iter_ne)\n* [`assert_iter_ne_as_result`](macro@crate::assert_iter_ne_as_result)\n* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)\n","links":{"macro@crate::assert_iter_ne_as_result":488,"macro@crate::assert_iter_ne":487,"macro@crate::debug_assert_iter_ne":489,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_ne {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1091":{"id":1091,"crate_id":0,"name":"assert_abs_diff_lt_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nDeprecated. Please rename from `assert_abs_diff_lt_as_result` into `assert_abs_diff_lt_x_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_lt_as_result` into `assert_abs_diff_lt_x_as_result`."},"inner":{"macro":"macro_rules! assert_abs_diff_lt_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"210":{"id":210,"crate_id":0,"name":"assert_count_ne_as_result","span":{"filename":"src/assert_count/assert_count_ne.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a count is not equal to another.\n\nPseudocode:<br>\na.count() ≠ b.count()\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_ne`](macro@crate::assert_count_ne)\n* [`assert_count_ne_as_result`](macro@crate::assert_count_ne_as_result)\n* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)\n","links":{"macro@crate::assert_count_ne":209,"macro@crate::debug_assert_count_ne":211,"macro@crate::assert_count_ne_as_result":210},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"814":{"id":814,"crate_id":0,"name":"debug_assert_command_stdout_gt_x","span":{"filename":"src/assert_command/assert_command_stdout_gt_x.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stdout string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_gt_x`](macro.assert_command_stdout_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)\n* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)\n* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)\n","links":{"macro@crate::assert_command_stdout_gt_x":812,"macro@crate::debug_assert_command_stdout_gt_x":814},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"537":{"id":537,"crate_id":0,"name":"assert_fn_ne","span":{"filename":"src/assert_fn/assert_fn_ne.rs","begin":[259,0],"end":[293,1]},"visibility":"public","docs":"Assert a function output is not equal to another.\n\nPseudocode:<br>\na_function(a) ≠ b_function(b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_ne!(i8::abs, a, i8::abs, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_ne!(i8::abs, a, i8::abs, b);\n# });\n// assertion failed: `assert_fn_ne!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ne.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-1`,\n//  b_function label: `i8::abs`,\n//     b_param label: `b`,\n//     b_param debug: `1`,\n//                 a: `1`,\n//                 b: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ne!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ne.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-1`,\\n\",\n#     \" b_function label: `i8::abs`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `1`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ne`](macro@crate::assert_fn_ne)\n* [`assert_fn_ne_as_result`](macro@crate::assert_fn_ne_as_result)\n* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fn_ne":539,"macro@crate::assert_fn_ne_as_result":538,"macro@crate::assert_fn_ne":537},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ne {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"260":{"id":260,"crate_id":0,"name":"assert_not_empty","span":{"filename":"src/assert_is_empty/assert_not_empty.rs","begin":[159,0],"end":[172,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is not empty.\n\nPseudocode:<br>\n¬ a.is_empty()\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"alfa\";\nassert_not_empty!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"\";\nassert_not_empty!(a);\n# });\n// assertion failed: `assert_not_empty!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_empty.html\n//  label: `a`,\n//  debug: `\\\"\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_empty!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_empty.html\\n\",\n#     \" label: `a`,\\n\",\n#     \" debug: `\\\"\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_empty`](macro@crate::assert_not_empty)\n* [`assert_not_empty_as_result`](macro@crate::assert_not_empty_as_result)\n* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)\n","links":{"`panic!`":1081,"macro@crate::assert_not_empty":260,"macro@crate::debug_assert_not_empty":262,"macro@crate::assert_not_empty_as_result":261},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_empty {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"1141":{"id":1141,"crate_id":0,"name":"assert_command_stdout_contains_as_result","span":{"filename":"src/assert_command/assert_command_stdout_contains.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nDeprecated. Please rename from `assert_command_stdout_contains_as_result` into `assert_command_stdout_string_contains_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stdout_contains_as_result` into `assert_command_stdout_string_contains_as_result`."},"inner":{"macro":"macro_rules! assert_command_stdout_contains_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"864":{"id":864,"crate_id":0,"name":"assert_command_stderr_ge_x_as_result","span":{"filename":"src/assert_command/assert_command_stderr_ge_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)\n* [`assert_command_stderr_ge_x_as_result`](macro@crate::assert_command_stderr_ge_x_as_result)\n* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)\n","links":{"macro@crate::assert_command_stderr_ge_x":863,"macro@crate::assert_command_stderr_ge_x_as_result":864,"macro@crate::debug_assert_command_stderr_ge_x":865},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ge_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"587":{"id":587,"crate_id":0,"name":"assert_fn_err_ne_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_ne.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function error is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)\n* [`assert_fn_err_ne_as_result`](macro@crate::assert_fn_err_ne_as_result)\n* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)\n","links":{"macro@crate::assert_fn_err_ne":586,"macro@crate::assert_fn_err_ne_as_result":587,"macro@crate::debug_assert_fn_err_ne":588},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ne_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"310":{"id":310,"crate_id":0,"name":"assert_len_le_x","span":{"filename":"src/assert_len/assert_len_le_x.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a length is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\n* If true, return `(a.len(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = 2;\nassert_len_le_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\";\nlet b = 1;\nassert_len_le_x!(a, b);\n# });\n// assertion failed: `assert_len_le_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_le_x.html\n//  a label: `a`,\n//  a debug: `\\\"xx\\\"`,\n//  a.len(): `2`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_le_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_le_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"xx\\\"`,\\n\",\n#     \" a.len(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_le_x`](macro@crate::assert_len_le_x)\n* [`assert_len_le_x_as_result`](macro@crate::assert_len_le_x_as_result)\n* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)\n","links":{"macro@crate::assert_len_le_x":310,"macro@crate::assert_len_le_x_as_result":311,"macro@crate::debug_assert_len_le_x":312,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_le_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"33":{"id":33,"crate_id":0,"name":"assert_f32_eq","span":{"filename":"src/assert_f32/assert_f32_eq.rs","begin":[1,0],"end":[368,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333333;\nassert_f32_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_f32_eq`](macro@crate::assert_f32_eq)\n* [`assert_f32_eq_as_result`](macro@crate::assert_f32_eq_as_result)\n* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)\nAssert a floating point 32-bit number is equal to another within f32::EPSILON.","links":{"macro@crate::assert_f32_eq":30,"macro@crate::debug_assert_f32_eq":32,"macro@crate::assert_f32_eq_as_result":31},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"914":{"id":914,"crate_id":0,"name":"debug_assert_program_args_stdout_lt","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt.rs","begin":[443,0],"end":[449,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)\n\nThis macro provides the same statements as [`assert_program_args_stdout_lt`](macro.assert_program_args_stdout_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)\n* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)\n* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)\n","links":{"macro@crate::debug_assert_program_args_stdout_lt":914,"macro@crate::assert_program_args_stdout_lt":912},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"637":{"id":637,"crate_id":0,"name":"debug_assert_fn_ok_ne","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne.rs","begin":[491,0],"end":[497,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_ok_ne`](macro.assert_fn_ok_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)\n* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)\n* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)\n","links":{"macro@crate::debug_assert_fn_ok_ne":637,"macro@crate::assert_fn_ok_ne":635},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"360":{"id":360,"crate_id":0,"name":"assert_err_ne_x","span":{"filename":"src/assert_err/assert_err_ne_x.rs","begin":[1,0],"end":[390,1]},"visibility":"public","docs":"Assert an expression is Err and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Err(1);\nlet b: i8 = 2;\nassert_err_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)\n* [`assert_err_ne_x_as_result`](macro@crate::assert_err_ne_x_as_result)\n* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)","links":{"macro@crate::assert_err_ne_x":357,"macro@crate::assert_err_ne_x_as_result":358,"macro@crate::debug_assert_err_ne_x":359},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"83":{"id":83,"crate_id":0,"name":"assert_abs_diff_eq_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq_x.rs","begin":[1,0],"end":[466,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nPseudocode:<br>\n|Δ| = x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 3;\nassert_abs_diff_eq_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)\n* [`assert_abs_diff_eq_x_as_result`](macro@crate::assert_abs_diff_eq_x_as_result)\n* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)","links":{"macro@crate::assert_abs_diff_eq_x":80,"macro@crate::assert_abs_diff_eq_x_as_result":81,"macro@crate::debug_assert_abs_diff_eq_x":82},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"964":{"id":964,"crate_id":0,"name":"debug_assert_program_args_stderr_gt","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt.rs","begin":[443,0],"end":[449,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)\n\nThis macro provides the same statements as [`assert_program_args_stderr_gt`](macro.assert_program_args_stderr_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)\n* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)\n* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)\n","links":{"macro@crate::assert_program_args_stderr_gt":962,"macro@crate::debug_assert_program_args_stderr_gt":964},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"687":{"id":687,"crate_id":0,"name":"assert_fs_read_to_string_ne","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa.txt\";\nlet b =\"bravo.txt\";\nassert_fs_read_to_string_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)\n* [`assert_fs_read_to_string_ne_as_result`](macro@crate::assert_fs_read_to_string_ne_as_result)\n* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)","links":{"macro@crate::assert_fs_read_to_string_ne_as_result":685,"macro@crate::debug_assert_fs_read_to_string_ne":686,"macro@crate::assert_fs_read_to_string_ne":684},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"410":{"id":410,"crate_id":0,"name":"assert_some_eq_x","span":{"filename":"src/assert_some/assert_some_eq_x.rs","begin":[228,0],"end":[241,1]},"visibility":"public","docs":"Assert an expression is Some and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Option<i8> = Option::Some(1);\nlet b: i8 = 1;\nassert_some_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Option<i8> = Option::Some(1);\nlet b: i8 = 2;\nassert_some_eq_x!(a, b);\n# });\n// assertion failed: `assert_some_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_some_eq_x.html\n//  a label: `a`,\n//  a debug: `Some(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_some_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_some_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Some(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)\n* [`assert_some_eq_x_as_result`](macro@crate::assert_some_eq_x_as_result)\n* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)\n","links":{"macro@crate::debug_assert_some_eq_x":412,"macro@crate::assert_some_eq_x_as_result":411,"macro@crate::assert_some_eq_x":410,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_eq_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1014":{"id":1014,"crate_id":0,"name":"assert_status_success","span":{"filename":"src/assert_status/assert_status_success.rs","begin":[1,0],"end":[274,1]},"visibility":"public","docs":"Assert a status is a success.\n\nPseudocode:<br>\na ⇒ status ⇒ success = true\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"0\");\nassert_status_success!(a);\n```\n\n# Module macros\n\n* [`assert_status_success`](macro@crate::assert_status_success)\n* [`assert_status_success_as_result`](macro@crate::assert_status_success_as_result)\n* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)","links":{"macro@crate::debug_assert_status_success":1013,"macro@crate::assert_status_success":1011,"macro@crate::assert_status_success_as_result":1012},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"133":{"id":133,"crate_id":0,"name":"assert_diff_ge_x_as_result","span":{"filename":"src/assert_diff/assert_diff_ge_x.rs","begin":[46,0],"end":[108,1]},"visibility":"public","docs":"Assert a difference is greater than or equal to an expression.\n\nPseudocode:<br>\nΔ ≥ x\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)\n* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)\n* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)\n","links":{"macro@crate::assert_diff_ge_x_as_result":133,"`Err`":1082,"macro@crate::assert_diff_ge_x":132,"macro@crate::debug_assert_diff_ge_x":134},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_ge_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"737":{"id":737,"crate_id":0,"name":"assert_io_read_to_string_le","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le.rs","begin":[1,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa\".as_bytes();\nlet b = \"zz\".as_bytes();\nassert_io_read_to_string_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)\n* [`assert_io_read_to_string_le_as_result`](macro@crate::assert_io_read_to_string_le_as_result)\n* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)","links":{"macro@crate::debug_assert_io_read_to_string_le":736,"macro@crate::assert_io_read_to_string_le":734,"macro@crate::assert_io_read_to_string_le_as_result":735},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"460":{"id":460,"crate_id":0,"name":"debug_assert_bag_subbag","span":{"filename":"src/assert_bag/assert_bag_subbag.rs","begin":[355,0],"end":[361,1]},"visibility":"public","docs":"Assert a bag is a subbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)\n\nThis macro provides the same statements as [`assert_bag_subbag`](macro.assert_bag_subbag.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)\n* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)\n* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)\n","links":{"macro@crate::assert_bag_subbag_as_result":459,"macro@crate::debug_assert_bag_subbag":460,"macro@crate::assert_bag_subbag":458},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_bag_subbag {\n    ($($arg:tt)*) => { ... };\n}"}},"183":{"id":183,"crate_id":0,"name":"assert_contains","span":{"filename":"src/assert_contains/assert_contains.rs","begin":[1,0],"end":[971,1]},"visibility":"public","docs":"Assert a container is a match for an expression.\n\nPseudocode:<br>\na.contains(b)\n\nThese macros work with many kinds of Rust types, such as String, Vec, Range, HashSet.\nThe specifics depend on each type's implementation of a method `contains`, and some types\nrequire the second argument to be borrowable, so be sure to check the Rust documentation.\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::collections::HashSet;\n\n// String contains substring\nlet a = \"alfa\";\nlet b = \"lf\";\nassert_contains!(a, b);\n\n// Range contains value.\n// Notice the &b because the macro calls Range.contains(&self, &value).\nlet a = 1..3;\nlet b = 2;\nassert_contains!(a, &b);\n\n// Vector contains element.\n// Notice the &b because the macro calls Vec.contains(&self, &value).\nlet a = vec![1, 2, 3];\nlet b = 2;\nassert_contains!(a, &b);\n\n// HashSet contains element.\n// Notice the &b because the macro calls HashSet.contains(&self, &value).\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b: String = String::from(\"1\");\nassert_contains!(a, &b);\n\n// HashSet contains element with automatic borrow optimization.\n// Notice the b because the value type &str is already a reference,\n// which HashSet.contains knows how to borrow to compare to String.\nlet a: HashSet<String> = [String::from(\"1\")].into();\nlet b = \"1\";\nassert_contains!(a, b);\n```\n\n# Module macros\n\n* [`assert_contains`](macro@crate::assert_contains)\n* [`assert_contains_as_result`](macro@crate::assert_contains_as_result)\n* [`debug_assert_contains`](macro@crate::debug_assert_contains)","links":{"macro@crate::assert_contains":180,"macro@crate::assert_contains_as_result":181,"macro@crate::debug_assert_contains":182},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1064":{"id":1064,"crate_id":0,"name":"assert_status_code_value_lt_x_as_result","span":{"filename":"src/assert_status/assert_status_code_value_lt_x.rs","begin":[42,0],"end":[105,1]},"visibility":"public","docs":"Assert a status code value is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)\n* [`assert_status_code_value_lt_x_as_result`](macro@crate::assert_status_code_value_lt_x_as_result)\n* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)\n","links":{"macro@crate::assert_status_code_value_lt_x_as_result":1064,"macro@crate::debug_assert_status_code_value_lt_x":1065,"macro@crate::assert_status_code_value_lt_x":1063},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_lt_x_as_result {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n}"}},"787":{"id":787,"crate_id":0,"name":"assert_command_stdout_ge","span":{"filename":"src/assert_command/assert_command_stdout_ge.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stdout_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stdout_ge`](macro@crate::assert_command_stdout_ge)\n* [`assert_command_stdout_ge_as_result`](macro@crate::assert_command_stdout_ge_as_result)\n* [`debug_assert_command_stdout_ge`](macro@crate::debug_assert_command_stdout_ge)","links":{"macro@crate::assert_command_stdout_ge_as_result":785,"macro@crate::debug_assert_command_stdout_ge":786,"macro@crate::assert_command_stdout_ge":784},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"510":{"id":510,"crate_id":0,"name":"debug_assert_set_subset","span":{"filename":"src/assert_set/assert_set_subset.rs","begin":[298,0],"end":[304,1]},"visibility":"public","docs":"Assert a set is a subset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)\n\nThis macro provides the same statements as [`assert_set_subset`](macro.assert_set_subset.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_set_subset`](macro@crate::assert_set_subset)\n* [`assert_set_subset`](macro@crate::assert_set_subset)\n* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)\n","links":{"macro@crate::debug_assert_set_subset":510,"macro@crate::assert_set_subset":508},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_set_subset {\n    ($($arg:tt)*) => { ... };\n}"}},"233":{"id":233,"crate_id":0,"name":"assert_count_ne_x","span":{"filename":"src/assert_count/assert_count_ne_x.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a count is not equal to an expression.\n\nPseudocode:<br>\na.count() ≠ b\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = 1;\nassert_count_ne_x!(a, b);\n# });\n// assertion failed: `assert_count_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_ne_x.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)\n* [`assert_count_ne_x_as_result`](macro@crate::assert_count_ne_x_as_result)\n* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)\n","links":{"macro@crate::assert_count_ne_x_as_result":234,"macro@crate::debug_assert_count_ne_x":235,"macro@crate::assert_count_ne_x":233,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ne_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1114":{"id":1114,"crate_id":0,"name":"assert_option_some_eq","span":{"filename":"src/assert_option/assert_option_some_eq.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nDeprecated. Please rename from `assert_option_some_eq` into `assert_some_eq` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_some_eq` into `assert_some_eq` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_some_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"837":{"id":837,"crate_id":0,"name":"debug_assert_command_stderr_eq","span":{"filename":"src/assert_command/assert_command_stderr_eq.rs","begin":[387,0],"end":[393,1]},"visibility":"public","docs":"Assert a command stderr string is equal to another.\n\nThis macro provides the same statements as [`assert_command_stderr_eq {`](macro.assert_command_stderr_eq {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_eq {`](macro@crate::assert_command_stderr_eq {)\n* [`assert_command_stderr_eq {`](macro@crate::assert_command_stderr_eq {)\n* [`debug_assert_command_stderr_eq {`](macro@crate::debug_assert_command_stderr_eq {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"560":{"id":560,"crate_id":0,"name":"assert_fn_lt_x","span":{"filename":"src/assert_fn/assert_fn_lt_x.rs","begin":[1,0],"end":[512,1]},"visibility":"public","docs":"Assert a function output is less than an expression.\n\nPseudocode:<br>\na_function(a) < b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_lt_x!(i8::abs, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)\n* [`assert_fn_lt_x_as_result`](macro@crate::assert_fn_lt_x_as_result)\n* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)","links":{"macro@crate::assert_fn_lt_x_as_result":558,"macro@crate::debug_assert_fn_lt_x":559,"macro@crate::assert_fn_lt_x":557},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"283":{"id":283,"crate_id":0,"name":"assert_len_gt_as_result","span":{"filename":"src/assert_len/assert_len_gt.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a length is greater than another.\n\nPseudocode:<br>\na.len() > b.len()\n\n* If true, return Result `Ok((a.len(), b.len()))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_gt`](macro@crate::assert_len_gt)\n* [`assert_len_gt_as_result`](macro@crate::assert_len_gt_as_result)\n* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)\n","links":{"macro@crate::assert_len_gt_as_result":283,"macro@crate::debug_assert_len_gt":284,"macro@crate::assert_len_gt":282},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_gt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1164":{"id":1164,"crate_id":0,"name":"assert_program_args_stderr_is_match_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_is_match.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nDeprecated. Please rename from `assert_program_args_stderr_is_match_as_result` to `assert_program_args_stderr_string_is_match_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stderr_is_match_as_result` to `assert_program_args_stderr_string_is_match_as_result`."},"inner":{"macro":"macro_rules! assert_program_args_stderr_is_match_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"6":{"id":6,"crate_id":0,"name":"debug_assert_ge","span":{"filename":"src/assert_ge.rs","begin":[486,0],"end":[492,1]},"visibility":"public","docs":"Assert an expression is greater than or equal to another.\n\nPseudocode:<br>\na ≥ b\n\nThis macro provides the same statements as [`assert_ge`](macro.assert_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ge`](macro@crate::assert_ge)\n* [`assert_ge`](macro@crate::assert_ge)\n* [`debug_assert_ge`](macro@crate::debug_assert_ge)\n","links":{"macro@crate::debug_assert_ge":6,"macro@crate::assert_ge":4},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"887":{"id":887,"crate_id":0,"name":"debug_assert_command_stderr_string_contains","span":{"filename":"src/assert_command/assert_command_stderr_string_contains.rs","begin":[328,0],"end":[334,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) contains (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_string_contains`](macro.assert_command_stderr_string_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)\n* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)\n* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)\n","links":{"macro@crate::assert_command_stderr_string_contains":885,"macro@crate::debug_assert_command_stderr_string_contains":887},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_string_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"610":{"id":610,"crate_id":0,"name":"assert_fn_err_ne_x","span":{"filename":"src/assert_fn_err/assert_fn_err_ne_x.rs","begin":[307,0],"end":[340,1]},"visibility":"public","docs":"Assert a function error is not equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≠ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_ne_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_ne_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_err_ne_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_ne_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"10 is out of range\\\"`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"10 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_ne_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_ne_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"10 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)\n* [`assert_fn_err_ne_x_as_result`](macro@crate::assert_fn_err_ne_x_as_result)\n* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)\n","links":{"macro@crate::assert_fn_err_ne_x_as_result":611,"macro@crate::assert_fn_err_ne_x":610,"macro@crate::debug_assert_fn_err_ne_x":612,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ne_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"333":{"id":333,"crate_id":0,"name":"assert_not_starts_with_as_result","span":{"filename":"src/assert_starts_with/assert_not_starts_with.rs","begin":[47,0],"end":[74,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not start with an expression (such as a substring).\n\nPseudocode:<br>\n¬ a.starts_with(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)\n* [`assert_not_starts_with_as_result`](macro@crate::assert_not_starts_with_as_result)\n* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)\n","links":{"macro@crate::assert_not_starts_with":332,"macro@crate::debug_assert_not_starts_with":334,"macro@crate::assert_not_starts_with_as_result":333},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_starts_with_as_result {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n}"}},"56":{"id":56,"crate_id":0,"name":"assert_f64_eq_as_result","span":{"filename":"src/assert_f64/assert_f64_eq.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f64_eq`](macro@crate::assert_f64_eq)\n* [`assert_f64_eq_as_result`](macro@crate::assert_f64_eq_as_result)\n* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)\n","links":{"macro@crate::assert_f64_eq_as_result":56,"macro@crate::debug_assert_f64_eq":57,"macro@crate::assert_f64_eq":55},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"937":{"id":937,"crate_id":0,"name":"assert_program_args_stdout_lt_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)\n* [`assert_program_args_stdout_lt_x_as_result`](macro@crate::assert_program_args_stdout_lt_x_as_result)\n* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)\n","links":{"macro@crate::assert_program_args_stdout_lt_x_as_result":937,"macro@crate::assert_program_args_stdout_lt_x":936,"macro@crate::debug_assert_program_args_stdout_lt_x":938},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_lt_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"660":{"id":660,"crate_id":0,"name":"assert_fn_ok_ne_x_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne_x.rs","begin":[47,0],"end":[162,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)\n* [`assert_fn_ok_ne_x_as_result`](macro@crate::assert_fn_ok_ne_x_as_result)\n* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)\n","links":{"macro@crate::assert_fn_ok_ne_x":659,"macro@crate::debug_assert_fn_ok_ne_x":661,"macro@crate::assert_fn_ok_ne_x_as_result":660},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ne_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"383":{"id":383,"crate_id":0,"name":"assert_result_err","span":{"filename":"src/assert_result/assert_result_err.rs","begin":[1,0],"end":[44,1]},"visibility":"public","docs":"Assert expression is Err.\n\nDeprecated. Please rename from `assert_result_err` into `assert_err` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"106":{"id":106,"crate_id":0,"name":"assert_abs_diff_gt","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt.rs","begin":[1,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nDeprecated. Please rename from `assert_abs_diff_gt` into `assert_abs_diff_gt_x`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"987":{"id":987,"crate_id":0,"name":"debug_assert_program_args_stderr_gt_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt_x.rs","begin":[402,0],"end":[408,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_gt_x`](macro.assert_program_args_stderr_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)\n* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)\n* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_gt_x":987,"macro@crate::assert_program_args_stderr_gt_x":985},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"710":{"id":710,"crate_id":0,"name":"debug_assert_fs_read_to_string_ne_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne_x.rs","begin":[393,0],"end":[399,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≠ expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_ne_x`](macro.assert_fs_read_to_string_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)\n* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)\n* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)\n","links":{"macro@crate::assert_fs_read_to_string_ne_x":708,"macro@crate::debug_assert_fs_read_to_string_ne_x":710},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"433":{"id":433,"crate_id":0,"name":"assert_ready_eq","span":{"filename":"src/assert_ready/assert_ready_eq.rs","begin":[207,0],"end":[220,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::task::Poll;\nuse std::task::Poll::*;\n# fn main() {\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(1);\nassert_ready_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(2);\nassert_ready_eq!(a, b);\n# });\n// assertion failed: `assert_ready_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ready_eq.html\n//  a label: `a`,\n//  a debug: `Ready(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Ready(2)`,\n//  b inner: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ready_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ready_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ready(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Ready(2)`,\\n\",\n#     \" b inner: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ready_eq`](macro@crate::assert_ready_eq)\n* [`assert_ready_eq_as_result`](macro@crate::assert_ready_eq_as_result)\n* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)\n","links":{"macro@crate::assert_ready_eq":433,"macro@crate::assert_ready_eq_as_result":434,"macro@crate::debug_assert_ready_eq":435,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"156":{"id":156,"crate_id":0,"name":"assert_in","span":{"filename":"src/assert_in/assert_in.rs","begin":[1,0],"end":[281,1]},"visibility":"public","docs":"Assert an item is in a container.\n\nPseudocode:<br>\na is in container\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 1;\nlet b = 0..2;\nassert_in!(a, b);\n```\n\n# Module macros\n\n* [`assert_in`](macro@crate::assert_in)\n* [`assert_in_as_result`](macro@crate::assert_in_as_result)\n* [`debug_assert_in`](macro@crate::debug_assert_in)","links":{"macro@crate::debug_assert_in":155,"macro@crate::assert_in_as_result":154,"macro@crate::assert_in":153},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1037":{"id":1037,"crate_id":0,"name":"debug_assert_status_code_value_le","span":{"filename":"src/assert_status/assert_status_code_value_le.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_le`](macro.assert_status_code_value_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)\n* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)\n* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)\n","links":{"macro@crate::debug_assert_status_code_value_le":1037,"macro@crate::assert_status_code_value_le":1035},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_le {\n    ($($arg:tt)*) => { ... };\n}"}},"760":{"id":760,"crate_id":0,"name":"debug_assert_io_read_to_string_le_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le_x.rs","begin":[366,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_le_x`](macro.assert_io_read_to_string_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)\n* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)\n* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)\n","links":{"macro@crate::assert_io_read_to_string_le_x":758,"macro@crate::debug_assert_io_read_to_string_le_x":760},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"483":{"id":483,"crate_id":0,"name":"assert_iter_lt","span":{"filename":"src/assert_iter/assert_iter_lt.rs","begin":[182,0],"end":[195,1]},"visibility":"public","docs":"Assert an iterable is less than another.\n\nPseudocode:<br>\n(collection1 into iter) < (collection2 into iter)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_lt!(&a, &b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [3, 4];\nlet b = [1, 2];\nassert_iter_lt!(&a, &b);\n# });\n// assertion failed: `assert_iter_lt!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_iter_lt.html\n//  a label: `&a`,\n//  a debug: `[3, 4]`,\n//  b label: `&b`,\n//  b debug: `[1, 2]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_iter_lt!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_iter_lt.html\\n\",\n#     \" a label: `&a`,\\n\",\n#     \" a debug: `[3, 4]`,\\n\",\n#     \" b label: `&b`,\\n\",\n#     \" b debug: `[1, 2]`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_lt`](macro@crate::assert_iter_lt)\n* [`assert_iter_lt_as_result`](macro@crate::assert_iter_lt_as_result)\n* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)\n","links":{"macro@crate::assert_iter_lt_as_result":484,"macro@crate::assert_iter_lt":483,"macro@crate::debug_assert_iter_lt":485,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_lt {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1087":{"id":1087,"crate_id":0,"name":"assert_abs_diff_gt_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nDeprecated. Please rename from `assert_abs_diff_gt_as_result` into `assert_abs_diff_gt_x_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_gt_as_result` into `assert_abs_diff_gt_x_as_result`."},"inner":{"macro":"macro_rules! assert_abs_diff_gt_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"206":{"id":206,"crate_id":0,"name":"assert_count_lt_as_result","span":{"filename":"src/assert_count/assert_count_lt.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a count is less than another.\n\nPseudocode:<br>\na.count() < b.count()\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_lt`](macro@crate::assert_count_lt)\n* [`assert_count_lt_as_result`](macro@crate::assert_count_lt_as_result)\n* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)\n","links":{"macro@crate::assert_count_lt":205,"macro@crate::assert_count_lt_as_result":206,"macro@crate::debug_assert_count_lt":207},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_lt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"810":{"id":810,"crate_id":0,"name":"debug_assert_command_stdout_ge_x","span":{"filename":"src/assert_command/assert_command_stdout_ge_x.rs","begin":[375,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_ge_x`](macro.assert_command_stdout_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)\n* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)\n* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)\n","links":{"macro@crate::debug_assert_command_stdout_ge_x":810,"macro@crate::assert_command_stdout_ge_x":808},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"533":{"id":533,"crate_id":0,"name":"assert_fn_lt","span":{"filename":"src/assert_fn/assert_fn_lt.rs","begin":[297,0],"end":[331,1]},"visibility":"public","docs":"Assert a function output is less than another.\n\nPseudocode:<br>\na_function(a) < b_function(b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_lt!(i8::abs, a, i8::abs, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_lt!(i8::abs, a, i8::abs, b);\n# });\n// assertion failed: `assert_fn_lt!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_lt.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-2`,\n//  b_function label: `i8::abs`,\n//     b_param label: `b`,\n//     b_param debug: `1`,\n//                 a: `2`,\n//                 b: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_lt!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_lt.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-2`,\\n\",\n#     \" b_function label: `i8::abs`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `1`,\\n\",\n#     \"                a: `2`,\\n\",\n#     \"                b: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_lt`](macro@crate::assert_fn_lt)\n* [`assert_fn_lt_as_result`](macro@crate::assert_fn_lt_as_result)\n* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)\n","links":{"macro@crate::debug_assert_fn_lt":535,"macro@crate::assert_fn_lt_as_result":534,"macro@crate::assert_fn_lt":533,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_lt {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"256":{"id":256,"crate_id":0,"name":"assert_is_empty","span":{"filename":"src/assert_is_empty/assert_is_empty.rs","begin":[159,0],"end":[172,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is empty.\n\nPseudocode:<br>\na.is_empty()\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"\";\nassert_is_empty!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"alfa\";\nassert_is_empty!(a);\n# });\n// assertion failed: `assert_is_empty!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_is_empty.html\n//  label: `a`,\n//  debug: `\\\"alfa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_is_empty!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_is_empty.html\\n\",\n#     \" label: `a`,\\n\",\n#     \" debug: `\\\"alfa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_is_empty`](macro@crate::assert_is_empty)\n* [`assert_is_empty_as_result`](macro@crate::assert_is_empty_as_result)\n* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)\n","links":{"macro@crate::debug_assert_is_empty":258,"macro@crate::assert_is_empty":256,"macro@crate::assert_is_empty_as_result":257,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_is_empty {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"1137":{"id":1137,"crate_id":0,"name":"assert_io_read_to_string_matches","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_matches.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a ::std::io::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `assert_io_read_to_string_matches` into `assert_io_read_to_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_io_read_to_string_matches` into `assert_io_read_to_string_is_match`."},"inner":{"macro":"macro_rules! assert_io_read_to_string_matches {\n    ($($arg:tt)*) => { ... };\n}"}},"860":{"id":860,"crate_id":0,"name":"assert_command_stderr_eq_x_as_result","span":{"filename":"src/assert_command/assert_command_stderr_eq_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stderr string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)\n* [`assert_command_stderr_eq_x_as_result`](macro@crate::assert_command_stderr_eq_x_as_result)\n* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)\n","links":{"macro@crate::assert_command_stderr_eq_x_as_result":860,"macro@crate::debug_assert_command_stderr_eq_x":861,"macro@crate::assert_command_stderr_eq_x":859},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_eq_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"583":{"id":583,"crate_id":0,"name":"assert_fn_err_lt_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_lt.rs","begin":[44,0],"end":[166,1]},"visibility":"public","docs":"Assert a function error is less than another.\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)\n* [`assert_fn_err_lt_as_result`](macro@crate::assert_fn_err_lt_as_result)\n* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)\n","links":{"macro@crate::assert_fn_err_lt":582,"macro@crate::assert_fn_err_lt_as_result":583,"macro@crate::debug_assert_fn_err_lt":584},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_lt_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"306":{"id":306,"crate_id":0,"name":"assert_len_gt_x","span":{"filename":"src/assert_len/assert_len_gt_x.rs","begin":[211,0],"end":[224,1]},"visibility":"public","docs":"Assert a length is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\n* If true, return `(a.len(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\";\nlet b = 1;\nassert_len_gt_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = 2;\nassert_len_gt_x!(a, b);\n# });\n// assertion failed: `assert_len_gt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_gt_x.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_gt_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_gt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)\n* [`assert_len_gt_x_as_result`](macro@crate::assert_len_gt_x_as_result)\n* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)\n","links":{"macro@crate::assert_len_gt_x":306,"macro@crate::debug_assert_len_gt_x":308,"macro@crate::assert_len_gt_x_as_result":307,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_gt_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"910":{"id":910,"crate_id":0,"name":"debug_assert_program_args_stdout_le","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le.rs","begin":[466,0],"end":[472,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)\n\nThis macro provides the same statements as [`assert_program_args_stdout_le`](macro.assert_program_args_stdout_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)\n* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)\n* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)\n","links":{"macro@crate::debug_assert_program_args_stdout_le":910,"macro@crate::assert_program_args_stdout_le":908},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_le {\n    ($($arg:tt)*) => { ... };\n}"}},"29":{"id":29,"crate_id":0,"name":"assert_eq_f64","span":{"filename":"src/assert_eq_f64.rs","begin":[1,0],"end":[373,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333334;\nassert_eq_f64!(a, b);\n```\n\n# Module macros\n\n* [`assert_eq_f64`](macro@crate::assert_eq_f64)\n* [`assert_eq_f64_as_result`](macro@crate::assert_eq_f64_as_result)\n* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)","links":{"macro@crate::assert_eq_f64":26,"macro@crate::assert_eq_f64_as_result":27,"macro@crate::debug_assert_eq_f64":28},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"633":{"id":633,"crate_id":0,"name":"debug_assert_fn_ok_lt","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt.rs","begin":[583,0],"end":[589,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_ok_lt`](macro.assert_fn_ok_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)\n* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)\n* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)\n","links":{"macro@crate::debug_assert_fn_ok_lt":633,"macro@crate::assert_fn_ok_lt":631},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"356":{"id":356,"crate_id":0,"name":"assert_err_eq_x","span":{"filename":"src/assert_err/assert_err_eq_x.rs","begin":[1,0],"end":[349,1]},"visibility":"public","docs":"Assert an expression is Err and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Err(1);\nlet b: i8 = 1;\nassert_err_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)\n* [`assert_err_eq_x_as_result`](macro@crate::assert_err_eq_x_as_result)\n* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)","links":{"macro@crate::assert_err_eq_x":353,"macro@crate::assert_err_eq_x_as_result":354,"macro@crate::debug_assert_err_eq_x":355},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"960":{"id":960,"crate_id":0,"name":"debug_assert_program_args_stderr_ge","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge.rs","begin":[466,0],"end":[472,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)\n\nThis macro provides the same statements as [`assert_program_args_stderr_ge`](macro.assert_program_args_stderr_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)\n* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)\n* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)\n","links":{"macro@crate::debug_assert_program_args_stderr_ge":960,"macro@crate::assert_program_args_stderr_ge":958},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"79":{"id":79,"crate_id":0,"name":"assert_f64","span":{"filename":"src/assert_f64/mod.rs","begin":[1,0],"end":[33,22]},"visibility":"public","docs":"Assert for comparing floating-point 32-bit numbers within 2.0 * EPSILON.\n\nThese macros are available:\n\n* [`assert_f64_eq!(a, b)`](macro@crate::assert_f64_eq) ≈ a = b (within 2ε)\n* [`assert_f64_ne!(a, b)`](macro@crate::assert_f64_ne) ≈ a ≠ b (within 2ε)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333335;\nassert_f64_eq!(a, b);\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_ne!(a, b);\n```","links":{"macro@crate::assert_f64_ne":75,"macro@crate::assert_f64_eq":55},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[58,62,66,70,74,78],"is_stripped":false}}},"683":{"id":683,"crate_id":0,"name":"assert_fs_read_to_string_lt","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt.rs","begin":[1,0],"end":[405,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa.txt\";\nlet b =\"bravo.txt\";\nassert_fs_read_to_string_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)\n* [`assert_fs_read_to_string_lt_as_result`](macro@crate::assert_fs_read_to_string_lt_as_result)\n* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)","links":{"macro@crate::debug_assert_fs_read_to_string_lt":682,"macro@crate::assert_fs_read_to_string_lt_as_result":681,"macro@crate::assert_fs_read_to_string_lt":680},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"406":{"id":406,"crate_id":0,"name":"assert_some_ne","span":{"filename":"src/assert_some/assert_some_ne.rs","begin":[273,0],"end":[286,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Option<i8> = Option::Some(1);\nlet b: Option<i8> = Option::Some(2);\nassert_some_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Option<i8> = Option::Some(1);\nlet b: Option<i8> = Option::Some(1);\nassert_some_ne!(a, b);\n# });\n// assertion failed: `assert_some_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_some_ne.html\n//  a label: `a`,\n//  a debug: `Some(1)`,\n//  b label: `b`,\n//  b debug: `Some(1)`,\n//  a inner: `1`,\n//  b inner: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_some_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_some_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Some(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Some(1)`,\\n\",\n#     \" b inner: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_some_ne`](macro@crate::assert_some_ne)\n* [`assert_some_ne_as_result`](macro@crate::assert_some_ne_as_result)\n* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)\n","links":{"macro@crate::debug_assert_some_ne":408,"macro@crate::assert_some_ne":406,"macro@crate::assert_some_ne_as_result":407,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1010":{"id":1010,"crate_id":0,"name":"assert_program_args_stderr_string_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_is_match.rs","begin":[1,0],"end":[354,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse regex::Regex;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_program_args_stderr_string_is_match!(program, args, matcher);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)\n* [`assert_program_args_stderr_string_is_match_as_result`](macro@crate::assert_program_args_stderr_string_is_match_as_result)\n* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)","links":{"macro@crate::assert_program_args_stderr_string_is_match_as_result":1008,"macro@crate::debug_assert_program_args_stderr_string_is_match":1009,"macro@crate::assert_program_args_stderr_string_is_match":1007},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"129":{"id":129,"crate_id":0,"name":"assert_diff_eq_x_as_result","span":{"filename":"src/assert_diff/assert_diff_eq_x.rs","begin":[46,0],"end":[108,1]},"visibility":"public","docs":"Assert a difference is equal to an expression.\n\nPseudocode:<br>\nΔ = x\n\n* If true, return Result `Ok((lhs, rhs))`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)\n* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)\n* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)\n","links":{"macro@crate::debug_assert_diff_eq_x":130,"macro@crate::assert_diff_eq_x_as_result":129,"`Err`":1082,"macro@crate::assert_diff_eq_x":128},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_eq_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"733":{"id":733,"crate_id":0,"name":"assert_io_read_to_string_gt","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt.rs","begin":[1,0],"end":[371,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa\".as_bytes();\nlet b = \"aa\".as_bytes();\nassert_io_read_to_string_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)\n* [`assert_io_read_to_string_gt_as_result`](macro@crate::assert_io_read_to_string_gt_as_result)\n* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)","links":{"macro@crate::debug_assert_io_read_to_string_gt":732,"macro@crate::assert_io_read_to_string_gt_as_result":731,"macro@crate::assert_io_read_to_string_gt":730},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"456":{"id":456,"crate_id":0,"name":"debug_assert_bag_ne","span":{"filename":"src/assert_bag/assert_bag_ne.rs","begin":[346,0],"end":[352,1]},"visibility":"public","docs":"Assert a bag is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)\n\nThis macro provides the same statements as [`assert_bag_ne`](macro.assert_bag_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_bag_ne`](macro@crate::assert_bag_ne)\n* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)\n* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)\n","links":{"macro@crate::assert_bag_ne_as_result":455,"macro@crate::debug_assert_bag_ne":456,"macro@crate::assert_bag_ne":454},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_bag_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"179":{"id":179,"crate_id":0,"name":"assert_infix","span":{"filename":"src/assert_infix.rs","begin":[1,0],"end":[314,1]},"visibility":"public","docs":"Assert a infix operator, such as assert_infix!(a == b).\n\nPseudocode:<br>\na infix b\n\nCompare values via infix value operator:\n\n* `assert_infix!(a == b)` ≈ a == b\n\n* `assert_infix!(a != b)` ≈ a ≠ b\n\n* `assert_infix!(a < b)` ≈ a < b\n\n* `assert_infix!(a <= b)` ≈ a ≤ b\n\n* `assert_infix!(a > b)` ≈ a > b\n\n* `assert_infix!(a >= b)` ≈ a ≥ b\n\nRelate values via infix logical operator:\n\n* `assert_infix!(a & b)` ≈ a ∧ b ≈ a AND b\n\n* `assert_infix!(a | b)` ≈ a ∨ b ≈ a OR b\n\n* `assert_infix!(a ^ b)` ≈ a ⊻ b ≈ a XOR b\n\n* `assert_infix!(a && b)` ≈ a …∧ b ≈ a lazy AND b\n\n* `assert_infix!(a || b)` ≈ a …∨ b ≈ a lazy OR b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 1;\nlet b = 1;\nassert_infix!(a == b);\n```\n\n# Infix operators\n\nFor values:\n\n* `==`  equal\n* `!=`  not equal\n* `<`\tless than\n* `<=`\tless than or equal to\n* `>`\tgreater than\n* `>=`\tgreater than or equal to\n\nFor booleans:\n\n* `^`\tlogical XOR\n* `!`\tlogical NOT\n* `&`\tlogical AND\n* `|`\tlogical OR\n* `&&`\tlogical lazy AND\n* `||`\tlogical lazy OR\n\n# Module macros\n\n* [`assert_infix`](macro@crate::assert_infix)\n* [`assert_infix_as_result`](macro@crate::assert_infix_as_result)\n* [`debug_assert_infix`](macro@crate::debug_assert_infix)","links":{"macro@crate::debug_assert_infix":178,"macro@crate::assert_infix":176,"macro@crate::assert_infix_as_result":177},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1060":{"id":1060,"crate_id":0,"name":"assert_status_code_value_le_x_as_result","span":{"filename":"src/assert_status/assert_status_code_value_le_x.rs","begin":[42,0],"end":[105,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)\n* [`assert_status_code_value_le_x_as_result`](macro@crate::assert_status_code_value_le_x_as_result)\n* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)\n","links":{"macro@crate::debug_assert_status_code_value_le_x":1061,"macro@crate::assert_status_code_value_le_x_as_result":1060,"macro@crate::assert_status_code_value_le_x":1059},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_le_x_as_result {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n}"}},"783":{"id":783,"crate_id":0,"name":"assert_command_stdout_eq","span":{"filename":"src/assert_command/assert_command_stdout_eq.rs","begin":[1,0],"end":[395,1]},"visibility":"public","docs":"Assert a command stdout string is equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stdout\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stdout\");\nb.args([\"%s\", \"alfa\"]);\nassert_command_stdout_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stdout_eq`](macro@crate::assert_command_stdout_eq)\n* [`assert_command_stdout_eq_as_result`](macro@crate::assert_command_stdout_eq_as_result)\n* [`debug_assert_command_stdout_eq`](macro@crate::debug_assert_command_stdout_eq)","links":{"macro@crate::assert_command_stdout_eq_as_result":781,"macro@crate::assert_command_stdout_eq":780,"macro@crate::debug_assert_command_stdout_eq":782},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"506":{"id":506,"crate_id":0,"name":"debug_assert_set_joint","span":{"filename":"src/assert_set/assert_set_joint.rs","begin":[297,0],"end":[303,1]},"visibility":"public","docs":"Assert a set is joint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)\n\nThis macro provides the same statements as [`assert_set_joint`](macro.assert_set_joint.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_set_joint`](macro@crate::assert_set_joint)\n* [`assert_set_joint`](macro@crate::assert_set_joint)\n* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)\n","links":{"macro@crate::assert_set_joint":504,"macro@crate::debug_assert_set_joint":506},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_set_joint {\n    ($($arg:tt)*) => { ... };\n}"}},"229":{"id":229,"crate_id":0,"name":"assert_count_lt_x","span":{"filename":"src/assert_count/assert_count_lt_x.rs","begin":[211,0],"end":[224,1]},"visibility":"public","docs":"Assert a count is less than an expression.\n\nPseudocode:<br>\na.count() < b\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_lt_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\".chars();\nlet b = 1;\nassert_count_lt_x!(a, b);\n# });\n// assertion failed: `assert_count_lt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_lt_x.html\n//  a label: `a`,\n//  a debug: `Chars(['x', 'x'])`,\n//  a.count(): `2`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_lt_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_lt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x', 'x'])`,\\n\",\n#     \" a.count(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)\n* [`assert_count_lt_x_as_result`](macro@crate::assert_count_lt_x_as_result)\n* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)\n","links":{"macro@crate::assert_count_lt_x":229,"macro@crate::debug_assert_count_lt_x":231,"macro@crate::assert_count_lt_x_as_result":230,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_lt_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1110":{"id":1110,"crate_id":0,"name":"assert_option_some_as_result","span":{"filename":"src/assert_option/assert_option_some.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert expression is Some.\n\nDeprecated. Please rename from `assert_option_some_as_result` into `assert_some_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_some_as_result` into `assert_some_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_some_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"833":{"id":833,"crate_id":0,"name":"debug_assert_command_stdout_string_is_match","span":{"filename":"src/assert_command/assert_command_stdout_string_is_match.rs","begin":[327,0],"end":[333,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) is match (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_string_is_match`](macro.assert_command_stdout_string_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)\n* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)\n* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)\n","links":{"macro@crate::assert_command_stdout_string_is_match":831,"macro@crate::debug_assert_command_stdout_string_is_match":833},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_string_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"556":{"id":556,"crate_id":0,"name":"assert_fn_le_x","span":{"filename":"src/assert_fn/assert_fn_le_x.rs","begin":[1,0],"end":[457,1]},"visibility":"public","docs":"Assert a function output is less than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_le_x!(i8::abs, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)\n* [`assert_fn_le_x_as_result`](macro@crate::assert_fn_le_x_as_result)\n* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)","links":{"macro@crate::assert_fn_le_x_as_result":554,"macro@crate::assert_fn_le_x":553,"macro@crate::debug_assert_fn_le_x":555},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"279":{"id":279,"crate_id":0,"name":"assert_len_ge_as_result","span":{"filename":"src/assert_len/assert_len_ge.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a length is greater than or equal to another.\n\nPseudocode:<br>\na.len() ≥ b.len()\n\n* If true, return Result `Ok((a.len(), b.len()))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_ge`](macro@crate::assert_len_ge)\n* [`assert_len_ge_as_result`](macro@crate::assert_len_ge_as_result)\n* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)\n","links":{"macro@crate::assert_len_ge_as_result":279,"macro@crate::assert_len_ge":278,"macro@crate::debug_assert_len_ge":280},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ge_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1160":{"id":1160,"crate_id":0,"name":"assert_program_args_stderr_ge_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)\n* [`assert_program_args_stderr_ge_x_as_result`](macro@crate::assert_program_args_stderr_ge_x_as_result)\n* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_ge_x":983,"macro@crate::assert_program_args_stderr_ge_x_as_result":1160,"macro@crate::assert_program_args_stderr_ge_x":982},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ge_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"883":{"id":883,"crate_id":0,"name":"assert_command_stderr_contains","span":{"filename":"src/assert_command/assert_command_stderr_contains.rs","begin":[1,0],"end":[49,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nDeprecated. Please rename from `assert_command_stderr_contains`","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2":{"id":2,"crate_id":0,"name":"assert_eq_as_result","span":{"filename":"src/assert_eq.rs","begin":[37,0],"end":[64,1]},"visibility":"public","docs":"Assert an expression is equal to another.\n\nPseudocode:<br>\na = b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_eq_as_result`](macro@crate::assert_eq_as_result)\n\n# Rust standard macros\n\n* [`assert_eq`](https://doc.rust-lang.org/std/macro.assert_eq.html)\n* [`debug_assert_eq`](https://doc.rust-lang.org/std/macro.debug_assert_eq.html)\n","links":{"macro@crate::assert_eq_as_result":2},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"606":{"id":606,"crate_id":0,"name":"assert_fn_err_lt_x","span":{"filename":"src/assert_fn_err/assert_fn_err_lt_x.rs","begin":[346,0],"end":[379,1]},"visibility":"public","docs":"Assert a function error is less than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) < expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_lt_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 20;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_lt_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_err_lt_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_lt_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `20`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"10 is out of range\\\"`,\n//                 a: `\\\"20 is out of range\\\"`,\n//                 b: `\\\"10 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_lt_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_lt_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `20`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                a: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"10 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)\n* [`assert_fn_err_lt_x_as_result`](macro@crate::assert_fn_err_lt_x_as_result)\n* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)\n","links":{"macro@crate::assert_fn_err_lt_x":606,"macro@crate::debug_assert_fn_err_lt_x":608,"macro@crate::assert_fn_err_lt_x_as_result":607,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_lt_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"329":{"id":329,"crate_id":0,"name":"debug_assert_not_matches","span":{"filename":"src/assert_matches/assert_not_matches.rs","begin":[286,0],"end":[292,1]},"visibility":"public","docs":"Assert expression is Some.\n\nThis macro provides the same statements as [`assert_not_matches`](macro.assert_not_matches.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_matches`](macro@crate::assert_not_matches)\n* [`assert_not_matches`](macro@crate::assert_not_matches)\n* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)\n","links":{"macro@crate::assert_not_matches":327,"macro@crate::debug_assert_not_matches":329},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_matches {\n    ($($arg:tt)*) => { ... };\n}"}},"933":{"id":933,"crate_id":0,"name":"assert_program_args_stdout_le_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)\n* [`assert_program_args_stdout_le_x_as_result`](macro@crate::assert_program_args_stdout_le_x_as_result)\n* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)\n","links":{"macro@crate::assert_program_args_stdout_le_x":932,"macro@crate::assert_program_args_stdout_le_x_as_result":933,"macro@crate::debug_assert_program_args_stdout_le_x":934},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_le_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"52":{"id":52,"crate_id":0,"name":"debug_assert_f32_ne","span":{"filename":"src/assert_f32/assert_f32_ne.rs","begin":[342,0],"end":[348,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is not equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\n\nThis macro provides the same statements as [`assert_f32_ne`](macro.assert_f32_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f32_ne`](macro@crate::assert_f32_ne)\n* [`assert_f32_ne`](macro@crate::assert_f32_ne)\n* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)\n","links":{"macro@crate::debug_assert_f32_ne":52,"macro@crate::assert_f32_ne":50},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f32_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"656":{"id":656,"crate_id":0,"name":"assert_fn_ok_lt_x_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt_x.rs","begin":[49,0],"end":[165,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\n# Examples\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)\n* [`assert_fn_ok_lt_x_as_result`](macro@crate::assert_fn_ok_lt_x_as_result)\n* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)\n","links":{"macro@crate::assert_fn_ok_lt_x":655,"macro@crate::assert_fn_ok_lt_x_as_result":656,"macro@crate::debug_assert_fn_ok_lt_x":657},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_lt_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"379":{"id":379,"crate_id":0,"name":"assert_ok_ne_x_as_result","span":{"filename":"src/assert_ok/assert_ok_ne_x.rs","begin":[41,0],"end":[88,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = b\n\n* If true, return Result `Ok((a1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)\n* [`assert_ok_ne_x_as_result`](macro@crate::assert_ok_ne_x_as_result)\n* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)\n","links":{"macro@crate::assert_ok_ne_x":378,"macro@crate::debug_assert_ok_ne_x":380,"macro@crate::assert_ok_ne_x_as_result":379},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_ne_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"983":{"id":983,"crate_id":0,"name":"debug_assert_program_args_stderr_ge_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge_x.rs","begin":[411,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_ge_x`](macro.assert_program_args_stderr_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)\n* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)\n* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_ge_x":983,"macro@crate::assert_program_args_stderr_ge_x":982},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"102":{"id":102,"crate_id":0,"name":"debug_assert_abs_diff_ne_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne_x.rs","begin":[469,0],"end":[475,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nPseudocode:<br>\n|Δ| ≠ c\n\nThis macro provides the same statements as [`assert_abs_diff_ne_x`](macro.assert_abs_diff_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-x debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)\n* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)\n* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)\n","links":{"macro@crate::assert_abs_diff_ne_x":100,"macro@crate::debug_assert_abs_diff_ne_x":102},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_abs_diff_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"706":{"id":706,"crate_id":0,"name":"debug_assert_fs_read_to_string_lt_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt_x.rs","begin":[398,0],"end":[404,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) < expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_lt_x`](macro.assert_fs_read_to_string_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)\n* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)\n* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)\n","links":{"macro@crate::assert_fs_read_to_string_lt_x":704,"macro@crate::debug_assert_fs_read_to_string_lt_x":706},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"429":{"id":429,"crate_id":0,"name":"assert_ready","span":{"filename":"src/assert_ready/assert_ready.rs","begin":[141,0],"end":[154,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nPseudocode:<br>\na is Ready(a1)\n\n* If true, return `(a1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::task::Poll;\nuse std::task::Poll::*;\n# fn main() {\nlet a: Poll<i8> = Ready(1);\nassert_ready!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Poll<i8> = Pending;\nassert_ready!(a);\n# });\n// assertion failed: `assert_ready!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ready.html\n//  a label: `a`,\n//  a debug: `Pending`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ready!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ready.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Pending`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ready`](macro@crate::assert_ready)\n* [`assert_ready_as_result`](macro@crate::assert_ready_as_result)\n* [`debug_assert_ready`](macro@crate::debug_assert_ready)\n","links":{"macro@crate::debug_assert_ready":431,"macro@crate::assert_ready_as_result":430,"macro@crate::assert_ready":429,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ready {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"1033":{"id":1033,"crate_id":0,"name":"debug_assert_status_code_value_gt","span":{"filename":"src/assert_status/assert_status_code_value_gt.rs","begin":[390,0],"end":[396,1]},"visibility":"public","docs":"Assert a status code value is greater than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_gt`](macro.assert_status_code_value_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)\n* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)\n* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)\n","links":{"macro@crate::assert_status_code_value_gt":1031,"macro@crate::debug_assert_status_code_value_gt":1033},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"152":{"id":152,"crate_id":0,"name":"assert_diff","span":{"filename":"src/assert_diff/mod.rs","begin":[1,0],"end":[28,25]},"visibility":"public","docs":"Assert for comparing delta differences.\n\nCompare a delta with an expression:\n\n* [`assert_diff_eq_x!(a, b, expr)`](macro@crate::assert_diff_eq_x) ≈ b - a = expr\n* [`assert_diff_ne_x!(a, b, expr)`](macro@crate::assert_diff_ne_x) ≈ b - a ≠ expr\n* [`assert_diff_lt_x!(a, b, expr)`](macro@crate::assert_diff_lt_x) ≈ b - a < expr\n* [`assert_diff_le_x!(a, b, expr)`](macro@crate::assert_diff_le_x) ≈ b - a ≤ expr\n* [`assert_diff_gt_x!(a, b, expr)`](macro@crate::assert_diff_gt_x) ≈ b - a > expr\n* [`assert_diff_ge_x!(a, b, expr)`](macro@crate::assert_diff_ge_x) ≈ b - a ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 12;\nlet x: i8 = 2;\nassert_diff_eq_x!(a, b, x);\n```","links":{"macro@crate::assert_diff_lt_x":144,"macro@crate::assert_diff_gt_x":136,"macro@crate::assert_diff_eq_x":128,"macro@crate::assert_diff_ne_x":148,"macro@crate::assert_diff_ge_x":132,"macro@crate::assert_diff_le_x":140},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[131,135,139,143,147,151],"is_stripped":false}}},"756":{"id":756,"crate_id":0,"name":"debug_assert_io_read_to_string_gt_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt_x.rs","begin":[365,0],"end":[371,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_gt_x`](macro.assert_io_read_to_string_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)\n* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)\n* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)\n","links":{"macro@crate::assert_io_read_to_string_gt_x":754,"macro@crate::debug_assert_io_read_to_string_gt_x":756},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"479":{"id":479,"crate_id":0,"name":"assert_iter_le","span":{"filename":"src/assert_iter/assert_iter_le.rs","begin":[174,0],"end":[187,1]},"visibility":"public","docs":"Assert an iterable is less than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≤ (collection2 into iter)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_le!(&a, &b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [3, 4];\nlet b = [1, 2];\nassert_iter_le!(&a, &b);\n# });\n// assertion failed: `assert_iter_le!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_iter_le.html\n//  a label: `&a`,\n//  a debug: `[3, 4]`,\n//  b label: `&b`,\n//  b debug: `[1, 2]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_iter_le!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_iter_le.html\\n\",\n#     \" a label: `&a`,\\n\",\n#     \" a debug: `[3, 4]`,\\n\",\n#     \" b label: `&b`,\\n\",\n#     \" b debug: `[1, 2]`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_le`](macro@crate::assert_iter_le)\n* [`assert_iter_le_as_result`](macro@crate::assert_iter_le_as_result)\n* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)\n","links":{"macro@crate::debug_assert_iter_le":481,"macro@crate::assert_iter_le_as_result":480,"macro@crate::assert_iter_le":479,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_le {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1083":{"id":1083,"crate_id":0,"name":"assert_abs_diff_eq_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_eq_as_result` into `assert_abs_diff_eq_x_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_eq_as_result` into `assert_abs_diff_eq_x_as_result`."},"inner":{"macro":"macro_rules! assert_abs_diff_eq_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"202":{"id":202,"crate_id":0,"name":"assert_count_le_as_result","span":{"filename":"src/assert_count/assert_count_le.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a count is less than or equal to another.\n\nPseudocode:<br>\na.count() ≤ b.count()\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_le`](macro@crate::assert_count_le)\n* [`assert_count_le_as_result`](macro@crate::assert_count_le_as_result)\n* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)\n","links":{"macro@crate::assert_count_le":201,"macro@crate::assert_count_le_as_result":202,"macro@crate::debug_assert_count_le":203},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_le_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"806":{"id":806,"crate_id":0,"name":"debug_assert_command_stdout_eq_x","span":{"filename":"src/assert_command/assert_command_stdout_eq_x.rs","begin":[372,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stdout string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_eq_x`](macro.assert_command_stdout_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)\n* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)\n* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)\n","links":{"macro@crate::debug_assert_command_stdout_eq_x":806,"macro@crate::assert_command_stdout_eq_x":804},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"529":{"id":529,"crate_id":0,"name":"assert_fn_le","span":{"filename":"src/assert_fn/assert_fn_le.rs","begin":[279,0],"end":[313,1]},"visibility":"public","docs":"Assert a function output is less than or equal to another.\n\nPseudocode:<br>\na_function(a) ≤ b_function(b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_le!(i8::abs, a, i8::abs, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_le!(i8::abs, a, i8::abs, b);\n# });\n// assertion failed: `assert_fn_le!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_le.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-2`,\n//  b_function label: `i8::abs`,\n//     b_param label: `b`,\n//     b_param debug: `1`,\n//                 a: `2`,\n//                 b: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_le!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_le.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-2`,\\n\",\n#     \" b_function label: `i8::abs`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `1`,\\n\",\n#     \"                a: `2`,\\n\",\n#     \"                b: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_le`](macro@crate::assert_fn_le)\n* [`assert_fn_le_as_result`](macro@crate::assert_fn_le_as_result)\n* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)\n","links":{"macro@crate::debug_assert_fn_le":531,"macro@crate::assert_fn_le_as_result":530,"macro@crate::assert_fn_le":529,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_le {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"1133":{"id":1133,"crate_id":0,"name":"assert_fs_read_to_string_matches_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_matches.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `assert_fs_read_to_string_matches_as_result` into `assert_fs_read_to_string_is_match_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_fs_read_to_string_matches_as_result` into `assert_fs_read_to_string_is_match_as_result`."},"inner":{"macro":"macro_rules! assert_fs_read_to_string_matches_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"252":{"id":252,"crate_id":0,"name":"assert_not_ends_with_as_result","span":{"filename":"src/assert_ends_with/assert_not_ends_with.rs","begin":[47,0],"end":[74,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not end with an expression (such as a substring).\n\nPseudocode:<br>\n¬ a.ends_with(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)\n* [`assert_not_ends_with_as_result`](macro@crate::assert_not_ends_with_as_result)\n* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)\n","links":{"macro@crate::assert_not_ends_with":251,"macro@crate::debug_assert_not_ends_with":253,"macro@crate::assert_not_ends_with_as_result":252},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_ends_with_as_result {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n}"}},"856":{"id":856,"crate_id":0,"name":"assert_command_stderr_ne_as_result","span":{"filename":"src/assert_command/assert_command_stderr_ne.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_ne`](macro@crate::assert_command_stderr_ne)\n* [`assert_command_stderr_ne_as_result`](macro@crate::assert_command_stderr_ne_as_result)\n* [`debug_assert_command_stderr_ne`](macro@crate::debug_assert_command_stderr_ne)\n","links":{"macro@crate::assert_command_stderr_ne":855,"macro@crate::assert_command_stderr_ne_as_result":856,"macro@crate::debug_assert_command_stderr_ne":857},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ne_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"579":{"id":579,"crate_id":0,"name":"assert_fn_err_le_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_le.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function error is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)\n* [`assert_fn_err_le_as_result`](macro@crate::assert_fn_err_le_as_result)\n* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)\n","links":{"macro@crate::assert_fn_err_le":578,"macro@crate::assert_fn_err_le_as_result":579,"macro@crate::debug_assert_fn_err_le":580},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_le_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"302":{"id":302,"crate_id":0,"name":"assert_len_ge_x","span":{"filename":"src/assert_len/assert_len_ge_x.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a length is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\n* If true, return `(a.len(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\";\nlet b = 1;\nassert_len_ge_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = 2;\nassert_len_ge_x!(a, b);\n# });\n// assertion failed: `assert_len_ge_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_ge_x.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_ge_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_ge_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)\n* [`assert_len_ge_x_as_result`](macro@crate::assert_len_ge_x_as_result)\n* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)\n","links":{"`panic!`":1081,"macro@crate::assert_len_ge_x":302,"macro@crate::debug_assert_len_ge_x":304,"macro@crate::assert_len_ge_x_as_result":303},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ge_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"25":{"id":25,"crate_id":0,"name":"assert_eq_f32","span":{"filename":"src/assert_eq_f32.rs","begin":[1,0],"end":[374,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333333;\nassert_eq_f32!(a, b);\n```\n\n# Module macros\n\n* [`assert_eq_f32`](macro@crate::assert_eq_f32)\n* [`assert_eq_f32_as_result`](macro@crate::assert_eq_f32_as_result)\n* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)\nAssert a floating point 32-bit number is equal to another within f32::EPSILON.","links":{"macro@crate::debug_assert_eq_f32":24,"macro@crate::assert_eq_f32":22,"macro@crate::assert_eq_f32_as_result":23},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"906":{"id":906,"crate_id":0,"name":"debug_assert_program_args_stdout_gt","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt.rs","begin":[443,0],"end":[449,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)\n\nThis macro provides the same statements as [`assert_program_args_stdout_gt`](macro.assert_program_args_stdout_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)\n* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)\n* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)\n","links":{"macro@crate::assert_program_args_stdout_gt":904,"macro@crate::debug_assert_program_args_stdout_gt":906},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"629":{"id":629,"crate_id":0,"name":"debug_assert_fn_ok_le","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le.rs","begin":[527,0],"end":[533,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_ok_le`](macro.assert_fn_ok_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)\n* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)\n* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)\n","links":{"macro@crate::debug_assert_fn_ok_le":629,"macro@crate::assert_fn_ok_le":627},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_le {\n    ($($arg:tt)*) => { ... };\n}"}},"352":{"id":352,"crate_id":0,"name":"assert_err_ne","span":{"filename":"src/assert_err/assert_err_ne.rs","begin":[1,0],"end":[393,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Err(1);\nlet b: Result<i8, i8> = Err(2);\nassert_err_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_err_ne`](macro@crate::assert_err_ne)\n* [`assert_err_ne_as_result`](macro@crate::assert_err_ne_as_result)\n* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)","links":{"macro@crate::debug_assert_err_ne":351,"macro@crate::assert_err_ne_as_result":350,"macro@crate::assert_err_ne":349},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"75":{"id":75,"crate_id":0,"name":"assert_f64_ne","span":{"filename":"src/assert_f64/assert_f64_ne.rs","begin":[277,0],"end":[290,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is not equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333338;\nassert_f64_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333333;\nassert_f64_ne!(a, b);\n# });\n// assertion failed: `assert_f64_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f64_ne.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333333`,`\n//     diff: `0`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f64_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f64_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333333`,\\n\",\n#     \"    diff: `0`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f64_ne`](macro@crate::assert_f64_ne)\n* [`assert_f64_ne_as_result`](macro@crate::assert_f64_ne_as_result)\n* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)\n","links":{"macro@crate::assert_f64_ne":75,"macro@crate::debug_assert_f64_ne":77,"macro@crate::assert_f64_ne_as_result":76,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"956":{"id":956,"crate_id":0,"name":"debug_assert_program_args_stderr_eq","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq.rs","begin":[444,0],"end":[450,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)\n\nThis macro provides the same statements as [`assert_program_args_stderr_eq`](macro.assert_program_args_stderr_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)\n* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)\n* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)\n","links":{"macro@crate::assert_program_args_stderr_eq":954,"macro@crate::debug_assert_program_args_stderr_eq":956},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"679":{"id":679,"crate_id":0,"name":"assert_fs_read_to_string_le","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le.rs","begin":[1,0],"end":[401,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa.txt\";\nlet b =\"bravo.txt\";\nassert_fs_read_to_string_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)\n* [`assert_fs_read_to_string_le_as_result`](macro@crate::assert_fs_read_to_string_le_as_result)\n* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)","links":{"macro@crate::assert_fs_read_to_string_le":676,"macro@crate::debug_assert_fs_read_to_string_le":678,"macro@crate::assert_fs_read_to_string_le_as_result":677},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"402":{"id":402,"crate_id":0,"name":"assert_some_eq","span":{"filename":"src/assert_some/assert_some_eq.rs","begin":[233,0],"end":[246,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Option<i8> = Option::Some(1);\nlet b: Option<i8> = Option::Some(1);\nassert_some_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Option<i8> = Option::Some(1);\nlet b: Option<i8> = Option::Some(2);\nassert_some_eq!(a, b);\n# });\n// assertion failed: `assert_some_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_some_eq.html\n//  a label: `a`,\n//  a debug: `Some(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Some(2)`,\n//  b inner: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_some_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_some_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Some(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Some(2)`,\\n\",\n#     \" b inner: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_some_eq`](macro@crate::assert_some_eq)\n* [`assert_some_eq_as_result`](macro@crate::assert_some_eq_as_result)\n* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)\n","links":{"`panic!`":1081,"macro@crate::assert_some_eq":402,"macro@crate::debug_assert_some_eq":404,"macro@crate::assert_some_eq_as_result":403},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1006":{"id":1006,"crate_id":0,"name":"assert_program_args_stderr_string_contains","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_contains.rs","begin":[1,0],"end":[360,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)\n\nThis uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.\n\n* The containee can be a &str, char, a slice of chars, or a function or\nclosure that determines if a character contains.\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet containee = \"lf\";\nassert_program_args_stderr_string_contains!(program, args, containee);\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)\n* [`assert_program_args_stderr_string_contains_as_result`](macro@crate::assert_program_args_stderr_string_contains_as_result)\n* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)","links":{"macro@crate::debug_assert_program_args_stderr_string_contains":1005,"macro@crate::assert_program_args_stderr_string_contains":1003,"macro@crate::assert_program_args_stderr_string_contains_as_result":1004},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"125":{"id":125,"crate_id":0,"name":"debug_assert_approx_ne","span":{"filename":"src/assert_approx/assert_approx_ne.rs","begin":[353,0],"end":[359,1]},"visibility":"public","docs":"Assert a number is approximately not equal to another.\n\nPseudocode:<br>\n| a - b | > 1e-6\n\nThis macro provides the same statements as [`assert_approx_ne`](macro.assert_approx_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_approx_ne`](macro@crate::assert_approx_ne)\n* [`assert_approx_ne`](macro@crate::assert_approx_ne)\n* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)\n","links":{"macro@crate::assert_approx_ne":118,"macro@crate::debug_assert_approx_ne":125},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_approx_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"729":{"id":729,"crate_id":0,"name":"assert_io_read_to_string_ge","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge.rs","begin":[1,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa\".as_bytes();\nlet b = \"aa\".as_bytes();\nassert_io_read_to_string_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)\n* [`assert_io_read_to_string_ge_as_result`](macro@crate::assert_io_read_to_string_ge_as_result)\n* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)","links":{"macro@crate::assert_io_read_to_string_ge":726,"macro@crate::debug_assert_io_read_to_string_ge":728,"macro@crate::assert_io_read_to_string_ge_as_result":727},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"452":{"id":452,"crate_id":0,"name":"debug_assert_bag_eq","span":{"filename":"src/assert_bag/assert_bag_eq.rs","begin":[300,0],"end":[306,1]},"visibility":"public","docs":"Assert a bag is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)\n\nThis macro provides the same statements as [`assert_bag_eq`](macro.assert_bag_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_bag_eq`](macro@crate::assert_bag_eq)\n* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)\n* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)\n","links":{"macro@crate::assert_bag_eq":450,"macro@crate::assert_bag_eq_as_result":451,"macro@crate::debug_assert_bag_eq":452},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_bag_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"1056":{"id":1056,"crate_id":0,"name":"assert_status_code_value_gt_x_as_result","span":{"filename":"src/assert_status/assert_status_code_value_gt_x.rs","begin":[42,0],"end":[105,1]},"visibility":"public","docs":"Assert a status code value is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)\n* [`assert_status_code_value_gt_x_as_result`](macro@crate::assert_status_code_value_gt_x_as_result)\n* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)\n","links":{"macro@crate::debug_assert_status_code_value_gt_x":1057,"macro@crate::assert_status_code_value_gt_x":1055,"macro@crate::assert_status_code_value_gt_x_as_result":1056},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_gt_x_as_result {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n}"}},"175":{"id":175,"crate_id":0,"name":"assert_any","span":{"filename":"src/assert_any.rs","begin":[1,0],"end":[262,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2, 3];\nassert_any!(a.into_iter(), |x: i8| x > 0);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_any`](macro@crate::assert_any)\n* [`assert_any_as_result`](macro@crate::assert_any_as_result)\n* [`debug_assert_any`](macro@crate::debug_assert_any)","links":{"macro@crate::assert_any":172,"macro@crate::assert_any_as_result":173,"macro@crate::debug_assert_any":174},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"779":{"id":779,"crate_id":0,"name":"assert_io_read_to_string","span":{"filename":"src/assert_io_read_to_string/mod.rs","begin":[1,0],"end":[97,41]},"visibility":"public","docs":"Assert for comparing input/output reader streams.\n\nThese macros help with input/output readers, such as file handles, byte arrays,\ninput streams, the trait `::std::io::Read`, and anything that implements a\nmethod `read_to_string() -> String`. See tutorial below.\n\n## Macros\n\nCompare a reader with another reader:\n\n* [`assert_io_read_to_string_eq!(reader1, reader2)`](macro@crate::assert_io_read_to_string_eq) ≈ reader1.read_to_string() = reader2.read_to_string()\n* [`assert_io_read_to_string_ne!(reader1, reader2)`](macro@crate::assert_io_read_to_string_ne) ≈ reader1.read_to_string() ≠ reader2.read_to_string()\n* [`assert_io_read_to_string_lt!(reader1, reader2)`](macro@crate::assert_io_read_to_string_lt) ≈ reader1.read_to_string() < reader2.read_to_string()\n* [`assert_io_read_to_string_le!(reader1, reader2)`](macro@crate::assert_io_read_to_string_le) ≈ reader1.read_to_string() ≤ reader2.read_to_string()\n* [`assert_io_read_to_string_gt!(reader1, reader2)`](macro@crate::assert_io_read_to_string_gt) ≈ reader1.read_to_string() > reader2.read_to_string()\n* [`assert_io_read_to_string_ge!(reader1, reader2)`](macro@crate::assert_io_read_to_string_ge) ≈ reader1.read_to_string() ≥ reader2.read_to_string()\n\nCompare a reader with an expression:\n\n* [`assert_io_read_to_string_eq_x!(reader, expr)`](macro@crate::assert_io_read_to_string_eq_x) ≈ reader.read_to_string() = expr\n* [`assert_io_read_to_string_ne_x!(reader, expr)`](macro@crate::assert_io_read_to_string_ne_x) ≈ reader.read_to_string() ≠ expr\n* [`assert_io_read_to_string_lt_x!(reader, expr)`](macro@crate::assert_io_read_to_string_lt_x) ≈ reader.read_to_string() < expr\n* [`assert_io_read_to_string_le_x!(reader, expr)`](macro@crate::assert_io_read_to_string_le_x) ≈ reader.read_to_string() ≤ expr\n* [`assert_io_read_to_string_gt_x!(reader, expr)`](macro@crate::assert_io_read_to_string_gt_x) ≈ reader.read_to_string() > expr\n* [`assert_io_read_to_string_ge_x!(reader, expr)`](macro@crate::assert_io_read_to_string_ge_x) ≈ reader.read_to_string() ≥ expr\n\nCompare a reader with its contents:\n\n* [`assert_io_read_to_string_contains!(reader, &containee)`](macro@crate::assert_io_read_to_string_contains) ≈ reader.read_to_string().contains(containee)\n* [`assert_io_read_to_string_is_match!(reader, matcher)`](macro@crate::assert_io_read_to_string_is_match) ≈ matcher.is_match(reader.read_to_string())\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet mut a = \"alfa\".as_bytes();\nlet mut b = \"alfa\".as_bytes();\nassert_io_read_to_string_eq!(a, b);\n```\n\n## Tutorial\n\nRust has a concept of a \"reader\", such as using `::std::io::Read` to read bytes,\nor to use the method `read_to_string` to read bytes into a string buffer.\n\n```rust\nuse std::io::Read;\nlet mut reader = \"hello\".as_bytes();\nlet mut string = String::new();\nlet result = reader.read_to_string(&mut string);\n```\n\nRust can compare a reader's string to another reader's string:\n\n```rust\nuse std::io::Read;\nlet mut reader1 = \"hello\".as_bytes();\nlet mut reader2 = \"world\".as_bytes();\nlet mut a_string = String::new();\nlet mut b_string = String::new();\nlet result1 = reader1.read_to_string(&mut a_string);\nlet result2 = reader2.read_to_string(&mut b_string);\nassert_ne!(a_string, b_string);\n```\n\nThe `assertables` crate provides macros that do the reading and string buffering for you:\n\n```rust\n# use std::io::Read;\n# use assertables::*;\nlet mut reader1 = \"hello\".as_bytes();\nlet mut reader2 = \"world\".as_bytes();\nassert_io_read_to_string_ne!(reader1, reader2);\n```","links":{"macro@crate::assert_io_read_to_string_eq":722,"macro@crate::assert_io_read_to_string_le_x":758,"macro@crate::assert_io_read_to_string_ge_x":750,"macro@crate::assert_io_read_to_string_ne":742,"macro@crate::assert_io_read_to_string_lt_x":762,"macro@crate::assert_io_read_to_string_contains":770,"macro@crate::assert_io_read_to_string_is_match":774,"macro@crate::assert_io_read_to_string_lt":738,"macro@crate::assert_io_read_to_string_gt_x":754,"macro@crate::assert_io_read_to_string_eq_x":746,"macro@crate::assert_io_read_to_string_ne_x":766,"macro@crate::assert_io_read_to_string_ge":726,"macro@crate::assert_io_read_to_string_le":734,"macro@crate::assert_io_read_to_string_gt":730},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[725,729,733,737,741,745,749,753,757,761,765,769,773,777,778],"is_stripped":false}}},"502":{"id":502,"crate_id":0,"name":"debug_assert_set_disjoint","span":{"filename":"src/assert_set/assert_set_disjoint.rs","begin":[297,0],"end":[303,1]},"visibility":"public","docs":"Assert a set is disjoint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)\n\nThis macro provides the same statements as [`assert_set_disjoint`](macro.assert_set_disjoint.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)\n* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)\n* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)\n","links":{"macro@crate::debug_assert_set_disjoint":502,"macro@crate::assert_set_disjoint":500},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_set_disjoint {\n    ($($arg:tt)*) => { ... };\n}"}},"1106":{"id":1106,"crate_id":0,"name":"debug_assert_result_ok_ne","span":{"filename":"src/assert_result/assert_result_ok_ne.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nPlease rename from `debug_assert_result_ok_ne` into `deubg_assert_ok_ne` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_result_ok_ne` into `debug_result_ok_ne` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_result_ok_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"225":{"id":225,"crate_id":0,"name":"assert_count_le_x","span":{"filename":"src/assert_count/assert_count_le_x.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a count is less than or equal to an expression.\n\nPseudocode:<br>\na.count() ≤ b\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_le_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\".chars();\nlet b = 1;\nassert_count_le_x!(a, b);\n# });\n// assertion failed: `assert_count_le_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_le_x.html\n//  a label: `a`,\n//  a debug: `Chars(['x', 'x'])`,\n//  a.count(): `2`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_le_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_le_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x', 'x'])`,\\n\",\n#     \" a.count(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_le_x`](macro@crate::assert_count_le_x)\n* [`assert_count_le_x_as_result`](macro@crate::assert_count_le_x_as_result)\n* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)\n","links":{"macro@crate::assert_count_le_x":225,"macro@crate::assert_count_le_x_as_result":226,"macro@crate::debug_assert_count_le_x":227,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_le_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"829":{"id":829,"crate_id":0,"name":"debug_assert_command_stdout_string_contains","span":{"filename":"src/assert_command/assert_command_stdout_string_contains.rs","begin":[328,0],"end":[334,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) contains (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_string_contains`](macro.assert_command_stdout_string_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)\n* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)\n* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)\n","links":{"macro@crate::assert_command_stdout_string_contains":827,"macro@crate::debug_assert_command_stdout_string_contains":829},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_string_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"552":{"id":552,"crate_id":0,"name":"assert_fn_gt_x","span":{"filename":"src/assert_fn/assert_fn_gt_x.rs","begin":[1,0],"end":[511,1]},"visibility":"public","docs":"Assert a function output is greater than an expression.\n\nPseudocode:<br>\nfunction(a) > b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_gt_x!(i8::abs, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)\n* [`assert_fn_gt_x_as_result`](macro@crate::assert_fn_gt_x_as_result)\n* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)","links":{"macro@crate::assert_fn_gt_x":549,"macro@crate::assert_fn_gt_x_as_result":550,"macro@crate::debug_assert_fn_gt_x":551},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1156":{"id":1156,"crate_id":0,"name":"debug_assert_program_args_stdout_contains","span":{"filename":"src/assert_program_args/assert_program_args_stdout_contains.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nDeprecated. Please rename from `debug_assert_program_args_stdout_contains` to `debug_assert_program_args_stdout_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_program_args_stdout_contains` to `debug_assert_program_args_stdout_string_contains`."},"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"275":{"id":275,"crate_id":0,"name":"assert_len_eq_as_result","span":{"filename":"src/assert_len/assert_len_eq.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a length is equal to another.\n\nPseudocode:<br>\na.len() = b.len()\n\n* If true, return Result `Ok((a.len(), b.len()))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_len_eq`](macro@crate::assert_len_eq)\n* [`assert_len_eq_as_result`](macro@crate::assert_len_eq_as_result)\n* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)\n","links":{"macro@crate::assert_len_eq_as_result":275,"macro@crate::assert_len_eq":274,"macro@crate::debug_assert_len_eq":276},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"879":{"id":879,"crate_id":0,"name":"assert_command_stderr_ne_x","span":{"filename":"src/assert_command/assert_command_stderr_ne_x.rs","begin":[270,0],"end":[283,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_ne_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_command_stderr_ne_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stderr_ne_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_ne_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[97, 108, 102, 97]`,\n//     expr value: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_ne_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_ne_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr value: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)\n* [`assert_command_stderr_ne_x_as_result`](macro@crate::assert_command_stderr_ne_x_as_result)\n* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_command_stderr_ne_x":881,"macro@crate::assert_command_stderr_ne_x_as_result":880,"macro@crate::assert_command_stderr_ne_x":879},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ne_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"602":{"id":602,"crate_id":0,"name":"assert_fn_err_le_x","span":{"filename":"src/assert_fn_err/assert_fn_err_le_x.rs","begin":[326,0],"end":[359,1]},"visibility":"public","docs":"Assert a function error is less than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≤ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_le_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 20;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_le_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_err_le_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_le_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `20`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"10 is out of range\\\"`,\n//                 a: `\\\"20 is out of range\\\"`,\n//                 b: `\\\"10 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_le_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_le_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `20`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                a: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"10 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)\n* [`assert_fn_err_le_x_as_result`](macro@crate::assert_fn_err_le_x_as_result)\n* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)\n","links":{"macro@crate::assert_fn_err_le_x_as_result":603,"macro@crate::assert_fn_err_le_x":602,"macro@crate::debug_assert_fn_err_le_x":604,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_le_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"325":{"id":325,"crate_id":0,"name":"debug_assert_matches","span":{"filename":"src/assert_matches/assert_matches.rs","begin":[286,0],"end":[292,1]},"visibility":"public","docs":"Assert expression is Some.\n\nThis macro provides the same statements as [`assert_matches`](macro.assert_matches.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_matches`](macro@crate::assert_matches)\n* [`assert_matches`](macro@crate::assert_matches)\n* [`debug_assert_matches`](macro@crate::debug_assert_matches)\n","links":{"macro@crate::assert_matches":323,"macro@crate::debug_assert_matches":325},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_matches {\n    ($($arg:tt)*) => { ... };\n}"}},"48":{"id":48,"crate_id":0,"name":"debug_assert_f32_lt","span":{"filename":"src/assert_f32/assert_f32_lt.rs","begin":[322,0],"end":[328,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na < b\n\n\nThis macro provides the same statements as [`assert_f32_lt`](macro.assert_f32_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f32_lt`](macro@crate::assert_f32_lt)\n* [`assert_f32_lt`](macro@crate::assert_f32_lt)\n* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)\n","links":{"macro@crate::assert_f32_lt":46,"macro@crate::debug_assert_f32_lt":48},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f32_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"929":{"id":929,"crate_id":0,"name":"assert_program_args_stdout_gt_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)\n* [`assert_program_args_stdout_gt_x_as_result`](macro@crate::assert_program_args_stdout_gt_x_as_result)\n* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)\n","links":{"macro@crate::assert_program_args_stdout_gt_x_as_result":929,"macro@crate::debug_assert_program_args_stdout_gt_x":930,"macro@crate::assert_program_args_stdout_gt_x":928},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_gt_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"652":{"id":652,"crate_id":0,"name":"assert_fn_ok_le_x_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)\n* [`assert_fn_ok_le_x_as_result`](macro@crate::assert_fn_ok_le_x_as_result)\n* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)\n","links":{"macro@crate::debug_assert_fn_ok_le_x":653,"macro@crate::assert_fn_ok_le_x":651,"macro@crate::assert_fn_ok_le_x_as_result":652},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_le_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"375":{"id":375,"crate_id":0,"name":"assert_ok_eq_x_as_result","span":{"filename":"src/assert_ok/assert_ok_eq_x.rs","begin":[41,0],"end":[88,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = b\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)\n* [`assert_ok_eq_x_as_result`](macro@crate::assert_ok_eq_x_as_result)\n* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)\n","links":{"macro@crate::assert_ok_eq_x":374,"macro@crate::assert_ok_eq_x_as_result":375,"macro@crate::debug_assert_ok_eq_x":376},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_eq_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"98":{"id":98,"crate_id":0,"name":"debug_assert_abs_diff_lt_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt_x.rs","begin":[460,0],"end":[466,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nPseudocode:<br>\n|Δ| < c\n\nThis macro provides the same statements as [`assert_abs_diff_lt_x`](macro.assert_abs_diff_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-x debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)\n* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)\n* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)\n","links":{"macro@crate::debug_assert_abs_diff_lt_x":98,"macro@crate::assert_abs_diff_lt_x":96},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_abs_diff_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"979":{"id":979,"crate_id":0,"name":"assert_program_args_stderr_eq_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)\n* [`assert_program_args_stderr_eq_x_as_result`](macro@crate::assert_program_args_stderr_eq_x_as_result)\n* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_eq_x":980,"macro@crate::assert_program_args_stderr_eq_x":978,"macro@crate::assert_program_args_stderr_eq_x_as_result":979},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_eq_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"702":{"id":702,"crate_id":0,"name":"debug_assert_fs_read_to_string_le_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le_x.rs","begin":[393,0],"end":[399,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≤ expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_le_x`](macro.assert_fs_read_to_string_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)\n* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)\n* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)\n","links":{"macro@crate::assert_fs_read_to_string_le_x":700,"macro@crate::debug_assert_fs_read_to_string_le_x":702},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"425":{"id":425,"crate_id":0,"name":"assert_poll_ready","span":{"filename":"src/assert_poll/assert_poll_ready.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nDeprecated. Please rename from `assert_poll_ready` into `assert_ready` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"148":{"id":148,"crate_id":0,"name":"assert_diff_ne_x","span":{"filename":"src/assert_diff/assert_diff_ne_x.rs","begin":[332,0],"end":[345,1]},"visibility":"public","docs":"Assert a difference is not equal to an expression.\n\nPseudocode:<br>\nΔ ≠ x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 4;\nassert_diff_ne_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 3;\nassert_diff_ne_x!(a, b, x);\n# });\n// assertion failed: `assert_diff_ne_x!(a, b, x)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_diff_ne_x.html\n//        a label: `a`,\n//        a debug: `10`,\n//        b label: `b`,\n//        b debug: `13`,\n//        x label: `x`,\n//        x debug: `3`,\n//              Δ: `3`,\n//          Δ ≠ x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_diff_ne_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_diff_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `3`,\\n\",\n#     \"       Δ: `3`,\\n\",\n#     \"   Δ ≠ x: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)\n* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)\n* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)\n","links":{"macro@crate::assert_diff_ne_x_as_result":149,"macro@crate::debug_assert_diff_ne_x":150,"macro@crate::assert_diff_ne_x":148,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_ne_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"1029":{"id":1029,"crate_id":0,"name":"debug_assert_status_code_value_ge","span":{"filename":"src/assert_status/assert_status_code_value_ge.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_ge`](macro.assert_status_code_value_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)\n* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)\n* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)\n","links":{"macro@crate::debug_assert_status_code_value_ge":1029,"macro@crate::assert_status_code_value_ge":1027},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"752":{"id":752,"crate_id":0,"name":"debug_assert_io_read_to_string_ge_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge_x.rs","begin":[366,0],"end":[372,1]},"visibility":"public","docs":"Assert zzz.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_ge_x`](macro.assert_io_read_to_string_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)\n* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)\n* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)\n","links":{"macro@crate::assert_io_read_to_string_ge_x":750,"macro@crate::debug_assert_io_read_to_string_ge_x":752},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"475":{"id":475,"crate_id":0,"name":"assert_iter_gt","span":{"filename":"src/assert_iter/assert_iter_gt.rs","begin":[182,0],"end":[195,1]},"visibility":"public","docs":"Assert an iterable is greater than another.\n\nPseudocode:<br>\n(collection1 into iter) > (collection2 into iter)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [3, 4];\nlet b = [1, 2];\nassert_iter_gt!(&a, &b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_gt!(&a, &b);\n# });\n// assertion failed: `assert_iter_gt!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_iter_gt.html\n//  a label: `&a`,\n//  a debug: `[1, 2]`,\n//  b label: `&b`,\n//  b debug: `[3, 4]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_iter_gt!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_iter_gt.html\\n\",\n#     \" a label: `&a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `&b`,\\n\",\n#     \" b debug: `[3, 4]`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_gt`](macro@crate::assert_iter_gt)\n* [`assert_iter_gt_as_result`](macro@crate::assert_iter_gt_as_result)\n* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_iter_gt":477,"macro@crate::assert_iter_gt_as_result":476,"macro@crate::assert_iter_gt":475},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_gt {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1079":{"id":1079,"crate_id":0,"name":"assert_success","span":{"filename":"src/assert_success/mod.rs","begin":[1,0],"end":[23,29]},"visibility":"public","docs":"Assert a success method is true.\n\nThese macros help compare None items, such as `::std::Option::None` or similar.\n\nAssert expression is None:\n\n* [`assert_success!(a)`](macro@crate::assert_success)\n  ≈ a.success() is true\n\n# Example\n\n```rust\nuse assertables::*;\n\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { true }}\nlet a = A{};\nassert_success!(a);\n```","links":{"macro@crate::assert_success":1071},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[1074,1078],"is_stripped":false}}},"198":{"id":198,"crate_id":0,"name":"assert_count_gt_as_result","span":{"filename":"src/assert_count/assert_count_gt.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a count is greater than another.\n\nPseudocode:<br>\na.count() > b.count()\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_gt`](macro@crate::assert_count_gt)\n* [`assert_count_gt_as_result`](macro@crate::assert_count_gt_as_result)\n* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)\n","links":{"macro@crate::assert_count_gt":197,"macro@crate::debug_assert_count_gt":199,"macro@crate::assert_count_gt_as_result":198},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_gt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"802":{"id":802,"crate_id":0,"name":"debug_assert_command_stdout_ne","span":{"filename":"src/assert_command/assert_command_stdout_ne.rs","begin":[392,0],"end":[398,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to another.\n\nThis macro provides the same statements as [`assert_command_stdout_ne {`](macro.assert_command_stdout_ne {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_ne {`](macro@crate::assert_command_stdout_ne {)\n* [`assert_command_stdout_ne {`](macro@crate::assert_command_stdout_ne {)\n* [`debug_assert_command_stdout_ne {`](macro@crate::debug_assert_command_stdout_ne {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"525":{"id":525,"crate_id":0,"name":"assert_fn_gt","span":{"filename":"src/assert_fn/assert_fn_gt.rs","begin":[297,0],"end":[331,1]},"visibility":"public","docs":"Assert a function output is greater than another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_gt!(i8::abs, a, i8::abs, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_gt!(i8::abs, a, i8::abs, b);\n# });\n// assertion failed: `assert_fn_gt!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_gt.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//  b_function label: `i8::abs`,\n//     b_param label: `b`,\n//     b_param debug: `-2`,\n//                 a: `1`,\n//                 b: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_gt!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_gt.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \" b_function label: `i8::abs`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `-2`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_gt`](macro@crate::assert_fn_gt)\n* [`assert_fn_gt_as_result`](macro@crate::assert_fn_gt_as_result)\n* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)\n","links":{"macro@crate::debug_assert_fn_gt":527,"macro@crate::assert_fn_gt":525,"macro@crate::assert_fn_gt_as_result":526,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_gt {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"248":{"id":248,"crate_id":0,"name":"assert_ends_with_as_result","span":{"filename":"src/assert_ends_with/assert_ends_with.rs","begin":[47,0],"end":[74,1]},"visibility":"public","docs":"Assert an expression (such as a string) ends with an expression (such as a substring).\n\nPseudocode:<br>\na.ends_with(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ends_with`](macro@crate::assert_ends_with)\n* [`assert_ends_with_as_result`](macro@crate::assert_ends_with_as_result)\n* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)\n","links":{"macro@crate::assert_ends_with":247,"macro@crate::debug_assert_ends_with":249,"macro@crate::assert_ends_with_as_result":248},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ends_with_as_result {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n}"}},"1129":{"id":1129,"crate_id":0,"name":"assert_poll_ready_ne","span":{"filename":"src/assert_poll/assert_poll_ready_ne.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are not equal.\n\nDeprecated. Please rename from `assert_poll_ready_ne` into `assert_ready_ne` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_ready_ne` into `assert_ready_ne` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_ready_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"852":{"id":852,"crate_id":0,"name":"assert_command_stderr_lt_as_result","span":{"filename":"src/assert_command/assert_command_stderr_lt.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string is less than another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_lt`](macro@crate::assert_command_stderr_lt)\n* [`assert_command_stderr_lt_as_result`](macro@crate::assert_command_stderr_lt_as_result)\n* [`debug_assert_command_stderr_lt`](macro@crate::debug_assert_command_stderr_lt)\n","links":{"macro@crate::debug_assert_command_stderr_lt":853,"macro@crate::assert_command_stderr_lt":851,"macro@crate::assert_command_stderr_lt_as_result":852},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_lt_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"575":{"id":575,"crate_id":0,"name":"assert_fn_err_gt_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_gt.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function error is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)\n* [`assert_fn_err_gt_as_result`](macro@crate::assert_fn_err_gt_as_result)\n* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)\n","links":{"macro@crate::assert_fn_err_gt":574,"macro@crate::assert_fn_err_gt_as_result":575,"macro@crate::debug_assert_fn_err_gt":576},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_gt_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"298":{"id":298,"crate_id":0,"name":"assert_len_eq_x","span":{"filename":"src/assert_len/assert_len_eq_x.rs","begin":[211,0],"end":[224,1]},"visibility":"public","docs":"Assert a length is equal to an expression.\n\nPseudocode:<br>\na.len() = b\n\n* If true, return `(a.len(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = 1;\nassert_len_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = 2;\nassert_len_eq_x!(a, b);\n# });\n// assertion failed: `assert_len_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_eq_x.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)\n* [`assert_len_eq_x_as_result`](macro@crate::assert_len_eq_x_as_result)\n* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)\n","links":{"macro@crate::assert_len_eq_x":298,"macro@crate::debug_assert_len_eq_x":300,"macro@crate::assert_len_eq_x_as_result":299,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_eq_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"21":{"id":21,"crate_id":0,"name":"assert_ne","span":{"filename":"src/assert_ne.rs","begin":[1,0],"end":[274,1]},"visibility":"public","docs":"Assert an expression is not equal to another.\n\nPseudocode:<br>\na ≠ b\n\n# Module macro\n\n* [`assert_ne_as_result`](macro@crate::assert_ne_as_result)\n\n# Rust standard macros\n\n* [`assert_ne`](https://doc.rust-lang.org/std/macro.assert_ne.html)\n* [`debug_assert_ne`](https://doc.rust-lang.org/std/macro.debug_assert_ne.html)","links":{"macro@crate::assert_ne_as_result":20},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"902":{"id":902,"crate_id":0,"name":"debug_assert_program_args_stdout_ge","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge.rs","begin":[466,0],"end":[472,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)\n\nThis macro provides the same statements as [`assert_program_args_stdout_ge`](macro.assert_program_args_stdout_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)\n* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)\n* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)\n","links":{"macro@crate::assert_program_args_stdout_ge":900,"macro@crate::debug_assert_program_args_stdout_ge":902},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"625":{"id":625,"crate_id":0,"name":"debug_assert_fn_ok_gt","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt.rs","begin":[585,0],"end":[591,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_ok_gt`](macro.assert_fn_ok_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)\n* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)\n* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)\n","links":{"macro@crate::assert_fn_ok_gt":623,"macro@crate::debug_assert_fn_ok_gt":625},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"348":{"id":348,"crate_id":0,"name":"assert_err_eq","span":{"filename":"src/assert_err/assert_err_eq.rs","begin":[1,0],"end":[356,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Err(1);\nlet b: Result<i8, i8> = Err(1);\nassert_err_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_err_eq`](macro@crate::assert_err_eq)\n* [`assert_err_eq_as_result`](macro@crate::assert_err_eq_as_result)\n* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)","links":{"macro@crate::assert_err_eq":345,"macro@crate::assert_err_eq_as_result":346,"macro@crate::debug_assert_err_eq":347},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"71":{"id":71,"crate_id":0,"name":"assert_f64_lt","span":{"filename":"src/assert_f64/assert_f64_lt.rs","begin":[257,0],"end":[270,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is less than another within f64::EPSILON.\n\nPseudocode:<br>\na < b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333329;\nassert_f64_lt!(a, b);\n# });\n// assertion failed: `assert_f64_lt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f64_lt.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333329`,`\n//     diff: `0.0000000000000003885780586188048`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f64_lt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f64_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333329`,\\n\",\n#     \"    diff: `0.0000000000000003885780586188048`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f64_lt`](macro@crate::assert_f64_lt)\n* [`assert_f64_lt_as_result`](macro@crate::assert_f64_lt_as_result)\n* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)\n","links":{"macro@crate::assert_f64_lt_as_result":72,"macro@crate::debug_assert_f64_lt":73,"macro@crate::assert_f64_lt":71,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_lt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"952":{"id":952,"crate_id":0,"name":"debug_assert_program_args_stdout_string_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_is_match.rs","begin":[348,0],"end":[354,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stdout_string_is_match`](macro.assert_program_args_stdout_string_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)\n* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)\n* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)\n","links":{"macro@crate::assert_program_args_stdout_string_is_match":950,"macro@crate::debug_assert_program_args_stdout_string_is_match":952},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_string_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"675":{"id":675,"crate_id":0,"name":"assert_fs_read_to_string_gt","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt.rs","begin":[1,0],"end":[406,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa.txt\";\nlet b =\"bravo.txt\";\nassert_fs_read_to_string_gt!(&b, &a);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)\n* [`assert_fs_read_to_string_gt_as_result`](macro@crate::assert_fs_read_to_string_gt_as_result)\n* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)","links":{"macro@crate::assert_fs_read_to_string_gt":672,"macro@crate::debug_assert_fs_read_to_string_gt":674,"macro@crate::assert_fs_read_to_string_gt_as_result":673},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"398":{"id":398,"crate_id":0,"name":"assert_some","span":{"filename":"src/assert_some/assert_some.rs","begin":[154,0],"end":[167,1]},"visibility":"public","docs":"Assert expression is Some.\n\nPseudocode:<br>\na is Some(a1)\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Option<i8> = Option::Some(1);\nassert_some!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Option<i8> = Option::None;\nassert_some!(a);\n# });\n// assertion failed: `assert_some!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_some.html\n//  option label: `a`,\n//  option debug: `None`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_some!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_some.html\\n\",\n#     \" option label: `a`,\\n\",\n#     \" option debug: `None`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_some`](macro@crate::assert_some)\n* [`assert_some_as_result`](macro@crate::assert_some_as_result)\n* [`debug_assert_some`](macro@crate::debug_assert_some)\n","links":{"macro@crate::assert_some_as_result":399,"macro@crate::assert_some":398,"macro@crate::debug_assert_some":400,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_some {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"1002":{"id":1002,"crate_id":0,"name":"assert_program_args_stderr_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stderr_is_match.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nDeprecated. Please rename from `assert_program_args_stderr_is_match` to `assert_program_args_stderr_string_is_match`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"121":{"id":121,"crate_id":0,"name":"assert_approx_eq_as_result","span":{"filename":"src/assert_approx/assert_approx_eq.rs","begin":[82,0],"end":[116,1]},"visibility":"public","docs":"Assert a number is approximately equal to another.\n\nPseudocode:<br>\n| a - b | ≤ 1e-6\n\n* If true, return Result `Ok(abs_diff, approx)`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq)\n* [`assert_approx_eq_as_result`](macro@crate::assert_approx_eq_as_result)\n* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)\n","links":{"macro@crate::debug_assert_approx_eq":122,"macro@crate::assert_approx_eq":117,"`Err`":1082,"macro@crate::assert_approx_eq_as_result":121},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_approx_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"725":{"id":725,"crate_id":0,"name":"assert_io_read_to_string_eq","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq.rs","begin":[1,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa\".as_bytes();\nlet b = \"alfa\".as_bytes();\nassert_io_read_to_string_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)\n* [`assert_io_read_to_string_eq_as_result`](macro@crate::assert_io_read_to_string_eq_as_result)\n* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)","links":{"macro@crate::assert_io_read_to_string_eq":722,"macro@crate::debug_assert_io_read_to_string_eq":724,"macro@crate::assert_io_read_to_string_eq_as_result":723},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"448":{"id":448,"crate_id":0,"name":"assert_ready_ne_x","span":{"filename":"src/assert_ready/assert_ready_ne_x.rs","begin":[1,0],"end":[327,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\nlet a: Poll<i8> = Ready(1);\nlet b: i8 = 2;\nassert_ready_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)\n* [`assert_ready_ne_x_as_result`](macro@crate::assert_ready_ne_x_as_result)\n* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)","links":{"macro@crate::assert_ready_ne_x":445,"macro@crate::assert_ready_ne_x_as_result":446,"macro@crate::debug_assert_ready_ne_x":447},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"171":{"id":171,"crate_id":0,"name":"assert_all","span":{"filename":"src/assert_all.rs","begin":[1,0],"end":[261,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2, 3];\nassert_all!(a.into_iter(), |x: i8| x > 0);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_all`](macro@crate::assert_all)\n* [`assert_all_as_result`](macro@crate::assert_all_as_result)\n* [`debug_assert_all`](macro@crate::debug_assert_all)","links":{"macro@crate::debug_assert_all":170,"macro@crate::assert_all":168,"macro@crate::assert_all_as_result":169},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1052":{"id":1052,"crate_id":0,"name":"assert_status_code_value_ge_x_as_result","span":{"filename":"src/assert_status/assert_status_code_value_ge_x.rs","begin":[42,0],"end":[105,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)\n* [`assert_status_code_value_ge_x_as_result`](macro@crate::assert_status_code_value_ge_x_as_result)\n* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)\n","links":{"macro@crate::assert_status_code_value_ge_x":1051,"macro@crate::debug_assert_status_code_value_ge_x":1053,"macro@crate::assert_status_code_value_ge_x_as_result":1052},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ge_x_as_result {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n}"}},"775":{"id":775,"crate_id":0,"name":"assert_io_read_to_string_is_match_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_is_match.rs","begin":[42,0],"end":[95,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is a match to a regex.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) matches matcher\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)\n* [`assert_io_read_to_string_is_match_as_result`](macro@crate::assert_io_read_to_string_is_match_as_result)\n* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)\n","links":{"macro@crate::assert_io_read_to_string_is_match_as_result":775,"macro@crate::assert_io_read_to_string_is_match":774,"macro@crate::debug_assert_io_read_to_string_is_match":776},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_is_match_as_result {\n    ($reader:expr, $matcher:expr $(,)?) => { ... };\n}"}},"498":{"id":498,"crate_id":0,"name":"debug_assert_set_ne","span":{"filename":"src/assert_set/assert_set_ne.rs","begin":[297,0],"end":[303,1]},"visibility":"public","docs":"Assert a set is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)\n\nThis macro provides the same statements as [`assert_set_ne`](macro.assert_set_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_set_ne`](macro@crate::assert_set_ne)\n* [`assert_set_ne`](macro@crate::assert_set_ne)\n* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)\n","links":{"macro@crate::debug_assert_set_ne":498,"macro@crate::assert_set_ne":496},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_set_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"221":{"id":221,"crate_id":0,"name":"assert_count_gt_x","span":{"filename":"src/assert_count/assert_count_gt_x.rs","begin":[211,0],"end":[224,1]},"visibility":"public","docs":"Assert a count is greater than an expression.\n\nPseudocode:<br>\na.count() > b\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\".chars();\nlet b = 1;\nassert_count_gt_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_gt_x!(a, b);\n# });\n// assertion failed: `assert_count_gt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_gt_x.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_gt_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_gt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)\n* [`assert_count_gt_x_as_result`](macro@crate::assert_count_gt_x_as_result)\n* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)\n","links":{"macro@crate::debug_assert_count_gt_x":223,"macro@crate::assert_count_gt_x":221,"macro@crate::assert_count_gt_x_as_result":222,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_gt_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1102":{"id":1102,"crate_id":0,"name":"assert_result_ok_eq","span":{"filename":"src/assert_result/assert_result_ok_eq.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nDeprecated. Please rename from `assert_result_ok_eq` into `assert_ok_eq` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_ok_eq` into `assert_ok_eq` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_ok_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"825":{"id":825,"crate_id":0,"name":"assert_command_stdout_contains","span":{"filename":"src/assert_command/assert_command_stdout_contains.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nDeprecated. Please rename from `assert_command_stdout_contains` into `assert_command_stdout_string_contains`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"548":{"id":548,"crate_id":0,"name":"assert_fn_ge_x","span":{"filename":"src/assert_fn/assert_fn_ge_x.rs","begin":[1,0],"end":[462,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_ge_x!(i8::abs, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)\n* [`assert_fn_ge_x_as_result`](macro@crate::assert_fn_ge_x_as_result)\n* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)","links":{"macro@crate::debug_assert_fn_ge_x":547,"macro@crate::assert_fn_ge_x_as_result":546,"macro@crate::assert_fn_ge_x":545},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"271":{"id":271,"crate_id":0,"name":"debug_assert_not_match","span":{"filename":"src/assert_is_match/assert_not_match.rs","begin":[279,0],"end":[285,1]},"visibility":"public","docs":"Assert an expression (such as a regex) is not a match for an expression (such as a string).\n\nPseudocode:<br>\n¬ a.is_match(b)\n\nThis macro provides the same statements as [`assert_not_match`](macro.assert_not_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_match`](macro@crate::assert_not_match)\n* [`assert_not_match`](macro@crate::assert_not_match)\n* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)\n","links":{"macro@crate::assert_not_match":269,"macro@crate::debug_assert_not_match":271},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_match {\n    ($($arg:tt)*) => { ... };\n}"}},"1152":{"id":1152,"crate_id":0,"name":"debug_assert_command_stderr_is_match","span":{"filename":"src/assert_command/assert_command_stderr_is_match.rs","begin":[42,0],"end":[46,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nDeprecated. Please rename from `debug_assert_command_stderr_is_match` into `debug_assert_command_stderr_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_command_stderr_is_match` into `debug_assert_command_stderr_string_is_match`."},"inner":{"macro":"macro_rules! debug_assert_command_stderr_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"875":{"id":875,"crate_id":0,"name":"assert_command_stderr_lt_x","span":{"filename":"src/assert_command/assert_command_stderr_lt_x.rs","begin":[248,0],"end":[261,1]},"visibility":"public","docs":"Assert a command stderr string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_lt_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stderr_lt_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stderr_lt_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_lt_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[97, 97]`,\n//     expr value: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_lt_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_lt_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[97, 97]`,\\n\",\n#     \"    expr value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)\n* [`assert_command_stderr_lt_x_as_result`](macro@crate::assert_command_stderr_lt_x_as_result)\n* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)\n","links":{"macro@crate::assert_command_stderr_lt_x_as_result":876,"macro@crate::assert_command_stderr_lt_x":875,"macro@crate::debug_assert_command_stderr_lt_x":877,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_lt_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"598":{"id":598,"crate_id":0,"name":"assert_fn_err_gt_x","span":{"filename":"src/assert_fn_err/assert_fn_err_gt_x.rs","begin":[346,0],"end":[379,1]},"visibility":"public","docs":"Assert a function error is greater than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) > expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 20;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_gt_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_gt_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_err_gt_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_gt_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"20 is out of range\\\"`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"20 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_gt_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_gt_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"20 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)\n* [`assert_fn_err_gt_x_as_result`](macro@crate::assert_fn_err_gt_x_as_result)\n* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)\n","links":{"macro@crate::assert_fn_err_gt_x":598,"macro@crate::debug_assert_fn_err_gt_x":600,"macro@crate::assert_fn_err_gt_x_as_result":599,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_gt_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"321":{"id":321,"crate_id":0,"name":"assert_len_ne_x","span":{"filename":"src/assert_len/assert_len_ne_x.rs","begin":[1,0],"end":[338,1]},"visibility":"public","docs":"Assert a length is not equal to an expression.\n\nPseudocode:<br>\na.len() ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = 2;\nassert_len_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)\n* [`assert_len_ne_x_as_result`](macro@crate::assert_len_ne_x_as_result)\n* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)","links":{"macro@crate::debug_assert_len_ne_x":320,"macro@crate::assert_len_ne_x_as_result":319,"macro@crate::assert_len_ne_x":318},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"44":{"id":44,"crate_id":0,"name":"debug_assert_f32_le","span":{"filename":"src/assert_f32/assert_f32_le.rs","begin":[382,0],"end":[388,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\n\nThis macro provides the same statements as [`assert_f32_le`](macro.assert_f32_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f32_le`](macro@crate::assert_f32_le)\n* [`assert_f32_le`](macro@crate::assert_f32_le)\n* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)\n","links":{"macro@crate::assert_f32_le":42,"macro@crate::debug_assert_f32_le":44},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f32_le {\n    ($($arg:tt)*) => { ... };\n}"}},"925":{"id":925,"crate_id":0,"name":"assert_program_args_stdout_ge_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)\n* [`assert_program_args_stdout_ge_x_as_result`](macro@crate::assert_program_args_stdout_ge_x_as_result)\n* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)\n","links":{"macro@crate::assert_program_args_stdout_ge_x_as_result":925,"macro@crate::assert_program_args_stdout_ge_x":924,"macro@crate::debug_assert_program_args_stdout_ge_x":926},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ge_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"648":{"id":648,"crate_id":0,"name":"assert_fn_ok_gt_x_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)\n* [`assert_fn_ok_gt_x_as_result`](macro@crate::assert_fn_ok_gt_x_as_result)\n* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)\n","links":{"macro@crate::assert_fn_ok_gt_x_as_result":648,"macro@crate::debug_assert_fn_ok_gt_x":649,"macro@crate::assert_fn_ok_gt_x":647},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_gt_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"371":{"id":371,"crate_id":0,"name":"assert_ok_ne_as_result","span":{"filename":"src/assert_ok/assert_ok_ne.rs","begin":[41,0],"end":[90,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ok_ne`](macro@crate::assert_ok_ne)\n* [`assert_ok_ne_as_result`](macro@crate::assert_ok_ne_as_result)\n* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)\n","links":{"macro@crate::assert_ok_ne_as_result":371,"macro@crate::assert_ok_ne":370,"macro@crate::debug_assert_ok_ne":372},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"94":{"id":94,"crate_id":0,"name":"debug_assert_abs_diff_le_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le_x.rs","begin":[469,0],"end":[475,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≤ c\n\nThis macro provides the same statements as [`assert_abs_diff_le_x`](macro.assert_abs_diff_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-x debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)\n* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)\n* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)\n","links":{"macro@crate::debug_assert_abs_diff_le_x":94,"macro@crate::assert_abs_diff_le_x":92},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_abs_diff_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"975":{"id":975,"crate_id":0,"name":"assert_program_args_stderr_ne_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne.rs","begin":[43,0],"end":[121,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)\n* [`assert_program_args_stderr_ne_as_result`](macro@crate::assert_program_args_stderr_ne_as_result)\n* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)\n","links":{"macro@crate::debug_assert_program_args_stderr_ne":976,"macro@crate::assert_program_args_stderr_ne":974,"macro@crate::assert_program_args_stderr_ne_as_result":975},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ne_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"698":{"id":698,"crate_id":0,"name":"debug_assert_fs_read_to_string_gt_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt_x.rs","begin":[398,0],"end":[404,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) > expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_gt_x`](macro.assert_fs_read_to_string_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)\n* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)\n* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)\n","links":{"macro@crate::debug_assert_fs_read_to_string_gt_x":698,"macro@crate::assert_fs_read_to_string_gt_x":696},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"421":{"id":421,"crate_id":0,"name":"debug_assert_pending","span":{"filename":"src/assert_pending/assert_pending.rs","begin":[248,0],"end":[254,1]},"visibility":"public","docs":"Assert an expression is Pending.\n\nPseudocode:<br>\na is Pending\n\nThis macro provides the same statements as [`assert_pending`](macro.assert_pending.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_pending`](macro@crate::assert_pending)\n* [`assert_pending`](macro@crate::assert_pending)\n* [`debug_assert_pending`](macro@crate::debug_assert_pending)\n","links":{"macro@crate::debug_assert_pending":421,"macro@crate::assert_pending":419},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_pending {\n    ($($arg:tt)*) => { ... };\n}"}},"144":{"id":144,"crate_id":0,"name":"assert_diff_lt_x","span":{"filename":"src/assert_diff/assert_diff_lt_x.rs","begin":[302,0],"end":[315,1]},"visibility":"public","docs":"Assert a difference is less than an expression.\n\nPseudocode:<br>\nΔ < x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 4;\nassert_diff_lt_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 2;\nassert_diff_lt_x!(a, b, x);\n# });\n// assertion failed: `assert_diff_lt_x!(a, b, x)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_diff_lt_x.html\n//        a label: `a`,\n//        a debug: `10`,\n//        b label: `b`,\n//        b debug: `13`,\n//        x label: `x`,\n//        x debug: `2`,\n//              Δ: `3`,\n//          Δ < x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_diff_lt_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_diff_lt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `2`,\\n\",\n#     \"       Δ: `3`,\\n\",\n#     \"   Δ < x: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)\n* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)\n* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)\n","links":{"macro@crate::assert_diff_lt_x":144,"macro@crate::assert_diff_lt_x_as_result":145,"macro@crate::debug_assert_diff_lt_x":146,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_lt_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"1025":{"id":1025,"crate_id":0,"name":"debug_assert_status_code_value_eq","span":{"filename":"src/assert_status/assert_status_code_value_eq.rs","begin":[390,0],"end":[396,1]},"visibility":"public","docs":"Assert a status code value is equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_eq`](macro.assert_status_code_value_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)\n* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)\n* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)\n","links":{"macro@crate::debug_assert_status_code_value_eq":1025,"macro@crate::assert_status_code_value_eq":1023},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"748":{"id":748,"crate_id":0,"name":"debug_assert_io_read_to_string_eq_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq_x.rs","begin":[357,0],"end":[363,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) = expr\n\nThis macro provides the same statements as [`assert_io_read_to_string_eq_x`](macro.assert_io_read_to_string_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)\n* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)\n* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)\n","links":{"macro@crate::assert_io_read_to_string_eq_x":746,"macro@crate::debug_assert_io_read_to_string_eq_x":748},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"471":{"id":471,"crate_id":0,"name":"assert_iter_ge","span":{"filename":"src/assert_iter/assert_iter_ge.rs","begin":[174,0],"end":[187,1]},"visibility":"public","docs":"Assert an iterable is greater than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≥ (collection2 into iter)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [3, 4];\nlet b = [1, 2];\nassert_iter_ge!(&a, &b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_ge!(&a, &b);\n# });\n// assertion failed: `assert_iter_ge!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_iter_ge.html\n//  a label: `&a`,\n//  a debug: `[1, 2]`,\n//  b label: `&b`,\n//  b debug: `[3, 4]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_iter_ge!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_iter_ge.html\\n\",\n#     \" a label: `&a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `&b`,\\n\",\n#     \" b debug: `[3, 4]`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_ge`](macro@crate::assert_iter_ge)\n* [`assert_iter_ge_as_result`](macro@crate::assert_iter_ge_as_result)\n* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)\n","links":{"macro@crate::debug_assert_iter_ge":473,"macro@crate::assert_iter_ge_as_result":472,"macro@crate::assert_iter_ge":471,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_ge {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"194":{"id":194,"crate_id":0,"name":"assert_count_ge_as_result","span":{"filename":"src/assert_count/assert_count_ge.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a count is greater than or equal to another.\n\nPseudocode:<br>\na.count() ≥ b.count()\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_ge`](macro@crate::assert_count_ge)\n* [`assert_count_ge_as_result`](macro@crate::assert_count_ge_as_result)\n* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)\n","links":{"macro@crate::assert_count_ge_as_result":194,"macro@crate::debug_assert_count_ge":195,"macro@crate::assert_count_ge":193},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ge_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1075":{"id":1075,"crate_id":0,"name":"assert_success_false","span":{"filename":"src/assert_success/assert_success_false.rs","begin":[160,0],"end":[173,1]},"visibility":"public","docs":"Assert a failure method is true.\n\nPseudocode:<br>\na.success() = false\n\n* If true, return `true`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { false }}\nlet a = A{};\nassert_success_false!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { true }}\nlet a = A{};\nassert_success_false!(a);\n# });\n// assertion failed: `assert_success_false!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_success_false.html\n//  a label: `a`,\n//  a debug: `A`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_success_false!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_success_false.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `A`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_success_false`](macro@crate::assert_success_false)\n* [`assert_success_false_as_result`](macro@crate::assert_success_false_as_result)\n* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)\n","links":{"macro@crate::debug_assert_success_false":1077,"macro@crate::assert_success_false":1075,"macro@crate::assert_success_false_as_result":1076,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_success_false {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"798":{"id":798,"crate_id":0,"name":"debug_assert_command_stdout_lt","span":{"filename":"src/assert_command/assert_command_stdout_lt.rs","begin":[384,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stdout string is less than another.\n\nThis macro provides the same statements as [`assert_command_stdout_lt {`](macro.assert_command_stdout_lt {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_lt {`](macro@crate::assert_command_stdout_lt {)\n* [`assert_command_stdout_lt {`](macro@crate::assert_command_stdout_lt {)\n* [`debug_assert_command_stdout_lt {`](macro@crate::debug_assert_command_stdout_lt {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"521":{"id":521,"crate_id":0,"name":"assert_fn_ge","span":{"filename":"src/assert_fn/assert_fn_ge.rs","begin":[277,0],"end":[311,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_ge!(i8::abs, a, i8::abs, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_ge!(i8::abs, a, i8::abs, b);\n# });\n// assertion failed: `assert_fn_ge!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ge.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//  b_function label: `i8::abs`,\n//     b_param label: `b`,\n//     b_param debug: `-2`,\n//                 a: `1`,\n//                 b: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ge!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ge.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \" b_function label: `i8::abs`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `-2`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ge`](macro@crate::assert_fn_ge)\n* [`assert_fn_ge_as_result`](macro@crate::assert_fn_ge_as_result)\n* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)\n","links":{"macro@crate::assert_fn_ge":521,"`panic!`":1081,"macro@crate::debug_assert_fn_ge":523,"macro@crate::assert_fn_ge_as_result":522},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ge {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path $(,)?) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"244":{"id":244,"crate_id":0,"name":"debug_assert_not_email_address","span":{"filename":"src/assert_email_address/assert_not_email_address.rs","begin":[418,0],"end":[424,1]},"visibility":"public","docs":"Assert expression is possibly not an email address.\n\nThis macro provides the same statements as [`assert_not_email_address`](macro.assert_not_email_address.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_email_address`](macro@crate::assert_not_email_address)\n* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)\n* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)\n","links":{"macro@crate::debug_assert_not_email_address":244,"macro@crate::assert_not_email_address_as_result":243,"macro@crate::assert_not_email_address":242},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_email_address {\n    ($($arg:tt)*) => { ... };\n}"}},"1125":{"id":1125,"crate_id":0,"name":"assert_poll_ready_eq_as_result","span":{"filename":"src/assert_poll/assert_poll_ready_eq.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are equal.\n\nDeprecated. Please rename from `assert_poll_ready_eq_as_result` into `assert_ready_eq_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_ready_eq_as_result` into `assert_ready_eq_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_ready_eq_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"848":{"id":848,"crate_id":0,"name":"assert_command_stderr_le_as_result","span":{"filename":"src/assert_command/assert_command_stderr_le.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_le`](macro@crate::assert_command_stderr_le)\n* [`assert_command_stderr_le_as_result`](macro@crate::assert_command_stderr_le_as_result)\n* [`debug_assert_command_stderr_le`](macro@crate::debug_assert_command_stderr_le)\n","links":{"macro@crate::debug_assert_command_stderr_le":849,"macro@crate::assert_command_stderr_le_as_result":848,"macro@crate::assert_command_stderr_le":847},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_le_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"571":{"id":571,"crate_id":0,"name":"assert_fn_err_ge_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_ge.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function error is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)\n* [`assert_fn_err_ge_as_result`](macro@crate::assert_fn_err_ge_as_result)\n* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)\n","links":{"macro@crate::assert_fn_err_ge_as_result":571,"macro@crate::debug_assert_fn_err_ge":572,"macro@crate::assert_fn_err_ge":570},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ge_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"294":{"id":294,"crate_id":0,"name":"assert_len_ne","span":{"filename":"src/assert_len/assert_len_ne.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a length is not equal to another.\n\nPseudocode:<br>\na.len() ≠ b.len()\n\n* If true, return `(a.len(), b.len())`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = \"x\";\nassert_len_ne!(a, b);\n# });\n// assertion failed: `assert_len_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_ne.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `\\\"x\\\"`,\n//  b.len(): `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"x\\\"`\\n\",\n#     \" b.len(): `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_ne`](macro@crate::assert_len_ne)\n* [`assert_len_ne_as_result`](macro@crate::assert_len_ne_as_result)\n* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)\n","links":{"macro@crate::assert_len_ne":294,"macro@crate::debug_assert_len_ne":296,"macro@crate::assert_len_ne_as_result":295,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"898":{"id":898,"crate_id":0,"name":"debug_assert_program_args_stdout_eq","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq.rs","begin":[444,0],"end":[450,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)\n\nThis macro provides the same statements as [`assert_program_args_stdout_eq`](macro.assert_program_args_stdout_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)\n* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)\n* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)\n","links":{"macro@crate::assert_program_args_stdout_eq":896,"macro@crate::debug_assert_program_args_stdout_eq":898},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"17":{"id":17,"crate_id":0,"name":"assert_lt_as_result","span":{"filename":"src/assert_lt.rs","begin":[42,0],"end":[69,1]},"visibility":"public","docs":"Assert an expression is less than another.\n\nPseudocode:<br>\na < b\n\n* If true, return `Ok(())`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_lt`](macro@crate::assert_lt)\n* [`assert_lt_as_result`](macro@crate::assert_lt_as_result)\n* [`debug_assert_lt`](macro@crate::debug_assert_lt)\n","links":{"macro@crate::debug_assert_lt":18,"macro@crate::assert_lt":16,"`Err`":1082,"macro@crate::assert_lt_as_result":17},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_lt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"621":{"id":621,"crate_id":0,"name":"debug_assert_fn_ok_ge","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge.rs","begin":[527,0],"end":[533,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_ok_ge`](macro.assert_fn_ok_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)\n* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)\n* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)\n","links":{"macro@crate::debug_assert_fn_ok_ge":621,"macro@crate::assert_fn_ok_ge":619},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"344":{"id":344,"crate_id":0,"name":"assert_err","span":{"filename":"src/assert_err/assert_err.rs","begin":[1,0],"end":[247,1]},"visibility":"public","docs":"Assert expression is Err.\n\nPseudocode:<br>\na is Err(_)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Err(1);\nassert_err!(a);\n```\n\n# Module macros\n\n* [`assert_err`](macro@crate::assert_err)\n* [`assert_err_as_result`](macro@crate::assert_err_as_result)\n* [`debug_assert_err`](macro@crate::debug_assert_err)","links":{"macro@crate::debug_assert_err":343,"macro@crate::assert_err":341,"macro@crate::assert_err_as_result":342},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"948":{"id":948,"crate_id":0,"name":"debug_assert_program_args_stdout_string_contains","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_contains.rs","begin":[351,0],"end":[357,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nThis macro provides the same statements as [`assert_program_args_stdout_string_contains`](macro.assert_program_args_stdout_string_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)\n* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)\n* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)\n","links":{"macro@crate::assert_program_args_stdout_string_contains":946,"macro@crate::debug_assert_program_args_stdout_string_contains":948},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_string_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"67":{"id":67,"crate_id":0,"name":"assert_f64_le","span":{"filename":"src/assert_f64/assert_f64_le.rs","begin":[317,0],"end":[330,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333335;\nassert_f64_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333329;\nassert_f64_le!(a, b);\n# });\n// assertion failed: `assert_f64_le!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f64_le.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333329`,`\n//     diff: `0.0000000000000004996003610813204`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f64_le!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f64_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333329`,\\n\",\n#     \"    diff: `0.0000000000000003885780586188048`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f64_le`](macro@crate::assert_f64_le)\n* [`assert_f64_le_as_result`](macro@crate::assert_f64_le_as_result)\n* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)\n","links":{"`panic!`":1081,"macro@crate::assert_f64_le":67,"macro@crate::debug_assert_f64_le":69,"macro@crate::assert_f64_le_as_result":68},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_le {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"671":{"id":671,"crate_id":0,"name":"assert_fs_read_to_string_ge","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge.rs","begin":[1,0],"end":[402,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa.txt\";\nlet b =\"bravo.txt\";\nassert_fs_read_to_string_ge!(&b, &a);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)\n* [`assert_fs_read_to_string_ge_as_result`](macro@crate::assert_fs_read_to_string_ge_as_result)\n* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)","links":{"macro@crate::assert_fs_read_to_string_ge_as_result":669,"macro@crate::debug_assert_fs_read_to_string_ge":670,"macro@crate::assert_fs_read_to_string_ge":668},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"394":{"id":394,"crate_id":0,"name":"assert_option_some","span":{"filename":"src/assert_option/assert_option_some.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert expression is Some.\n\nDeprecated. Please rename from `assert_option_some` into `assert_some` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"998":{"id":998,"crate_id":0,"name":"assert_program_args_stderr_ne_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)\n* [`assert_program_args_stderr_ne_x_as_result`](macro@crate::assert_program_args_stderr_ne_x_as_result)\n* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)\n","links":{"macro@crate::assert_program_args_stderr_ne_x":997,"macro@crate::debug_assert_program_args_stderr_ne_x":999,"macro@crate::assert_program_args_stderr_ne_x_as_result":998},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ne_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"117":{"id":117,"crate_id":0,"name":"assert_approx_eq","span":{"filename":"src/assert_approx/assert_approx_eq.rs","begin":[261,0],"end":[274,1]},"visibility":"public","docs":"Assert a number is approximately equal to another.\n\nPseudocode:<br>\n| a - b | ≤ 1e-6\n\n* If true, return `(diff, approx)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000011;\nassert_approx_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000012;\nassert_approx_eq!(a, b);\n# });\n// assertion failed: `assert_approx_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_approx_eq.html\n//             a label: `a`,\n//             a debug: `1.0000001`,\n//             b label: `b`,\n//             b debug: `1.0000012`,\n//           | a - b |: `1.0728836e-6`,\n//              approx: `1e-6`,\n//  | a - b | ≤ approx: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_approx_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_approx_eq.html\\n\",\n#     \"            a label: `a`,\\n\",\n#     \"            a debug: `1.0000001`,\\n\",\n#     \"            b label: `b`,\\n\",\n#     \"            b debug: `1.0000012`,\\n\",\n#     \"          | a - b |: `1.0728836e-6`,\\n\",\n#     \"             approx: `1e-6`,\\n\",\n#     \" | a - b | ≤ approx: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThe macros `assert_approx_eq` and `assert_in_epsilon` can test\napproximations:\n\n* For an approximation, the absolute error (i.e. approx) is the magnitude of\n  the difference between the exact value and the approximation. For this,\n use the macro\n\n* For an approximation, the relative error (i.e. epsilon) is the absolute\n  error divided by the magnitude of the exact value. This can be used to\n  compare approximations of numbers of wildly differing size.\n\n* For example, approximating the number 1,000 with an absolute error of 3\n  is, in most applications, much worse than approximating the number\n  1,000,000 with an absolute error of 3; in the first case the relative\n  error is 0.003 and in the second it is only 0.000003.\n\n* Thanks to Ruby minitest for the example and documentation.\n\n# Module macros\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq)\n* [`assert_approx_eq_as_result`](macro@crate::assert_approx_eq_as_result)\n* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)\n","links":{"macro@crate::debug_assert_approx_eq":122,"macro@crate::assert_approx_eq":117,"macro@crate::assert_approx_eq_as_result":121,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_approx_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"721":{"id":721,"crate_id":0,"name":"assert_fs_read_to_string","span":{"filename":"src/assert_fs_read_to_string/mod.rs","begin":[1,0],"end":[89,41]},"visibility":"public","docs":"Assert for comparing file system path contents.\n\nThese macros help with file system paths, such as disk files, `Path`,\n`PathBuf`, the trait `AsRef<Path>`, and anything that is readable via\n`::std::fs::read_to_string(…)`. See tutorial below.\n\nCompare a path with another path:\n\n* [`assert_fs_read_to_string_eq!(path1, path2)`](macro@crate::assert_fs_read_to_string_eq) ≈ std::fs::read_to_string(path1) = std::fs::read_to_string(path2)\n* [`assert_fs_read_to_string_ne!(path1, path2)`](macro@crate::assert_fs_read_to_string_ne) ≈ std::fs::read_to_string(path1) ≠ std::fs::read_to_string(path2)\n* [`assert_fs_read_to_string_lt!(path1, path2)`](macro@crate::assert_fs_read_to_string_lt) ≈ std::fs::read_to_string(path1) < std::fs::read_to_string(path2)\n* [`assert_fs_read_to_string_le!(path1, path2)`](macro@crate::assert_fs_read_to_string_le) ≈ std::fs::read_to_string(path1) ≤ std::fs::read_to_string(path2)\n* [`assert_fs_read_to_string_gt!(path1, path2)`](macro@crate::assert_fs_read_to_string_gt) ≈ std::fs::read_to_string(path1) > std::fs::read_to_string(path2)\n* [`assert_fs_read_to_string_ge!(path1, path2)`](macro@crate::assert_fs_read_to_string_ge) ≈ std::fs::read_to_string(path1) ≥ std::fs::read_to_string(path2)\n\nCompare a path with an expression:\n\n* [`assert_fs_read_to_string_eq_x!(path, expr)`](macro@crate::assert_fs_read_to_string_eq_x) ≈ std::fs::read_to_string(path) = expr\n* [`assert_fs_read_to_string_ne_x!(path, expr)`](macro@crate::assert_fs_read_to_string_ne_x) ≈ std::fs::read_to_string(path) ≠ expr\n* [`assert_fs_read_to_string_lt_x!(path, expr)`](macro@crate::assert_fs_read_to_string_lt_x) ≈ std::fs::read_to_string(path) < expr\n* [`assert_fs_read_to_string_le_x!(path, expr)`](macro@crate::assert_fs_read_to_string_le_x) ≈ std::fs::read_to_string(path) ≤ expr\n* [`assert_fs_read_to_string_gt_x!(path, expr)`](macro@crate::assert_fs_read_to_string_gt_x) ≈ std::fs::read_to_string(path) > expr\n* [`assert_fs_read_to_string_ge_x!(path, expr)`](macro@crate::assert_fs_read_to_string_ge_x) ≈ std::fs::read_to_string(path) ≥ expr\n\nCompare a path with its contents:\n\n* [`assert_fs_read_to_string_contains!(path, containee)`](macro@crate::assert_fs_read_to_string_contains) ≈ std::fs::read_to_string(path).contains(containee)\n* [`assert_fs_read_to_string_is_match!(path, matcher)`](macro@crate::assert_fs_read_to_string_is_match) ≈ matcher.is_match(::std::fs::read_to_string(path))\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::io::Read;\n\nlet a = \"alfa.txt\";\nlet b = \"alfa.txt\";\nassert_fs_read_to_string_eq!(a, b);\n```\n\n## Tutorial\n\nRust has a concept of a \"file system\" and a function \"read to string\"\nthat makes it easy to read a file to a string:\n\n```rust\nlet path = \"alfa.txt\";\nlet string = ::std::fs::read_to_string(path);\n```\n\nRust can compare a file's string to another file's string:\n\n```rust\nlet path1 = \"alfa.txt\";\nlet path2 = \"bravo.txt\";\nlet a_string = ::std::fs::read_to_string(path1).unwrap();\nlet b_string = ::std::fs::read_to_string(path2).unwrap();\nassert_ne!(a_string, b_string);\n```\n\nThe `assertables` crate provides macros that do the reading for you:\n\n```rust\n# use assertables::*;\nlet path1 = \"alfa.txt\";\nlet path2 = \"bravo.txt\";\nassert_fs_read_to_string_ne!(path1, path2);\n```","links":{"macro@crate::assert_fs_read_to_string_lt":680,"macro@crate::assert_fs_read_to_string_lt_x":704,"macro@crate::assert_fs_read_to_string_ge":668,"macro@crate::assert_fs_read_to_string_eq_x":688,"macro@crate::assert_fs_read_to_string_eq":664,"macro@crate::assert_fs_read_to_string_ne_x":708,"macro@crate::assert_fs_read_to_string_le_x":700,"macro@crate::assert_fs_read_to_string_gt_x":696,"macro@crate::assert_fs_read_to_string_ge_x":692,"macro@crate::assert_fs_read_to_string_contains":712,"macro@crate::assert_fs_read_to_string_gt":672,"macro@crate::assert_fs_read_to_string_le":676,"macro@crate::assert_fs_read_to_string_is_match":716,"macro@crate::assert_fs_read_to_string_ne":684},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[667,671,675,679,683,687,691,695,699,703,707,711,715,719,720],"is_stripped":false}}},"444":{"id":444,"crate_id":0,"name":"assert_ready_eq_x","span":{"filename":"src/assert_ready/assert_ready_eq_x.rs","begin":[1,0],"end":[327,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\nlet a: Poll<i8> = Ready(1);\nlet b: i8 = 1;\nassert_ready_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)\n* [`assert_ready_eq_x_as_result`](macro@crate::assert_ready_eq_x_as_result)\n* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)","links":{"macro@crate::debug_assert_ready_eq_x":443,"macro@crate::assert_ready_eq_x_as_result":442,"macro@crate::assert_ready_eq_x":441},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1048":{"id":1048,"crate_id":0,"name":"assert_status_code_value_eq_x_as_result","span":{"filename":"src/assert_status/assert_status_code_value_eq_x.rs","begin":[42,0],"end":[105,1]},"visibility":"public","docs":"Assert a status code value is equal to an expression.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)\n* [`assert_status_code_value_eq_x_as_result`](macro@crate::assert_status_code_value_eq_x_as_result)\n* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)\n","links":{"macro@crate::assert_status_code_value_eq_x":1047,"macro@crate::assert_status_code_value_eq_x_as_result":1048,"macro@crate::debug_assert_status_code_value_eq_x":1049},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_eq_x_as_result {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n}"}},"167":{"id":167,"crate_id":0,"name":"assert_in","span":{"filename":"src/assert_in/mod.rs","begin":[1,0],"end":[25,24]},"visibility":"public","docs":"Assert in nearness.\n\nThese macros compare numbers, such as two numbers\nwhere one number may be close to another number.\n\n* [`assert_in!(a, container)`](macro@crate::assert_in) ≈ a is in container\n* [`assert_in_range!(a, range)`](macro@crate::assert_in_range) ≈ a is in range\n* [`assert_in_delta!(a, b, delta)`](macro@crate::assert_in_delta) ≈ | a - b | ≤ Δ\n* [`assert_in_epsilon!(a, b, epsilon)`](macro@crate::assert_in_epsilon) ≈ | a - b | ≤ ε * min(a, b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 11;\nlet delta: i8 = 1;\nassert_in_delta!(a, b, delta);\n```","links":{"macro@crate::assert_in_range":163,"macro@crate::assert_in_delta":119,"macro@crate::assert_in_epsilon":120,"macro@crate::assert_in":153},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[156,159,162,166],"is_stripped":false}}},"771":{"id":771,"crate_id":0,"name":"assert_io_read_to_string_contains_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_contains.rs","begin":[42,0],"end":[95,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() contains a pattern.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) contains (expr)\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)\n* [`assert_io_read_to_string_contains_as_result`](macro@crate::assert_io_read_to_string_contains_as_result)\n* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)\n","links":{"macro@crate::debug_assert_io_read_to_string_contains":772,"macro@crate::assert_io_read_to_string_contains":770,"macro@crate::assert_io_read_to_string_contains_as_result":771},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_contains_as_result {\n    ($reader:expr, $containee:expr $(,)?) => { ... };\n}"}},"494":{"id":494,"crate_id":0,"name":"debug_assert_set_eq","span":{"filename":"src/assert_set/assert_set_eq.rs","begin":[299,0],"end":[305,1]},"visibility":"public","docs":"Assert a set is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) = (b_collection ⇒ b_set)\n\nThis macro provides the same statements as [`assert_set_eq`](macro.assert_set_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_set_eq`](macro@crate::assert_set_eq)\n* [`assert_set_eq`](macro@crate::assert_set_eq)\n* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)\n","links":{"macro@crate::debug_assert_set_eq":494,"macro@crate::assert_set_eq":492},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_set_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"1098":{"id":1098,"crate_id":0,"name":"assert_result_ok_as_result","span":{"filename":"src/assert_result/assert_result_ok.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nDeprecated. Please rename from `assert_result_ok_as_result` into `assert_ok_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_ok_as_result` into `assert_ok_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_ok_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"217":{"id":217,"crate_id":0,"name":"assert_count_ge_x","span":{"filename":"src/assert_count/assert_count_ge_x.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a count is greater than or equal to an expression.\n\nPseudocode:<br>\na.count() ≥ b\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\".chars();\nlet b = 1;\nassert_count_ge_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_ge_x!(a, b);\n# });\n// assertion failed: `assert_count_ge_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_ge_x.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_ge_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_ge_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)\n* [`assert_count_ge_x_as_result`](macro@crate::assert_count_ge_x_as_result)\n* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)\n","links":{"macro@crate::assert_count_ge_x_as_result":218,"macro@crate::assert_count_ge_x":217,"macro@crate::debug_assert_count_ge_x":219,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ge_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"821":{"id":821,"crate_id":0,"name":"assert_command_stdout_lt_x_as_result","span":{"filename":"src/assert_command/assert_command_stdout_lt_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stdout string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)\n* [`assert_command_stdout_lt_x_as_result`](macro@crate::assert_command_stdout_lt_x_as_result)\n* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)\n","links":{"macro@crate::debug_assert_command_stdout_lt_x":822,"macro@crate::assert_command_stdout_lt_x":820,"macro@crate::assert_command_stdout_lt_x_as_result":821},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_lt_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"544":{"id":544,"crate_id":0,"name":"assert_fn_eq_x","span":{"filename":"src/assert_fn/assert_fn_eq_x.rs","begin":[1,0],"end":[416,1]},"visibility":"public","docs":"Assert a function output is equal to an expression.\n\nPseudocode:<br>\nfunction(a) = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_eq_x!(i8::abs, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)\n* [`assert_fn_eq_x_as_result`](macro@crate::assert_fn_eq_x_as_result)\n* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)","links":{"macro@crate::assert_fn_eq_x":541,"macro@crate::debug_assert_fn_eq_x":543,"macro@crate::assert_fn_eq_x_as_result":542},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"267":{"id":267,"crate_id":0,"name":"debug_assert_is_match","span":{"filename":"src/assert_is_match/assert_is_match.rs","begin":[279,0],"end":[285,1]},"visibility":"public","docs":"Assert a matcher is a match for an expression.\n\nPseudocode:<br>\na.is_match(b)\n\nThis macro provides the same statements as [`assert_is_match`](macro.assert_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_is_match`](macro@crate::assert_is_match)\n* [`assert_is_match`](macro@crate::assert_is_match)\n* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)\n","links":{"macro@crate::assert_is_match":265,"macro@crate::debug_assert_is_match":267},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"1148":{"id":1148,"crate_id":0,"name":"assert_command_stderr_contains","span":{"filename":"src/assert_command/assert_command_stderr_contains.rs","begin":[30,0],"end":[34,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nDeprecated. Please rename from `assert_command_stderr_contains` into\n`assert_command_stderr_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stderr_contains` into `assert_command_stderr_string_contains`."},"inner":{"macro":"macro_rules! assert_command_stderr_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"871":{"id":871,"crate_id":0,"name":"assert_command_stderr_le_x","span":{"filename":"src/assert_command/assert_command_stderr_le_x.rs","begin":[270,0],"end":[283,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_le_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stderr_le_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stderr_le_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_le_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[97, 97]`,\n//     expr value: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_le_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_le_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[97, 97]`,\\n\",\n#     \"    expr value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)\n* [`assert_command_stderr_le_x_as_result`](macro@crate::assert_command_stderr_le_x_as_result)\n* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)\n","links":{"macro@crate::assert_command_stderr_le_x_as_result":872,"macro@crate::debug_assert_command_stderr_le_x":873,"macro@crate::assert_command_stderr_le_x":871,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_le_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"594":{"id":594,"crate_id":0,"name":"assert_fn_err_ge_x","span":{"filename":"src/assert_fn_err/assert_fn_err_ge_x.rs","begin":[326,0],"end":[359,1]},"visibility":"public","docs":"Assert a function error is greater than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≥ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 20;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_ge_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_ge_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_err_ge_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_ge_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"20 is out of range\\\"`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"20 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_ge_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_ge_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"20 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)\n* [`assert_fn_err_ge_x_as_result`](macro@crate::assert_fn_err_ge_x_as_result)\n* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)\n","links":{"macro@crate::debug_assert_fn_err_ge_x":596,"macro@crate::assert_fn_err_ge_x":594,"macro@crate::assert_fn_err_ge_x_as_result":595,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ge_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"317":{"id":317,"crate_id":0,"name":"assert_len_lt_x","span":{"filename":"src/assert_len/assert_len_lt_x.rs","begin":[1,0],"end":[335,1]},"visibility":"public","docs":"Assert a length is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = 2;\nassert_len_lt_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)\n* [`assert_len_lt_x_as_result`](macro@crate::assert_len_lt_x_as_result)\n* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)","links":{"macro@crate::debug_assert_len_lt_x":316,"macro@crate::assert_len_lt_x_as_result":315,"macro@crate::assert_len_lt_x":314},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"40":{"id":40,"crate_id":0,"name":"debug_assert_f32_gt","span":{"filename":"src/assert_f32/assert_f32_gt.rs","begin":[321,0],"end":[327,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is greater than another within f32::EPSILON.\n\nPseudocode:<br>\na > b\n\n\nThis macro provides the same statements as [`assert_f32_gt`](macro.assert_f32_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f32_gt`](macro@crate::assert_f32_gt)\n* [`assert_f32_gt`](macro@crate::assert_f32_gt)\n* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)\n","links":{"macro@crate::assert_f32_gt":38,"macro@crate::debug_assert_f32_gt":40},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f32_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"921":{"id":921,"crate_id":0,"name":"assert_program_args_stdout_eq_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq_x.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)\n* [`assert_program_args_stdout_eq_x_as_result`](macro@crate::assert_program_args_stdout_eq_x_as_result)\n* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)\n","links":{"macro@crate::assert_program_args_stdout_eq_x":920,"macro@crate::debug_assert_program_args_stdout_eq_x":922,"macro@crate::assert_program_args_stdout_eq_x_as_result":921},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_eq_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"644":{"id":644,"crate_id":0,"name":"assert_fn_ok_ge_x_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)\n* [`assert_fn_ok_ge_x_as_result`](macro@crate::assert_fn_ok_ge_x_as_result)\n* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)\n","links":{"macro@crate::assert_fn_ok_ge_x_as_result":644,"macro@crate::assert_fn_ok_ge_x":643,"macro@crate::debug_assert_fn_ok_ge_x":645},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ge_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"367":{"id":367,"crate_id":0,"name":"assert_ok_eq_as_result","span":{"filename":"src/assert_ok/assert_ok_eq.rs","begin":[41,0],"end":[90,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)\n\n* If true, return Result `Ok((a1, b1))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ok_eq`](macro@crate::assert_ok_eq)\n* [`assert_ok_eq_as_result`](macro@crate::assert_ok_eq_as_result)\n* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)\n","links":{"macro@crate::assert_ok_eq":366,"macro@crate::debug_assert_ok_eq":368,"macro@crate::assert_ok_eq_as_result":367},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"971":{"id":971,"crate_id":0,"name":"assert_program_args_stderr_lt_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt.rs","begin":[43,0],"end":[121,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)\n* [`assert_program_args_stderr_lt_as_result`](macro@crate::assert_program_args_stderr_lt_as_result)\n* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)\n","links":{"macro@crate::assert_program_args_stderr_lt_as_result":971,"macro@crate::debug_assert_program_args_stderr_lt":972,"macro@crate::assert_program_args_stderr_lt":970},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_lt_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"90":{"id":90,"crate_id":0,"name":"debug_assert_abs_diff_gt_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt_x.rs","begin":[460,0],"end":[466,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nPseudocode:<br>\n|Δ| > c\n\nThis macro provides the same statements as [`assert_abs_diff_gt_x`](macro.assert_abs_diff_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-x debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)\n* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)\n* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)\n","links":{"macro@crate::debug_assert_abs_diff_gt_x":90,"macro@crate::assert_abs_diff_gt_x":88},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_abs_diff_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"694":{"id":694,"crate_id":0,"name":"debug_assert_fs_read_to_string_ge_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge_x.rs","begin":[393,0],"end":[399,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≥ expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_ge_x`](macro.assert_fs_read_to_string_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)\n* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)\n* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)\n","links":{"macro@crate::assert_fs_read_to_string_ge_x":692,"macro@crate::debug_assert_fs_read_to_string_ge_x":694},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"417":{"id":417,"crate_id":0,"name":"assert_some_ne_x","span":{"filename":"src/assert_some/assert_some_ne_x.rs","begin":[1,0],"end":[391,1]},"visibility":"public","docs":"Assert an expression is Some and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::Some(1);\nlet b: i8 = 2;\nassert_some_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)\n* [`assert_some_ne_x_as_result`](macro@crate::assert_some_ne_x_as_result)\n* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)","links":{"macro@crate::debug_assert_some_ne_x":416,"macro@crate::assert_some_ne_x":414,"macro@crate::assert_some_ne_x_as_result":415},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1021":{"id":1021,"crate_id":0,"name":"debug_assert_status_failure","span":{"filename":"src/assert_status/assert_status_failure.rs","begin":[268,0],"end":[274,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\nThis macro provides the same statements as [`assert_status_failure`](macro.assert_status_failure.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_failure`](macro@crate::assert_status_failure)\n* [`assert_status_failure`](macro@crate::assert_status_failure)\n* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)\n","links":{"macro@crate::assert_status_failure":1019,"macro@crate::debug_assert_status_failure":1021},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_failure {\n    ($($arg:tt)*) => { ... };\n}"}},"140":{"id":140,"crate_id":0,"name":"assert_diff_le_x","span":{"filename":"src/assert_diff/assert_diff_le_x.rs","begin":[332,0],"end":[345,1]},"visibility":"public","docs":"Assert a difference is less than or equal to an expression.\n\nPseudocode:<br>\nΔ ≤ x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 3;\nassert_diff_le_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 1;\nassert_diff_le_x!(a, b, x);\n# });\n// assertion failed: `assert_diff_le_x!(a, b, x)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_diff_le_x.html\n//        a label: `a`,\n//        a debug: `10`,\n//        b label: `b`,\n//        b debug: `13`,\n//        x label: `x`,\n//        x debug: `1`,\n//              Δ: `3`,\n//          Δ ≤ x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_diff_le_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_diff_le_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `1`,\\n\",\n#     \"       Δ: `3`,\\n\",\n#     \"   Δ ≤ x: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)\n* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)\n* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)\n","links":{"`panic!`":1081,"macro@crate::assert_diff_le_x_as_result":141,"macro@crate::debug_assert_diff_le_x":142,"macro@crate::assert_diff_le_x":140},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_le_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"744":{"id":744,"crate_id":0,"name":"debug_assert_io_read_to_string_ne","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne.rs","begin":[363,0],"end":[369,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_ne`](macro.assert_io_read_to_string_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)\n* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)\n* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)\n","links":{"macro@crate::debug_assert_io_read_to_string_ne":744,"macro@crate::assert_io_read_to_string_ne":742},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"467":{"id":467,"crate_id":0,"name":"assert_iter_eq","span":{"filename":"src/assert_iter/assert_iter_eq.rs","begin":[164,0],"end":[177,1]},"visibility":"public","docs":"Assert an iterable is equal to another.\n\nPseudocode:<br>\n(collection1 into iter) = (collection2 into iter)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [1, 2];\nassert_iter_eq!(&a, &b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [2, 1];\nassert_iter_eq!(&a, &b);\n# });\n// assertion failed: `assert_iter_eq!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_iter_eq.html\n//  a label: `&a`,\n//  a debug: `[1, 2]`,\n//  b label: `&b`,\n//  b debug: `[2, 1]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_iter_eq!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_iter_eq.html\\n\",\n#     \" a label: `&a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `&b`,\\n\",\n#     \" b debug: `[2, 1]`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_eq`](macro@crate::assert_iter_eq)\n* [`assert_iter_eq_as_result`](macro@crate::assert_iter_eq_as_result)\n* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_iter_eq":469,"macro@crate::assert_iter_eq_as_result":468,"macro@crate::assert_iter_eq":467},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_iter_eq {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1071":{"id":1071,"crate_id":0,"name":"assert_success","span":{"filename":"src/assert_success/assert_success.rs","begin":[160,0],"end":[173,1]},"visibility":"public","docs":"Assert a success method is true.\n\nPseudocode:<br>\na.success() = true\n\n* If true, return `true`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { true }}\nlet a = A{};\nassert_success!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { false }}\nlet a = A{};\nassert_success!(a);\n# });\n// assertion failed: `assert_success!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_success.html\n//  a label: `a`,\n//  a debug: `A`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_success!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_success.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `A`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_success`](macro@crate::assert_success)\n* [`assert_success_as_result`](macro@crate::assert_success_as_result)\n* [`debug_assert_success`](macro@crate::debug_assert_success)\n","links":{"macro@crate::debug_assert_success":1073,"macro@crate::assert_success_as_result":1072,"macro@crate::assert_success":1071,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_success {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"190":{"id":190,"crate_id":0,"name":"assert_count_eq_as_result","span":{"filename":"src/assert_count/assert_count_eq.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a count is equal to another.\n\nPseudocode:<br>\na.count() = b.count()\n\n* If true, return Result `Ok((a.count(), b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_count_eq`](macro@crate::assert_count_eq)\n* [`assert_count_eq_as_result`](macro@crate::assert_count_eq_as_result)\n* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)\n","links":{"macro@crate::assert_count_eq_as_result":190,"macro@crate::debug_assert_count_eq":191,"macro@crate::assert_count_eq":189},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"794":{"id":794,"crate_id":0,"name":"debug_assert_command_stdout_le","span":{"filename":"src/assert_command/assert_command_stdout_le.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to another.\n\nThis macro provides the same statements as [`assert_command_stdout_le {`](macro.assert_command_stdout_le {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_le {`](macro@crate::assert_command_stdout_le {)\n* [`assert_command_stdout_le {`](macro@crate::assert_command_stdout_le {)\n* [`debug_assert_command_stdout_le {`](macro@crate::debug_assert_command_stdout_le {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_le {\n    ($($arg:tt)*) => { ... };\n}"}},"517":{"id":517,"crate_id":0,"name":"assert_fn_eq","span":{"filename":"src/assert_fn/assert_fn_eq.rs","begin":[259,0],"end":[293,1]},"visibility":"public","docs":"Assert a function output is equal to another.\n\nPseudocode:<br>\na_function(a) == b_function(b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_eq!(i8::abs, a, i8::abs, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_eq!(i8::abs, a, i8::abs, b);\n# });\n// assertion failed: `assert_fn_eq!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_eq.html\n//  a_function label: `i8::abs`,\n//     a_param label: `a`,\n//     a_param debug: `-1`,\n//  b_function label: `i8::abs`,\n//     b_param label: `b`,\n//     b_param debug: `2`,\n//                 a: `1`,\n//                 b: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_eq!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_eq.html\\n\",\n#     \" a_function label: `i8::abs`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `-1`,\\n\",\n#     \" b_function label: `i8::abs`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `2`,\\n\",\n#     \"                a: `1`,\\n\",\n#     \"                b: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_eq`](macro@crate::assert_fn_eq)\n* [`assert_fn_eq_as_result`](macro@crate::assert_fn_eq_as_result)\n* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)\n","links":{"macro@crate::debug_assert_fn_eq":519,"macro@crate::assert_fn_eq":517,"macro@crate::assert_fn_eq_as_result":518,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_eq {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"1121":{"id":1121,"crate_id":0,"name":"debug_assert_poll_pending","span":{"filename":"src/assert_poll/assert_poll_pending.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert an expression is Pending.\n\nDeprecated. Please rename from `debug_assert_poll_pending` into `debug_assert_pending` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_poll_pending` into `debug_assert_pending` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_poll_pending {\n    ($($arg:tt)*) => { ... };\n}"}},"240":{"id":240,"crate_id":0,"name":"debug_assert_email_address","span":{"filename":"src/assert_email_address/assert_email_address.rs","begin":[527,0],"end":[533,1]},"visibility":"public","docs":"Assert expression is possibly an email address.\n\nThis macro provides the same statements as [`assert_email_address`](macro.assert_email_address.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_email_address`](macro@crate::assert_email_address)\n* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)\n* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)\n","links":{"macro@crate::assert_email_address":238,"macro@crate::assert_email_address_as_result":239,"macro@crate::debug_assert_email_address":240},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_email_address {\n    ($($arg:tt)*) => { ... };\n}"}},"844":{"id":844,"crate_id":0,"name":"assert_command_stderr_gt_as_result","span":{"filename":"src/assert_command/assert_command_stderr_gt.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string is greater than another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_gt`](macro@crate::assert_command_stderr_gt)\n* [`assert_command_stderr_gt_as_result`](macro@crate::assert_command_stderr_gt_as_result)\n* [`debug_assert_command_stderr_gt`](macro@crate::debug_assert_command_stderr_gt)\n","links":{"macro@crate::debug_assert_command_stderr_gt":845,"macro@crate::assert_command_stderr_gt":843,"macro@crate::assert_command_stderr_gt_as_result":844},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_gt_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"567":{"id":567,"crate_id":0,"name":"assert_fn_err_eq_as_result","span":{"filename":"src/assert_fn_err/assert_fn_err_eq.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function error is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* e, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)\n* [`assert_fn_err_eq_as_result`](macro@crate::assert_fn_err_eq_as_result)\n* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)\n","links":{"macro@crate::assert_fn_err_eq":566,"macro@crate::debug_assert_fn_err_eq":568,"macro@crate::assert_fn_err_eq_as_result":567},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_eq_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"290":{"id":290,"crate_id":0,"name":"assert_len_lt","span":{"filename":"src/assert_len/assert_len_lt.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a length is less than another.\n\nPseudocode:<br>\na.len() < b.len()\n\n* If true, return `(a.len(), b.len())`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\";\nlet b = \"x\";\nassert_len_lt!(a, b);\n# });\n// assertion failed: `assert_len_lt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_lt.html\n//  a label: `a`,\n//  a debug: `\\\"xx\\\"`,\n//  a.len(): `2`\",\n//  b label: `b`,\n//  b debug: `\\\"x\\\"`,\n//  b.len(): `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_lt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"xx\\\"`,\\n\",\n#     \" a.len(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"x\\\"`\\n\",\n#     \" b.len(): `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_lt`](macro@crate::assert_len_lt)\n* [`assert_len_lt_as_result`](macro@crate::assert_len_lt_as_result)\n* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)\n","links":{"macro@crate::assert_len_lt":290,"macro@crate::assert_len_lt_as_result":291,"macro@crate::debug_assert_len_lt":292,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_lt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"13":{"id":13,"crate_id":0,"name":"assert_le_as_result","span":{"filename":"src/assert_le.rs","begin":[41,0],"end":[68,1]},"visibility":"public","docs":"Assert an expression is less than or equal to another.\n\nPseudocode:<br>\na ≤ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_le`](macro@crate::assert_le)\n* [`assert_le_as_result`](macro@crate::assert_le_as_result)\n* [`debug_assert_le`](macro@crate::debug_assert_le)\n","links":{"macro@crate::assert_le":12,"macro@crate::assert_le_as_result":13,"macro@crate::debug_assert_le":14},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_le_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"894":{"id":894,"crate_id":0,"name":"assert_command_stdout_ne_x","span":{"filename":"src/assert_command/assert_command_stdout_ne_x.rs","begin":[264,0],"end":[277,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_ne_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_command_stdout_ne_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stdout_ne_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_ne_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[97, 108, 102, 97]`,\n//     expr value: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_ne_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_ne_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr value: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)\n* [`assert_command_stdout_ne_x_as_result`](macro@crate::assert_command_stdout_ne_x_as_result)\n* [`debug_assert_command_stdout_ne_x`](macro@crate::debug_assert_command_stdout_ne_x)\n","links":{"macro@crate::assert_command_stdout_ne_x_as_result":1139,"macro@crate::assert_command_stdout_ne_x":894,"macro@crate::debug_assert_command_stdout_ne_x":1140,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ne_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"617":{"id":617,"crate_id":0,"name":"debug_assert_fn_ok_eq","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq.rs","begin":[491,0],"end":[497,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\nThis macro provides the same statements as [`assert_fn_ok_eq`](macro.assert_fn_ok_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)\n* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)\n* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)\n","links":{"macro@crate::assert_fn_ok_eq":615,"macro@crate::debug_assert_fn_ok_eq":617},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ok_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"340":{"id":340,"crate_id":0,"name":"assert_starts_with","span":{"filename":"src/assert_starts_with/mod.rs","begin":[1,0],"end":[27,27]},"visibility":"public","docs":"Assert for a sequence that may start with a part.\n\nThese macros help with comparison of a sequence (such as a string, vector, range)\nand a part (such as a string substring, an array element, a range value).\n\n* [`assert_starts_with(sequence, subsequence)`](macro@crate::assert_starts_with) ≈ container.contains(containee)\n\n* [`assert_not_starts_with!(sequence, subsequence)`](macro@crate::assert_not_starts_with) ≈ !container.contains(containee)\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String starts with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"al\";\nassert_starts_with!(sequence, subsequence);\n\n// Vector starts with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [1];\nassert_starts_with!(sequence, subsequence);\n```","links":{"macro@crate::assert_not_starts_with":332,"macro@crate::assert_starts_with":336},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[335,339],"is_stripped":false}}},"944":{"id":944,"crate_id":0,"name":"assert_program_args_stdout_contains","span":{"filename":"src/assert_program_args/assert_program_args_stdout_contains.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nDeprecated. Please rename from `assert_program_args_stdout_contains` to `assert_program_args_stdout_string_contains`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"63":{"id":63,"crate_id":0,"name":"assert_f64_gt","span":{"filename":"src/assert_f64/assert_f64_gt.rs","begin":[257,0],"end":[270,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is greater than another within f64::EPSILON.\n\nPseudocode:<br>\na > b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333329;\nassert_f64_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_gt!(a, b);\n# });\n// assertion failed: `assert_f64_gt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f64_gt.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333339`,`\n//     diff: `-0.0000000000000006106226635438361`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f64_gt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f64_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333339`,\\n\",\n#     \"    diff: `-0.0000000000000006106226635438361`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f64_gt`](macro@crate::assert_f64_gt)\n* [`assert_f64_gt_as_result`](macro@crate::assert_f64_gt_as_result)\n* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)\n","links":{"macro@crate::assert_f64_gt":63,"macro@crate::assert_f64_gt_as_result":64,"macro@crate::debug_assert_f64_gt":65,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_gt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"667":{"id":667,"crate_id":0,"name":"assert_fs_read_to_string_eq","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq.rs","begin":[1,0],"end":[405,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa.txt\";\nlet b = \"alfa.txt\";\nassert_fs_read_to_string_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)\n* [`assert_fs_read_to_string_eq_as_result`](macro@crate::assert_fs_read_to_string_eq_as_result)\n* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)","links":{"macro@crate::assert_fs_read_to_string_eq_as_result":665,"macro@crate::assert_fs_read_to_string_eq":664,"macro@crate::debug_assert_fs_read_to_string_eq":666},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"390":{"id":390,"crate_id":0,"name":"debug_assert_none","span":{"filename":"src/assert_none/assert_none.rs","begin":[241,0],"end":[247,1]},"visibility":"public","docs":"Assert expression is None.\n\nPseudocode:<br>\na is None\n\nThis macro provides the same statements as [`assert_none`](macro.assert_none.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_none`](macro@crate::assert_none)\n* [`assert_none`](macro@crate::assert_none)\n* [`debug_assert_none`](macro@crate::debug_assert_none)\n","links":{"macro@crate::debug_assert_none":390,"macro@crate::assert_none":388},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_none {\n    ($($arg:tt)*) => { ... };\n}"}},"113":{"id":113,"crate_id":0,"name":"assert_abs_diff_le","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le.rs","begin":[25,0],"end":[29,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_le` into `assert_abs_diff_le_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_le` into `assert_abs_diff_le_x`."},"inner":{"macro":"macro_rules! assert_abs_diff_le {\n    ($($arg:tt)*) => { ... };\n}"}},"994":{"id":994,"crate_id":0,"name":"assert_program_args_stderr_lt_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)\n* [`assert_program_args_stderr_lt_x_as_result`](macro@crate::assert_program_args_stderr_lt_x_as_result)\n* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_lt_x":995,"macro@crate::assert_program_args_stderr_lt_x_as_result":994,"macro@crate::assert_program_args_stderr_lt_x":993},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_lt_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"717":{"id":717,"crate_id":0,"name":"assert_fs_read_to_string_is_match_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_is_match.rs","begin":[42,0],"end":[95,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) matches expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)\n* [`assert_fs_read_to_string_is_match_as_result`](macro@crate::assert_fs_read_to_string_is_match_as_result)\n* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)\n","links":{"macro@crate::assert_fs_read_to_string_is_match_as_result":717,"macro@crate::debug_assert_fs_read_to_string_is_match":718,"macro@crate::assert_fs_read_to_string_is_match":716},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_is_match_as_result {\n    ($path:expr, $matcher:expr $(,)?) => { ... };\n}"}},"440":{"id":440,"crate_id":0,"name":"assert_ready_ne","span":{"filename":"src/assert_ready/assert_ready_ne.rs","begin":[1,0],"end":[333,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(2);\nassert_ready_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_ready_ne`](macro@crate::assert_ready_ne)\n* [`assert_ready_ne_as_result`](macro@crate::assert_ready_ne_as_result)\n* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)","links":{"macro@crate::assert_ready_ne":437,"macro@crate::debug_assert_ready_ne":439,"macro@crate::assert_ready_ne_as_result":438},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"163":{"id":163,"crate_id":0,"name":"assert_in_range","span":{"filename":"src/assert_in/assert_in_range.rs","begin":[226,0],"end":[239,1]},"visibility":"public","docs":"Assert an item is in a range.\n\nPseudocode:<br>\na is in range\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 1;\nlet b = 0..2;\nassert_in_range!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 1;\nlet b = 2..4;\nassert_in_range!(a, b);\n# });\n// assertion failed: `assert_in_range!(a, range)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_in_range.html\n//  a label: `a`,\n//  a debug: `1`,\n//  range label: `b`,\n//  range debug: `2..4`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_in_range!(a, range)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_in_range.html\\n\",\n#     \"     a label: `a`,\\n\",\n#     \"     a debug: `1`,\\n\",\n#     \" range label: `b`,\\n\",\n#     \" range debug: `2..4`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_in_range`](macro@crate::assert_in_range)\n* [`assert_in_range_as_result`](macro@crate::assert_in_range_as_result)\n* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)\n","links":{"macro@crate::assert_in_range":163,"macro@crate::debug_assert_in_range":165,"macro@crate::assert_in_range_as_result":164,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_range {\n    ($a:expr, $range:expr $(,)?) => { ... };\n    ($a:expr, $range:expr, $($message:tt)+) => { ... };\n}"}},"1044":{"id":1044,"crate_id":0,"name":"assert_status_code_value_ne_as_result","span":{"filename":"src/assert_status/assert_status_code_value_ne.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne_as_result`](macro@crate::assert_status_code_value_ne_as_result)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)\n","links":{"macro@crate::assert_status_code_value_ne_as_result":1044,"macro@crate::assert_status_code_value_ne":1043,"macro@crate::debug_assert_status_code_value_ne":1045},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ne_as_result {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n}"}},"767":{"id":767,"crate_id":0,"name":"assert_io_read_to_string_ne_x_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne_x.rs","begin":[42,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)\n* [`assert_io_read_to_string_ne_x_as_result`](macro@crate::assert_io_read_to_string_ne_x_as_result)\n* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)\n","links":{"macro@crate::assert_io_read_to_string_ne_x":766,"macro@crate::assert_io_read_to_string_ne_x_as_result":767,"macro@crate::debug_assert_io_read_to_string_ne_x":768},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ne_x_as_result {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"490":{"id":490,"crate_id":0,"name":"assert_iter_ne","span":{"filename":"src/assert_iter/assert_iter_ne.rs","begin":[1,0],"end":[259,1]},"visibility":"public","docs":"Assert an iter is not equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≠ (collection2 into iter)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_ne!(&a, &b);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_ne`](macro@crate::assert_iter_ne)\n* [`assert_iter_ne_as_result`](macro@crate::assert_iter_ne_as_result)\n* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)","links":{"macro@crate::assert_iter_ne_as_result":488,"macro@crate::assert_iter_ne":487,"macro@crate::debug_assert_iter_ne":489},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1094":{"id":1094,"crate_id":0,"name":"debug_assert_abs_diff_ne","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne.rs","begin":[39,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nDeprecated. Please rename from `debug_assert_abs_diff_ne` into `debug_assert_abs_diff_ne_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_abs_diff_ne` into `debug_assert_abs_diff_ne_x`."},"inner":{"macro":"macro_rules! debug_assert_abs_diff_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"213":{"id":213,"crate_id":0,"name":"assert_count_eq_x","span":{"filename":"src/assert_count/assert_count_eq_x.rs","begin":[211,0],"end":[224,1]},"visibility":"public","docs":"Assert a count is equal to an expression.\n\nPseudocode:<br>\na.count() = b\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = 1;\nassert_count_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_eq_x!(a, b);\n# });\n// assertion failed: `assert_count_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_eq_x.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)\n* [`assert_count_eq_x_as_result`](macro@crate::assert_count_eq_x_as_result)\n* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)\n","links":{"macro@crate::assert_count_eq_x_as_result":214,"macro@crate::assert_count_eq_x":213,"macro@crate::debug_assert_count_eq_x":215,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_eq_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"817":{"id":817,"crate_id":0,"name":"assert_command_stdout_le_x_as_result","span":{"filename":"src/assert_command/assert_command_stdout_le_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)\n* [`assert_command_stdout_le_x_as_result`](macro@crate::assert_command_stdout_le_x_as_result)\n* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)\n","links":{"macro@crate::assert_command_stdout_le_x":816,"macro@crate::assert_command_stdout_le_x_as_result":817,"macro@crate::debug_assert_command_stdout_le_x":818},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_le_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"540":{"id":540,"crate_id":0,"name":"assert_fn_ne","span":{"filename":"src/assert_fn/assert_fn_ne.rs","begin":[1,0],"end":[436,1]},"visibility":"public","docs":"Assert a function output is not equal to another.\n\nPseudocode:<br>\na_function(a) ≠ b_function(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -1;\nlet b: i8 = 2;\nassert_fn_ne!(i8::abs, a, i8::abs, b);\n```\n\n# Module macros\n\n* [`assert_fn_ne`](macro@crate::assert_fn_ne)\n* [`assert_fn_ne_as_result`](macro@crate::assert_fn_ne_as_result)\n* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)","links":{"macro@crate::assert_fn_ne_as_result":538,"macro@crate::debug_assert_fn_ne":539,"macro@crate::assert_fn_ne":537},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1144":{"id":1144,"crate_id":0,"name":"assert_command_stdout_is_match_as_result","span":{"filename":"src/assert_command/assert_command_stdout_is_match.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nDeprecated. Please rename from `assert_command_stdout_is_match_as_result` into `assert_command_stdout_string_is_match_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stdout_is_match_as_result` into `assert_command_stdout_string_is_match_as_result`."},"inner":{"macro":"macro_rules! assert_command_stdout_is_match_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"263":{"id":263,"crate_id":0,"name":"assert_not_empty","span":{"filename":"src/assert_is_empty/assert_not_empty.rs","begin":[1,0],"end":[250,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is not empty.\n\nPseudocode:<br>\n¬ a.is_empty()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"alfa\";\nassert_not_empty!(a);\n```\n\n# Module macros\n\n* [`assert_not_empty`](macro@crate::assert_not_empty)\n* [`assert_not_empty_as_result`](macro@crate::assert_not_empty_as_result)\n* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)","links":{"macro@crate::debug_assert_not_empty":262,"macro@crate::assert_not_empty":260,"macro@crate::assert_not_empty_as_result":261},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"867":{"id":867,"crate_id":0,"name":"assert_command_stderr_gt_x","span":{"filename":"src/assert_command/assert_command_stderr_gt_x.rs","begin":[248,0],"end":[261,1]},"visibility":"public","docs":"Assert a command stderr string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stderr_gt_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_gt_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stderr_gt_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_gt_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[122, 122]`,\n//     expr value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_gt_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_gt_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[122, 122]`,\\n\",\n#     \"    expr value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)\n* [`assert_command_stderr_gt_x_as_result`](macro@crate::assert_command_stderr_gt_x_as_result)\n* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)\n","links":{"`panic!`":1081,"macro@crate::assert_command_stderr_gt_x":867,"macro@crate::debug_assert_command_stderr_gt_x":869,"macro@crate::assert_command_stderr_gt_x_as_result":868},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_gt_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"590":{"id":590,"crate_id":0,"name":"assert_fn_err_eq_x","span":{"filename":"src/assert_fn_err/assert_fn_err_eq_x.rs","begin":[301,0],"end":[335,1]},"visibility":"public","docs":"Assert a function error is equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) = expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_eq_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_eq_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_err_eq_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_eq_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"20 is out of range\\\"`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"20 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_eq_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_eq_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"20 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)\n* [`assert_fn_err_eq_x_as_result`](macro@crate::assert_fn_err_eq_x_as_result)\n* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)\n","links":{"macro@crate::assert_fn_err_eq_x":590,"macro@crate::assert_fn_err_eq_x_as_result":591,"macro@crate::debug_assert_fn_err_eq_x":592,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_eq_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"313":{"id":313,"crate_id":0,"name":"assert_len_le_x","span":{"filename":"src/assert_len/assert_len_le_x.rs","begin":[1,0],"end":[338,1]},"visibility":"public","docs":"Assert a length is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = 2;\nassert_len_le_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_le_x`](macro@crate::assert_len_le_x)\n* [`assert_len_le_x_as_result`](macro@crate::assert_len_le_x_as_result)\n* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)","links":{"macro@crate::assert_len_le_x":310,"macro@crate::assert_len_le_x_as_result":311,"macro@crate::debug_assert_len_le_x":312},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"36":{"id":36,"crate_id":0,"name":"debug_assert_f32_ge","span":{"filename":"src/assert_f32/assert_f32_ge.rs","begin":[382,0],"end":[388,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\n\nThis macro provides the same statements as [`assert_f32_ge`](macro.assert_f32_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f32_ge`](macro@crate::assert_f32_ge)\n* [`assert_f32_ge`](macro@crate::assert_f32_ge)\n* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)\n","links":{"macro@crate::assert_f32_ge":34,"macro@crate::debug_assert_f32_ge":36},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f32_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"917":{"id":917,"crate_id":0,"name":"assert_program_args_stdout_ne_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne.rs","begin":[44,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* If true, return Result `Err` with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)\n* [`assert_program_args_stdout_ne_as_result`](macro@crate::assert_program_args_stdout_ne_as_result)\n* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)\n","links":{"macro@crate::assert_program_args_stdout_ne":916,"macro@crate::debug_assert_program_args_stdout_ne":918,"macro@crate::assert_program_args_stdout_ne_as_result":917},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ne_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"640":{"id":640,"crate_id":0,"name":"assert_fn_ok_eq_x_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq_x.rs","begin":[47,0],"end":[163,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)\n* [`assert_fn_ok_eq_x_as_result`](macro@crate::assert_fn_ok_eq_x_as_result)\n* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)\n","links":{"macro@crate::debug_assert_fn_ok_eq_x":641,"macro@crate::assert_fn_ok_eq_x":639,"macro@crate::assert_fn_ok_eq_x_as_result":640},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_eq_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"363":{"id":363,"crate_id":0,"name":"assert_ok_as_result","span":{"filename":"src/assert_ok/assert_ok.rs","begin":[40,0],"end":[60,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nPseudocode:<br>\na is Ok(a1)\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ok`](macro@crate::assert_ok)\n* [`assert_ok_as_result`](macro@crate::assert_ok_as_result)\n* [`debug_assert_ok`](macro@crate::debug_assert_ok)\n","links":{"macro@crate::assert_ok":362,"macro@crate::assert_ok_as_result":363,"macro@crate::debug_assert_ok":364},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"86":{"id":86,"crate_id":0,"name":"debug_assert_abs_diff_ge_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge_x.rs","begin":[479,0],"end":[485,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≥ c\n\nThis macro provides the same statements as [`assert_abs_diff_ge_x`](macro.assert_abs_diff_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-x debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)\n* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)\n* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)\n","links":{"macro@crate::assert_abs_diff_ge_x":84,"macro@crate::debug_assert_abs_diff_ge_x":86},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_abs_diff_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"967":{"id":967,"crate_id":0,"name":"assert_program_args_stderr_le_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le.rs","begin":[43,0],"end":[121,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)\n* [`assert_program_args_stderr_le_as_result`](macro@crate::assert_program_args_stderr_le_as_result)\n* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)\n","links":{"macro@crate::assert_program_args_stderr_le":966,"macro@crate::debug_assert_program_args_stderr_le":968,"macro@crate::assert_program_args_stderr_le_as_result":967},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_le_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"690":{"id":690,"crate_id":0,"name":"debug_assert_fs_read_to_string_eq_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq_x.rs","begin":[398,0],"end":[404,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) = expr\n\nThis macro provides the same statements as [`assert_fs_read_to_string_eq_x`](macro.assert_fs_read_to_string_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)\n* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)\n* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)\n","links":{"macro@crate::assert_fs_read_to_string_eq_x":688,"macro@crate::debug_assert_fs_read_to_string_eq_x":690},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"413":{"id":413,"crate_id":0,"name":"assert_some_eq_x","span":{"filename":"src/assert_some/assert_some_eq_x.rs","begin":[1,0],"end":[351,1]},"visibility":"public","docs":"Assert an expression is Some and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::Some(1);\nlet b: i8 = 1;\nassert_some_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)\n* [`assert_some_eq_x_as_result`](macro@crate::assert_some_eq_x_as_result)\n* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)","links":{"macro@crate::assert_some_eq_x_as_result":411,"macro@crate::assert_some_eq_x":410,"macro@crate::debug_assert_some_eq_x":412},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"136":{"id":136,"crate_id":0,"name":"assert_diff_gt_x","span":{"filename":"src/assert_diff/assert_diff_gt_x.rs","begin":[302,0],"end":[315,1]},"visibility":"public","docs":"Assert a difference is greater than an expression.\n\nPseudocode:<br>\nΔ > x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 2;\nassert_diff_gt_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 4;\nassert_diff_gt_x!(a, b, x);\n# });\n// assertion failed: `assert_diff_gt_x!(a, b, x)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_diff_gt_x.html\n//        a label: `a`,\n//        a debug: `10`,\n//        b label: `b`,\n//        b debug: `13`,\n//        x label: `x`,\n//        x debug: `4`,\n//              Δ: `3`,\n//          Δ > x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_diff_gt_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_diff_gt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `4`,\\n\",\n#     \"       Δ: `3`,\\n\",\n#     \"   Δ > x: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)\n* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)\n* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)\n","links":{"macro@crate::assert_diff_gt_x":136,"macro@crate::assert_diff_gt_x_as_result":137,"macro@crate::debug_assert_diff_gt_x":138,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_gt_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"1017":{"id":1017,"crate_id":0,"name":"debug_assert_status_success_false","span":{"filename":"src/assert_status/assert_status_success_false.rs","begin":[268,0],"end":[274,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\nThis macro provides the same statements as [`assert_status_success_false`](macro.assert_status_success_false.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_success_false`](macro@crate::assert_status_success_false)\n* [`assert_status_success_false`](macro@crate::assert_status_success_false)\n* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)\n","links":{"macro@crate::debug_assert_status_success_false":1017,"macro@crate::assert_status_success_false":1015},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_success_false {\n    ($($arg:tt)*) => { ... };\n}"}},"740":{"id":740,"crate_id":0,"name":"debug_assert_io_read_to_string_lt","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt.rs","begin":[335,0],"end":[341,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_lt`](macro.assert_io_read_to_string_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)\n* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)\n* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)\n","links":{"macro@crate::assert_io_read_to_string_lt":738,"macro@crate::debug_assert_io_read_to_string_lt":740},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"463":{"id":463,"crate_id":0,"name":"assert_bag_superbag_as_result","span":{"filename":"src/assert_bag/assert_bag_superbag.rs","begin":[43,0],"end":[80,1]},"visibility":"public","docs":"Assert a bag is a superbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)\n\n* If true, return Result `Ok((a, b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)\n* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)\n* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)\n","links":{"macro@crate::assert_bag_superbag_as_result":463,"macro@crate::debug_assert_bag_superbag":464,"macro@crate::assert_bag_superbag":462},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_superbag_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"186":{"id":186,"crate_id":0,"name":"debug_assert_not_contains","span":{"filename":"src/assert_contains/assert_not_contains.rs","begin":[962,0],"end":[968,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not contain an expression (such as a substring).\n\nPseudocode:<br>\n¬ a.contains(b)\n\nThis macro provides the same statements as [`assert_not_contains`](macro.assert_not_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_contains`](macro@crate::assert_not_contains)\n* [`assert_not_contains`](macro@crate::assert_not_contains)\n* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)\n","links":{"macro@crate::assert_not_contains":184,"macro@crate::debug_assert_not_contains":186},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"1067":{"id":1067,"crate_id":0,"name":"assert_status_code_value_ne_x_as_result","span":{"filename":"src/assert_status/assert_status_code_value_ne_x.rs","begin":[42,0],"end":[105,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne_x_as_result`](macro@crate::assert_status_code_value_ne_x_as_result)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)\n","links":{"macro@crate::assert_status_code_value_ne_x_as_result":1067,"macro@crate::assert_status_code_value_ne":1043,"macro@crate::debug_assert_status_code_value_ne":1045},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ne_x_as_result {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n}"}},"790":{"id":790,"crate_id":0,"name":"debug_assert_command_stdout_gt","span":{"filename":"src/assert_command/assert_command_stdout_gt.rs","begin":[384,0],"end":[390,1]},"visibility":"public","docs":"Assert a command stdout string is greater than another.\n\nThis macro provides the same statements as [`assert_command_stdout_gt {`](macro.assert_command_stdout_gt {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_gt {`](macro@crate::assert_command_stdout_gt {)\n* [`assert_command_stdout_gt {`](macro@crate::assert_command_stdout_gt {)\n* [`debug_assert_command_stdout_gt {`](macro@crate::debug_assert_command_stdout_gt {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"513":{"id":513,"crate_id":0,"name":"assert_set_superset_as_result","span":{"filename":"src/assert_set/assert_set_superset.rs","begin":[45,0],"end":[78,1]},"visibility":"public","docs":"Assert a set is a superset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)\n\n* If true, return Result `Ok((a_set, b_set))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_superset`](macro@crate::assert_set_superset)\n* [`assert_set_superset_as_result`](macro@crate::assert_set_superset_as_result)\n* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)\n","links":{"macro@crate::debug_assert_set_superset":514,"macro@crate::assert_set_superset":512,"macro@crate::assert_set_superset_as_result":513},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_superset_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"236":{"id":236,"crate_id":0,"name":"assert_count_ne_x","span":{"filename":"src/assert_count/assert_count_ne_x.rs","begin":[1,0],"end":[338,1]},"visibility":"public","docs":"Assert a count is not equal to an expression.\n\nPseudocode:<br>\na.count() ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)\n* [`assert_count_ne_x_as_result`](macro@crate::assert_count_ne_x_as_result)\n* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)","links":{"macro@crate::assert_count_ne_x_as_result":234,"macro@crate::debug_assert_count_ne_x":235,"macro@crate::assert_count_ne_x":233},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1117":{"id":1117,"crate_id":0,"name":"assert_option_some_ne","span":{"filename":"src/assert_option/assert_option_some_ne.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nDeprecated. Please rename from `assert_option_some_ne` into `assert_some_ne` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_some_ne` into `assert_some_ne` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_some_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"840":{"id":840,"crate_id":0,"name":"assert_command_stderr_ge_as_result","span":{"filename":"src/assert_command/assert_command_stderr_ge.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_ge`](macro@crate::assert_command_stderr_ge)\n* [`assert_command_stderr_ge_as_result`](macro@crate::assert_command_stderr_ge_as_result)\n* [`debug_assert_command_stderr_ge`](macro@crate::debug_assert_command_stderr_ge)\n","links":{"macro@crate::assert_command_stderr_ge_as_result":840,"macro@crate::debug_assert_command_stderr_ge":841,"macro@crate::assert_command_stderr_ge":839},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ge_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"563":{"id":563,"crate_id":0,"name":"debug_assert_fn_ne_x","span":{"filename":"src/assert_fn/assert_fn_ne_x.rs","begin":[408,0],"end":[414,1]},"visibility":"public","docs":"Assert a function output is not equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≠ b\n\nThis macro provides the same statements as [`assert_fn_ne_x`](macro.assert_fn_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)\n* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)\n* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)\n","links":{"macro@crate::assert_fn_ne_x":561,"macro@crate::debug_assert_fn_ne_x":563},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"286":{"id":286,"crate_id":0,"name":"assert_len_le","span":{"filename":"src/assert_len/assert_len_le.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a length is less than or equal to another.\n\nPseudocode:<br>\na.len() ≤ b.len()\n\n* If true, return `(a.len(), b.len())`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\";\nlet b = \"x\";\nassert_len_le!(a, b);\n# });\n// assertion failed: `assert_len_le!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_le.html\n//  a label: `a`,\n//  a debug: `\\\"xx\\\"`,\n//  a.len(): `2`\",\n//  b label: `b`,\n//  b debug: `\\\"x\\\"`,\n//  b.len(): `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_le!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"xx\\\"`,\\n\",\n#     \" a.len(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"x\\\"`\\n\",\n#     \" b.len(): `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_le`](macro@crate::assert_len_le)\n* [`assert_len_le_as_result`](macro@crate::assert_len_le_as_result)\n* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)\n","links":{"macro@crate::assert_len_le_as_result":287,"macro@crate::debug_assert_len_le":288,"macro@crate::assert_len_le":286,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_le {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1167":{"id":1167,"crate_id":0,"name":"debug_assert_status_code_value_ne_x","span":{"filename":"src/assert_status/assert_status_code_value_ne_x.rs","begin":[379,0],"end":[385,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\nThis macro provides the same statements as [`assert_status_code_value_ne`](macro.assert_status_code_value_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)\n","links":{"macro@crate::assert_status_code_value_ne":1043,"macro@crate::debug_assert_status_code_value_ne":1045},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_code_value_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"9":{"id":9,"crate_id":0,"name":"assert_gt_as_result","span":{"filename":"src/assert_gt.rs","begin":[41,0],"end":[68,1]},"visibility":"public","docs":"Assert an expression is greater than another.\n\nPseudocode:<br>\na > b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_gt`](macro@crate::assert_gt)\n* [`assert_gt_as_result`](macro@crate::assert_gt_as_result)\n* [`debug_assert_gt`](macro@crate::debug_assert_gt)\n","links":{"macro@crate::debug_assert_gt":10,"macro@crate::assert_gt_as_result":9,"macro@crate::assert_gt":8},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_gt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"890":{"id":890,"crate_id":0,"name":"assert_command_stderr_string_is_match_as_result","span":{"filename":"src/assert_command/assert_command_stderr_string_is_match.rs","begin":[44,0],"end":[98,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) is match (expr into string)\n\n* If true, return Result `Ok(command ⇒ stderr ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)\n* [`assert_command_stderr_string_is_match_as_result`](macro@crate::assert_command_stderr_string_is_match_as_result)\n* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)\n","links":{"macro@crate::assert_command_stderr_string_is_match_as_result":890,"macro@crate::assert_command_stderr_string_is_match":889,"macro@crate::debug_assert_command_stderr_string_is_match":891},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_string_is_match_as_result {\n    ($command:expr, $matcher:expr $(,)?) => { ... };\n}"}},"613":{"id":613,"crate_id":0,"name":"assert_fn_err_ne_x","span":{"filename":"src/assert_fn_err/assert_fn_err_ne_x.rs","begin":[1,0],"end":[477,1]},"visibility":"public","docs":"Assert a function Err(…) is not equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_ne_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)\n* [`assert_fn_err_ne_x_as_result`](macro@crate::assert_fn_err_ne_x_as_result)\n* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)","links":{"macro@crate::assert_fn_err_ne_x":610,"macro@crate::assert_fn_err_ne_x_as_result":611,"macro@crate::debug_assert_fn_err_ne_x":612},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"336":{"id":336,"crate_id":0,"name":"assert_starts_with","span":{"filename":"src/assert_starts_with/assert_starts_with.rs","begin":[198,0],"end":[211,1]},"visibility":"public","docs":"Assert an expression (such as a string) starts with an expression (such as a string).\n\nPseudocode:<br>\na.starts_with(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\n// String starts with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"al\";\nassert_starts_with!(sequence, subsequence);\n\n// Vector starts with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [1];\nassert_starts_with!(sequence, subsequence);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet sequence = \"alfa\";\nlet subsequence = \"fa\";\nassert_starts_with!(sequence, subsequence);\n// assertion failed: `assert_starts_with!(sequence, subsequence)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_starts_with.html\n//  sequence label: `sequence`,\n//  sequence debug: `\\\"alfa\\\"`,\n//   part label: `subsequence`,\n//   part debug: `\\\"fa\\\"`\n# });\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_starts_with!(sequence, subsequence)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_starts_with.html\\n\",\n#     \"     sequence label: `sequence`,\\n\",\n#     \"     sequence debug: `\\\"alfa\\\"`,\\n\",\n#     \"  subsequence label: `subsequence`,\\n\",\n#     \"  subsequence debug: `\\\"fa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_starts_with`](macro@crate::assert_starts_with)\n* [`assert_starts_with_as_result`](macro@crate::assert_starts_with_as_result)\n* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)\n","links":{"macro@crate::assert_starts_with_as_result":337,"macro@crate::debug_assert_starts_with":338,"macro@crate::assert_starts_with":336,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_starts_with {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };\n}"}},"59":{"id":59,"crate_id":0,"name":"assert_f64_ge","span":{"filename":"src/assert_f64/assert_f64_ge.rs","begin":[317,0],"end":[330,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is greater than or equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333335;\nassert_f64_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_ge!(a, b);\n# });\n// assertion failed: `assert_f64_ge!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f64_ge.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333339`,`\n//     diff: `-0.0000000000000006106226635438361`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f64_ge!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f64_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333339`,\\n\",\n#     \"    diff: `-0.0000000000000006106226635438361`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f64_ge`](macro@crate::assert_f64_ge)\n* [`assert_f64_ge_as_result`](macro@crate::assert_f64_ge_as_result)\n* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)\n","links":{"macro@crate::assert_f64_ge":59,"macro@crate::assert_f64_ge_as_result":60,"macro@crate::debug_assert_f64_ge":61,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_ge {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"940":{"id":940,"crate_id":0,"name":"assert_program_args_stdout_ne_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne_x.rs","begin":[305,0],"end":[318,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'x', b'x'];\nassert_program_args_stdout_ne_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stdout_ne_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stdout_ne_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_ne_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[97, 108, 102, 97]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_ne_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_ne_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[97, 108, 102, 97]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)\n* [`assert_program_args_stdout_ne_x_as_result`](macro@crate::assert_program_args_stdout_ne_x_as_result)\n* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)\n","links":{"macro@crate::debug_assert_program_args_stdout_ne_x":942,"macro@crate::assert_program_args_stdout_ne_x_as_result":941,"macro@crate::assert_program_args_stdout_ne_x":940,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ne_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"663":{"id":663,"crate_id":0,"name":"assert_fn_ok","span":{"filename":"src/assert_fn_ok/mod.rs","begin":[1,0],"end":[60,26]},"visibility":"public","docs":"Assert for comparing functions that return Result::Ok.\n\nThese macros help compare functions that return results that are ok, such as\n`::std::Result::Ok` or similar.\n\nThe macros use these capabilities:\n\n* implements `.is_ok() -> bool`\n\n* implements `.unwrap_ok() -> comparable`\n\nCompare a function Ok() with another function Ok():\n\n* [`assert_fn_ok_eq!(a_function, b_function)`](macro@crate::assert_fn_ok_eq) ≈ a_function().unwrap_err() = b_function().unwrap_err()\n* [`assert_fn_ok_ne!(a_function, b_function)`](macro@crate::assert_fn_ok_ne) ≈ a_function().unwrap_err() ≠ b_function().unwrap_err()\n* [`assert_fn_ok_ge!(a_function, b_function)`](macro@crate::assert_fn_ok_ge) ≈ a_function().unwrap_err() ≥ b_function().unwrap_err()\n* [`assert_fn_ok_gt!(a_function, b_function)`](macro@crate::assert_fn_ok_gt) ≈ a_function().unwrap_err() > b_function().unwrap_err()\n* [`assert_fn_ok_le!(a_function, b_function)`](macro@crate::assert_fn_ok_le) ≈ a_function().unwrap_err() ≤ b_function().unwrap_err()\n* [`assert_fn_ok_lt!(a_function, b_function)`](macro@crate::assert_fn_ok_lt) ≈ a_function().unwrap_err() < b_function().unwrap_err()\n\nCompare a function Ok() with an expression:\n\n* [`assert_fn_ok_eq_x!(function, expr)`](macro@crate::assert_fn_ok_eq_x) ≈ function().unwrap_err() = expr\n* [`assert_fn_ok_ne_x!(function, expr)`](macro@crate::assert_fn_ok_ne_x) ≈ function().unwrap_err() ≠ expr\n* [`assert_fn_ok_ge_x!(function, expr)`](macro@crate::assert_fn_ok_ge_x) ≈ function().unwrap_err() ≥ expr\n* [`assert_fn_ok_gt_x!(function, expr)`](macro@crate::assert_fn_ok_gt_x) ≈ function().unwrap_err() > expr\n* [`assert_fn_ok_le_x!(function, expr)`](macro@crate::assert_fn_ok_le_x) ≈ function().unwrap_err() ≤ expr\n* [`assert_fn_ok_lt_x!(function, expr)`](macro@crate::assert_fn_ok_lt_x) ≈ function().unwrap_err() < expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b: i8 = 1;\nassert_fn_ok_eq!(f, a, f, b);\n```","links":{"macro@crate::assert_fn_ok_gt":623,"macro@crate::assert_fn_ok_eq":615,"macro@crate::assert_fn_ok_le_x":651,"macro@crate::assert_fn_ok_ge":619,"macro@crate::assert_fn_ok_gt_x":647,"macro@crate::assert_fn_ok_ne":635,"macro@crate::assert_fn_ok_eq_x":639,"macro@crate::assert_fn_ok_ge_x":643,"macro@crate::assert_fn_ok_ne_x":659,"macro@crate::assert_fn_ok_le":627,"macro@crate::assert_fn_ok_lt_x":655,"macro@crate::assert_fn_ok_lt":631},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[618,622,626,630,634,638,642,646,650,654,658,662],"is_stripped":false}}},"386":{"id":386,"crate_id":0,"name":"assert_result_ok_ne","span":{"filename":"src/assert_result/assert_result_ok_ne.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nDeprecated. Please rename from `assert_result_ok_ne` into `assert_ok_ne` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"109":{"id":109,"crate_id":0,"name":"assert_abs_diff_ne","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne.rs","begin":[1,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_ne` into `assert_abs_diff_ne_x`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"990":{"id":990,"crate_id":0,"name":"assert_program_args_stderr_le_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)\n* [`assert_program_args_stderr_le_x_as_result`](macro@crate::assert_program_args_stderr_le_x_as_result)\n* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)\n","links":{"macro@crate::assert_program_args_stderr_le_x_as_result":990,"macro@crate::debug_assert_program_args_stderr_le_x":991,"macro@crate::assert_program_args_stderr_le_x":989},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_le_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"713":{"id":713,"crate_id":0,"name":"assert_fs_read_to_string_contains_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_contains.rs","begin":[41,0],"end":[94,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) contains a pattern.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) contains expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)\n* [`assert_fs_read_to_string_contains_as_result`](macro@crate::assert_fs_read_to_string_contains_as_result)\n* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)\n","links":{"macro@crate::debug_assert_fs_read_to_string_contains":714,"macro@crate::assert_fs_read_to_string_contains":712,"macro@crate::assert_fs_read_to_string_contains_as_result":713},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_contains_as_result {\n    ($path:expr, $containee:expr $(,)?) => { ... };\n}"}},"436":{"id":436,"crate_id":0,"name":"assert_ready_eq","span":{"filename":"src/assert_ready/assert_ready_eq.rs","begin":[1,0],"end":[333,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\nlet a: Poll<i8> = Ready(1);\nlet b: Poll<i8> = Ready(1);\nassert_ready_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_ready_eq`](macro@crate::assert_ready_eq)\n* [`assert_ready_eq_as_result`](macro@crate::assert_ready_eq_as_result)\n* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)","links":{"macro@crate::assert_ready_eq":433,"macro@crate::assert_ready_eq_as_result":434,"macro@crate::debug_assert_ready_eq":435},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"159":{"id":159,"crate_id":0,"name":"assert_in_delta","span":{"filename":"src/assert_in/assert_in_delta.rs","begin":[1,0],"end":[384,1]},"visibility":"public","docs":"Assert a number is within delta of another.\n\nPseudocode:<br>\n| a - b | ≤ Δ\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 11;\nlet delta: i8 = 1;\nassert_in_delta!(a, b, delta);\n```\n\n## Comparisons\n\nThis crate provides macro groups that test approximations and nearness:\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq) and\n  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate\n  equality within 1e-6. The macro name and the approximate value are chosen\n  to be similar to the longtime popular rust crate `assert_approx_eq`.\n\n* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error\n  (i.e. delta). This is the magnitude of the difference between the exact\n  value and the approximation.\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative\n  error (i.e. epsilon). This is the absolute error divided by the magnitude\n  of the exact value. This can be used to compare approximations of numbers\n  of wildly differing size.\n\nExamples:\n\n* Approximating the number 100 and 103 has an absolute error (delta) of 3\n  and a relative error (epsilon) of 0.03.\n\n* Approximating the number 1,000,000 and 1,000,003 has an absolute error\n  (delta) of 3, and a relative error (epsilon) of 0.000003.\n\n* For many kinds of applications, the relative error is more important than\n  the absolute error.\n\n## Thanks\n\n* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for\n  creating and maintaining the `assert_approx_eq` crate.\n\n* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for\n  creating and maintaining `assert_in_delta` and `assert_in_epsilon` code.\n\n# Module macros\n\n* [`assert_in_delta`](macro@crate::assert_in_delta)\n* [`assert_in_delta_as_result`](macro@crate::assert_in_delta_as_result)\n* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)","links":{"macro@crate::assert_in_delta":119,"macro@crate::assert_approx_eq":117,"macro@crate::assert_approx_ne":118,"macro@crate::debug_assert_in_delta":158,"macro@crate::assert_in_epsilon":120,"macro@crate::assert_in_delta_as_result":157},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1040":{"id":1040,"crate_id":0,"name":"assert_status_code_value_lt_as_result","span":{"filename":"src/assert_status/assert_status_code_value_lt.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a status code value is less than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)\n* [`assert_status_code_value_lt_as_result`](macro@crate::assert_status_code_value_lt_as_result)\n* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)\n","links":{"macro@crate::assert_status_code_value_lt":1039,"macro@crate::assert_status_code_value_lt_as_result":1040,"macro@crate::debug_assert_status_code_value_lt":1041},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_lt_as_result {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n}"}},"763":{"id":763,"crate_id":0,"name":"assert_io_read_to_string_lt_x_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt_x.rs","begin":[42,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)\n* [`assert_io_read_to_string_lt_x_as_result`](macro@crate::assert_io_read_to_string_lt_x_as_result)\n* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)\n","links":{"macro@crate::assert_io_read_to_string_lt_x":762,"macro@crate::assert_io_read_to_string_lt_x_as_result":763,"macro@crate::debug_assert_io_read_to_string_lt_x":764},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_lt_x_as_result {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"486":{"id":486,"crate_id":0,"name":"assert_iter_lt","span":{"filename":"src/assert_iter/assert_iter_lt.rs","begin":[1,0],"end":[304,1]},"visibility":"public","docs":"Assert an iter is less than another.\n\nPseudocode:<br>\n(collection1 into iter) < (collection2 into iter)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [3, 4];\nassert_iter_lt!(&a, &b);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_lt`](macro@crate::assert_iter_lt)\n* [`assert_iter_lt_as_result`](macro@crate::assert_iter_lt_as_result)\n* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)","links":{"macro@crate::debug_assert_iter_lt":485,"macro@crate::assert_iter_lt":483,"macro@crate::assert_iter_lt_as_result":484},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1090":{"id":1090,"crate_id":0,"name":"debug_assert_abs_diff_le","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le.rs","begin":[39,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nDeprecated. Please rename from `debug_assert_abs_diff_le` into `debug_assert_abs_diff_le_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_abs_diff_le` into `debug_assert_abs_diff_le_x`."},"inner":{"macro":"macro_rules! debug_assert_abs_diff_le {\n    ($($arg:tt)*) => { ... };\n}"}},"209":{"id":209,"crate_id":0,"name":"assert_count_ne","span":{"filename":"src/assert_count/assert_count_ne.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a count is not equal to another.\n\nPseudocode:<br>\na.count() ≠ b.count()\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = \"x\".chars();\nassert_count_ne!(a, b);\n# });\n// assertion failed: `assert_count_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_ne.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `Chars(['x'])`,\n//  b.count(): `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Chars(['x'])`\\n\",\n#     \" b.count(): `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_ne`](macro@crate::assert_count_ne)\n* [`assert_count_ne_as_result`](macro@crate::assert_count_ne_as_result)\n* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_count_ne":211,"macro@crate::assert_count_ne":209,"macro@crate::assert_count_ne_as_result":210},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"813":{"id":813,"crate_id":0,"name":"assert_command_stdout_gt_x_as_result","span":{"filename":"src/assert_command/assert_command_stdout_gt_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stdout string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)\n* [`assert_command_stdout_gt_x_as_result`](macro@crate::assert_command_stdout_gt_x_as_result)\n* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)\n","links":{"macro@crate::assert_command_stdout_gt_x":812,"macro@crate::assert_command_stdout_gt_x_as_result":813,"macro@crate::debug_assert_command_stdout_gt_x":814},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_gt_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"536":{"id":536,"crate_id":0,"name":"assert_fn_lt","span":{"filename":"src/assert_fn/assert_fn_lt.rs","begin":[1,0],"end":[530,1]},"visibility":"public","docs":"Assert a function output is less than another.\n\nPseudocode:<br>\na_function(a) < b_function(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_lt!(i8::abs, a, i8::abs, b);\n```\n\n# Module macros\n\n* [`assert_fn_lt`](macro@crate::assert_fn_lt)\n* [`assert_fn_lt_as_result`](macro@crate::assert_fn_lt_as_result)\n* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)","links":{"macro@crate::debug_assert_fn_lt":535,"macro@crate::assert_fn_lt":533,"macro@crate::assert_fn_lt_as_result":534},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"259":{"id":259,"crate_id":0,"name":"assert_is_empty","span":{"filename":"src/assert_is_empty/assert_is_empty.rs","begin":[1,0],"end":[250,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is empty.\n\nPseudocode:<br>\na.is_empty()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"\";\nassert_is_empty!(a);\n```\n\n# Module macros\n\n* [`assert_is_empty`](macro@crate::assert_is_empty)\n* [`assert_is_empty_as_result`](macro@crate::assert_is_empty_as_result)\n* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)","links":{"macro@crate::assert_is_empty":256,"macro@crate::assert_is_empty_as_result":257,"macro@crate::debug_assert_is_empty":258},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1140":{"id":1140,"crate_id":0,"name":"debug_assert_command_stdout_ne_x","span":{"filename":"src/assert_command/assert_command_stdout_ne_x.rs","begin":[369,0],"end":[375,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stdout_ne_x`](macro.assert_command_stdout_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)\n* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)\n* [`debug_assert_command_stdout_ne_x`](macro@crate::debug_assert_command_stdout_ne_x)\n","links":{"macro@crate::debug_assert_command_stdout_ne_x":1140,"macro@crate::assert_command_stdout_ne_x":894},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"863":{"id":863,"crate_id":0,"name":"assert_command_stderr_ge_x","span":{"filename":"src/assert_command/assert_command_stderr_ge_x.rs","begin":[270,0],"end":[283,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stderr_ge_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_ge_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stderr_ge_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_ge_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[122, 122]`,\n//     expr value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_ge_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_ge_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[122, 122]`,\\n\",\n#     \"    expr value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)\n* [`assert_command_stderr_ge_x_as_result`](macro@crate::assert_command_stderr_ge_x_as_result)\n* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)\n","links":{"macro@crate::assert_command_stderr_ge_x":863,"macro@crate::assert_command_stderr_ge_x_as_result":864,"macro@crate::debug_assert_command_stderr_ge_x":865,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ge_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"586":{"id":586,"crate_id":0,"name":"assert_fn_err_ne","span":{"filename":"src/assert_fn_err/assert_fn_err_ne.rs","begin":[321,0],"end":[354,1]},"visibility":"public","docs":"Assert a function error is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_ne!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 10;\nassert_fn_err_ne!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_err_ne!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_ne.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `10`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"10 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_ne!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_ne.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `10`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"10 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)\n* [`assert_fn_err_ne_as_result`](macro@crate::assert_fn_err_ne_as_result)\n* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)\n","links":{"macro@crate::assert_fn_err_ne_as_result":587,"macro@crate::debug_assert_fn_err_ne":588,"macro@crate::assert_fn_err_ne":586,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ne {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"309":{"id":309,"crate_id":0,"name":"assert_len_gt_x","span":{"filename":"src/assert_len/assert_len_gt_x.rs","begin":[1,0],"end":[335,1]},"visibility":"public","docs":"Assert a length is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\";\nlet b = 1;\nassert_len_gt_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)\n* [`assert_len_gt_x_as_result`](macro@crate::assert_len_gt_x_as_result)\n* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)","links":{"macro@crate::assert_len_gt_x":306,"macro@crate::assert_len_gt_x_as_result":307,"macro@crate::debug_assert_len_gt_x":308},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"913":{"id":913,"crate_id":0,"name":"assert_program_args_stdout_lt_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt.rs","begin":[44,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* If true, return Result `Err` with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)\n* [`assert_program_args_stdout_lt_as_result`](macro@crate::assert_program_args_stdout_lt_as_result)\n* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)\n","links":{"macro@crate::assert_program_args_stdout_lt_as_result":913,"macro@crate::debug_assert_program_args_stdout_lt":914,"macro@crate::assert_program_args_stdout_lt":912},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_lt_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"32":{"id":32,"crate_id":0,"name":"debug_assert_f32_eq","span":{"filename":"src/assert_f32/assert_f32_eq.rs","begin":[362,0],"end":[368,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na = b\n\n\nThis macro provides the same statements as [`assert_f32_eq`](macro.assert_f32_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f32_eq`](macro@crate::assert_f32_eq)\n* [`assert_f32_eq`](macro@crate::assert_f32_eq)\n* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)\n","links":{"macro@crate::assert_f32_eq":30,"macro@crate::debug_assert_f32_eq":32},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f32_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"636":{"id":636,"crate_id":0,"name":"assert_fn_ok_ne_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)\n* [`assert_fn_ok_ne_as_result`](macro@crate::assert_fn_ok_ne_as_result)\n* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)\n","links":{"macro@crate::debug_assert_fn_ok_ne":637,"macro@crate::assert_fn_ok_ne":635,"macro@crate::assert_fn_ok_ne_as_result":636},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ne_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"359":{"id":359,"crate_id":0,"name":"debug_assert_err_ne_x","span":{"filename":"src/assert_err/assert_err_ne_x.rs","begin":[384,0],"end":[390,1]},"visibility":"public","docs":"Assert an expression is Err and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) ≠ b\n\nThis macro provides the same statements as [`assert_err_ne_x`](macro.assert_err_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)\n* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)\n* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)\n","links":{"macro@crate::assert_err_ne_x":357,"macro@crate::debug_assert_err_ne_x":359},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_err_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"963":{"id":963,"crate_id":0,"name":"assert_program_args_stderr_gt_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt.rs","begin":[43,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)\n* [`assert_program_args_stderr_gt_as_result`](macro@crate::assert_program_args_stderr_gt_as_result)\n* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)\n","links":{"macro@crate::assert_program_args_stderr_gt":962,"macro@crate::debug_assert_program_args_stderr_gt":964,"macro@crate::assert_program_args_stderr_gt_as_result":963},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_gt_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"82":{"id":82,"crate_id":0,"name":"debug_assert_abs_diff_eq_x","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq_x.rs","begin":[460,0],"end":[466,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nPseudocode:<br>\n|Δ| = c\n\nThis macro provides the same statements as [`assert_abs_diff_eq_x`](macro.assert_abs_diff_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-x debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)\n* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)\n* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)\n","links":{"macro@crate::assert_abs_diff_eq_x":80,"macro@crate::debug_assert_abs_diff_eq_x":82},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_abs_diff_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"686":{"id":686,"crate_id":0,"name":"debug_assert_fs_read_to_string_ne","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)\n\nThis macro provides the same statements as [`assert_fs_read_to_string_ne`](macro.assert_fs_read_to_string_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)\n* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)\n* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)\n","links":{"macro@crate::debug_assert_fs_read_to_string_ne":686,"macro@crate::assert_fs_read_to_string_ne":684},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"409":{"id":409,"crate_id":0,"name":"assert_some_ne","span":{"filename":"src/assert_some/assert_some_ne.rs","begin":[1,0],"end":[397,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::Some(1);\nlet b: Option<i8> = Option::Some(2);\nassert_some_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_some_ne`](macro@crate::assert_some_ne)\n* [`assert_some_ne_as_result`](macro@crate::assert_some_ne_as_result)\n* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)","links":{"macro@crate::debug_assert_some_ne":408,"macro@crate::assert_some_ne_as_result":407,"macro@crate::assert_some_ne":406},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"132":{"id":132,"crate_id":0,"name":"assert_diff_ge_x","span":{"filename":"src/assert_diff/assert_diff_ge_x.rs","begin":[332,0],"end":[345,1]},"visibility":"public","docs":"Assert a difference is greater than or equal to an expression.\n\nPseudocode:<br>\nΔ ≥ x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 2;\nassert_diff_ge_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 4;\nassert_diff_ge_x!(a, b, x);\n# });\n// assertion failed: `assert_diff_ge_x!(a, b, x)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_diff_ge_x.html\n//        a label: `a`,\n//        a debug: `10`,\n//        b label: `b`,\n//        b debug: `13`,\n//        x label: `x`,\n//        x debug: `4`,\n//              Δ: `3`,\n//          Δ ≥ x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_diff_ge_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_diff_ge_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `4`,\\n\",\n#     \"       Δ: `3`,\\n\",\n#     \"   Δ ≥ x: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)\n* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)\n* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)\n","links":{"macro@crate::assert_diff_ge_x_as_result":133,"macro@crate::debug_assert_diff_ge_x":134,"macro@crate::assert_diff_ge_x":132,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_ge_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"1013":{"id":1013,"crate_id":0,"name":"debug_assert_status_success","span":{"filename":"src/assert_status/assert_status_success.rs","begin":[268,0],"end":[274,1]},"visibility":"public","docs":"Assert a status is a success.\n\nPseudocode:<br>\na ⇒ status ⇒ success = true\n\nThis macro provides the same statements as [`assert_status_success`](macro.assert_status_success.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a \"bin/exit-with-arg\" in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_status_success`](macro@crate::assert_status_success)\n* [`assert_status_success`](macro@crate::assert_status_success)\n* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)\n","links":{"macro@crate::assert_status_success":1011,"macro@crate::debug_assert_status_success":1013},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_status_success {\n    ($($arg:tt)*) => { ... };\n}"}},"736":{"id":736,"crate_id":0,"name":"debug_assert_io_read_to_string_le","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le.rs","begin":[366,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_le`](macro.assert_io_read_to_string_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)\n* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)\n* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)\n","links":{"macro@crate::assert_io_read_to_string_le":734,"macro@crate::debug_assert_io_read_to_string_le":736},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_le {\n    ($($arg:tt)*) => { ... };\n}"}},"459":{"id":459,"crate_id":0,"name":"assert_bag_subbag_as_result","span":{"filename":"src/assert_bag/assert_bag_subbag.rs","begin":[43,0],"end":[80,1]},"visibility":"public","docs":"Assert a bag is a subbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)\n\n* If true, return Result `Ok((a, b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)\n* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)\n* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)\n","links":{"macro@crate::assert_bag_subbag_as_result":459,"macro@crate::debug_assert_bag_subbag":460,"macro@crate::assert_bag_subbag":458},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_subbag_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"182":{"id":182,"crate_id":0,"name":"debug_assert_contains","span":{"filename":"src/assert_contains/assert_contains.rs","begin":[965,0],"end":[971,1]},"visibility":"public","docs":"Assert a container is a match for an expression.\n\nPseudocode:<br>\na.contains(b)\n\nThis macro provides the same statements as [`assert_contains`](macro.assert_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_contains`](macro@crate::assert_contains)\n* [`assert_contains`](macro@crate::assert_contains)\n* [`debug_assert_contains`](macro@crate::debug_assert_contains)\n","links":{"macro@crate::assert_contains":180,"macro@crate::debug_assert_contains":182},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"1063":{"id":1063,"crate_id":0,"name":"assert_status_code_value_lt_x","span":{"filename":"src/assert_status/assert_status_code_value_lt_x.rs","begin":[252,0],"end":[265,1]},"visibility":"public","docs":"Assert a status code value is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_lt_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet b = 1;\nassert_status_code_value_lt_x!(a, b);\n# });\n// assertion failed: `assert_status_code_value_lt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_lt_x.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `2`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_lt_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_lt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`,\\n\",\n#     \"  a code: `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)\n* [`assert_status_code_value_lt_x_as_result`](macro@crate::assert_status_code_value_lt_x_as_result)\n* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_status_code_value_lt_x":1065,"macro@crate::assert_status_code_value_lt_x_as_result":1064,"macro@crate::assert_status_code_value_lt_x":1063},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_lt_x {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"786":{"id":786,"crate_id":0,"name":"debug_assert_command_stdout_ge","span":{"filename":"src/assert_command/assert_command_stdout_ge.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to another.\n\nThis macro provides the same statements as [`assert_command_stdout_ge {`](macro.assert_command_stdout_ge {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_ge {`](macro@crate::assert_command_stdout_ge {)\n* [`assert_command_stdout_ge {`](macro@crate::assert_command_stdout_ge {)\n* [`debug_assert_command_stdout_ge {`](macro@crate::debug_assert_command_stdout_ge {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"509":{"id":509,"crate_id":0,"name":"assert_set_subset_as_result","span":{"filename":"src/assert_set/assert_set_subset.rs","begin":[43,0],"end":[76,1]},"visibility":"public","docs":"Assert a set is a subset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)\n\n* If true, return Result `Ok((a_set, b_set))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_set_subset`](macro@crate::assert_set_subset)\n* [`assert_set_subset_as_result`](macro@crate::assert_set_subset_as_result)\n* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)\n","links":{"macro@crate::debug_assert_set_subset":510,"macro@crate::assert_set_subset":508,"macro@crate::assert_set_subset_as_result":509},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_subset_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"232":{"id":232,"crate_id":0,"name":"assert_count_lt_x","span":{"filename":"src/assert_count/assert_count_lt_x.rs","begin":[1,0],"end":[335,1]},"visibility":"public","docs":"Assert a count is less than an expression.\n\nPseudocode:<br>\na.count() < b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_lt_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)\n* [`assert_count_lt_x_as_result`](macro@crate::assert_count_lt_x_as_result)\n* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)","links":{"macro@crate::assert_count_lt_x":229,"macro@crate::assert_count_lt_x_as_result":230,"macro@crate::debug_assert_count_lt_x":231},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1113":{"id":1113,"crate_id":0,"name":"assert_option_some_eq_as_result","span":{"filename":"src/assert_option/assert_option_some_eq.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nDeprecated. Please rename from `assert_option_some_eq_as_result` into `assert_some_eq_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_some_eq_as_result` into `assert_some_eq_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_some_eq_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"836":{"id":836,"crate_id":0,"name":"assert_command_stderr_eq_as_result","span":{"filename":"src/assert_command/assert_command_stderr_eq.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string is equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_eq`](macro@crate::assert_command_stderr_eq)\n* [`assert_command_stderr_eq_as_result`](macro@crate::assert_command_stderr_eq_as_result)\n* [`debug_assert_command_stderr_eq`](macro@crate::debug_assert_command_stderr_eq)\n","links":{"macro@crate::assert_command_stderr_eq":835,"macro@crate::assert_command_stderr_eq_as_result":836,"macro@crate::debug_assert_command_stderr_eq":837},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_eq_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"559":{"id":559,"crate_id":0,"name":"debug_assert_fn_lt_x","span":{"filename":"src/assert_fn/assert_fn_lt_x.rs","begin":[506,0],"end":[512,1]},"visibility":"public","docs":"Assert a function output is less than an expression.\n\nPseudocode:<br>\na_function(a) < b\n\nThis macro provides the same statements as [`assert_fn_lt_x`](macro.assert_fn_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)\n* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)\n* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)\n","links":{"macro@crate::debug_assert_fn_lt_x":559,"macro@crate::assert_fn_lt_x":557},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"282":{"id":282,"crate_id":0,"name":"assert_len_gt","span":{"filename":"src/assert_len/assert_len_gt.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a length is greater than another.\n\nPseudocode:<br>\na.len() > b.len()\n\n* If true, return `(a.len(), b.len())`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\";\nlet b = \"x\";\nassert_len_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_gt!(a, b);\n# });\n// assertion failed: `assert_len_gt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_gt.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `\\\"xx\\\"`,\n//  b.len(): `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_gt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"xx\\\"`\\n\",\n#     \" b.len(): `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_gt`](macro@crate::assert_len_gt)\n* [`assert_len_gt_as_result`](macro@crate::assert_len_gt_as_result)\n* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)\n","links":{"macro@crate::assert_len_gt":282,"macro@crate::assert_len_gt_as_result":283,"macro@crate::debug_assert_len_gt":284,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_gt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1163":{"id":1163,"crate_id":0,"name":"debug_assert_program_args_stderr_contains","span":{"filename":"src/assert_program_args/assert_program_args_stderr_contains.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nDeprecated. Please rename from `debug_assert_program_args_stderr_contains` to `debug_assert_program_args_stderr_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_program_args_stderr_contains` to `debug_assert_program_args_stderr_string_contains`."},"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"886":{"id":886,"crate_id":0,"name":"assert_command_stderr_string_contains_as_result","span":{"filename":"src/assert_command/assert_command_stderr_string_contains.rs","begin":[43,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) contains (expr into string)\n\n* If true, return Result `Ok(command ⇒ stderr ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)\n* [`assert_command_stderr_string_contains_as_result`](macro@crate::assert_command_stderr_string_contains_as_result)\n* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)\n","links":{"macro@crate::assert_command_stderr_string_contains":885,"macro@crate::debug_assert_command_stderr_string_contains":887,"macro@crate::assert_command_stderr_string_contains_as_result":886},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_string_contains_as_result {\n    ($command:expr, $containee:expr $(,)?) => { ... };\n}"}},"5":{"id":5,"crate_id":0,"name":"assert_ge_as_result","span":{"filename":"src/assert_ge.rs","begin":[41,0],"end":[68,1]},"visibility":"public","docs":"Assert an expression is greater than or equal to another.\n\nPseudocode:<br>\na ≥ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_ge`](macro@crate::assert_ge)\n* [`assert_ge_as_result`](macro@crate::assert_ge_as_result)\n* [`debug_assert_ge`](macro@crate::debug_assert_ge)\n","links":{"macro@crate::assert_ge_as_result":5,"macro@crate::debug_assert_ge":6,"macro@crate::assert_ge":4},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ge_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"609":{"id":609,"crate_id":0,"name":"assert_fn_err_lt_x","span":{"filename":"src/assert_fn_err/assert_fn_err_lt_x.rs","begin":[1,0],"end":[573,1]},"visibility":"public","docs":"Assert a function Err(…) is less than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) < expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_lt_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)\n* [`assert_fn_err_lt_x_as_result`](macro@crate::assert_fn_err_lt_x_as_result)\n* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)","links":{"macro@crate::assert_fn_err_lt_x":606,"macro@crate::debug_assert_fn_err_lt_x":608,"macro@crate::assert_fn_err_lt_x_as_result":607},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"332":{"id":332,"crate_id":0,"name":"assert_not_starts_with","span":{"filename":"src/assert_starts_with/assert_not_starts_with.rs","begin":[198,0],"end":[211,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not start with an expression (such as a string).\n\nPseudocode:<br>\n¬ a.starts_with(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\n// String starts with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"z\";\nassert_not_starts_with!(sequence, subsequence);\n\n// Vector starts with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [3];\nassert_not_starts_with!(sequence, subsequence);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet sequence = \"alfa\";\nlet subsequence = \"al\";\nassert_not_starts_with!(sequence, subsequence);\n# });\n// assertion failed: `assert_not_starts_with!(sequence, subsequence)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_starts_with.html\n//  sequence label: `sequence`,\n//  sequence debug: `\\\"alfa\\\"`,\n//   part label: `subsequence`,\n//   part debug: `\\\"al\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_starts_with!(sequence, subsequence)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_starts_with.html\\n\",\n#     \"     sequence label: `sequence`,\\n\",\n#     \"     sequence debug: `\\\"alfa\\\"`,\\n\",\n#     \"  subsequence label: `subsequence`,\\n\",\n#     \"  subsequence debug: `\\\"al\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)\n* [`assert_not_starts_with_as_result`](macro@crate::assert_not_starts_with_as_result)\n* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)\n","links":{"macro@crate::debug_assert_not_starts_with":334,"macro@crate::assert_not_starts_with_as_result":333,"macro@crate::assert_not_starts_with":332,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_starts_with {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };\n}"}},"936":{"id":936,"crate_id":0,"name":"assert_program_args_stdout_lt_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt_x.rs","begin":[274,0],"end":[287,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_lt_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stdout_lt_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stdout_lt_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_lt_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[97, 97]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_lt_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_lt_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[97, 97]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)\n* [`assert_program_args_stdout_lt_x_as_result`](macro@crate::assert_program_args_stdout_lt_x_as_result)\n* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)\n","links":{"macro@crate::assert_program_args_stdout_lt_x_as_result":937,"macro@crate::assert_program_args_stdout_lt_x":936,"macro@crate::debug_assert_program_args_stdout_lt_x":938,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_lt_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"55":{"id":55,"crate_id":0,"name":"assert_f64_eq","span":{"filename":"src/assert_f64/assert_f64_eq.rs","begin":[297,0],"end":[310,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333335;\nassert_f64_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_eq!(a, b);\n# });\n// assertion failed: `assert_f64_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_f64_eq.html\n//  a label: `a`,\n//  a debug: `0.3333333333333333`,\n//  b label: `b`,\n//  b debug: `0.3333333333333339`,`\n//     diff: `-0.0000000000000006106226635438361`,\n//        ε: `0.0000000000000002220446049250313`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_f64_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_f64_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `0.3333333333333333`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `0.3333333333333339`,\\n\",\n#     \"    diff: `-0.0000000000000006106226635438361`,\\n\",\n#     \"       ε: `0.0000000000000002220446049250313`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_f64_eq`](macro@crate::assert_f64_eq)\n* [`assert_f64_eq_as_result`](macro@crate::assert_f64_eq_as_result)\n* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)\n","links":{"macro@crate::debug_assert_f64_eq":57,"macro@crate::assert_f64_eq":55,"macro@crate::assert_f64_eq_as_result":56,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f64_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"659":{"id":659,"crate_id":0,"name":"assert_fn_ok_ne_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne_x.rs","begin":[306,0],"end":[339,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_ne_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b = String::from(\"1\");\nassert_fn_ok_ne_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_ok_ne_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_ne_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"1\\\"`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_ne_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_ne_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"1\\\"`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)\n* [`assert_fn_ok_ne_x_as_result`](macro@crate::assert_fn_ok_ne_x_as_result)\n* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)\n","links":{"macro@crate::assert_fn_ok_ne_x_as_result":660,"macro@crate::assert_fn_ok_ne_x":659,"macro@crate::debug_assert_fn_ok_ne_x":661,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ne_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"382":{"id":382,"crate_id":0,"name":"assert_ok","span":{"filename":"src/assert_ok/mod.rs","begin":[1,0],"end":[38,23]},"visibility":"public","docs":"Assert for Ok(…) items.\n\nThese macros help compare Ok(…) items, such as `::std::Result::Ok` or similar.\n\nAssert expression is Ok:\n\n* [`assert_ok!(a)`](macro@crate::assert_ok)\n  ≈ a is Ok.\n\nCompare Ok(…) to another Ok(…):\n\n* [`assert_ok_eq!(a, b)`](macro@crate::assert_ok_eq) ≈ (a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)\n* [`assert_ok_ne!(a, b)`](macro@crate::assert_ok_ne) ≈ (a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)\n\nCompare Ok(…) to an expression:\n\n* [`assert_ok_eq_x!(a, expr)`](macro@crate::assert_ok_eq_x) ≈ (a ⇒ Ok(a1) ⇒ a1) = expr\n* [`assert_ok_ne_x!(a, expr)`](macro@crate::assert_ok_ne_x) ≈ (a ⇒ Ok(a1) ⇒ a1) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Ok(1);\nassert_ok!(a);\n```","links":{"macro@crate::assert_ok_ne_x":378,"macro@crate::assert_ok_eq":366,"macro@crate::assert_ok_eq_x":374,"macro@crate::assert_ok":362,"macro@crate::assert_ok_ne":370},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[365,369,373,377,381],"is_stripped":false}}},"986":{"id":986,"crate_id":0,"name":"assert_program_args_stderr_gt_x_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt_x.rs","begin":[42,0],"end":[106,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)\n* [`assert_program_args_stderr_gt_x_as_result`](macro@crate::assert_program_args_stderr_gt_x_as_result)\n* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_gt_x":987,"macro@crate::assert_program_args_stderr_gt_x":985,"macro@crate::assert_program_args_stderr_gt_x_as_result":986},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_gt_x_as_result {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"105":{"id":105,"crate_id":0,"name":"assert_abs_diff_ge","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge.rs","begin":[1,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_ge` into `assert_abs_diff_ge_x`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"709":{"id":709,"crate_id":0,"name":"assert_fs_read_to_string_ne_x_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne_x.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≠ expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)\n* [`assert_fs_read_to_string_ne_x_as_result`](macro@crate::assert_fs_read_to_string_ne_x_as_result)\n* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)\n","links":{"macro@crate::debug_assert_fs_read_to_string_ne_x":710,"macro@crate::assert_fs_read_to_string_ne_x":708,"macro@crate::assert_fs_read_to_string_ne_x_as_result":709},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ne_x_as_result {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"432":{"id":432,"crate_id":0,"name":"assert_ready","span":{"filename":"src/assert_ready/assert_ready.rs","begin":[1,0],"end":[234,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nPseudocode:<br>\na is Ready\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::task::Poll;\nuse std::task::Poll::*;\n\nlet a: Poll<i8> = Ready(1);\nassert_ready!(a);\n```\n\n# Module macros\n\n* [`assert_ready`](macro@crate::assert_ready)\n* [`assert_ready_as_result`](macro@crate::assert_ready_as_result)\n* [`debug_assert_ready`](macro@crate::debug_assert_ready)","links":{"macro@crate::assert_ready":429,"macro@crate::assert_ready_as_result":430,"macro@crate::debug_assert_ready":431},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1036":{"id":1036,"crate_id":0,"name":"assert_status_code_value_le_as_result","span":{"filename":"src/assert_status/assert_status_code_value_le.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)\n* [`assert_status_code_value_le_as_result`](macro@crate::assert_status_code_value_le_as_result)\n* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)\n","links":{"macro@crate::assert_status_code_value_le_as_result":1036,"macro@crate::debug_assert_status_code_value_le":1037,"macro@crate::assert_status_code_value_le":1035},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_le_as_result {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n}"}},"155":{"id":155,"crate_id":0,"name":"debug_assert_in","span":{"filename":"src/assert_in/assert_in.rs","begin":[275,0],"end":[281,1]},"visibility":"public","docs":"Assert an item is in a container.\n\nPseudocode:<br>\na is in container\n\nThis macro provides the same statements as [`assert_in`](macro.assert_in.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_in`](macro@crate::assert_in)\n* [`assert_in`](macro@crate::assert_in)\n* [`debug_assert_in`](macro@crate::debug_assert_in)\n","links":{"macro@crate::debug_assert_in":155,"macro@crate::assert_in":153},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_in {\n    ($($arg:tt)*) => { ... };\n}"}},"759":{"id":759,"crate_id":0,"name":"assert_io_read_to_string_le_x_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le_x.rs","begin":[42,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)\n* [`assert_io_read_to_string_le_x_as_result`](macro@crate::assert_io_read_to_string_le_x_as_result)\n* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)\n","links":{"macro@crate::assert_io_read_to_string_le_x":758,"macro@crate::debug_assert_io_read_to_string_le_x":760,"macro@crate::assert_io_read_to_string_le_x_as_result":759},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_le_x_as_result {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"482":{"id":482,"crate_id":0,"name":"assert_iter_le","span":{"filename":"src/assert_iter/assert_iter_le.rs","begin":[1,0],"end":[279,1]},"visibility":"public","docs":"Assert an iter is less than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≤ (collection2 into iter)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [1, 2];\nassert_iter_le!(&a, &b);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_le`](macro@crate::assert_iter_le)\n* [`assert_iter_le_as_result`](macro@crate::assert_iter_le_as_result)\n* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)","links":{"macro@crate::assert_iter_le_as_result":480,"macro@crate::assert_iter_le":479,"macro@crate::debug_assert_iter_le":481},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1086":{"id":1086,"crate_id":0,"name":"debug_assert_abs_diff_ge","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge.rs","begin":[39,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nDeprecated. Please rename from `debug_assert_abs_diff_ge` into `debug_assert_abs_diff_ge_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_abs_diff_ge` into `debug_assert_abs_diff_ge_x`."},"inner":{"macro":"macro_rules! debug_assert_abs_diff_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"205":{"id":205,"crate_id":0,"name":"assert_count_lt","span":{"filename":"src/assert_count/assert_count_lt.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a count is less than another.\n\nPseudocode:<br>\na.count() < b.count()\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\".chars();\nlet b = \"x\".chars();\nassert_count_lt!(a, b);\n# });\n// assertion failed: `assert_count_lt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_lt.html\n//  a label: `a`,\n//  a debug: `Chars(['x', 'x'])`,\n//  a.count(): `2`\",\n//  b label: `b`,\n//  b debug: `Chars(['x'])`,\n//  b.count(): `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_lt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x', 'x'])`,\\n\",\n#     \" a.count(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Chars(['x'])`\\n\",\n#     \" b.count(): `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_lt`](macro@crate::assert_count_lt)\n* [`assert_count_lt_as_result`](macro@crate::assert_count_lt_as_result)\n* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)\n","links":{"macro@crate::assert_count_lt":205,"macro@crate::assert_count_lt_as_result":206,"macro@crate::debug_assert_count_lt":207,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_lt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"809":{"id":809,"crate_id":0,"name":"assert_command_stdout_ge_x_as_result","span":{"filename":"src/assert_command/assert_command_stdout_ge_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)\n* [`assert_command_stdout_ge_x_as_result`](macro@crate::assert_command_stdout_ge_x_as_result)\n* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)\n","links":{"macro@crate::assert_command_stdout_ge_x_as_result":809,"macro@crate::debug_assert_command_stdout_ge_x":810,"macro@crate::assert_command_stdout_ge_x":808},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ge_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"532":{"id":532,"crate_id":0,"name":"assert_fn_le","span":{"filename":"src/assert_fn/assert_fn_le.rs","begin":[1,0],"end":[474,1]},"visibility":"public","docs":"Assert a function output is less than or equal to another.\n\nPseudocode:<br>\na_function(a) ≤ b_function(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 1;\nlet b: i8 = -2;\nassert_fn_le!(i8::abs, a, i8::abs, b);\n```\n\n# Module macros\n\n* [`assert_fn_le`](macro@crate::assert_fn_le)\n* [`assert_fn_le_as_result`](macro@crate::assert_fn_le_as_result)\n* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)","links":{"macro@crate::debug_assert_fn_le":531,"macro@crate::assert_fn_le_as_result":530,"macro@crate::assert_fn_le":529},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1136":{"id":1136,"crate_id":0,"name":"assert_io_read_to_string_matches_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_matches.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert a ::std::io::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `assert_io_read_to_string_matches_as_result` into `assert_io_read_to_string_is_match_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_io_read_to_string_matches_as_result` into `assert_io_read_to_string_is_match_as_result`."},"inner":{"macro":"macro_rules! assert_io_read_to_string_matches_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"255":{"id":255,"crate_id":0,"name":"assert_ends_with","span":{"filename":"src/assert_ends_with/mod.rs","begin":[1,0],"end":[27,29]},"visibility":"public","docs":"Assert for a sequence that may end with a part.\n\nThese macros help with comparison of a sequence (such as a string, array, range)\nand a part (such as a string substring, an array element, a range value).\n\n* [`assert_ends_with(sequence, subsequence)`](macro@crate::assert_ends_with) ≈ container.contains(containee)\n\n* [`assert_not_ends_with!(sequence, subsequence)`](macro@crate::assert_not_ends_with) ≈ !container.contains(containee)\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String ends with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"fa\";\nassert_ends_with!(sequence, subsequence);\n\n// Vector ends with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [3];\nassert_ends_with!(sequence, subsequence);\n```","links":{"macro@crate::assert_ends_with":247,"macro@crate::assert_not_ends_with":251},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[250,254],"is_stripped":false}}},"859":{"id":859,"crate_id":0,"name":"assert_command_stderr_eq_x","span":{"filename":"src/assert_command/assert_command_stderr_eq_x.rs","begin":[248,0],"end":[261,1]},"visibility":"public","docs":"Assert a command stderr string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_command_stderr_eq_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_eq_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stderr_eq_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_eq_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[122, 122]`,\n//     expr value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_eq_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_eq_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[122, 122]`,\\n\",\n#     \"    expr value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)\n* [`assert_command_stderr_eq_x_as_result`](macro@crate::assert_command_stderr_eq_x_as_result)\n* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)\n","links":{"macro@crate::assert_command_stderr_eq_x_as_result":860,"macro@crate::debug_assert_command_stderr_eq_x":861,"macro@crate::assert_command_stderr_eq_x":859,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_eq_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"582":{"id":582,"crate_id":0,"name":"assert_fn_err_lt","span":{"filename":"src/assert_fn_err/assert_fn_err_lt.rs","begin":[353,0],"end":[386,1]},"visibility":"public","docs":"Assert a function error is less than another.\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_lt!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 20;\nlet b: i8 = 10;\nassert_fn_err_lt!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_err_lt!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_lt.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `20`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `10`,\n//                 a: `\\\"20 is out of range\\\"`,\n//                 b: `\\\"10 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_lt!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_lt.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `20`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `10`,\\n\",\n#     \"                a: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"10 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)\n* [`assert_fn_err_lt_as_result`](macro@crate::assert_fn_err_lt_as_result)\n* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)\n","links":{"macro@crate::assert_fn_err_lt":582,"macro@crate::assert_fn_err_lt_as_result":583,"macro@crate::debug_assert_fn_err_lt":584,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_lt {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"305":{"id":305,"crate_id":0,"name":"assert_len_ge_x","span":{"filename":"src/assert_len/assert_len_ge_x.rs","begin":[1,0],"end":[338,1]},"visibility":"public","docs":"Assert a length is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\";\nlet b = 1;\nassert_len_ge_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)\n* [`assert_len_ge_x_as_result`](macro@crate::assert_len_ge_x_as_result)\n* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)","links":{"macro@crate::assert_len_ge_x":302,"macro@crate::debug_assert_len_ge_x":304,"macro@crate::assert_len_ge_x_as_result":303},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"28":{"id":28,"crate_id":0,"name":"debug_assert_eq_f64","span":{"filename":"src/assert_eq_f64.rs","begin":[367,0],"end":[373,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\nThis macro provides the same statements as [`assert_eq_f64`](macro.assert_eq_f64.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_eq_f64`](macro@crate::assert_eq_f64)\n* [`assert_eq_f64`](macro@crate::assert_eq_f64)\n* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)\n","links":{"macro@crate::assert_eq_f64":26,"macro@crate::debug_assert_eq_f64":28},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_eq_f64 {\n    ($($arg:tt)*) => { ... };\n}"}},"909":{"id":909,"crate_id":0,"name":"assert_program_args_stdout_le_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le.rs","begin":[44,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* If true, return Result `Err` with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)\n* [`assert_program_args_stdout_le_as_result`](macro@crate::assert_program_args_stdout_le_as_result)\n* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)\n","links":{"macro@crate::assert_program_args_stdout_le_as_result":909,"macro@crate::debug_assert_program_args_stdout_le":910,"macro@crate::assert_program_args_stdout_le":908},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_le_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"632":{"id":632,"crate_id":0,"name":"assert_fn_ok_lt_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)\n* [`assert_fn_ok_lt_as_result`](macro@crate::assert_fn_ok_lt_as_result)\n* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)\n","links":{"macro@crate::assert_fn_ok_lt_as_result":632,"macro@crate::debug_assert_fn_ok_lt":633,"macro@crate::assert_fn_ok_lt":631},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_lt_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"355":{"id":355,"crate_id":0,"name":"debug_assert_err_eq_x","span":{"filename":"src/assert_err/assert_err_eq_x.rs","begin":[343,0],"end":[349,1]},"visibility":"public","docs":"Assert an expression is Err and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = b\n\nThis macro provides the same statements as [`assert_err_eq_x`](macro.assert_err_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)\n* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)\n* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)\n","links":{"macro@crate::assert_err_eq_x":353,"macro@crate::debug_assert_err_eq_x":355},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_err_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"78":{"id":78,"crate_id":0,"name":"assert_f64_ne","span":{"filename":"src/assert_f64/assert_f64_ne.rs","begin":[1,0],"end":[347,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is not equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_f64_ne`](macro@crate::assert_f64_ne)\n* [`assert_f64_ne_as_result`](macro@crate::assert_f64_ne_as_result)\n* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)","links":{"macro@crate::assert_f64_ne":75,"macro@crate::debug_assert_f64_ne":77,"macro@crate::assert_f64_ne_as_result":76},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"959":{"id":959,"crate_id":0,"name":"assert_program_args_stderr_ge_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge.rs","begin":[43,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)\n* [`assert_program_args_stderr_ge_as_result`](macro@crate::assert_program_args_stderr_ge_as_result)\n* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)\n","links":{"macro@crate::debug_assert_program_args_stderr_ge":960,"macro@crate::assert_program_args_stderr_ge_as_result":959,"macro@crate::assert_program_args_stderr_ge":958},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ge_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"682":{"id":682,"crate_id":0,"name":"debug_assert_fs_read_to_string_lt","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt.rs","begin":[399,0],"end":[405,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)\n\nThis macro provides the same statements as [`assert_fs_read_to_string_lt`](macro.assert_fs_read_to_string_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)\n* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)\n* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)\n","links":{"macro@crate::debug_assert_fs_read_to_string_lt":682,"macro@crate::assert_fs_read_to_string_lt":680},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"405":{"id":405,"crate_id":0,"name":"assert_some_eq","span":{"filename":"src/assert_some/assert_some_eq.rs","begin":[1,0],"end":[357,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Option<i8> = Option::Some(1);\nlet b: Option<i8> = Option::Some(1);\nassert_some_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_some_eq`](macro@crate::assert_some_eq)\n* [`assert_some_eq_as_result`](macro@crate::assert_some_eq_as_result)\n* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)\nAssert two expressions are Some and their values are equal.","links":{"macro@crate::assert_some_eq":402,"macro@crate::debug_assert_some_eq":404,"macro@crate::assert_some_eq_as_result":403},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"128":{"id":128,"crate_id":0,"name":"assert_diff_eq_x","span":{"filename":"src/assert_diff/assert_diff_eq_x.rs","begin":[302,0],"end":[315,1]},"visibility":"public","docs":"Assert a difference is equal to an expression.\n\nPseudocode:<br>\nΔ = x\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 3;\nassert_diff_eq_x!(a, b, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 2;\nassert_diff_eq_x!(a, b, x);\n# });\n// assertion failed: `assert_diff_eq_x!(a, b, x)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_diff_eq_x.html\n//  a label: `a`,\n//  a debug: `10`,\n//  b label: `b`,\n//  b debug: `13`,\n//  x label: `x`,\n//  x debug: `2`,\n//        Δ: `3`,\n//    Δ = x: false\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_diff_eq_x!(a, b, x)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_diff_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `10`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `13`,\\n\",\n#     \" x label: `x`,\\n\",\n#     \" x debug: `2`,\\n\",\n#     \"       Δ: `3`,\\n\",\n#     \"   Δ = x: false\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)\n* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)\n* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)\n","links":{"macro@crate::debug_assert_diff_eq_x":130,"macro@crate::assert_diff_eq_x_as_result":129,"macro@crate::assert_diff_eq_x":128,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_diff_eq_x {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };\n}"}},"1009":{"id":1009,"crate_id":0,"name":"debug_assert_program_args_stderr_string_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_is_match.rs","begin":[348,0],"end":[354,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_string_is_match`](macro.assert_program_args_stderr_string_is_match.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)\n* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)\n* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)\n","links":{"macro@crate::debug_assert_program_args_stderr_string_is_match":1009,"macro@crate::assert_program_args_stderr_string_is_match":1007},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_string_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"732":{"id":732,"crate_id":0,"name":"debug_assert_io_read_to_string_gt","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt.rs","begin":[365,0],"end":[371,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_gt`](macro.assert_io_read_to_string_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)\n* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)\n* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)\n","links":{"macro@crate::debug_assert_io_read_to_string_gt":732,"macro@crate::assert_io_read_to_string_gt":730},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"455":{"id":455,"crate_id":0,"name":"assert_bag_ne_as_result","span":{"filename":"src/assert_bag/assert_bag_ne.rs","begin":[43,0],"end":[76,1]},"visibility":"public","docs":"Assert a bag is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)\n\n* If true, return Result `Ok((a, b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_bag_ne`](macro@crate::assert_bag_ne)\n* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)\n* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)\n","links":{"macro@crate::assert_bag_ne_as_result":455,"macro@crate::debug_assert_bag_ne":456,"macro@crate::assert_bag_ne":454},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_ne_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"1059":{"id":1059,"crate_id":0,"name":"assert_status_code_value_le_x","span":{"filename":"src/assert_status/assert_status_code_value_le_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_le_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet b = 1;\nassert_status_code_value_le_x!(a, b);\n# });\n// assertion failed: `assert_status_code_value_le_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_le_x.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `2`\",\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_le_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_le_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`,\\n\",\n#     \"  a code: `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)\n* [`assert_status_code_value_le_x_as_result`](macro@crate::assert_status_code_value_le_x_as_result)\n* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)\n","links":{"macro@crate::assert_status_code_value_le_x_as_result":1060,"macro@crate::debug_assert_status_code_value_le_x":1061,"macro@crate::assert_status_code_value_le_x":1059,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_le_x {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"178":{"id":178,"crate_id":0,"name":"debug_assert_infix","span":{"filename":"src/assert_infix.rs","begin":[308,0],"end":[314,1]},"visibility":"public","docs":"Assert a infix operator, such as assert_infix!(a == b).\n\nPseudocode:<br>\na infix b\n\nThis macro provides the same statements as [`assert_infix`](macro.assert_infix.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_infix`](macro@crate::assert_infix)\n* [`assert_infix`](macro@crate::assert_infix)\n* [`debug_assert_infix`](macro@crate::debug_assert_infix)\n","links":{"macro@crate::debug_assert_infix":178,"macro@crate::assert_infix":176},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_infix {\n    ($($arg:tt)*) => { ... };\n}"}},"782":{"id":782,"crate_id":0,"name":"debug_assert_command_stdout_eq","span":{"filename":"src/assert_command/assert_command_stdout_eq.rs","begin":[389,0],"end":[395,1]},"visibility":"public","docs":"Assert a command stdout string is equal to another.\n\nThis macro provides the same statements as [`assert_command_stdout_eq {`](macro.assert_command_stdout_eq {.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stdout_eq {`](macro@crate::assert_command_stdout_eq {)\n* [`assert_command_stdout_eq {`](macro@crate::assert_command_stdout_eq {)\n* [`debug_assert_command_stdout_eq {`](macro@crate::debug_assert_command_stdout_eq {)\n","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stdout_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"505":{"id":505,"crate_id":0,"name":"assert_set_joint_as_result","span":{"filename":"src/assert_set/assert_set_joint.rs","begin":[43,0],"end":[76,1]},"visibility":"public","docs":"Assert a set is joint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)\n\n* If true, return Result `Ok((a_set, b_set))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_set_joint`](macro@crate::assert_set_joint)\n* [`assert_set_joint_as_result`](macro@crate::assert_set_joint_as_result)\n* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)\n","links":{"macro@crate::debug_assert_set_joint":506,"macro@crate::assert_set_joint":504,"macro@crate::assert_set_joint_as_result":505},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_joint_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"1109":{"id":1109,"crate_id":0,"name":"debug_assert_option_none","span":{"filename":"src/assert_option/assert_option_none.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert expression is None.\n\nDeprecated. Please rename from `debug_assert_option_none` into `debug_assert_none` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_option_none` into `debug_assert_none` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_option_none {\n    ($($arg:tt)*) => { ... };\n}"}},"228":{"id":228,"crate_id":0,"name":"assert_count_le_x","span":{"filename":"src/assert_count/assert_count_le_x.rs","begin":[1,0],"end":[336,1]},"visibility":"public","docs":"Assert a count is less than or equal to an expression.\n\nPseudocode:<br>\na.count() ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = 2;\nassert_count_le_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_le_x`](macro@crate::assert_count_le_x)\n* [`assert_count_le_x_as_result`](macro@crate::assert_count_le_x_as_result)\n* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)","links":{"macro@crate::assert_count_le_x":225,"macro@crate::assert_count_le_x_as_result":226,"macro@crate::debug_assert_count_le_x":227},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"832":{"id":832,"crate_id":0,"name":"assert_command_stdout_string_is_match_as_result","span":{"filename":"src/assert_command/assert_command_stdout_string_is_match.rs","begin":[44,0],"end":[98,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) is match (expr into string)\n\n* If true, return Result `Ok(command ⇒ stdout ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)\n* [`assert_command_stdout_string_is_match_as_result`](macro@crate::assert_command_stdout_string_is_match_as_result)\n* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)\n","links":{"macro@crate::debug_assert_command_stdout_string_is_match":833,"macro@crate::assert_command_stdout_string_is_match":831,"macro@crate::assert_command_stdout_string_is_match_as_result":832},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_string_is_match_as_result {\n    ($command:expr, $matcher:expr $(,)?) => { ... };\n}"}},"555":{"id":555,"crate_id":0,"name":"debug_assert_fn_le_x","span":{"filename":"src/assert_fn/assert_fn_le_x.rs","begin":[451,0],"end":[457,1]},"visibility":"public","docs":"Assert a function output is less than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≤ b\n\nThis macro provides the same statements as [`assert_fn_le_x`](macro.assert_fn_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)\n* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)\n* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)\n","links":{"macro@crate::debug_assert_fn_le_x":555,"macro@crate::assert_fn_le_x":553},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1159":{"id":1159,"crate_id":0,"name":"debug_assert_program_args_stdout_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stdout_is_match.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nDeprecated. Please rename from `debug_assert_program_args_stdout_is_match` to `debug_assert_program_args_stdout_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_program_args_stdout_is_match` to `debug_assert_program_args_stdout_string_is_match`."},"inner":{"macro":"macro_rules! debug_assert_program_args_stdout_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"278":{"id":278,"crate_id":0,"name":"assert_len_ge","span":{"filename":"src/assert_len/assert_len_ge.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a length is greater than or equal to another.\n\nPseudocode:<br>\na.len() ≥ b.len()\n\n* If true, return `(a.len(), b.len())`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\";\nlet b = \"x\";\nassert_len_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_ge!(a, b);\n# });\n// assertion failed: `assert_len_ge!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_ge.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `\\\"xx\\\"`,\n//  b.len(): `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_ge!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"xx\\\"`\\n\",\n#     \" b.len(): `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_ge`](macro@crate::assert_len_ge)\n* [`assert_len_ge_as_result`](macro@crate::assert_len_ge_as_result)\n* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)\n","links":{"macro@crate::assert_len_ge_as_result":279,"macro@crate::debug_assert_len_ge":280,"macro@crate::assert_len_ge":278,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_ge {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1":{"id":1,"crate_id":0,"name":"assert","span":{"filename":"src/assert.rs","begin":[1,0],"end":[89,1]},"visibility":"public","docs":"Assert a condition is true.\n\nPseudocode:<br>\ncondition\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro provides the same statements as [`assert`](macro@assert),\nexcept this macro returns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_as_result`](macro.assert_as_result.html)","links":{"macro@assert":0},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"882":{"id":882,"crate_id":0,"name":"assert_command_stderr_ne_x","span":{"filename":"src/assert_command/assert_command_stderr_ne_x.rs","begin":[1,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_ne_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)\n* [`assert_command_stderr_ne_x_as_result`](macro@crate::assert_command_stderr_ne_x_as_result)\n* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)","links":{"macro@crate::debug_assert_command_stderr_ne_x":881,"macro@crate::assert_command_stderr_ne_x":879,"macro@crate::assert_command_stderr_ne_x_as_result":880},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"605":{"id":605,"crate_id":0,"name":"assert_fn_err_le_x","span":{"filename":"src/assert_fn_err/assert_fn_err_le_x.rs","begin":[1,0],"end":[515,1]},"visibility":"public","docs":"Assert a function Err(…) is less than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≤ expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b = String::from(\"20 is out of range\");\nassert_fn_err_le_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)\n* [`assert_fn_err_le_x_as_result`](macro@crate::assert_fn_err_le_x_as_result)\n* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)","links":{"macro@crate::assert_fn_err_le_x":602,"macro@crate::assert_fn_err_le_x_as_result":603,"macro@crate::debug_assert_fn_err_le_x":604},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"328":{"id":328,"crate_id":0,"name":"assert_not_matches_as_result","span":{"filename":"src/assert_matches/assert_not_matches.rs","begin":[40,0],"end":[57,1]},"visibility":"public","docs":"Assert expression matches a case.\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_matches`](macro@crate::assert_not_matches)\n* [`assert_not_matches_as_result`](macro@crate::assert_not_matches_as_result)\n* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)\n","links":{"macro@crate::assert_not_matches":327,"macro@crate::assert_not_matches_as_result":328,"macro@crate::debug_assert_not_matches":329},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_matches_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"51":{"id":51,"crate_id":0,"name":"assert_f32_ne_as_result","span":{"filename":"src/assert_f32/assert_f32_ne.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na ≠ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f32_ne`](macro@crate::assert_f32_ne)\n* [`assert_f32_ne_as_result`](macro@crate::assert_f32_ne_as_result)\n* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)\n","links":{"macro@crate::debug_assert_f32_ne":52,"macro@crate::assert_f32_ne_as_result":51,"macro@crate::assert_f32_ne":50},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"932":{"id":932,"crate_id":0,"name":"assert_program_args_stdout_le_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le_x.rs","begin":[305,0],"end":[318,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_le_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stdout_le_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stdout_le_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_le_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[97, 97]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_le_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_le_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[97, 97]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)\n* [`assert_program_args_stdout_le_x_as_result`](macro@crate::assert_program_args_stdout_le_x_as_result)\n* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)\n","links":{"macro@crate::assert_program_args_stdout_le_x":932,"macro@crate::assert_program_args_stdout_le_x_as_result":933,"macro@crate::debug_assert_program_args_stdout_le_x":934,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_le_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"655":{"id":655,"crate_id":0,"name":"assert_fn_ok_lt_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt_x.rs","begin":[309,0],"end":[342,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_lt_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 2;\nlet b = String::from(\"1\");\nassert_fn_ok_lt_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_ok_lt_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_lt_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `2`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"1\\\"`,\n//                 a: `\\\"2\\\"`,\n//                 b: `\\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_lt_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_lt_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `2`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"1\\\"`,\\n\",\n#     \"                a: `\\\"2\\\"`,\\n\",\n#     \"                b: `\\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)\n* [`assert_fn_ok_lt_x_as_result`](macro@crate::assert_fn_ok_lt_x_as_result)\n* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)\n","links":{"macro@crate::assert_fn_ok_lt_x":655,"macro@crate::assert_fn_ok_lt_x_as_result":656,"macro@crate::debug_assert_fn_ok_lt_x":657,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_lt_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"378":{"id":378,"crate_id":0,"name":"assert_ok_ne_x","span":{"filename":"src/assert_ok/assert_ok_ne_x.rs","begin":[267,0],"end":[280,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) ≠ b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Ok(1);\nlet b: i8 = 2;\nassert_ok_ne_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Ok(1);\nlet b: i8 = 1;\nassert_ok_ne_x!(a, b);\n# });\n// assertion failed: `assert_ok_ne_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ok_ne_x.html\n//  a label: `a`,\n//  a debug: `Ok(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ok_ne_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ok_ne_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ok(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)\n* [`assert_ok_ne_x_as_result`](macro@crate::assert_ok_ne_x_as_result)\n* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)\n","links":{"macro@crate::assert_ok_ne_x":378,"macro@crate::assert_ok_ne_x_as_result":379,"macro@crate::debug_assert_ok_ne_x":380,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_ne_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"101":{"id":101,"crate_id":0,"name":"assert_abs_diff_ne_x_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne_x.rs","begin":[43,0],"end":[105,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nPseudocode:<br>\n|Δ| ≠ x\n\n* If true, return `Ok((lhs, rhs))`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)\n* [`assert_abs_diff_ne_x_as_result`](macro@crate::assert_abs_diff_ne_x_as_result)\n* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)\n","links":{"macro@crate::assert_abs_diff_ne_x_as_result":101,"`Err`":1082,"macro@crate::assert_abs_diff_ne_x":100,"macro@crate::debug_assert_abs_diff_ne_x":102},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_ne_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"982":{"id":982,"crate_id":0,"name":"assert_program_args_stderr_ge_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge_x.rs","begin":[305,0],"end":[318,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stderr_ge_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_ge_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stderr_ge_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_ge_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[122, 122]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_ge_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_ge_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[122, 122]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)\n* [`assert_program_args_stderr_ge_x_as_result`](macro@crate::assert_program_args_stderr_ge_x_as_result)\n* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)\n","links":{"macro@crate::assert_program_args_stderr_ge_x_as_result":1160,"macro@crate::assert_program_args_stderr_ge_x":982,"macro@crate::debug_assert_program_args_stderr_ge_x":983,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ge_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"705":{"id":705,"crate_id":0,"name":"assert_fs_read_to_string_lt_x_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt_x.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) < expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)\n* [`assert_fs_read_to_string_lt_x_as_result`](macro@crate::assert_fs_read_to_string_lt_x_as_result)\n* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)\n","links":{"macro@crate::assert_fs_read_to_string_lt_x":704,"macro@crate::assert_fs_read_to_string_lt_x_as_result":705,"macro@crate::debug_assert_fs_read_to_string_lt_x":706},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_lt_x_as_result {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"428":{"id":428,"crate_id":0,"name":"assert_poll","span":{"filename":"src/assert_poll/mod.rs","begin":[1,0],"end":[12,29]},"visibility":"public","docs":"Assert for `Poll` {`Ready`, `Pending`}\n\nDeprecated.\n\nPlease rename from `assert_poll_ready*` into `assert_ready*`.\n\nPlease rename from `assert_poll_pending` into `assert_pending`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[424,425,426,427],"is_stripped":false}}},"151":{"id":151,"crate_id":0,"name":"assert_diff_ne_x","span":{"filename":"src/assert_diff/assert_diff_ne_x.rs","begin":[1,0],"end":[478,1]},"visibility":"public","docs":"Assert a difference is not equal to an expression.\n\nPseudocode:<br>\nΔ ≠ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 4;\nassert_diff_ne_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)\n* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)\n* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)","links":{"macro@crate::assert_diff_ne_x_as_result":149,"macro@crate::assert_diff_ne_x":148,"macro@crate::debug_assert_diff_ne_x":150},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1032":{"id":1032,"crate_id":0,"name":"assert_status_code_value_gt_as_result","span":{"filename":"src/assert_status/assert_status_code_value_gt.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a status code value is greater than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)\n* [`assert_status_code_value_gt_as_result`](macro@crate::assert_status_code_value_gt_as_result)\n* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)\n","links":{"macro@crate::assert_status_code_value_gt":1031,"macro@crate::assert_status_code_value_gt_as_result":1032,"macro@crate::debug_assert_status_code_value_gt":1033},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_gt_as_result {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n}"}},"755":{"id":755,"crate_id":0,"name":"assert_io_read_to_string_gt_x_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt_x.rs","begin":[42,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)\n* [`assert_io_read_to_string_gt_x_as_result`](macro@crate::assert_io_read_to_string_gt_x_as_result)\n* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)\n","links":{"macro@crate::assert_io_read_to_string_gt_x_as_result":755,"macro@crate::assert_io_read_to_string_gt_x":754,"macro@crate::debug_assert_io_read_to_string_gt_x":756},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_gt_x_as_result {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"478":{"id":478,"crate_id":0,"name":"assert_iter_gt","span":{"filename":"src/assert_iter/assert_iter_gt.rs","begin":[1,0],"end":[304,1]},"visibility":"public","docs":"Assert an iter is greater than another.\n\nPseudocode:<br>\n(collection1 into iter) > (collection2 into iter)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [3, 4];\nlet b = [1, 2];\nassert_iter_gt!(&a, &b);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_gt`](macro@crate::assert_iter_gt)\n* [`assert_iter_gt_as_result`](macro@crate::assert_iter_gt_as_result)\n* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)","links":{"macro@crate::debug_assert_iter_gt":477,"macro@crate::assert_iter_gt_as_result":476,"macro@crate::assert_iter_gt":475},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"201":{"id":201,"crate_id":0,"name":"assert_count_le","span":{"filename":"src/assert_count/assert_count_le.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a count is less than or equal to another.\n\nPseudocode:<br>\na.count() ≤ b.count()\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"xx\".chars();\nlet b = \"x\".chars();\nassert_count_le!(a, b);\n# });\n// assertion failed: `assert_count_le!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_le.html\n//  a label: `a`,\n//  a debug: `Chars(['x', 'x'])`,\n//  a.count(): `2`\",\n//  b label: `b`,\n//  b debug: `Chars(['x'])`,\n//  b.count(): `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_le!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x', 'x'])`,\\n\",\n#     \" a.count(): `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Chars(['x'])`\\n\",\n#     \" b.count(): `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_le`](macro@crate::assert_count_le)\n* [`assert_count_le_as_result`](macro@crate::assert_count_le_as_result)\n* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)\n","links":{"macro@crate::assert_count_le":201,"macro@crate::assert_count_le_as_result":202,"macro@crate::debug_assert_count_le":203,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_le {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"805":{"id":805,"crate_id":0,"name":"assert_command_stdout_eq_x_as_result","span":{"filename":"src/assert_command/assert_command_stdout_eq_x.rs","begin":[43,0],"end":[95,1]},"visibility":"public","docs":"Assert a command stdout string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)\n* [`assert_command_stdout_eq_x_as_result`](macro@crate::assert_command_stdout_eq_x_as_result)\n* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)\n","links":{"macro@crate::assert_command_stdout_eq_x_as_result":805,"macro@crate::debug_assert_command_stdout_eq_x":806,"macro@crate::assert_command_stdout_eq_x":804},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_eq_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"528":{"id":528,"crate_id":0,"name":"assert_fn_gt","span":{"filename":"src/assert_fn/assert_fn_gt.rs","begin":[1,0],"end":[530,1]},"visibility":"public","docs":"Assert a function output is greater than another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_gt!(i8::abs, a, i8::abs, b);\n```\n\n# Module macros\n\n* [`assert_fn_gt`](macro@crate::assert_fn_gt)\n* [`assert_fn_gt_as_result`](macro@crate::assert_fn_gt_as_result)\n* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)","links":{"macro@crate::assert_fn_gt":525,"macro@crate::assert_fn_gt_as_result":526,"macro@crate::debug_assert_fn_gt":527},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"251":{"id":251,"crate_id":0,"name":"assert_not_ends_with","span":{"filename":"src/assert_ends_with/assert_not_ends_with.rs","begin":[198,0],"end":[211,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not end with an expression (such as a string).\n\nPseudocode:<br>\n¬ a.ends_with(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\n// String ends with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"al\";\nassert_not_ends_with!(sequence, subsequence);\n\n// Vector ends with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [1];\nassert_not_ends_with!(sequence, subsequence);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet sequence = \"alfa\";\nlet subsequence = \"fa\";\nassert_not_ends_with!(sequence, subsequence);\n# });\n// assertion failed: `assert_not_ends_with!(sequence, subsequence)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_not_ends_with.html\n//  sequence label: `sequence`,\n//  sequence debug: `\\\"alfa\\\"`,\n//   part label: `subsequence`,\n//   part debug: `\\\"fa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_not_ends_with!(sequence, subsequence)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_not_ends_with.html\\n\",\n#     \"     sequence label: `sequence`,\\n\",\n#     \"     sequence debug: `\\\"alfa\\\"`,\\n\",\n#     \"  subsequence label: `subsequence`,\\n\",\n#     \"  subsequence debug: `\\\"fa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)\n* [`assert_not_ends_with_as_result`](macro@crate::assert_not_ends_with_as_result)\n* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)\n","links":{"`panic!`":1081,"macro@crate::assert_not_ends_with":251,"macro@crate::debug_assert_not_ends_with":253,"macro@crate::assert_not_ends_with_as_result":252},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_ends_with {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };\n}"}},"1132":{"id":1132,"crate_id":0,"name":"assert_set_impl_prep","span":{"filename":"src/assert_set/mod.rs","begin":[97,0],"end":[103,1]},"visibility":"public","docs":"Assert set implementation preparation.","links":{},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_impl_prep {\n    ($impl_into_iter:expr $(,)?) => { ... };\n}"}},"855":{"id":855,"crate_id":0,"name":"assert_command_stderr_ne","span":{"filename":"src/assert_command/assert_command_stderr_ne.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"alfa\"]);\nassert_command_stderr_ne!(a, b);\n# });\n// assertion failed: `assert_command_stderr_ne!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_ne.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b value: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_ne!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" b value: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_ne`](macro@crate::assert_command_stderr_ne)\n* [`assert_command_stderr_ne_as_result`](macro@crate::assert_command_stderr_ne_as_result)\n* [`debug_assert_command_stderr_ne`](macro@crate::debug_assert_command_stderr_ne)\n","links":{"macro@crate::assert_command_stderr_ne_as_result":856,"macro@crate::assert_command_stderr_ne":855,"macro@crate::debug_assert_command_stderr_ne":857,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ne {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"578":{"id":578,"crate_id":0,"name":"assert_fn_err_le","span":{"filename":"src/assert_fn_err/assert_fn_err_le.rs","begin":[339,0],"end":[372,1]},"visibility":"public","docs":"Assert a function error is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_le!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 20;\nlet b: i8 = 10;\nassert_fn_err_le!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_err_le!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_le.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `20`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `10`,\n//                 a: `\\\"20 is out of range\\\"`,\n//                 b: `\\\"10 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_le!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_le.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `20`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `10`,\\n\",\n#     \"                a: `\\\"20 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"10 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)\n* [`assert_fn_err_le_as_result`](macro@crate::assert_fn_err_le_as_result)\n* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)\n","links":{"macro@crate::assert_fn_err_le":578,"macro@crate::debug_assert_fn_err_le":580,"macro@crate::assert_fn_err_le_as_result":579,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_le {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"301":{"id":301,"crate_id":0,"name":"assert_len_eq_x","span":{"filename":"src/assert_len/assert_len_eq_x.rs","begin":[1,0],"end":[335,1]},"visibility":"public","docs":"Assert a length is equal to an expression.\n\nPseudocode:<br>\na.len() = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = 1;\nassert_len_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)\n* [`assert_len_eq_x_as_result`](macro@crate::assert_len_eq_x_as_result)\n* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)","links":{"macro@crate::assert_len_eq_x_as_result":299,"macro@crate::assert_len_eq_x":298,"macro@crate::debug_assert_len_eq_x":300},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"24":{"id":24,"crate_id":0,"name":"debug_assert_eq_f32","span":{"filename":"src/assert_eq_f32.rs","begin":[368,0],"end":[374,1]},"visibility":"public","docs":"Assert a floating point 32-bit number is equal to another within f32::EPSILON.\n\nPseudocode:<br>\na = b\n\n\nThis macro provides the same statements as [`assert_eq_f32`](macro.assert_eq_f32.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_eq_f32`](macro@crate::assert_eq_f32)\n* [`assert_eq_f32`](macro@crate::assert_eq_f32)\n* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)\n","links":{"macro@crate::debug_assert_eq_f32":24,"macro@crate::assert_eq_f32":22},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_eq_f32 {\n    ($($arg:tt)*) => { ... };\n}"}},"905":{"id":905,"crate_id":0,"name":"assert_program_args_stdout_gt_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt.rs","begin":[44,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* If true, return Result `Err` with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)\n* [`assert_program_args_stdout_gt_as_result`](macro@crate::assert_program_args_stdout_gt_as_result)\n* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)\n","links":{"macro@crate::assert_program_args_stdout_gt":904,"macro@crate::assert_program_args_stdout_gt_as_result":905,"macro@crate::debug_assert_program_args_stdout_gt":906},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_gt_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"628":{"id":628,"crate_id":0,"name":"assert_fn_ok_le_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)\n* [`assert_fn_ok_le_as_result`](macro@crate::assert_fn_ok_le_as_result)\n* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)\n","links":{"macro@crate::debug_assert_fn_ok_le":629,"macro@crate::assert_fn_ok_le":627,"macro@crate::assert_fn_ok_le_as_result":628},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_le_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"351":{"id":351,"crate_id":0,"name":"debug_assert_err_ne","span":{"filename":"src/assert_err/assert_err_ne.rs","begin":[387,0],"end":[393,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are not equal.\n\nThis macro provides the same statements as [`assert_err_ne`](macro.assert_err_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_err_ne`](macro@crate::assert_err_ne)\n* [`assert_err_ne`](macro@crate::assert_err_ne)\n* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)\n","links":{"macro@crate::debug_assert_err_ne":351,"macro@crate::assert_err_ne":349},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_err_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"74":{"id":74,"crate_id":0,"name":"assert_f64_lt","span":{"filename":"src/assert_f64/assert_f64_lt.rs","begin":[1,0],"end":[327,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is less than another within f64::EPSILON.\n\nPseudocode:<br>\na < b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_f64_lt`](macro@crate::assert_f64_lt)\n* [`assert_f64_lt_as_result`](macro@crate::assert_f64_lt_as_result)\n* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)","links":{"macro@crate::assert_f64_lt_as_result":72,"macro@crate::debug_assert_f64_lt":73,"macro@crate::assert_f64_lt":71},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"955":{"id":955,"crate_id":0,"name":"assert_program_args_stderr_eq_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq.rs","begin":[43,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return Result `Ok(stderr)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)\n* [`assert_program_args_stderr_eq_as_result`](macro@crate::assert_program_args_stderr_eq_as_result)\n* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)\n","links":{"macro@crate::assert_program_args_stderr_eq":954,"macro@crate::assert_program_args_stderr_eq_as_result":955,"macro@crate::debug_assert_program_args_stderr_eq":956},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_eq_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"678":{"id":678,"crate_id":0,"name":"debug_assert_fs_read_to_string_le","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le.rs","begin":[395,0],"end":[401,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)\n\nThis macro provides the same statements as [`assert_fs_read_to_string_le`](macro.assert_fs_read_to_string_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)\n* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)\n* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)\n","links":{"macro@crate::assert_fs_read_to_string_le":676,"macro@crate::debug_assert_fs_read_to_string_le":678},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_le {\n    ($($arg:tt)*) => { ... };\n}"}},"401":{"id":401,"crate_id":0,"name":"assert_some","span":{"filename":"src/assert_some/assert_some.rs","begin":[1,0],"end":[245,1]},"visibility":"public","docs":"Assert expression is Some.\n\n Pseudocode:<br>\n a is Some\n\n # Example\n\n ```rust\n use assertables::*;\n\n let a: Option<i8> = Option::Some(1);\n assert_some!(a);\n ```\n\n # Module macros\n\n * [`assert_some`](macro@crate::assert_some)\n * [`assert_some_as_result`](macro@crate::assert_some_as_result)\n * [`debug_assert_some`](macro@crate::debug_assert_some)","links":{"macro@crate::assert_some_as_result":399,"macro@crate::assert_some":398,"macro@crate::debug_assert_some":400},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"124":{"id":124,"crate_id":0,"name":"assert_approx_ne_as_result","span":{"filename":"src/assert_approx/assert_approx_ne.rs","begin":[82,0],"end":[116,1]},"visibility":"public","docs":"Assert a number is approximately not equal to another.\n\nPseudocode:<br>\n| a - b | > 1e-6\n\n* If true, return Result `Ok(abs_diff, approx)`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro provides the same statements as [`assert_`](macro.assert_.html), except this macro\nreturns a Result, rather than doing a panic.\n\nThis macro is useful for runtime checks, such as checking parameters, or\nsanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_approx_ne`](macro@crate::assert_approx_ne)\n* [`assert_approx_ne_as_result`](macro@crate::assert_approx_ne_as_result)\n* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)\n","links":{"macro@crate::assert_approx_ne":118,"`Err`":1082,"macro@crate::assert_approx_ne_as_result":124,"macro@crate::debug_assert_approx_ne":125},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_approx_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"1005":{"id":1005,"crate_id":0,"name":"debug_assert_program_args_stderr_string_contains","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_contains.rs","begin":[354,0],"end":[360,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)\n\nThis macro provides the same statements as [`assert_program_args_stderr_string_contains`](macro.assert_program_args_stderr_string_contains.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)\n* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)\n* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)\n","links":{"macro@crate::assert_program_args_stderr_string_contains":1003,"macro@crate::debug_assert_program_args_stderr_string_contains":1005},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_string_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"728":{"id":728,"crate_id":0,"name":"debug_assert_io_read_to_string_ge","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge.rs","begin":[366,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_ge`](macro.assert_io_read_to_string_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)\n* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)\n* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)\n","links":{"macro@crate::assert_io_read_to_string_ge":726,"macro@crate::debug_assert_io_read_to_string_ge":728},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"451":{"id":451,"crate_id":0,"name":"assert_bag_eq_as_result","span":{"filename":"src/assert_bag/assert_bag_eq.rs","begin":[41,0],"end":[74,1]},"visibility":"public","docs":"Assert a bag is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)\n\n* If true, return Result `Ok((a, b))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_bag_eq!`](macro@crate::assert_bag_eq)\n* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)\n* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)\n","links":{"macro@crate::assert_bag_eq":450,"macro@crate::assert_bag_eq_as_result":451,"macro@crate::debug_assert_bag_eq":452},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_eq_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"174":{"id":174,"crate_id":0,"name":"debug_assert_any","span":{"filename":"src/assert_any.rs","begin":[256,0],"end":[262,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\nThis macro provides the same statements as [`assert_any`](macro.assert_any.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_any`](macro@crate::assert_any)\n* [`assert_any`](macro@crate::assert_any)\n* [`debug_assert_any`](macro@crate::debug_assert_any)\n","links":{"macro@crate::assert_any":172,"macro@crate::debug_assert_any":174},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_any {\n    ($($arg:tt)*) => { ... };\n}"}},"1055":{"id":1055,"crate_id":0,"name":"assert_status_code_value_gt_x","span":{"filename":"src/assert_status/assert_status_code_value_gt_x.rs","begin":[252,0],"end":[265,1]},"visibility":"public","docs":"Assert a status code value is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet b = 1;\nassert_status_code_value_gt_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_gt_x!(a, b);\n# });\n// assertion failed: `assert_status_code_value_gt_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_gt_x.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_gt_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_gt_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)\n* [`assert_status_code_value_gt_x_as_result`](macro@crate::assert_status_code_value_gt_x_as_result)\n* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)\n","links":{"macro@crate::assert_status_code_value_gt_x_as_result":1056,"macro@crate::assert_status_code_value_gt_x":1055,"macro@crate::debug_assert_status_code_value_gt_x":1057,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_gt_x {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"778":{"id":778,"crate_id":0,"name":"assert_io_read_to_string_matches","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_matches.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a ::std::io::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `assert_io_read_to_string_matches` into `assert_io_read_to_string_is_match`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"501":{"id":501,"crate_id":0,"name":"assert_set_disjoint_as_result","span":{"filename":"src/assert_set/assert_set_disjoint.rs","begin":[43,0],"end":[76,1]},"visibility":"public","docs":"Assert a set is disjoint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)\n\n* If true, return Result `Ok((a_set, b_set))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)\n* [`assert_set_disjoint_as_result`](macro@crate::assert_set_disjoint_as_result)\n* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)\n","links":{"macro@crate::assert_set_disjoint_as_result":501,"macro@crate::debug_assert_set_disjoint":502,"macro@crate::assert_set_disjoint":500},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_disjoint_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"224":{"id":224,"crate_id":0,"name":"assert_count_gt_x","span":{"filename":"src/assert_count/assert_count_gt_x.rs","begin":[1,0],"end":[335,1]},"visibility":"public","docs":"Assert a count is greater than an expression.\n\nPseudocode:<br>\na.count() > b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\".chars();\nlet b = 1;\nassert_count_gt_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)\n* [`assert_count_gt_x_as_result`](macro@crate::assert_count_gt_x_as_result)\n* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)","links":{"macro@crate::assert_count_gt_x_as_result":222,"macro@crate::debug_assert_count_gt_x":223,"macro@crate::assert_count_gt_x":221},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1105":{"id":1105,"crate_id":0,"name":"assert_result_ok_ne","span":{"filename":"src/assert_result/assert_result_ok_ne.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nPlease rename from `assert_result_ok_ne` into `assert_ok_ne` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_ok_ne` into `assert_ok_ne` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_ok_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"828":{"id":828,"crate_id":0,"name":"assert_command_stdout_string_contains_as_result","span":{"filename":"src/assert_command/assert_command_stdout_string_contains.rs","begin":[43,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) contains (expr into string)\n\n* If true, return Result `Ok(command ⇒ stdout ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)\n* [`assert_command_stdout_string_contains_as_result`](macro@crate::assert_command_stdout_string_contains_as_result)\n* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)\n","links":{"macro@crate::debug_assert_command_stdout_string_contains":829,"macro@crate::assert_command_stdout_string_contains":827,"macro@crate::assert_command_stdout_string_contains_as_result":828},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_string_contains_as_result {\n    ($command:expr, $containee:expr $(,)?) => { ... };\n}"}},"551":{"id":551,"crate_id":0,"name":"debug_assert_fn_gt_x","span":{"filename":"src/assert_fn/assert_fn_gt_x.rs","begin":[505,0],"end":[511,1]},"visibility":"public","docs":"Assert a function output is greater than an expression.\n\nPseudocode:<br>\nfunction(a) > b\n\nThis macro provides the same statements as [`assert_fn_gt_x`](macro.assert_fn_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)\n* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)\n* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)\n","links":{"macro@crate::assert_fn_gt_x":549,"macro@crate::debug_assert_fn_gt_x":551},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"274":{"id":274,"crate_id":0,"name":"assert_len_eq","span":{"filename":"src/assert_len/assert_len_eq.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a length is equal to another.\n\nPseudocode:<br>\na.len() = b.len()\n\n* If true, return `(a.len(), b.len())`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\";\nlet b = \"x\";\nassert_len_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_eq!(a, b);\n# });\n// assertion failed: `assert_len_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_len_eq.html\n//  a label: `a`,\n//  a debug: `\\\"x\\\"`,\n//  a.len(): `1`\",\n//  b label: `b`,\n//  b debug: `\\\"xx\\\"`,\n//  b.len(): `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_len_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_len_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"x\\\"`,\\n\",\n#     \" a.len(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"xx\\\"`\\n\",\n#     \" b.len(): `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_len_eq`](macro@crate::assert_len_eq)\n* [`assert_len_eq_as_result`](macro@crate::assert_len_eq_as_result)\n* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)\n","links":{"macro@crate::assert_len_eq_as_result":275,"macro@crate::debug_assert_len_eq":276,"macro@crate::assert_len_eq":274,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_len_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"1155":{"id":1155,"crate_id":0,"name":"assert_program_args_stdout_contains","span":{"filename":"src/assert_program_args/assert_program_args_stdout_contains.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nDeprecated. Please rename from `assert_program_args_stdout_contains` to `assert_program_args_stdout_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stdout_contains` to `assert_program_args_stdout_string_contains`."},"inner":{"macro":"macro_rules! assert_program_args_stdout_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"878":{"id":878,"crate_id":0,"name":"assert_command_stderr_lt_x","span":{"filename":"src/assert_command/assert_command_stderr_lt_x.rs","begin":[1,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stderr string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_lt_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)\n* [`assert_command_stderr_lt_x_as_result`](macro@crate::assert_command_stderr_lt_x_as_result)\n* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)","links":{"macro@crate::debug_assert_command_stderr_lt_x":877,"macro@crate::assert_command_stderr_lt_x":875,"macro@crate::assert_command_stderr_lt_x_as_result":876},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"601":{"id":601,"crate_id":0,"name":"assert_fn_err_gt_x","span":{"filename":"src/assert_fn_err/assert_fn_err_gt_x.rs","begin":[1,0],"end":[573,1]},"visibility":"public","docs":"Assert a function Err(…) is greater than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) > expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 20;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_gt_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)\n* [`assert_fn_err_gt_x_as_result`](macro@crate::assert_fn_err_gt_x_as_result)\n* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)","links":{"macro@crate::assert_fn_err_gt_x_as_result":599,"macro@crate::assert_fn_err_gt_x":598,"macro@crate::debug_assert_fn_err_gt_x":600},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"324":{"id":324,"crate_id":0,"name":"assert_matches_as_result","span":{"filename":"src/assert_matches/assert_matches.rs","begin":[40,0],"end":[57,1]},"visibility":"public","docs":"Assert expression matches a case.\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_matches`](macro@crate::assert_matches)\n* [`assert_matches_as_result`](macro@crate::assert_matches_as_result)\n* [`debug_assert_matches`](macro@crate::debug_assert_matches)\n","links":{"macro@crate::assert_matches_as_result":324,"macro@crate::assert_matches":323,"macro@crate::debug_assert_matches":325},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_matches_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"47":{"id":47,"crate_id":0,"name":"assert_f32_lt_as_result","span":{"filename":"src/assert_f32/assert_f32_lt.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na < b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f32_lt`](macro@crate::assert_f32_lt)\n* [`assert_f32_lt_as_result`](macro@crate::assert_f32_lt_as_result)\n* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)\n","links":{"macro@crate::assert_f32_lt":46,"macro@crate::assert_f32_lt_as_result":47,"macro@crate::debug_assert_f32_lt":48},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_lt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"928":{"id":928,"crate_id":0,"name":"assert_program_args_stdout_gt_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_gt_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stdout_gt_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_gt_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stdout_gt_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_gt_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[122, 122]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_gt_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_gt_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[122, 122]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)\n* [`assert_program_args_stdout_gt_x_as_result`](macro@crate::assert_program_args_stdout_gt_x_as_result)\n* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_program_args_stdout_gt_x":930,"macro@crate::assert_program_args_stdout_gt_x_as_result":929,"macro@crate::assert_program_args_stdout_gt_x":928},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_gt_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"651":{"id":651,"crate_id":0,"name":"assert_fn_ok_le_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_le_x.rs","begin":[326,0],"end":[359,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_le_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 2;\nlet b = String::from(\"1\");\nassert_fn_ok_le_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_ok_le_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_le_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `2`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"1\\\"`,\n//                 a: `\\\"2\\\"`,\n//                 b: `\\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_le_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_le_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `2`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"1\\\"`,\\n\",\n#     \"                a: `\\\"2\\\"`,\\n\",\n#     \"                b: `\\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)\n* [`assert_fn_ok_le_x_as_result`](macro@crate::assert_fn_ok_le_x_as_result)\n* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)\n","links":{"macro@crate::assert_fn_ok_le_x":651,"macro@crate::assert_fn_ok_le_x_as_result":652,"macro@crate::debug_assert_fn_ok_le_x":653,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_le_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"374":{"id":374,"crate_id":0,"name":"assert_ok_eq_x","span":{"filename":"src/assert_ok/assert_ok_eq_x.rs","begin":[227,0],"end":[240,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = b\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Ok(1);\nlet b: i8 = 1;\nassert_ok_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Ok(1);\nlet b: i8 = 2;\nassert_ok_eq_x!(a, b);\n# });\n// assertion failed: `assert_ok_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ok_eq_x.html\n//  a label: `a`,\n//  a debug: `Ok(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ok_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ok_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ok(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)\n* [`assert_ok_eq_x_as_result`](macro@crate::assert_ok_eq_x_as_result)\n* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)\n","links":{"macro@crate::assert_ok_eq_x":374,"macro@crate::assert_ok_eq_x_as_result":375,"macro@crate::debug_assert_ok_eq_x":376,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_eq_x {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"97":{"id":97,"crate_id":0,"name":"assert_abs_diff_lt_x_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt_x.rs","begin":[43,0],"end":[105,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nPseudocode:<br>\n|Δ| < x\n\n* If true, return `Ok((lhs, rhs))`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)\n* [`assert_abs_diff_lt_x_as_result`](macro@crate::assert_abs_diff_lt_x_as_result)\n* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)\n","links":{"macro@crate::assert_abs_diff_lt_x_as_result":97,"`Err`":1082,"macro@crate::debug_assert_abs_diff_lt_x":98,"macro@crate::assert_abs_diff_lt_x":96},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_lt_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"978":{"id":978,"crate_id":0,"name":"assert_program_args_stderr_eq_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_eq_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stderr_eq_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_eq_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stderr_eq_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_eq_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[122, 122]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_eq_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_eq_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[122, 122]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)\n* [`assert_program_args_stderr_eq_x_as_result`](macro@crate::assert_program_args_stderr_eq_x_as_result)\n* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_eq_x":980,"macro@crate::assert_program_args_stderr_eq_x":978,"macro@crate::assert_program_args_stderr_eq_x_as_result":979,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_eq_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"701":{"id":701,"crate_id":0,"name":"assert_fs_read_to_string_le_x_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_le_x.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≤ expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)\n* [`assert_fs_read_to_string_le_x_as_result`](macro@crate::assert_fs_read_to_string_le_x_as_result)\n* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)\n","links":{"macro@crate::assert_fs_read_to_string_le_x_as_result":701,"macro@crate::assert_fs_read_to_string_le_x":700,"macro@crate::debug_assert_fs_read_to_string_le_x":702},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_le_x_as_result {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"424":{"id":424,"crate_id":0,"name":"assert_poll_pending","span":{"filename":"src/assert_poll/assert_poll_pending.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert an expression is Pending.\n\nDeprecated. Please rename from `assert_poll_pending` into `assert_pending_as_result` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"147":{"id":147,"crate_id":0,"name":"assert_diff_lt_x","span":{"filename":"src/assert_diff/assert_diff_lt_x.rs","begin":[1,0],"end":[469,1]},"visibility":"public","docs":"Assert a difference is less than an expression.\n\nPseudocode:<br>\nΔ < x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 4;\nassert_diff_lt_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)\n* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)\n* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)","links":{"macro@crate::assert_diff_lt_x":144,"macro@crate::assert_diff_lt_x_as_result":145,"macro@crate::debug_assert_diff_lt_x":146},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1028":{"id":1028,"crate_id":0,"name":"assert_status_code_value_ge_as_result","span":{"filename":"src/assert_status/assert_status_code_value_ge.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)\n* [`assert_status_code_value_ge_as_result`](macro@crate::assert_status_code_value_ge_as_result)\n* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)\n","links":{"macro@crate::assert_status_code_value_ge_as_result":1028,"macro@crate::debug_assert_status_code_value_ge":1029,"macro@crate::assert_status_code_value_ge":1027},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ge_as_result {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n}"}},"751":{"id":751,"crate_id":0,"name":"assert_io_read_to_string_ge_x_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ge_x.rs","begin":[42,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)\n* [`assert_io_read_to_string_ge_x_as_result`](macro@crate::assert_io_read_to_string_ge_x_as_result)\n* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)\n","links":{"macro@crate::assert_io_read_to_string_ge_x":750,"macro@crate::assert_io_read_to_string_ge_x_as_result":751,"macro@crate::debug_assert_io_read_to_string_ge_x":752},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ge_x_as_result {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"474":{"id":474,"crate_id":0,"name":"assert_iter_ge","span":{"filename":"src/assert_iter/assert_iter_ge.rs","begin":[1,0],"end":[279,1]},"visibility":"public","docs":"Assert an iter is greater than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≥ (collection2 into iter)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [1, 2];\nassert_iter_ge!(&a, &b);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_ge`](macro@crate::assert_iter_ge)\n* [`assert_iter_ge_as_result`](macro@crate::assert_iter_ge_as_result)\n* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)","links":{"macro@crate::debug_assert_iter_ge":473,"macro@crate::assert_iter_ge":471,"macro@crate::assert_iter_ge_as_result":472},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1078":{"id":1078,"crate_id":0,"name":"assert_success_false","span":{"filename":"src/assert_success/assert_success_false.rs","begin":[1,0],"end":[265,1]},"visibility":"public","docs":"Assert failure.\n\nPseudocode:<br>\na.success() = false\n\n# Example\n\n```rust\nuse assertables::*;\n\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { false }}\nlet a = A{};\nassert_success_false!(a);\n```\n\n# Module macros\n\n* [`assert_success_false`](macro@crate::assert_success_false)\n* [`assert_success_false_as_result`](macro@crate::assert_success_false_as_result)\n* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)","links":{"macro@crate::assert_success_false":1075,"macro@crate::assert_success_false_as_result":1076,"macro@crate::debug_assert_success_false":1077},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"197":{"id":197,"crate_id":0,"name":"assert_count_gt","span":{"filename":"src/assert_count/assert_count_gt.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a count is greater than another.\n\nPseudocode:<br>\na.count() > b.count()\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\".chars();\nlet b = \"x\".chars();\nassert_count_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_gt!(a, b);\n# });\n// assertion failed: `assert_count_gt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_gt.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `Chars(['x', 'x'])`,\n//  b.count(): `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_gt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Chars(['x', 'x'])`\\n\",\n#     \" b.count(): `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_gt`](macro@crate::assert_count_gt)\n* [`assert_count_gt_as_result`](macro@crate::assert_count_gt_as_result)\n* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_count_gt":199,"macro@crate::assert_count_gt":197,"macro@crate::assert_count_gt_as_result":198},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_gt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"801":{"id":801,"crate_id":0,"name":"assert_command_stdout_ne_as_result","span":{"filename":"src/assert_command/assert_command_stdout_ne.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_ne`](macro@crate::assert_command_stdout_ne)\n* [`assert_command_stdout_ne_as_result`](macro@crate::assert_command_stdout_ne_as_result)\n* [`debug_assert_command_stdout_ne`](macro@crate::debug_assert_command_stdout_ne)\n","links":{"macro@crate::assert_command_stdout_ne_as_result":801,"macro@crate::assert_command_stdout_ne":800,"macro@crate::debug_assert_command_stdout_ne":802},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ne_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"524":{"id":524,"crate_id":0,"name":"assert_fn_ge","span":{"filename":"src/assert_fn/assert_fn_ge.rs","begin":[1,0],"end":[472,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to another.\n\nPseudocode:<br>\na_function(a) > b_function(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -2;\nlet b: i8 = 1;\nassert_fn_ge!(i8::abs, a, i8::abs, b);\n```\n\n# Module macros\n\n* [`assert_fn_ge`](macro@crate::assert_fn_ge)\n* [`assert_fn_ge_as_result`](macro@crate::assert_fn_ge_as_result)\n* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)","links":{"macro@crate::assert_fn_ge":521,"macro@crate::debug_assert_fn_ge":523,"macro@crate::assert_fn_ge_as_result":522},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"247":{"id":247,"crate_id":0,"name":"assert_ends_with","span":{"filename":"src/assert_ends_with/assert_ends_with.rs","begin":[198,0],"end":[211,1]},"visibility":"public","docs":"Assert an expression (such as a string) ends with an expression (such as a string).\n\nPseudocode:<br>\na.ends_with(b)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\n// String ends with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"fa\";\nassert_ends_with!(sequence, subsequence);\n\n// Vector ends with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [3];\nassert_ends_with!(sequence, subsequence);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet sequence = \"alfa\";\nlet subsequence = \"al\";\nassert_ends_with!(sequence, subsequence);\n# });\n// assertion failed: `assert_ends_with!(sequence, subsequence)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ends_with.html\n//  sequence label: `sequence`,\n//  sequence debug: `\\\"alfa\\\"`,\n//   part label: `subsequence`,\n//   part debug: `\\\"al\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ends_with!(sequence, subsequence)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ends_with.html\\n\",\n#     \"     sequence label: `sequence`,\\n\",\n#     \"     sequence debug: `\\\"alfa\\\"`,\\n\",\n#     \"  subsequence label: `subsequence`,\\n\",\n#     \"  subsequence debug: `\\\"al\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ends_with`](macro@crate::assert_ends_with)\n* [`assert_ends_with_as_result`](macro@crate::assert_ends_with_as_result)\n* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)\n","links":{"macro@crate::assert_ends_with":247,"macro@crate::assert_ends_with_as_result":248,"macro@crate::debug_assert_ends_with":249,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ends_with {\n    ($sequence:expr, $subsequence:expr $(,)?) => { ... };\n    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };\n}"}},"1128":{"id":1128,"crate_id":0,"name":"assert_poll_ready_ne_as_result","span":{"filename":"src/assert_poll/assert_poll_ready_ne.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert two expressions are Ready(_) and their values are not equal.\n\nDeprecated. Please rename from `assert_poll_ready_ne_as_result` into `assert_ready_ne_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_ready_ne_as_result` into `assert_ready_ne_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_ready_ne_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"851":{"id":851,"crate_id":0,"name":"assert_command_stderr_lt","span":{"filename":"src/assert_command/assert_command_stderr_lt.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a command stderr string is less than another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stderr_lt!(a, b);\n# });\n// assertion failed: `assert_command_stderr_lt!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_lt.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"aa\\\"`,\n//  b value: `[97, 997]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_lt!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"aa\\\"`,\\n\",\n#     \" b value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_lt`](macro@crate::assert_command_stderr_lt)\n* [`assert_command_stderr_lt_as_result`](macro@crate::assert_command_stderr_lt_as_result)\n* [`debug_assert_command_stderr_lt`](macro@crate::debug_assert_command_stderr_lt)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_command_stderr_lt":853,"macro@crate::assert_command_stderr_lt_as_result":852,"macro@crate::assert_command_stderr_lt":851},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_lt {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"574":{"id":574,"crate_id":0,"name":"assert_fn_err_gt","span":{"filename":"src/assert_fn_err/assert_fn_err_gt.rs","begin":[359,0],"end":[392,1]},"visibility":"public","docs":"Assert a function error is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 20;\nlet b: i8 = 10;\nassert_fn_err_gt!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_gt!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_err_gt!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_gt.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `20`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"20 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_gt!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_gt.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `20`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"20 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)\n* [`assert_fn_err_gt_as_result`](macro@crate::assert_fn_err_gt_as_result)\n* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)\n","links":{"macro@crate::assert_fn_err_gt_as_result":575,"macro@crate::debug_assert_fn_err_gt":576,"macro@crate::assert_fn_err_gt":574,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_gt {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"297":{"id":297,"crate_id":0,"name":"assert_len_ne","span":{"filename":"src/assert_len/assert_len_ne.rs","begin":[1,0],"end":[345,1]},"visibility":"public","docs":"Assert a length is not equal to another.\n\nPseudocode:<br>\na.len() ≠ b.len()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_ne`](macro@crate::assert_len_ne)\n* [`assert_len_ne_as_result`](macro@crate::assert_len_ne_as_result)\n* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)","links":{"macro@crate::debug_assert_len_ne":296,"macro@crate::assert_len_ne_as_result":295,"macro@crate::assert_len_ne":294},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"901":{"id":901,"crate_id":0,"name":"assert_program_args_stdout_ge_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge.rs","begin":[44,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* If true, return Result `Err` with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)\n* [`assert_program_args_stdout_ge_as_result`](macro@crate::assert_program_args_stdout_ge_as_result)\n* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)\n","links":{"macro@crate::assert_program_args_stdout_ge":900,"macro@crate::debug_assert_program_args_stdout_ge":902,"macro@crate::assert_program_args_stdout_ge_as_result":901},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ge_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"20":{"id":20,"crate_id":0,"name":"assert_ne_as_result","span":{"filename":"src/assert_ne.rs","begin":[38,0],"end":[65,1]},"visibility":"public","docs":"Assert an expression is not equal to another.\n\nPseudocode:<br>\na ≠ b\n\n* If true, return Result `Ok(())`.\n\n* When false, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macro\n\n* [`assert_ne_as_result`](macro@crate::assert_ne_as_result)\n\n# Rust standard macros\n\n* [`assert_ne`](https://doc.rust-lang.org/std/macro.assert_ne.html)\n* [`debug_assert_ne`](https://doc.rust-lang.org/std/macro.debug_assert_ne.html)\n","links":{"`Err`":1082,"macro@crate::assert_ne_as_result":20},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ne_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"624":{"id":624,"crate_id":0,"name":"assert_fn_ok_gt_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)\n* [`assert_fn_ok_gt_as_result`](macro@crate::assert_fn_ok_gt_as_result)\n* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)\n","links":{"macro@crate::assert_fn_ok_gt":623,"macro@crate::debug_assert_fn_ok_gt":625,"macro@crate::assert_fn_ok_gt_as_result":624},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_gt_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"347":{"id":347,"crate_id":0,"name":"debug_assert_err_eq","span":{"filename":"src/assert_err/assert_err_eq.rs","begin":[350,0],"end":[356,1]},"visibility":"public","docs":"Assert two expressions are Err and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)\n\nThis macro provides the same statements as [`assert_err_eq`](macro.assert_err_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_err_eq`](macro@crate::assert_err_eq)\n* [`assert_err_eq`](macro@crate::assert_err_eq)\n* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)\n","links":{"macro@crate::assert_err_eq":345,"macro@crate::debug_assert_err_eq":347},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_err_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"951":{"id":951,"crate_id":0,"name":"assert_program_args_stdout_string_is_match_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_is_match.rs","begin":[43,0],"end":[107,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)\n\n* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stdout ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)\n* [`assert_program_args_stdout_string_is_match_as_result`](macro@crate::assert_program_args_stdout_string_is_match_as_result)\n* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)\n","links":{"macro@crate::debug_assert_program_args_stdout_string_is_match":952,"macro@crate::assert_program_args_stdout_string_is_match":950,"macro@crate::assert_program_args_stdout_string_is_match_as_result":951},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_string_is_match_as_result {\n    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };\n}"}},"70":{"id":70,"crate_id":0,"name":"assert_f64_le","span":{"filename":"src/assert_f64/assert_f64_le.rs","begin":[1,0],"end":[387,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333339;\nassert_f64_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_f64_le`](macro@crate::assert_f64_le)\n* [`assert_f64_le_as_result`](macro@crate::assert_f64_le_as_result)\n* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)","links":{"macro@crate::assert_f64_le":67,"macro@crate::debug_assert_f64_le":69,"macro@crate::assert_f64_le_as_result":68},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"674":{"id":674,"crate_id":0,"name":"debug_assert_fs_read_to_string_gt","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt.rs","begin":[400,0],"end":[406,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)\n\nThis macro provides the same statements as [`assert_fs_read_to_string_gt`](macro.assert_fs_read_to_string_gt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)\n* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)\n* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)\n","links":{"macro@crate::assert_fs_read_to_string_gt":672,"macro@crate::debug_assert_fs_read_to_string_gt":674},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_gt {\n    ($($arg:tt)*) => { ... };\n}"}},"397":{"id":397,"crate_id":0,"name":"assert_option","span":{"filename":"src/assert_option/mod.rs","begin":[1,0],"end":[12,30]},"visibility":"public","docs":"Assert for `Option` {`Some`, `None`}\n\nDeprecated.\n\nPlease rename from `assert_option_some*` into `assert_some*`.\n\nPlease rename from `assert_option_none` into `assert_none`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[393,394,395,396],"is_stripped":false}}},"1001":{"id":1001,"crate_id":0,"name":"assert_program_args_stderr_contains","span":{"filename":"src/assert_program_args/assert_program_args_stderr_contains.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nDeprecated. Please rename from `assert_program_args_stderr_contains` to `assert_program_args_stderr_string_contains`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"120":{"id":120,"crate_id":0,"name":"assert_in_epsilon","span":{"filename":"src/assert_in/assert_in_epsilon.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a number is within epsilon of another.\n\nPseudocode:<br>\n| a - b | ≤ ε * min(a, b)\n\n* If true, return `(lhs, rhs)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 20;\nlet epsilon: i8 = 1;\nassert_in_epsilon!(a, b, epsilon);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 30;\nlet epsilon: i8 = 1;\nassert_in_epsilon!(a, b, epsilon);\n# });\n// assertion failed: `assert_in_epsilon!(a, b, epsilon)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_in_epsilon.html\n//                    a label: `a`,\n//                    a debug: `10`,\n//                    b label: `b`,\n//                    b debug: `30`,\n//                    ε label: `epsilon`,\n//                    ε debug: `1`,\n//                  | a - b |: `20`,\n//              ε * min(a, b): `10`,\\n\",\n//  | a - b | ≤ ε * min(a, b): false\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_in_epsilon!(a, b, ε)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_in_epsilon.html\\n\",\n#     \"                   a label: `a`,\\n\",\n#     \"                   a debug: `10`,\\n\",\n#     \"                   b label: `b`,\\n\",\n#     \"                   b debug: `30`,\\n\",\n#     \"                   ε label: `epsilon`,\\n\",\n#     \"                   ε debug: `1`,\\n\",\n#     \"                 | a - b |: `20`,\\n\",\n#     \"             ε * min(a, b): `10`,\\n\",\n#     \" | a - b | ≤ ε * min(a, b): false\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThe macros `assert_in_delta` and `assert_in_epsilon` can test\napproximations:\n\n* For an approximation, the absolute error (i.e. delta) is the magnitude of\n  the difference between the exact value and the approximation. For this,\n use the macro\n\n* For an approximation, the relative error (i.e. epsilon) is the absolute\n  error divided by the magnitude of the exact value. This can be used to\n  compare approximations of numbers of wildly differing size.\n\n* For example, approximating the number 1,000 with an absolute error of 3\n  is, in most applications, much worse than approximating the number\n  1,000,000 with an absolute error of 3; in the first case the relative\n  error is 0.003 and in the second it is only 0.000003.\n\n* Thanks to Ruby minitest for the example and documentation.\n\n# Module macros\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)\n* [`assert_in_epsilon_as_result`](macro@crate::assert_in_epsilon_as_result)\n* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)\n","links":{"macro@crate::assert_in_epsilon_as_result":160,"macro@crate::debug_assert_in_epsilon":161,"macro@crate::assert_in_epsilon":120,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_epsilon {\n    ($a:expr, $b:expr, $epsilon:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $epsilon:expr, $($message:tt)+) => { ... };\n}"}},"724":{"id":724,"crate_id":0,"name":"debug_assert_io_read_to_string_eq","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq.rs","begin":[366,0],"end":[372,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)\n\nThis macro provides the same statements as [`assert_io_read_to_string_eq`](macro.assert_io_read_to_string_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)\n* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)\n* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)\n","links":{"macro@crate::assert_io_read_to_string_eq":722,"macro@crate::debug_assert_io_read_to_string_eq":724},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_io_read_to_string_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"447":{"id":447,"crate_id":0,"name":"debug_assert_ready_ne_x","span":{"filename":"src/assert_ready/assert_ready_ne_x.rs","begin":[321,0],"end":[327,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ b\n\nThis macro provides the same statements as [`assert_ready_ne_x`](macro.assert_ready_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)\n* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)\n* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)\n","links":{"macro@crate::assert_ready_ne_x":445,"macro@crate::debug_assert_ready_ne_x":447},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ready_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1051":{"id":1051,"crate_id":0,"name":"assert_status_code_value_ge_x","span":{"filename":"src/assert_status/assert_status_code_value_ge_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a status code value is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet b = 1;\nassert_status_code_value_ge_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_ge_x!(a, b);\n# });\n// assertion failed: `assert_status_code_value_ge_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_ge_x.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_ge_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_ge_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)\n* [`assert_status_code_value_ge_x_as_result`](macro@crate::assert_status_code_value_ge_x_as_result)\n* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)\n","links":{"macro@crate::debug_assert_status_code_value_ge_x":1053,"macro@crate::assert_status_code_value_ge_x":1051,"macro@crate::assert_status_code_value_ge_x_as_result":1052,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ge_x {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"170":{"id":170,"crate_id":0,"name":"debug_assert_all","span":{"filename":"src/assert_all.rs","begin":[255,0],"end":[261,1]},"visibility":"public","docs":"Assert every element of the iterator matches a predicate.\n\nPseudocode:<br>\ncollection into iter ∀ predicate\n\nThis macro provides the same statements as [`assert_all`](macro.assert_all.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_all`](macro@crate::assert_all)\n* [`assert_all`](macro@crate::assert_all)\n* [`debug_assert_all`](macro@crate::debug_assert_all)\n","links":{"macro@crate::assert_all":168,"macro@crate::debug_assert_all":170},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_all {\n    ($($arg:tt)*) => { ... };\n}"}},"774":{"id":774,"crate_id":0,"name":"assert_io_read_to_string_is_match","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_is_match.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is a match to a regex.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) matches matcher\n\n* If true, return `(a_string, b_string)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse regex::Regex;\n\n# fn main() {\nlet reader = \"hello\".as_bytes();\nlet matcher = Regex::new(r\"ell\").expect(\"regex\");\nassert_io_read_to_string_is_match!(reader, matcher);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"hello\".as_bytes();\nlet matcher = Regex::new(r\"zz\").expect(\"regex\");\nassert_io_read_to_string_is_match!(reader, matcher);\n# });\n// assertion failed: `assert_io_read_to_string_is_match!(a_reader, &matcher)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_is_match.html\n//   reader label: `reader`,\n//   reader debug: `[104, 101, 108, 108, 111]`,\n//  matcher label: `matcher`,\n//  matcher debug: `Regex(\\\"zz\\\")`,\n//  reader string: `\\\"hello\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_is_match!(a_reader, &matcher)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_is_match.html\\n\",\n#     \"  reader label: `reader`,\\n\",\n#     \"  reader debug: `[104, 101, 108, 108, 111]`,\\n\",\n#     \" matcher label: `matcher`,\\n\",\n#     \" matcher debug: `Regex(\\\"zz\\\")`,\\n\",\n#     \" reader string: `\\\"hello\\\"`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)\n* [`assert_io_read_to_string_is_match_as_result`](macro@crate::assert_io_read_to_string_is_match_as_result)\n* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)\n","links":{"macro@crate::debug_assert_io_read_to_string_is_match":776,"macro@crate::assert_io_read_to_string_is_match_as_result":775,"macro@crate::assert_io_read_to_string_is_match":774,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_is_match {\n    ($a_reader:expr, $b_matcher:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_matcher:expr, $($message:tt)+) => { ... };\n}"}},"497":{"id":497,"crate_id":0,"name":"assert_set_ne_as_result","span":{"filename":"src/assert_set/assert_set_ne.rs","begin":[43,0],"end":[76,1]},"visibility":"public","docs":"Assert a set is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)\n\n* If true, return Result `Ok((a_set, b_set))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_set_ne`](macro@crate::assert_set_ne)\n* [`assert_set_ne_as_result`](macro@crate::assert_set_ne_as_result)\n* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)\n","links":{"macro@crate::assert_set_ne_as_result":497,"macro@crate::assert_set_ne":496,"macro@crate::debug_assert_set_ne":498},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_ne_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"220":{"id":220,"crate_id":0,"name":"assert_count_ge_x","span":{"filename":"src/assert_count/assert_count_ge_x.rs","begin":[1,0],"end":[338,1]},"visibility":"public","docs":"Assert a count is greater than or equal to an expression.\n\nPseudocode:<br>\na.count() ≥ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\".chars();\nlet b = 1;\nassert_count_ge_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)\n* [`assert_count_ge_x_as_result`](macro@crate::assert_count_ge_x_as_result)\n* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)","links":{"macro@crate::assert_count_ge_x":217,"macro@crate::assert_count_ge_x_as_result":218,"macro@crate::debug_assert_count_ge_x":219},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1101":{"id":1101,"crate_id":0,"name":"assert_result_ok_eq_as_result","span":{"filename":"src/assert_result/assert_result_ok_eq.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nDeprecated. Please rename from `assert_result_ok_eq_as_result` into `assert_ok_eq_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_result_ok_eq_as_result` into `assert_ok_eq_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_result_ok_eq_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"824":{"id":824,"crate_id":0,"name":"assert_command_stdout_ne_x","span":{"filename":"src/assert_command/assert_command_stdout_ne_x.rs","begin":[1,0],"end":[375,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_ne_x!(command, bytes);\n```","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"547":{"id":547,"crate_id":0,"name":"debug_assert_fn_ge_x","span":{"filename":"src/assert_fn/assert_fn_ge_x.rs","begin":[456,0],"end":[462,1]},"visibility":"public","docs":"Assert a function output is greater than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≥ expr\n\nThis macro provides the same statements as [`assert_fn_ge_x`](macro.assert_fn_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)\n* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)\n* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)\n","links":{"macro@crate::debug_assert_fn_ge_x":547,"macro@crate::assert_fn_ge_x":545},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"270":{"id":270,"crate_id":0,"name":"assert_not_match_as_result","span":{"filename":"src/assert_is_match/assert_not_match.rs","begin":[42,0],"end":[69,1]},"visibility":"public","docs":"Assert an expression (such as a regex) is not a match for an expression (such as a string).\n\nPseudocode:<br>\n¬ a.is_match(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_match`](macro@crate::assert_not_match)\n* [`assert_not_match_as_result`](macro@crate::assert_not_match_as_result)\n* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)\n","links":{"macro@crate::assert_not_match":269,"macro@crate::debug_assert_not_match":271,"macro@crate::assert_not_match_as_result":270},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_match_as_result {\n    ($matcher:expr, $matchee:expr $(,)?) => { ... };\n}"}},"1151":{"id":1151,"crate_id":0,"name":"assert_command_stderr_is_match","span":{"filename":"src/assert_command/assert_command_stderr_is_match.rs","begin":[28,0],"end":[32,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nDeprecated. Please rename from `assert_command_stderr_is_match` into `assert_command_stderr_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stderr_is_match` into `assert_command_stderr_string_is_match`."},"inner":{"macro":"macro_rules! assert_command_stderr_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"874":{"id":874,"crate_id":0,"name":"assert_command_stderr_le_x","span":{"filename":"src/assert_command/assert_command_stderr_le_x.rs","begin":[1,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stderr_le_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)\n* [`assert_command_stderr_le_x_as_result`](macro@crate::assert_command_stderr_le_x_as_result)\n* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)","links":{"macro@crate::assert_command_stderr_le_x_as_result":872,"macro@crate::assert_command_stderr_le_x":871,"macro@crate::debug_assert_command_stderr_le_x":873},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"597":{"id":597,"crate_id":0,"name":"assert_fn_err_ge_x","span":{"filename":"src/assert_fn_err/assert_fn_err_ge_x.rs","begin":[1,0],"end":[515,1]},"visibility":"public","docs":"Assert a function Err(…) is greater than or equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 20;\nlet b = String::from(\"10 is out of range\");\nassert_fn_err_ge_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)\n* [`assert_fn_err_ge_x_as_result`](macro@crate::assert_fn_err_ge_x_as_result)\n* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)","links":{"macro@crate::assert_fn_err_ge_x_as_result":595,"macro@crate::debug_assert_fn_err_ge_x":596,"macro@crate::assert_fn_err_ge_x":594},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"320":{"id":320,"crate_id":0,"name":"debug_assert_len_ne_x","span":{"filename":"src/assert_len/assert_len_ne_x.rs","begin":[332,0],"end":[338,1]},"visibility":"public","docs":"Assert a length is not equal to an expression.\n\nPseudocode:<br>\na.len() ≠ b\n\nThis macro provides the same statements as [`assert_len_ne_x`](macro.assert_len_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)\n* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)\n* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)\n","links":{"macro@crate::debug_assert_len_ne_x":320,"macro@crate::assert_len_ne_x":318},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"924":{"id":924,"crate_id":0,"name":"assert_program_args_stdout_ge_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ge_x.rs","begin":[305,0],"end":[318,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stdout_ge_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_ge_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stdout_ge_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_ge_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[122, 122]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_ge_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_ge_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[122, 122]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)\n* [`assert_program_args_stdout_ge_x_as_result`](macro@crate::assert_program_args_stdout_ge_x_as_result)\n* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)\n","links":{"macro@crate::debug_assert_program_args_stdout_ge_x":926,"macro@crate::assert_program_args_stdout_ge_x":924,"macro@crate::assert_program_args_stdout_ge_x_as_result":925,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ge_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"43":{"id":43,"crate_id":0,"name":"assert_f32_le_as_result","span":{"filename":"src/assert_f32/assert_f32_le.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na ≤ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f32_le`](macro@crate::assert_f32_le)\n* [`assert_f32_le_as_result`](macro@crate::assert_f32_le_as_result)\n* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)\n","links":{"macro@crate::debug_assert_f32_le":44,"macro@crate::assert_f32_le":42,"macro@crate::assert_f32_le_as_result":43},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_le_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"647":{"id":647,"crate_id":0,"name":"assert_fn_ok_gt_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_gt_x.rs","begin":[346,0],"end":[379,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 2;\nlet b = String::from(\"1\");\nassert_fn_ok_gt_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_gt_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_ok_gt_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_gt_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"2\\\"`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"2\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_gt_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_gt_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"2\\\"`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"2\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)\n* [`assert_fn_ok_gt_x_as_result`](macro@crate::assert_fn_ok_gt_x_as_result)\n* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)\n","links":{"`panic!`":1081,"macro@crate::assert_fn_ok_gt_x_as_result":648,"macro@crate::debug_assert_fn_ok_gt_x":649,"macro@crate::assert_fn_ok_gt_x":647},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_gt_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"370":{"id":370,"crate_id":0,"name":"assert_ok_ne","span":{"filename":"src/assert_ok/assert_ok_ne.rs","begin":[272,0],"end":[285,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Ok(1);\nlet b: Result<i8, i8> = Ok(2);\nassert_ok_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Ok(1);\nlet b: Result<i8, i8> = Ok(1);\nassert_ok_ne!(a, b);\n# });\n// assertion failed: `assert_ok_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ok_ne.html\n//  a label: `a`,\n//  a debug: `Ok(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Ok(1)`,\n//  b inner: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ok_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ok_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ok(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Ok(1)`,\\n\",\n#     \" b inner: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ok_ne`](macro@crate::assert_ok_ne)\n* [`assert_ok_ne_as_result`](macro@crate::assert_ok_ne_as_result)\n* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)\n","links":{"macro@crate::assert_ok_ne_as_result":371,"macro@crate::debug_assert_ok_ne":372,"macro@crate::assert_ok_ne":370,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_ne {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"974":{"id":974,"crate_id":0,"name":"assert_program_args_stderr_ne","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne.rs","begin":[355,0],"end":[368,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_ne!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"alfa\"];\nassert_program_args_stderr_ne!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_ne.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stderr\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_ne.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)\n* [`assert_program_args_stderr_ne_as_result`](macro@crate::assert_program_args_stderr_ne_as_result)\n* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_ne":976,"macro@crate::assert_program_args_stderr_ne":974,"macro@crate::assert_program_args_stderr_ne_as_result":975},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ne {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"93":{"id":93,"crate_id":0,"name":"assert_abs_diff_le_x_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le_x.rs","begin":[43,0],"end":[105,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≤ x\n\n* If true, return `Ok((lhs, rhs))`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)\n* [`assert_abs_diff_le_x_as_result`](macro@crate::assert_abs_diff_le_x_as_result)\n* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)\n","links":{"macro@crate::assert_abs_diff_le_x":92,"`Err`":1082,"macro@crate::assert_abs_diff_le_x_as_result":93,"macro@crate::debug_assert_abs_diff_le_x":94},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_le_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"697":{"id":697,"crate_id":0,"name":"assert_fs_read_to_string_gt_x_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_gt_x.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) > expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)\n* [`assert_fs_read_to_string_gt_x_as_result`](macro@crate::assert_fs_read_to_string_gt_x_as_result)\n* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)\n","links":{"macro@crate::assert_fs_read_to_string_gt_x_as_result":697,"macro@crate::debug_assert_fs_read_to_string_gt_x":698,"macro@crate::assert_fs_read_to_string_gt_x":696},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_gt_x_as_result {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"420":{"id":420,"crate_id":0,"name":"assert_pending_as_result","span":{"filename":"src/assert_pending/assert_pending.rs","begin":[42,0],"end":[62,1]},"visibility":"public","docs":"Assert an expression.is_pending() is true.\n\nPseudocode:<br>\na is Pending\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_pending`](macro@crate::assert_pending)\n* [`assert_pending_as_result`](macro@crate::assert_pending_as_result)\n* [`debug_assert_pending`](macro@crate::debug_assert_pending)\n","links":{"macro@crate::debug_assert_pending":421,"macro@crate::assert_pending_as_result":420,"macro@crate::assert_pending":419},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_pending_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"1024":{"id":1024,"crate_id":0,"name":"assert_status_code_value_eq_as_result","span":{"filename":"src/assert_status/assert_status_code_value_eq.rs","begin":[42,0],"end":[107,1]},"visibility":"public","docs":"Assert a status code value is equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value\n\n* If true, return Result `Ok((a value, b value)))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)\n* [`assert_status_code_value_eq_as_result`](macro@crate::assert_status_code_value_eq_as_result)\n* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)\n","links":{"macro@crate::assert_status_code_value_eq_as_result":1024,"macro@crate::debug_assert_status_code_value_eq":1025,"macro@crate::assert_status_code_value_eq":1023},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_eq_as_result {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n}"}},"143":{"id":143,"crate_id":0,"name":"assert_diff_le_x","span":{"filename":"src/assert_diff/assert_diff_le_x.rs","begin":[1,0],"end":[478,1]},"visibility":"public","docs":"Assert a difference is less than or equal to an expression.\n\nPseudocode:<br>\nΔ ≤ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 3;\nassert_diff_le_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)\n* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)\n* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)","links":{"macro@crate::debug_assert_diff_le_x":142,"macro@crate::assert_diff_le_x_as_result":141,"macro@crate::assert_diff_le_x":140},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"747":{"id":747,"crate_id":0,"name":"assert_io_read_to_string_eq_x_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_eq_x.rs","begin":[42,0],"end":[95,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) = expr\n\n* If true, return Result `Ok(a_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)\n* [`assert_io_read_to_string_eq_x_as_result`](macro@crate::assert_io_read_to_string_eq_x_as_result)\n* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)\n","links":{"macro@crate::assert_io_read_to_string_eq_x_as_result":747,"macro@crate::assert_io_read_to_string_eq_x":746,"macro@crate::debug_assert_io_read_to_string_eq_x":748},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_eq_x_as_result {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"470":{"id":470,"crate_id":0,"name":"assert_iter_eq","span":{"filename":"src/assert_iter/assert_iter_eq.rs","begin":[1,0],"end":[259,1]},"visibility":"public","docs":"Assert an iter is equal to another.\n\nPseudocode:<br>\n(collection1 into iter) = (collection2 into iter)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [1, 2];\nassert_iter_eq!(&a, &b);\n```\n\nThis implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).\n\n# Module macros\n\n* [`assert_iter_eq`](macro@crate::assert_iter_eq)\n* [`assert_iter_eq_as_result`](macro@crate::assert_iter_eq_as_result)\n* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)","links":{"macro@crate::debug_assert_iter_eq":469,"macro@crate::assert_iter_eq_as_result":468,"macro@crate::assert_iter_eq":467},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1074":{"id":1074,"crate_id":0,"name":"assert_success","span":{"filename":"src/assert_success/assert_success.rs","begin":[1,0],"end":[265,1]},"visibility":"public","docs":"Assert success.\n\nPseudocode:<br>\na.success() = true\n\n# Example\n\n```rust\nuse assertables::*;\n\n#[derive(Debug)]\nstruct A;\nimpl A { fn success(&self) -> bool { true }}\nlet a = A{};\nassert_success!(a);\n```\n\n# Module macros\n\n* [`assert_success`](macro@crate::assert_success)\n* [`assert_success_as_result`](macro@crate::assert_success_as_result)\n* [`debug_assert_success`](macro@crate::debug_assert_success)","links":{"macro@crate::assert_success_as_result":1072,"macro@crate::assert_success":1071,"macro@crate::debug_assert_success":1073},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"193":{"id":193,"crate_id":0,"name":"assert_count_ge","span":{"filename":"src/assert_count/assert_count_ge.rs","begin":[238,0],"end":[251,1]},"visibility":"public","docs":"Assert a count is greater than or equal to another.\n\nPseudocode:<br>\na.count() ≥ b.count()\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"xx\".chars();\nlet b = \"x\".chars();\nassert_count_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_ge!(a, b);\n# });\n// assertion failed: `assert_count_ge!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_ge.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `Chars(['x', 'x'])`,\n//  b.count(): `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_ge!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Chars(['x', 'x'])`\\n\",\n#     \" b.count(): `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_ge`](macro@crate::assert_count_ge)\n* [`assert_count_ge_as_result`](macro@crate::assert_count_ge_as_result)\n* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)\n","links":{"`panic!`":1081,"macro@crate::assert_count_ge":193,"macro@crate::debug_assert_count_ge":195,"macro@crate::assert_count_ge_as_result":194},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_ge {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"797":{"id":797,"crate_id":0,"name":"assert_command_stdout_lt_as_result","span":{"filename":"src/assert_command/assert_command_stdout_lt.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stdout string is less than another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_lt`](macro@crate::assert_command_stdout_lt)\n* [`assert_command_stdout_lt_as_result`](macro@crate::assert_command_stdout_lt_as_result)\n* [`debug_assert_command_stdout_lt`](macro@crate::debug_assert_command_stdout_lt)\n","links":{"macro@crate::assert_command_stdout_lt_as_result":797,"macro@crate::debug_assert_command_stdout_lt":798,"macro@crate::assert_command_stdout_lt":796},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_lt_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"520":{"id":520,"crate_id":0,"name":"assert_fn_eq","span":{"filename":"src/assert_fn/assert_fn_eq.rs","begin":[1,0],"end":[436,1]},"visibility":"public","docs":"Assert a function output is equal to another.\n\nPseudocode:<br>\na_function(a) == b_function(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = -1;\nlet b: i8 = 1;\nassert_fn_eq!(i8::abs, a, i8::abs, b);\n```\n\n# Module macros\n\n* [`assert_fn_eq`](macro@crate::assert_fn_eq)\n* [`assert_fn_eq_as_result`](macro@crate::assert_fn_eq_as_result)\n* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)","links":{"macro@crate::assert_fn_eq":517,"macro@crate::assert_fn_eq_as_result":518,"macro@crate::debug_assert_fn_eq":519},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1124":{"id":1124,"crate_id":0,"name":"debug_assert_poll_ready","span":{"filename":"src/assert_poll/assert_poll_ready.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert poll.is_ready() is true.\n\nDeprecated. lease rename from `debug_assert_poll_ready` into `debug_assert_ready` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_poll_ready` into `debug_assert_ready` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_poll_ready {\n    ($($arg:tt)*) => { ... };\n}"}},"243":{"id":243,"crate_id":0,"name":"assert_not_email_address_as_result","span":{"filename":"src/assert_email_address/assert_not_email_address.rs","begin":[40,0],"end":[87,1]},"visibility":"public","docs":"Assert expression is possibly not an email address.\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_email_address`](macro@crate::assert_not_email_address)\n* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)\n* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)\n","links":{"macro@crate::debug_assert_not_email_address":244,"macro@crate::assert_not_email_address_as_result":243,"macro@crate::assert_not_email_address":242},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_email_address_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"847":{"id":847,"crate_id":0,"name":"assert_command_stderr_le","span":{"filename":"src/assert_command/assert_command_stderr_le.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a command stderr string is less than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stderr_le!(a, b);\n# });\n// assertion failed: `assert_command_stderr_le!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_le.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"aa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_le!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"aa\\\"`,\\n\",\n#     \" b value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_le`](macro@crate::assert_command_stderr_le)\n* [`assert_command_stderr_le_as_result`](macro@crate::assert_command_stderr_le_as_result)\n* [`debug_assert_command_stderr_le`](macro@crate::debug_assert_command_stderr_le)\n","links":{"macro@crate::assert_command_stderr_le_as_result":848,"macro@crate::assert_command_stderr_le":847,"macro@crate::debug_assert_command_stderr_le":849,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_le {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"570":{"id":570,"crate_id":0,"name":"assert_fn_err_ge","span":{"filename":"src/assert_fn_err/assert_fn_err_ge.rs","begin":[339,0],"end":[372,1]},"visibility":"public","docs":"Assert a function error is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 20;\nlet b: i8 = 10;\nassert_fn_err_ge!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_ge!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_err_ge!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_ge.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `20`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"20 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_ge!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_ge.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `20`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"20 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)\n* [`assert_fn_err_ge_as_result`](macro@crate::assert_fn_err_ge_as_result)\n* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fn_err_ge":572,"macro@crate::assert_fn_err_ge_as_result":571,"macro@crate::assert_fn_err_ge":570},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_ge {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"293":{"id":293,"crate_id":0,"name":"assert_len_lt","span":{"filename":"src/assert_len/assert_len_lt.rs","begin":[1,0],"end":[344,1]},"visibility":"public","docs":"Assert a length is less than another.\n\nPseudocode:<br>\na.len() < b.len()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_lt`](macro@crate::assert_len_lt)\n* [`assert_len_lt_as_result`](macro@crate::assert_len_lt_as_result)\n* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)","links":{"macro@crate::assert_len_lt":290,"macro@crate::debug_assert_len_lt":292,"macro@crate::assert_len_lt_as_result":291},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"16":{"id":16,"crate_id":0,"name":"assert_lt","span":{"filename":"src/assert_lt.rs","begin":[289,0],"end":[302,1]},"visibility":"public","docs":"Assert an expression is less than another.\n\nPseudocode:<br>\na < b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 1;\nlet b = 2;\nassert_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 2;\nlet b = 1;\nassert_lt!(a, b);\n# });\n// assertion failed: `assert_lt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_lt.html\n//  a label: `a`,\n//  a debug: `2`,\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_lt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_lt`](macro@crate::assert_lt)\n* [`assert_lt_as_result`](macro@crate::assert_lt_as_result)\n* [`debug_assert_lt`](macro@crate::debug_assert_lt)\n","links":{"macro@crate::debug_assert_lt":18,"macro@crate::assert_lt":16,"macro@crate::assert_lt_as_result":17,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_lt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"897":{"id":897,"crate_id":0,"name":"assert_program_args_stdout_eq_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq.rs","begin":[44,0],"end":[122,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* If true, return Result `Err` with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)\n* [`assert_program_args_stdout_eq_as_result`](macro@crate::assert_program_args_stdout_eq_as_result)\n* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)\n","links":{"macro@crate::assert_program_args_stdout_eq":896,"macro@crate::debug_assert_program_args_stdout_eq":898,"macro@crate::assert_program_args_stdout_eq_as_result":897},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_eq_as_result {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n}"}},"620":{"id":620,"crate_id":0,"name":"assert_fn_ok_ge_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)\n* [`assert_fn_ok_ge_as_result`](macro@crate::assert_fn_ok_ge_as_result)\n* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)\n","links":{"macro@crate::assert_fn_ok_ge_as_result":620,"macro@crate::debug_assert_fn_ok_ge":621,"macro@crate::assert_fn_ok_ge":619},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ge_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"343":{"id":343,"crate_id":0,"name":"debug_assert_err","span":{"filename":"src/assert_err/assert_err.rs","begin":[241,0],"end":[247,1]},"visibility":"public","docs":"Assert expression is Err.\n\nPseudocode:<br>\na is Err(_)\n\nThis macro provides the same statements as [`assert_err`](macro.assert_err.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_err`](macro@crate::assert_err)\n* [`assert_err`](macro@crate::assert_err)\n* [`debug_assert_err`](macro@crate::debug_assert_err)\n","links":{"macro@crate::assert_err":341,"macro@crate::debug_assert_err":343},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_err {\n    ($($arg:tt)*) => { ... };\n}"}},"66":{"id":66,"crate_id":0,"name":"assert_f64_gt","span":{"filename":"src/assert_f64/assert_f64_gt.rs","begin":[1,0],"end":[327,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is greater than another within f64::EPSILON.\n\nPseudocode:<br>\na > b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333329;\nassert_f64_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_f64_gt`](macro@crate::assert_f64_gt)\n* [`assert_f64_gt_as_result`](macro@crate::assert_f64_gt_as_result)\n* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)","links":{"macro@crate::assert_f64_gt":63,"macro@crate::assert_f64_gt_as_result":64,"macro@crate::debug_assert_f64_gt":65},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"947":{"id":947,"crate_id":0,"name":"assert_program_args_stdout_string_contains_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stdout_string_contains.rs","begin":[47,0],"end":[111,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string contains a given containee.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout ⇒ string) contains (expr into string)\n\n* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stdout ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)\n* [`assert_program_args_stdout_string_contains_as_result`](macro@crate::assert_program_args_stdout_string_contains_as_result)\n* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)\n","links":{"macro@crate::assert_program_args_stdout_string_contains":946,"macro@crate::assert_program_args_stdout_string_contains_as_result":947,"macro@crate::debug_assert_program_args_stdout_string_contains":948},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_string_contains_as_result {\n    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };\n}"}},"670":{"id":670,"crate_id":0,"name":"debug_assert_fs_read_to_string_ge","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge.rs","begin":[396,0],"end":[402,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)\n\nThis macro provides the same statements as [`assert_fs_read_to_string_ge`](macro.assert_fs_read_to_string_ge.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)\n* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)\n* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)\n","links":{"macro@crate::debug_assert_fs_read_to_string_ge":670,"macro@crate::assert_fs_read_to_string_ge":668},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_ge {\n    ($($arg:tt)*) => { ... };\n}"}},"393":{"id":393,"crate_id":0,"name":"assert_option_none","span":{"filename":"src/assert_option/assert_option_none.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert expression is None.\n\nDeprecated. Please rename from `assert_option_none` into `assert_none` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"116":{"id":116,"crate_id":0,"name":"assert_abs_diff","span":{"filename":"src/assert_abs_diff/mod.rs","begin":[1,0],"end":[43,27]},"visibility":"public","docs":"Assert for comparing absolute differences.\n\nThese macros help with collection lengths, such as for strings, arrays,\nvectors, iterators, and anything that has a typical `.len()` method.\n\nCompare an absolute difference with an expression:\n\n* [`assert_abs_diff_eq_x!(a, b, x)`](macro@crate::assert_abs_diff_eq) ≈ | a - b | = x\n\n* [`assert_abs_diff_ne_x!(a, b, x)`](macro@crate::assert_abs_diff_ne) ≈ | a - b | ≠ x\n\n* [`assert_abs_diff_lt_x!(a, b, x)`](macro@crate::assert_abs_diff_lt) ≈ | a - b | < x\n\n* [`assert_abs_diff_le_x!(a, b, x)`](macro@crate::assert_abs_diff_le) ≈ | a - b | ≤ x\n\n* [`assert_abs_diff_gt_x!(a, b, x)`](macro@crate::assert_abs_diff_gt) ≈ | a - b | > x\n\n* [`assert_abs_diff_ge_x!(a, b, x)`](macro@crate::assert_abs_diff_ge) ≈ | a - b | ≥ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 10;\nlet b = 13;\nlet x = 3;\nassert_abs_diff_eq_x!(a, b, x);\n```","links":{"macro@crate::assert_abs_diff_ge":115,"macro@crate::assert_abs_diff_ne":111,"macro@crate::assert_abs_diff_le":113,"macro@crate::assert_abs_diff_gt":114,"macro@crate::assert_abs_diff_eq":110,"macro@crate::assert_abs_diff_lt":112},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[83,87,91,95,99,103,104,105,106,107,108,109],"is_stripped":false}}},"997":{"id":997,"crate_id":0,"name":"assert_program_args_stderr_ne_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ne_x.rs","begin":[305,0],"end":[318,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'x', b'x'];\nassert_program_args_stderr_ne_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stderr_ne_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stderr_ne_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_ne_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[97, 108, 102, 97]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_ne_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_ne_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[97, 108, 102, 97]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)\n* [`assert_program_args_stderr_ne_x_as_result`](macro@crate::assert_program_args_stderr_ne_x_as_result)\n* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_ne_x":999,"macro@crate::assert_program_args_stderr_ne_x":997,"macro@crate::assert_program_args_stderr_ne_x_as_result":998},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ne_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"720":{"id":720,"crate_id":0,"name":"assert_fs_read_to_string_matches","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_matches.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `assert_fs_read_to_string_matches` into `assert_fs_read_to_string_is_match`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"443":{"id":443,"crate_id":0,"name":"debug_assert_ready_eq_x","span":{"filename":"src/assert_ready/assert_ready_eq_x.rs","begin":[321,0],"end":[327,1]},"visibility":"public","docs":"Assert an expression is Ready and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = b\n\nThis macro provides the same statements as [`assert_ready_eq_x`](macro.assert_ready_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)\n* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)\n* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)\n","links":{"macro@crate::debug_assert_ready_eq_x":443,"macro@crate::assert_ready_eq_x":441},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ready_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"166":{"id":166,"crate_id":0,"name":"assert_in_range","span":{"filename":"src/assert_in/assert_in_range.rs","begin":[1,0],"end":[331,1]},"visibility":"public","docs":"Assert an item is in a range.\n\nPseudocode:<br>\na is in range\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 1;\nlet b = 0..2;\nassert_in_range!(a, b);\n```\n\n# Module macros\n\n* [`assert_in_range`](macro@crate::assert_in_range)\n* [`assert_in_range_as_result`](macro@crate::assert_in_range_as_result)\n* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)","links":{"macro@crate::assert_in_range":163,"macro@crate::assert_in_range_as_result":164,"macro@crate::debug_assert_in_range":165},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1047":{"id":1047,"crate_id":0,"name":"assert_status_code_value_eq_x","span":{"filename":"src/assert_status/assert_status_code_value_eq_x.rs","begin":[252,0],"end":[265,1]},"visibility":"public","docs":"Assert a status code value is equal to an expression.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value = b\n\n* If true, return `a ⇒ status ⇒ code ⇒ value``.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 1;\nassert_status_code_value_eq_x!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_eq_x!(a, b);\n# });\n// assertion failed: `assert_status_code_value_eq_x!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_eq_x.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_eq_x!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_eq_x.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)\n* [`assert_status_code_value_eq_x_as_result`](macro@crate::assert_status_code_value_eq_x_as_result)\n* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)\n","links":{"macro@crate::debug_assert_status_code_value_eq_x":1049,"macro@crate::assert_status_code_value_eq_x":1047,"macro@crate::assert_status_code_value_eq_x_as_result":1048,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_eq_x {\n    ($a_process:expr, $b:expr $(,)?) => { ... };\n    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"770":{"id":770,"crate_id":0,"name":"assert_io_read_to_string_contains","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_contains.rs","begin":[219,0],"end":[232,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() contains a pattern.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) contains (expr)\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"hello\".as_bytes();\nlet containee = \"ell\";\nassert_io_read_to_string_contains!(reader, containee);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"hello\".as_bytes();\nlet containee = \"zz\";\nassert_io_read_to_string_contains!(reader, containee);\n# });\n// assertion failed: `assert_io_read_to_string_contains!(reader, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_contains.html\n//     reader label: `&reader`,\n//     reader debug: `[104, 101, 108, 108, 111]`,\n//  containee label: `containee`,\n//  containee debug: `\\\"zz\\\"`,\n//           string: `\\\"hello\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_contains!(reader, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_contains.html\\n\",\n#     \"    reader label: `reader`,\\n\",\n#     \"    reader debug: `[104, 101, 108, 108, 111]`,\\n\",\n#     \" containee label: `containee`,\\n\",\n#     \" containee debug: `\\\"zz\\\"`,\\n\",\n#     \"          string: `\\\"hello\\\"`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)\n* [`assert_io_read_to_string_contains_as_result`](macro@crate::assert_io_read_to_string_contains_as_result)\n* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_io_read_to_string_contains":772,"macro@crate::assert_io_read_to_string_contains_as_result":771,"macro@crate::assert_io_read_to_string_contains":770},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_contains {\n    ($reader:expr, $containee:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"493":{"id":493,"crate_id":0,"name":"assert_set_eq_as_result","span":{"filename":"src/assert_set/assert_set_eq.rs","begin":[45,0],"end":[78,1]},"visibility":"public","docs":"Assert a set is equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) = (b_collection ⇒ b_set)\n\n* If true, return Result `Ok((a_set, b_set))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_eq`](macro@crate::assert_set_eq)\n* [`assert_set_eq_as_result`](macro@crate::assert_set_eq_as_result)\n* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)\n","links":{"macro@crate::debug_assert_set_eq":494,"macro@crate::assert_set_eq":492,"macro@crate::assert_set_eq_as_result":493},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_eq_as_result {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n}"}},"216":{"id":216,"crate_id":0,"name":"assert_count_eq_x","span":{"filename":"src/assert_count/assert_count_eq_x.rs","begin":[1,0],"end":[335,1]},"visibility":"public","docs":"Assert a count is equal to an expression.\n\nPseudocode:<br>\na.count() = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = 1;\nassert_count_eq_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)\n* [`assert_count_eq_x_as_result`](macro@crate::assert_count_eq_x_as_result)\n* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)","links":{"macro@crate::debug_assert_count_eq_x":215,"macro@crate::assert_count_eq_x_as_result":214,"macro@crate::assert_count_eq_x":213},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1097":{"id":1097,"crate_id":0,"name":"debug_assert_result_err","span":{"filename":"src/assert_result/assert_result_err.rs","begin":[40,0],"end":[44,1]},"visibility":"public","docs":"Assert expression is Err.\n\nDeprecated. Please rename from `debug_assert_result_err` into `debug_assert_err` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_result_err` into `debug_assert_err` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_result_err {\n    ($($arg:tt)*) => { ... };\n}"}},"820":{"id":820,"crate_id":0,"name":"assert_command_stdout_lt_x","span":{"filename":"src/assert_command/assert_command_stdout_lt_x.rs","begin":[248,0],"end":[261,1]},"visibility":"public","docs":"Assert a command stdout string is less than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_lt_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stdout_lt_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stdout_lt_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_lt_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[97, 97]`,\n//     expr value: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_lt_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_lt_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[97, 97]`,\\n\",\n#     \"    expr value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)\n* [`assert_command_stdout_lt_x_as_result`](macro@crate::assert_command_stdout_lt_x_as_result)\n* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)\n","links":{"macro@crate::assert_command_stdout_lt_x_as_result":821,"macro@crate::assert_command_stdout_lt_x":820,"macro@crate::debug_assert_command_stdout_lt_x":822,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_lt_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"543":{"id":543,"crate_id":0,"name":"debug_assert_fn_eq_x","span":{"filename":"src/assert_fn/assert_fn_eq_x.rs","begin":[410,0],"end":[416,1]},"visibility":"public","docs":"Assert a function output is equal to an expression.\n\nPseudocode:<br>\nfunction(a) = b\n\nThis macro provides the same statements as [`assert_fn_eq_x`](macro.assert_fn_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)\n* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)\n* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)\n","links":{"macro@crate::assert_fn_eq_x":541,"macro@crate::debug_assert_fn_eq_x":543},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1147":{"id":1147,"crate_id":0,"name":"assert_command_stderr_contains_as_result","span":{"filename":"src/assert_command/assert_command_stderr_contains.rs","begin":[15,0],"end":[19,1]},"visibility":"public","docs":"into `assert_command_stderr_string_contains`.\nAssert a command stderr string contains a given containee.\n\nDeprecated. Please rename from `assert_command_stderr_contains_as_result`\ninto `assert_command_stderr_string_contains_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_command_stderr_contains_as_result` into `assert_command_stderr_string_contains_as_result`."},"inner":{"macro":"macro_rules! assert_command_stderr_contains_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"266":{"id":266,"crate_id":0,"name":"assert_is_match_as_result","span":{"filename":"src/assert_is_match/assert_is_match.rs","begin":[42,0],"end":[69,1]},"visibility":"public","docs":"Assert an expression (such as a regex) is a match for an expression (such as a string).\n\nPseudocode:<br>\na.is_match(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_is_match`](macro@crate::assert_is_match)\n* [`assert_is_match_as_result`](macro@crate::assert_is_match_as_result)\n* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)\n","links":{"macro@crate::assert_is_match":265,"macro@crate::debug_assert_is_match":267,"macro@crate::assert_is_match_as_result":266},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_is_match_as_result {\n    ($matcher:expr, $matchee:expr $(,)?) => { ... };\n}"}},"870":{"id":870,"crate_id":0,"name":"assert_command_stderr_gt_x","span":{"filename":"src/assert_command/assert_command_stderr_gt_x.rs","begin":[1,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stderr string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stderr_gt_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)\n* [`assert_command_stderr_gt_x_as_result`](macro@crate::assert_command_stderr_gt_x_as_result)\n* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)","links":{"macro@crate::debug_assert_command_stderr_gt_x":869,"macro@crate::assert_command_stderr_gt_x":867,"macro@crate::assert_command_stderr_gt_x_as_result":868},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"593":{"id":593,"crate_id":0,"name":"assert_fn_err_eq_x","span":{"filename":"src/assert_fn_err/assert_fn_err_eq_x.rs","begin":[1,0],"end":[471,1]},"visibility":"public","docs":"Assert a function Err(…) is equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) = expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n```\n\n# Module macros\n\n* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)\n* [`assert_fn_err_eq_x_as_result`](macro@crate::assert_fn_err_eq_x_as_result)\n* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)","links":{"macro@crate::assert_fn_err_eq_x":590,"macro@crate::debug_assert_fn_err_eq_x":592,"macro@crate::assert_fn_err_eq_x_as_result":591},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"316":{"id":316,"crate_id":0,"name":"debug_assert_len_lt_x","span":{"filename":"src/assert_len/assert_len_lt_x.rs","begin":[329,0],"end":[335,1]},"visibility":"public","docs":"Assert a length is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\nThis macro provides the same statements as [`assert_len_lt_x`](macro.assert_len_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)\n* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)\n* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)\n","links":{"macro@crate::debug_assert_len_lt_x":316,"macro@crate::assert_len_lt_x":314},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"39":{"id":39,"crate_id":0,"name":"assert_f32_gt_as_result","span":{"filename":"src/assert_f32/assert_f32_gt.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na > b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f32_gt`](macro@crate::assert_f32_gt)\n* [`assert_f32_gt_as_result`](macro@crate::assert_f32_gt_as_result)\n* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)\n","links":{"macro@crate::assert_f32_gt":38,"macro@crate::debug_assert_f32_gt":40,"macro@crate::assert_f32_gt_as_result":39},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_gt_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"920":{"id":920,"crate_id":0,"name":"assert_program_args_stdout_eq_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_eq_x.rs","begin":[276,0],"end":[289,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_program_args_stdout_eq_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_eq_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stdout_eq_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_eq_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[122, 122]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_eq_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_eq_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[122, 122]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)\n* [`assert_program_args_stdout_eq_x_as_result`](macro@crate::assert_program_args_stdout_eq_x_as_result)\n* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)\n","links":{"`panic!`":1081,"macro@crate::assert_program_args_stdout_eq_x":920,"macro@crate::debug_assert_program_args_stdout_eq_x":922,"macro@crate::assert_program_args_stdout_eq_x_as_result":921},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_eq_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"643":{"id":643,"crate_id":0,"name":"assert_fn_ok_ge_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ge_x.rs","begin":[326,0],"end":[359,1]},"visibility":"public","docs":"Assert a function Ok(…) is greater than or equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 2;\nlet b = String::from(\"1\");\nassert_fn_ok_ge_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_ge_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_ok_ge_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_ge_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"2\\\"`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"2\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_ge_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_ge_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"2\\\"`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"2\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)\n* [`assert_fn_ok_ge_x_as_result`](macro@crate::assert_fn_ok_ge_x_as_result)\n* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)\n","links":{"macro@crate::assert_fn_ok_ge_x":643,"macro@crate::debug_assert_fn_ok_ge_x":645,"macro@crate::assert_fn_ok_ge_x_as_result":644,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ge_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"366":{"id":366,"crate_id":0,"name":"assert_ok_eq","span":{"filename":"src/assert_ok/assert_ok_eq.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)\n\n* If true, return `(a1, b1)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Ok(1);\nlet b: Result<i8, i8> = Ok(1);\nassert_ok_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Ok(1);\nlet b: Result<i8, i8> = Ok(2);\nassert_ok_eq!(a, b);\n# });\n// assertion failed: `assert_ok_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ok_eq.html\n//  a label: `a`,\n//  a debug: `Ok(1)`,\n//  a inner: `1`,\n//  b label: `b`,\n//  b debug: `Ok(2)`,\n//  b inner: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ok_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ok_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Ok(1)`,\\n\",\n#     \" a inner: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Ok(2)`,\\n\",\n#     \" b inner: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ok_eq`](macro@crate::assert_ok_eq)\n* [`assert_ok_eq_as_result`](macro@crate::assert_ok_eq_as_result)\n* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)\n","links":{"macro@crate::assert_ok_eq":366,"macro@crate::assert_ok_eq_as_result":367,"macro@crate::debug_assert_ok_eq":368,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"89":{"id":89,"crate_id":0,"name":"assert_abs_diff_gt_x_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_gt_x.rs","begin":[43,0],"end":[105,1]},"visibility":"public","docs":"Assert an absolute difference is greater than an expression.\n\nPseudocode:<br>\n|Δ| > x\n\n* If true, return `Ok((lhs, rhs))`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)\n* [`assert_abs_diff_gt_x_as_result`](macro@crate::assert_abs_diff_gt_x_as_result)\n* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)\n","links":{"macro@crate::debug_assert_abs_diff_gt_x":90,"macro@crate::assert_abs_diff_gt_x":88,"`Err`":1082,"macro@crate::assert_abs_diff_gt_x_as_result":89},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_gt_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"970":{"id":970,"crate_id":0,"name":"assert_program_args_stderr_lt","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt.rs","begin":[312,0],"end":[325,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_lt!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"aa\"];\nassert_program_args_stderr_lt!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_lt.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stderr\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s\\\", \\\"aa\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_lt.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s\\\", \\\"aa\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)\n* [`assert_program_args_stderr_lt_as_result`](macro@crate::assert_program_args_stderr_lt_as_result)\n* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)\n","links":{"macro@crate::assert_program_args_stderr_lt_as_result":971,"macro@crate::assert_program_args_stderr_lt":970,"macro@crate::debug_assert_program_args_stderr_lt":972,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_lt {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"693":{"id":693,"crate_id":0,"name":"assert_fs_read_to_string_ge_x_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ge_x.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≥ expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)\n* [`assert_fs_read_to_string_ge_x_as_result`](macro@crate::assert_fs_read_to_string_ge_x_as_result)\n* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)\n","links":{"macro@crate::assert_fs_read_to_string_ge_x":692,"macro@crate::debug_assert_fs_read_to_string_ge_x":694,"macro@crate::assert_fs_read_to_string_ge_x_as_result":693},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ge_x_as_result {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"416":{"id":416,"crate_id":0,"name":"debug_assert_some_ne_x","span":{"filename":"src/assert_some/assert_some_ne_x.rs","begin":[385,0],"end":[391,1]},"visibility":"public","docs":"Assert an expression is Some and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ b\n\nThis macro provides the same statements as [`assert_some_ne_x`](macro.assert_some_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)\n* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)\n* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)\n","links":{"macro@crate::debug_assert_some_ne_x":416,"macro@crate::assert_some_ne_x":414},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_some_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"139":{"id":139,"crate_id":0,"name":"assert_diff_gt_x","span":{"filename":"src/assert_diff/assert_diff_gt_x.rs","begin":[1,0],"end":[469,1]},"visibility":"public","docs":"Assert a difference is greater than an expression.\n\nPseudocode:<br>\nΔ > x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 2;\nassert_diff_gt_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)\n* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)\n* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)","links":{"macro@crate::assert_diff_gt_x_as_result":137,"macro@crate::assert_diff_gt_x":136,"macro@crate::debug_assert_diff_gt_x":138},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1020":{"id":1020,"crate_id":0,"name":"assert_status_failure_as_result","span":{"filename":"src/assert_status/assert_status_failure.rs","begin":[41,0],"end":[78,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_failure`](macro@crate::assert_status_failure)\n* [`assert_status_failure_as_result`](macro@crate::assert_status_failure_as_result)\n* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)\n","links":{"macro@crate::assert_status_failure_as_result":1020,"macro@crate::assert_status_failure":1019,"macro@crate::debug_assert_status_failure":1021},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_failure_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"743":{"id":743,"crate_id":0,"name":"assert_io_read_to_string_ne_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne.rs","begin":[42,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)\n* [`assert_io_read_to_string_ne_as_result`](macro@crate::assert_io_read_to_string_ne_as_result)\n* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)\n","links":{"macro@crate::debug_assert_io_read_to_string_ne":744,"macro@crate::assert_io_read_to_string_ne_as_result":743,"macro@crate::assert_io_read_to_string_ne":742},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ne_as_result {\n    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };\n}"}},"466":{"id":466,"crate_id":0,"name":"assert_bag","span":{"filename":"src/assert_bag/mod.rs","begin":[1,0],"end":[116,28]},"visibility":"public","docs":"Assert for comparing bag collections.\n\nThese macros help with comparison of bag parameters, such as comparison of\ntwo arrays or two vectors, where the item order does not matter, and the\nitem count does matter. These macros convert their inputs into HashMap\niterators. See tutorial below.\n\nFor eq & ne:\n\n* [`assert_bag_eq!(collection1, collection2)`](macro@crate::assert_bag_eq) ≈ bag a = bag b\n\n* [`assert_bag_ne!(collection1, collection2)`](macro@crate::assert_bag_ne) ≈ bag a ≠ bag b\n\nFor subbag & superbag:\n\n* [`assert_bag_subbag(collection1, collection2)`](macro@crate::assert_bag_subbag) ≈ bag a ⊆ bag b\n\n* [`assert_bag_superbag!(collection1, collection2)`](macro@crate::assert_bag_superbag) ≈ bag a ⊇ bag b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 1];\nlet b = [1, 1];\nassert_bag_eq!(&a, &b);\n```\n\n## Tutorial\n\nA **bag** means a collection of elements, without any ordering, and tracking duplicate elements.\n\nA bag is sometimes written by using mathematical notation, which looks like this:\n\n```text\nbag = {1, 1, 1, 2, 3}\n```\n\nBags are equal when they contain all the same elements and corresponding counts in any order:\n\n```text\n{1, 1, 1, 2, 3} = {1, 1, 1, 2, 3} (same order)\n{1, 1, 1, 2, 3} = {1, 3, 1, 2, 1} (different order)\n```\n\nBags are not equal when they contain any different elements or any different corresponding counts:\n\n```text\n{1, 1, 1, 2, 3} ≠ {1, 1, 2, 3}\n{1, 1, 1, 2, 3} ≠ {1, 1, 1, 2, 3, 4}\n```\n\nTo create a bag using Rust, one way is to create an array or vector, then convert it into an iterator by using the method `into_iter`, then convert the elements into a map by using `std::collections::BTreeMap` and tracking each element's count:\n\n```rust\n# use ::std::collections::BTreeMap;\nlet array = [1, 1, 1, 2, 3];\nlet mut bag: BTreeMap<_, usize> = BTreeMap::new();\nfor x in array.into_iter() {\n    let n = bag.entry(x).or_insert(0);\n    *n += 1;\n}\n```\n\nTo compare two arrays as bags, one way is to convert each array to a bag, then use `assert_eq!` to compare the bags:\n\n```rust\n# use ::std::collections::BTreeMap;\nlet array1 = [1, 1, 1, 2, 3];\nlet array2 = [1, 3, 1, 2, 1];\nlet mut bag1: BTreeMap<_, usize> = BTreeMap::new();\nfor x in array1.into_iter() {\n    let n = bag1.entry(x).or_insert(0);\n    *n += 1;\n}\nlet mut bag2: BTreeMap<_, usize> = BTreeMap::new();\nfor x in array2.into_iter() {\n    let n = bag2.entry(x).or_insert(0);\n    *n += 1;\n}\nassert_eq!(bag1, bag2);\n```\n\nThe `assertables` crate provides macros that do the conversion for you:\n\n```rust\n# use ::std::collections::BTreeMap;\n# use assertables::*;\nlet array1 = [1, 2, 3];\nlet array2 = [3, 2, 1];\nassert_bag_eq!(array1, array2);\n```","links":{"macro@crate::assert_bag_superbag":462,"macro@crate::assert_bag_eq":450,"macro@crate::assert_bag_subbag":458,"macro@crate::assert_bag_ne":454},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[453,457,461,465],"is_stripped":false}}},"1070":{"id":1070,"crate_id":0,"name":"assert_status","span":{"filename":"src/assert_status/mod.rs","begin":[1,0],"end":[63,38]},"visibility":"public","docs":"Assert for comparing status concepts.\n\nThese macros help with commands, program, processes, and anything else that\nprovides a method `status()`, and optionally status methods such as:\n\n* `success() => bool`\n* `code() => Result(T, E)`\n\nTry success/failure:\n\n* [`assert_status_success!(a)`](macro@crate::assert_status_success) ≈ a.status().success() = true``\n* [`assert_status_success_false!(a)`](macro@crate::assert_status_success_false) ≈ a.status().success() = false``\n* [`assert_status_failure!(a)`](macro@crate::assert_status_failure) ≈ a.status().success() = false``\n\nCompare a status code with another status code:\n\n* [`assert_status_code_value_eq!(a, b)`](macro@crate::assert_status_code_value_eq) ≈ a.len() = b.len()\n* [`assert_status_code_value_ne!(a, b)`](macro@crate::assert_status_code_value_ne) ≈ a.len() ≠ b.len()\n* [`assert_status_code_value_lt!(a, b)`](macro@crate::assert_status_code_value_lt) ≈ a.len() < b.len()\n* [`assert_status_code_value_le!(a, b)`](macro@crate::assert_status_code_value_le) ≈ a.len() ≤ b.len()\n* [`assert_status_code_value_gt!(a, b)`](macro@crate::assert_status_code_value_gt) ≈ a.len() > b.len()\n* [`assert_status_code_value_ge!(a, b)`](macro@crate::assert_status_code_value_ge) ≈ a.len() ≥ b.len()\n\nCompare a status code with an expression:\n\n* [`assert_status_code_value_eq_x!(a, expr)`](macro@crate::assert_status_code_value_eq_x) ≈ a.len() = expr\n* [`assert_status_code_value_ne_x!(a, expr)`](macro@crate::assert_status_code_value_ne_x) ≈ a.len() ≠ expr\n* [`assert_status_code_value_lt_x!(a, expr)`](macro@crate::assert_status_code_value_lt_x) ≈ a.len() < expr\n* [`assert_status_code_value_le_x!(a, expr)`](macro@crate::assert_status_code_value_le_x) ≈ a.len() ≤ expr\n* [`assert_status_code_value_gt_x!(a, expr)`](macro@crate::assert_status_code_value_gt_x) ≈ a.len() > expr\n* [`assert_status_code_value_ge_x!(a, expr)`](macro@crate::assert_status_code_value_ge_x) ≈ a.len() ≥ expr\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_eq!(a, b);\n```","links":{"macro@crate::assert_status_code_value_le":1035,"macro@crate::assert_status_success_false":1015,"macro@crate::assert_status_code_value_eq_x":1047,"macro@crate::assert_status_failure":1019,"macro@crate::assert_status_code_value_ge_x":1051,"macro@crate::assert_status_code_value_ne_x":1069,"macro@crate::assert_status_code_value_ge":1027,"macro@crate::assert_status_code_value_lt_x":1063,"macro@crate::assert_status_code_value_gt_x":1055,"macro@crate::assert_status_success":1011,"macro@crate::assert_status_code_value_ne":1043,"macro@crate::assert_status_code_value_le_x":1059,"macro@crate::assert_status_code_value_gt":1031,"macro@crate::assert_status_code_value_eq":1023,"macro@crate::assert_status_code_value_lt":1039},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[1014,1018,1022,1026,1030,1034,1038,1042,1046,1050,1054,1058,1062,1066,1068],"is_stripped":false}}},"189":{"id":189,"crate_id":0,"name":"assert_count_eq","span":{"filename":"src/assert_count/assert_count_eq.rs","begin":[218,0],"end":[231,1]},"visibility":"public","docs":"Assert a count is equal to another.\n\nPseudocode:<br>\na.count() = b.count()\n\n* If true, return `(a.count(), b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = \"x\".chars();\nlet b = \"x\".chars();\nassert_count_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_eq!(a, b);\n# });\n// assertion failed: `assert_count_eq!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_count_eq.html\n//  a label: `a`,\n//  a debug: `Chars(['x'])`,\n//  a.count(): `1`\",\n//  b label: `b`,\n//  b debug: `Chars(['x', 'x'])`,\n//  b.count(): `2`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_count_eq!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_count_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Chars(['x'])`,\\n\",\n#     \" a.count(): `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `Chars(['x', 'x'])`\\n\",\n#     \" b.count(): `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_count_eq`](macro@crate::assert_count_eq)\n* [`assert_count_eq_as_result`](macro@crate::assert_count_eq_as_result)\n* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)\n","links":{"`panic!`":1081,"macro@crate::assert_count_eq_as_result":190,"macro@crate::debug_assert_count_eq":191,"macro@crate::assert_count_eq":189},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_count_eq {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"793":{"id":793,"crate_id":0,"name":"assert_command_stdout_le_as_result","span":{"filename":"src/assert_command/assert_command_stdout_le.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_le`](macro@crate::assert_command_stdout_le)\n* [`assert_command_stdout_le_as_result`](macro@crate::assert_command_stdout_le_as_result)\n* [`debug_assert_command_stdout_le`](macro@crate::debug_assert_command_stdout_le)\n","links":{"macro@crate::assert_command_stdout_le_as_result":793,"macro@crate::debug_assert_command_stdout_le":794,"macro@crate::assert_command_stdout_le":792},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_le_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"516":{"id":516,"crate_id":0,"name":"assert_set","span":{"filename":"src/assert_set/mod.rs","begin":[1,0],"end":[115,28]},"visibility":"public","docs":"Assert for comparing set collections.\n\nThese macros help with comparison of set parameters, such as two arrays or\ntwo vectors. where the item order does not matter, and the item count does\nnot matter. These macros convert their inputs into HashSet iterators.\nSee tutorial below.\n\nFor eq & ne:\n\n* [`assert_set_eq!(collection1, collection2)`](macro@crate::assert_set_eq) ≈ set a = set b\n\n* [`assert_set_ne!(collection1, collection2)`](macro@crate::assert_set_ne) ≈ set a ≠ set b\n\nFor subset & superset:\n\n* [`assert_set_subset!(collection1, collection2)`](macro@crate::assert_set_subset) ≈ set a ⊆ set b\n\n* [`assert_set_superset!(collection1, collection2)`](macro@crate::assert_set_superset) ≈ set a ⊇ set b\n\nFor joint & disjoint:\n\n* [`assert_set_joint!(collection1, collection2)`](macro@crate::assert_set_joint) ≈ set a ∩ set b ≠ ∅\n\n* [`assert_set_disjoint!(collection1, collection2)`](macro@crate::assert_set_disjoint) ≈ set a ∩ set b = ∅\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = [1, 2];\nlet b = [2, 1];\nassert_set_eq!(&a, &b);\n```\n\n## Tutorial\n\nA **set** means a collection of elements, without any ordering, without duplicate elements.\n\nA set is sometimes written by using mathematical notation, which looks like this:\n\n```text\nset = {1, 2, 3}\n```\n\nThe definition of a set includes never having duplicate elements:\n\n```text\nset = {1, 2, 3, 2} // error because the element 2 is a duplicate\n```\n\nSets are equal when they contain all the same elements in any order:\n\n```text\n{1, 2, 3} = {1, 2, 3} (same order)\n{1, 2, 3} = {3, 2, 1} (different order)\n```\n\nSets are not equal when they contain any different elements:\n\n```text\n{1, 2, 3} ≠ {1, 2}\n{1, 2, 3} ≠ {1, 2, 3, 4}\n```\n\nTo create a set using Rust, one way is to create an array or vector, then convert it into an iterator by using the method `into_iter`, then convert the elements into a set by using `std::collections::BTreeSet`:\n\n```rust\n# use ::std::collections::BTreeSet;\nlet array = [1, 2, 3];\nlet set: BTreeSet<_> = array.into_iter().collect();\n```\n\nTo compare two arrays as sets, one way is to convert each array to a set, then use `assert_eq!` to compare the sets:\n\n```rust\n# use ::std::collections::BTreeSet;\nlet array1 = [1, 2, 3];\nlet array2 = [3, 2, 1];\nlet set1: BTreeSet<_> = array1.into_iter().collect();\nlet set2: BTreeSet<_> = array2.into_iter().collect();\nassert_eq!(set1, set2);\n```\n\nThe `assertables` crate provides macros that do the conversion for you:\n\n```rust\n# use ::std::collections::BTreeSet;\n# use assertables::*;\nlet array1 = [1, 2, 3];\nlet array2 = [3, 2, 1];\nassert_set_eq!(array1, array2);\n```","links":{"macro@crate::assert_set_joint":504,"macro@crate::assert_set_ne":496,"macro@crate::assert_set_eq":492,"macro@crate::assert_set_disjoint":500,"macro@crate::assert_set_subset":508,"macro@crate::assert_set_superset":512},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[495,499,503,507,511,515],"is_stripped":false}}},"239":{"id":239,"crate_id":0,"name":"assert_email_address_as_result","span":{"filename":"src/assert_email_address/assert_email_address.rs","begin":[40,0],"end":[172,1]},"visibility":"public","docs":"Assert expression is possibly an email address.\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_email_address`](macro@crate::assert_email_address)\n* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)\n* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)\n","links":{"macro@crate::assert_email_address":238,"macro@crate::assert_email_address_as_result":239,"macro@crate::debug_assert_email_address":240},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_email_address_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"1120":{"id":1120,"crate_id":0,"name":"assert_poll_pending","span":{"filename":"src/assert_poll/assert_poll_pending.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert an expression is Pending.\n\nDeprecated. Please rename from `assert_poll_pending` into `assert_pending` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_poll_pending` into `assert_pending` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_poll_pending {\n    ($($arg:tt)*) => { ... };\n}"}},"843":{"id":843,"crate_id":0,"name":"assert_command_stderr_gt","span":{"filename":"src/assert_command/assert_command_stderr_gt.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a command stderr string is greater than another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stderr_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_gt!(a, b);\n# });\n// assertion failed: `assert_command_stderr_gt!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_gt.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"zz\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_gt!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"zz\\\"`,\\n\",\n#     \" b value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_gt`](macro@crate::assert_command_stderr_gt)\n* [`assert_command_stderr_gt_as_result`](macro@crate::assert_command_stderr_gt_as_result)\n* [`debug_assert_command_stderr_gt`](macro@crate::debug_assert_command_stderr_gt)\n","links":{"macro@crate::debug_assert_command_stderr_gt":845,"macro@crate::assert_command_stderr_gt_as_result":844,"macro@crate::assert_command_stderr_gt":843,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_gt {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"566":{"id":566,"crate_id":0,"name":"assert_fn_err_eq","span":{"filename":"src/assert_fn_err/assert_fn_err_eq.rs","begin":[321,0],"end":[355,1]},"visibility":"public","docs":"Assert a function error is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n* e, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 10;\nlet b: i8 = 10;\nassert_fn_err_eq!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_eq!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_err_eq!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_err_eq.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `10`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `20`,\n//                 a: `\\\"10 is out of range\\\"`,\n//                 b: `\\\"20 is out of range\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_err_eq!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_err_eq.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `10`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `20`,\\n\",\n#     \"                a: `\\\"10 is out of range\\\"`,\\n\",\n#     \"                b: `\\\"20 is out of range\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)\n* [`assert_fn_err_eq_as_result`](macro@crate::assert_fn_err_eq_as_result)\n* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)\n","links":{"`panic!`":1081,"macro@crate::assert_fn_err_eq":566,"macro@crate::debug_assert_fn_err_eq":568,"macro@crate::assert_fn_err_eq_as_result":567},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_err_eq {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"289":{"id":289,"crate_id":0,"name":"assert_len_le","span":{"filename":"src/assert_len/assert_len_le.rs","begin":[1,0],"end":[345,1]},"visibility":"public","docs":"Assert a length is less than or equal to another.\n\nPseudocode:<br>\na.len() ≤ b.len()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = \"xx\";\nassert_len_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_le`](macro@crate::assert_len_le)\n* [`assert_len_le_as_result`](macro@crate::assert_len_le_as_result)\n* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)","links":{"macro@crate::assert_len_le_as_result":287,"macro@crate::debug_assert_len_le":288,"macro@crate::assert_len_le":286},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"893":{"id":893,"crate_id":0,"name":"assert_program_args","span":{"filename":"src/assert_program_args/mod.rs","begin":[1,0],"end":[170,51]},"visibility":"public","docs":"Assert for comparing programs with arguments.\n\nThese macros help with calling external programs with arguments, then\ncapturing the standard output stream and standard error stream.\nSee tutorial below.\n\nThese macros have corresponding macros in the module [`assert_command`](module@crate::assert_command).\n\n## Program args stdout\n\nCompare program and arguments standard output to another program and arguments standard output:\n\n* [`assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_eq) ≈ command using a_program and a_args to stdout = b_command with b_program and b_args to stdout\n* [`assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_ne) ≈ command using a_program and a_args to stdout ≠ b_command with b_program and b_args to stdout\n* [`assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_lt) ≈ command using a_program and a_args to stdout < b_command with b_program and b_args to stdout\n* [`assert_program_args_stdout_le!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_le) ≈ command using a_program and a_args to stdout ≤ b_command with b_program and b_args to stdout\n* [`assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_gt) ≈ command using a_program and a_args to stdout > b_command with b_program and b_args to stdout\n* [`assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_ge) ≈ command using a_program and a_args to stdout ≥ b_command with b_program and b_args to stdout\n\nCompare program and arguments standard output to an expression:\n\n* [`assert_program_args_stdout_eq_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_eq_x) ≈ command using program and args to stdout = expr\n* [`assert_program_args_stdout_ne_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_ne_x) ≈ command using program and args to stdout ≠ expr\n* [`assert_program_args_stdout_lt_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_lt_x) ≈ command using program and args to stdout < expr\n* [`assert_program_args_stdout_le_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_le_x) ≈ command using program and args to stdout ≤ expr\n* [`assert_program_args_stdout_gt_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_gt_x) ≈ command using program and args to stdout > expr\n* [`assert_program_args_stdout_ge_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_ge_x) ≈ command using program and args to stdout ≥ expr\n\nAssert program and arguments standard output as a string:\n\n* [`assert_program_args_stdout_string_contains!(program, args, containee)`](macro@crate::assert_program_args_stdout_string_contains) ≈ command using program and args to stdout string contains containee\n* [`assert_program_args_stdout_string_is_match!(program, args, matcher)`](macro@crate::assert_program_args_stdout_string_is_match) ≈ matcher is match with command using program and args\n\n## Program args stderr\n\nCompare program and arguments standard error to another program and arguments standard error:\n\n* [`assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_eq) ≈ command using a_program and a_args to stderr = b_command with b_program and b_args to stderr\n* [`assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_ne) ≈ command using a_program and a_args to stderr ≠ b_command with b_program and b_args to stderr\n* [`assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_lt) ≈ command using a_program and a_args to stderr < b_command with b_program and b_args to stderr\n* [`assert_program_args_stderr_le!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_le) ≈ command using a_program and a_args to stderr ≤ b_command with b_program and b_args to stderr\n* [`assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_gt) ≈ command using a_program and a_args to stderr > b_command with b_program and b_args to stderr\n* [`assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_ge) ≈ command using a_program and a_args to stderr ≥ b_command with b_program and b_args to stderr\n\nCompare program and arguments standard error to an expression:\n\n* [`assert_program_args_stderr_eq_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_eq_x) ≈ command using program and args to stderr = expr\n* [`assert_program_args_stderr_ne_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_ne_x) ≈ command using program and args to stderr ≠ expr\n* [`assert_program_args_stderr_lt_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_lt_x) ≈ command using program and args to stderr < expr\n* [`assert_program_args_stderr_le_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_le_x) ≈ command using program and args to stderr ≤ expr\n* [`assert_program_args_stderr_gt_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_gt_x) ≈ command using program and args to stderr > expr\n* [`assert_program_args_stderr_ge_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_ge_x) ≈ command using program and args to stderr ≥ expr\n\nAssert program and arguments standard error as a string:\n\n* [`assert_program_args_stderr_string_contains!(program, args, containee)`](macro@crate::assert_program_args_stderr_string_contains) ≈ command using program and args to stderr string contains containee\n* [`assert_program_args_stderr_string_is_match!(program, args, matcher)`](macro@crate::assert_program_args_stderr_string_is_match) ≈ matcher is match with command using program and args\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"];\nassert_program_args_stdout_eq!(&a_program, &a_args, &b_program, &b_args);\n```\n\n## Tutorial\n\nRust programs can call system commands.\n\nFor example this system command will print the word hello:\n\n```sh\nprintf %s hello\n```\n\nRust can create a system command then capture its standard output, by using:\n\n```rust\n# use std::process::Command;\nlet program = \"printf\";\nlet args = [\"%s\", \"hello\"];\nlet mut command = Command::new(program);\ncommand.args(args);\nlet stdout = command.output().unwrap().stdout;\n```\n\nRust can compare a command's standard output to another command's standard output, by using:\n\n```rust\n# use std::process::Command;\nlet a_program = \"printf\";\nlet a_args = [\"%s\", \"hello\"];\nlet b_program = \"printf\";\nlet b_args = [\"%s\", \"world\"];\nlet mut a_command = Command::new(a_program); a_command.args(a_args);\nlet mut b_command = Command::new(b_program); b_command.args(b_args);\nlet a_stdout = a_command.output().unwrap().stdout;\nlet b_stdout = b_command.output().unwrap().stdout;\nassert_ne!(a_stdout, b_stdout);\n```\n\nThe `assertables` crate provides macros that do the same kind of processing, by automatically converting programs and args into commands, then to standard outputs:\n\n```rust\n# use std::process::Command;\n# use assertables::*;\nlet a_program = \"printf\";\nlet a_args = [\"%s\", \"hello\"];\nlet b_program = \"printf\";\nlet b_args = [\"%s\", \"world\"];\nassert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);\n```","links":{"macro@crate::assert_program_args_stdout_lt_x":936,"macro@crate::assert_program_args_stdout_lt":912,"macro@crate::assert_program_args_stdout_ne":916,"macro@crate::assert_program_args_stdout_le":908,"macro@crate::assert_program_args_stderr_eq_x":978,"macro@crate::assert_program_args_stderr_lt_x":993,"macro@crate::assert_program_args_stdout_ne_x":940,"macro@crate::assert_program_args_stderr_gt":962,"macro@crate::assert_program_args_stderr_gt_x":985,"macro@crate::assert_program_args_stdout_le_x":932,"macro@crate::assert_program_args_stderr_ge":958,"macro@crate::assert_program_args_stderr_le":966,"macro@crate::assert_program_args_stdout_ge_x":924,"macro@crate::assert_program_args_stderr_ne":974,"macro@crate::assert_program_args_stdout_eq_x":920,"module@crate::assert_command":895,"macro@crate::assert_program_args_stdout_ge":900,"macro@crate::assert_program_args_stdout_gt":904,"macro@crate::assert_program_args_stderr_eq":954,"macro@crate::assert_program_args_stderr_string_contains":1003,"macro@crate::assert_program_args_stdout_string_contains":946,"macro@crate::assert_program_args_stdout_string_is_match":950,"macro@crate::assert_program_args_stdout_gt_x":928,"macro@crate::assert_program_args_stdout_eq":896,"macro@crate::assert_program_args_stderr_le_x":989,"macro@crate::assert_program_args_stderr_string_is_match":1007,"macro@crate::assert_program_args_stderr_ge_x":982,"macro@crate::assert_program_args_stderr_lt":970,"macro@crate::assert_program_args_stderr_ne_x":997},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[899,903,907,911,915,919,923,927,931,935,939,943,944,945,949,953,957,961,965,969,973,977,981,984,988,992,996,1000,1001,1002,1006,1010],"is_stripped":false}}},"12":{"id":12,"crate_id":0,"name":"assert_le","span":{"filename":"src/assert_le.rs","begin":[331,0],"end":[344,1]},"visibility":"public","docs":"Assert an expression is less than or equal to another.\n\nPseudocode:<br>\na ≤ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 1;\nlet b = 2;\nassert_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 2;\nlet b = 1;\nassert_le!(a, b);\n# });\n// assertion failed: `assert_le!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_le.html\n//  a label: `a`,\n//  a debug: `2`,\n//  b label: `b`,\n//  b debug: `1`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_le!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_le`](macro@crate::assert_le)\n* [`assert_le_as_result`](macro@crate::assert_le_as_result)\n* [`debug_assert_le`](macro@crate::debug_assert_le)\n","links":{"macro@crate::assert_le_as_result":13,"macro@crate::debug_assert_le":14,"macro@crate::assert_le":12,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_le {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"616":{"id":616,"crate_id":0,"name":"assert_fn_ok_eq_as_result","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq.rs","begin":[47,0],"end":[169,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return Result `Ok(a, b)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)\n* [`assert_fn_ok_eq_as_result`](macro@crate::assert_fn_ok_eq_as_result)\n* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)\n","links":{"macro@crate::assert_fn_ok_eq":615,"macro@crate::assert_fn_ok_eq_as_result":616,"macro@crate::debug_assert_fn_ok_eq":617},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_eq_as_result {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n}"}},"339":{"id":339,"crate_id":0,"name":"assert_starts_with","span":{"filename":"src/assert_starts_with/assert_starts_with.rs","begin":[1,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) starts with an expression (such as a string).\n\nPseudocode:<br>\na.starts_with(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String starts with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"al\";\nassert_starts_with!(sequence, subsequence);\n\n// Vector starts with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [1];\nassert_starts_with!(sequence, subsequence);\n```\n\n# Module macros\n\n* [`assert_starts_with`](macro@crate::assert_starts_with)\n* [`assert_starts_with_as_result`](macro@crate::assert_starts_with_as_result)\n* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)","links":{"macro@crate::assert_starts_with_as_result":337,"macro@crate::assert_starts_with":336,"macro@crate::debug_assert_starts_with":338},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"62":{"id":62,"crate_id":0,"name":"assert_f64_ge","span":{"filename":"src/assert_f64/assert_f64_ge.rs","begin":[1,0],"end":[387,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is greater than or equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≥ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333329;\nassert_f64_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_f64_ge`](macro@crate::assert_f64_ge)\n* [`assert_f64_ge_as_result`](macro@crate::assert_f64_ge_as_result)\n* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)","links":{"macro@crate::assert_f64_ge":59,"macro@crate::assert_f64_ge_as_result":60,"macro@crate::debug_assert_f64_ge":61},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"943":{"id":943,"crate_id":0,"name":"assert_program_args_stdout_ne_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne_x.rs","begin":[1,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'x', b'x'];\nassert_program_args_stdout_ne_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)\n* [`assert_program_args_stdout_ne_x_as_result`](macro@crate::assert_program_args_stdout_ne_x_as_result)\n* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)","links":{"macro@crate::assert_program_args_stdout_ne_x":940,"macro@crate::debug_assert_program_args_stdout_ne_x":942,"macro@crate::assert_program_args_stdout_ne_x_as_result":941},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"666":{"id":666,"crate_id":0,"name":"debug_assert_fs_read_to_string_eq","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq.rs","begin":[399,0],"end":[405,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)\n\nThis macro provides the same statements as [`assert_fs_read_to_string_eq`](macro.assert_fs_read_to_string_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)\n* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)\n* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)\n","links":{"macro@crate::assert_fs_read_to_string_eq":664,"macro@crate::debug_assert_fs_read_to_string_eq":666},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"389":{"id":389,"crate_id":0,"name":"assert_none_as_result","span":{"filename":"src/assert_none/assert_none.rs","begin":[40,0],"end":[60,1]},"visibility":"public","docs":"Assert an expression is None.\n\nPseudocode:<br>\na is None\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_none`](macro@crate::assert_none)\n* [`assert_none_as_result`](macro@crate::assert_none_as_result)\n* [`debug_assert_none`](macro@crate::debug_assert_none)\n","links":{"macro@crate::debug_assert_none":390,"macro@crate::assert_none":388,"macro@crate::assert_none_as_result":389},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_none_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"112":{"id":112,"crate_id":0,"name":"assert_abs_diff_lt","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt.rs","begin":[25,0],"end":[29,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nDeprecated. Please rename from `assert_abs_diff_lt` into `assert_abs_diff_lt_x`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_lt` into `assert_abs_diff_lt_x`."},"inner":{"macro":"macro_rules! assert_abs_diff_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"993":{"id":993,"crate_id":0,"name":"assert_program_args_stderr_lt_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_lt_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_lt_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stderr_lt_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stderr_lt_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_lt_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[97, 97]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_lt_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_lt_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[97, 97]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)\n* [`assert_program_args_stderr_lt_x_as_result`](macro@crate::assert_program_args_stderr_lt_x_as_result)\n* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)\n","links":{"macro@crate::assert_program_args_stderr_lt_x":993,"macro@crate::debug_assert_program_args_stderr_lt_x":995,"macro@crate::assert_program_args_stderr_lt_x_as_result":994,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_lt_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"716":{"id":716,"crate_id":0,"name":"assert_fs_read_to_string_is_match","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_is_match.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) matches expr\n\n* If true, return `path_into_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\nuse regex::Regex;\n\n# fn main() {\nlet path = \"alfa.txt\";\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_fs_read_to_string_is_match!(path, matcher);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"alfa.txt\";\nlet matcher = Regex::new(r\"zz\").expect(\"regex\");\nassert_fs_read_to_string_is_match!(path, matcher);\n# });\n// assertion failed: `assert_fs_read_to_string_is_match!(path, matcher)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_is_match.html\n//     path label: `path`,\n//     path debug: `\\\"alfa.txt\\\"`,\n//  matcher label: `matcher`,\n//  matcher debug: `Regex(\\\"zz\\\")`,\n//         string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_is_match!(path, matcher)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_is_match.html\\n\",\n#     \"    path label: `path`,\\n\",\n#     \"    path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" matcher label: `matcher`,\\n\",\n#     \" matcher debug: `Regex(\\\"zz\\\")`,\\n\",\n#     \"        string: `\\\"alfa\\\\n\\\"`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)\n* [`assert_fs_read_to_string_is_match_as_result`](macro@crate::assert_fs_read_to_string_is_match_as_result)\n* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fs_read_to_string_is_match":718,"macro@crate::assert_fs_read_to_string_is_match_as_result":717,"macro@crate::assert_fs_read_to_string_is_match":716},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_is_match {\n    ($path:expr, $matcher:expr $(,)?) => { ... };\n    ($path:expr, $matcher:expr, $($message:tt)+) => { ... };\n}"}},"439":{"id":439,"crate_id":0,"name":"debug_assert_ready_ne","span":{"filename":"src/assert_ready/assert_ready_ne.rs","begin":[327,0],"end":[333,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)\n\nThis macro provides the same statements as [`assert_ready_ne`](macro.assert_ready_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ready_ne`](macro@crate::assert_ready_ne)\n* [`assert_ready_ne`](macro@crate::assert_ready_ne)\n* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)\n","links":{"macro@crate::assert_ready_ne":437,"macro@crate::debug_assert_ready_ne":439},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ready_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"162":{"id":162,"crate_id":0,"name":"assert_in_epsilon","span":{"filename":"src/assert_in/assert_in_epsilon.rs","begin":[1,0],"end":[389,1]},"visibility":"public","docs":"Assert a number is within epsilon of another.\n\nPseudocode:<br>\n| a - b | ≤ ε * min(a, b)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 20;\nlet epsilon: i8 = 1;\nassert_in_epsilon!(a, b, epsilon);\n```\n\n## Comparisons\n\nThis crate provides macro groups that test approximations and nearness:\n\n* [`assert_approx_eq`](macro@crate::assert_approx_eq) and\n  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate\n  equality within 1e-6. The macro name and the approximate value are chosen\n  to be similar to the longtime popular rust crate `assert_approx_eq`.\n\n* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error\n  (i.e. delta). This is the magnitude of the difference between the exact\n  value and the approximation.\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative\n  error (i.e. epsilon). This is the absolute error divided by the magnitude\n  of the exact value. This can be used to compare approximations of numbers\n  of wildly differing size.\n\nExamples:\n\n* Approximating the number 100 and 103 has an absolute error (delta) of 3\n  and a relative error (epsilon) of 0.03.\n\n* Approximating the number 1,000,000 and 1,000,003 has an absolute error\n  (delta) of 3, and a relative error (epsilon) of 0.000003.\n\n* For many kinds of applications, the relative error is more important than\n  the absolute error.\n\n## Thanks\n\n* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for\n  creating and maintaining the `assert_approx_eq` crate.\n\n* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for\n  creating and maintaining `assert_in_delta` and `assert_in_epsilon` code.\n\n# Module macros\n\n* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)\n* [`assert_in_epsilon_as_result`](macro@crate::assert_in_epsilon_as_result)\n* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)","links":{"macro@crate::assert_in_delta":119,"macro@crate::assert_approx_eq":117,"macro@crate::assert_approx_ne":118,"macro@crate::assert_in_epsilon_as_result":160,"macro@crate::debug_assert_in_epsilon":161,"macro@crate::assert_in_epsilon":120},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1043":{"id":1043,"crate_id":0,"name":"assert_status_code_value_ne","span":{"filename":"src/assert_status/assert_status_code_value_ne.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a status code value is not equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_ne!(a, b);\n# });\n// assertion failed: `assert_status_code_value_ne!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_ne.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `1`\",\n//  b label: `b`,\n//  b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  b value: `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_ne!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\\n\",\n#     \"  a code: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`\\n\",\n#     \"  b code: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)\n* [`assert_status_code_value_ne_as_result`](macro@crate::assert_status_code_value_ne_as_result)\n* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)\n","links":{"macro@crate::debug_assert_status_code_value_ne":1045,"macro@crate::assert_status_code_value_ne_as_result":1044,"macro@crate::assert_status_code_value_ne":1043,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_ne {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };\n}"}},"766":{"id":766,"crate_id":0,"name":"assert_io_read_to_string_ne_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_ne_x.rs","begin":[264,0],"end":[277,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() is not equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_ne_x!(reader, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"alfa\");\nassert_io_read_to_string_ne_x!(reader, x);\n# });\n// assertion failed: `assert_io_read_to_string_ne_x!(a_reader, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_ne_x.html\n//  a_reader label: `reader`,\n//  a_reader debug: `[97, 108, 102, 97]`,\n//    b_expr label: `x`,\n//    b_expr debug: `\\\"alfa\\\"`,\n//               a: `\\\"alfa\\\"`,\n//               b: `\\\"alfa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_ne_x!(a_reader, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_ne_x.html\\n\",\n#     \" a_reader label: `reader`,\\n\",\n#     \" a_reader debug: `[97, 108, 102, 97]`,\\n\",\n#     \"   b_expr label: `x`,\\n\",\n#     \"   b_expr debug: `\\\"alfa\\\"`,\\n\",\n#     \"              a: `\\\"alfa\\\"`,\\n\",\n#     \"              b: `\\\"alfa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)\n* [`assert_io_read_to_string_ne_x_as_result`](macro@crate::assert_io_read_to_string_ne_x_as_result)\n* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)\n","links":{"macro@crate::debug_assert_io_read_to_string_ne_x":768,"macro@crate::assert_io_read_to_string_ne_x":766,"macro@crate::assert_io_read_to_string_ne_x_as_result":767,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_ne_x {\n    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"489":{"id":489,"crate_id":0,"name":"debug_assert_iter_ne","span":{"filename":"src/assert_iter/assert_iter_ne.rs","begin":[253,0],"end":[259,1]},"visibility":"public","docs":"Assert an iterable is not equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≠ (collection2 into iter)\n\nThis macro provides the same statements as [`assert_iter_ne`](macro.assert_iter_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_iter_ne`](macro@crate::assert_iter_ne)\n* [`assert_iter_ne`](macro@crate::assert_iter_ne)\n* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)\n","links":{"macro@crate::debug_assert_iter_ne":489,"macro@crate::assert_iter_ne":487},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_iter_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"212":{"id":212,"crate_id":0,"name":"assert_count_ne","span":{"filename":"src/assert_count/assert_count_ne.rs","begin":[1,0],"end":[345,1]},"visibility":"public","docs":"Assert a count is not equal to another.\n\nPseudocode:<br>\na.count() ≠ b.count()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_ne`](macro@crate::assert_count_ne)\n* [`assert_count_ne_as_result`](macro@crate::assert_count_ne_as_result)\n* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)","links":{"macro@crate::assert_count_ne":209,"macro@crate::debug_assert_count_ne":211,"macro@crate::assert_count_ne_as_result":210},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1093":{"id":1093,"crate_id":0,"name":"assert_abs_diff_ne_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ne.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an absolute difference is not equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_ne_as_result` into `assert_abs_diff_ne_x_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_ne_as_result` into `assert_abs_diff_ne_x_as_result`."},"inner":{"macro":"macro_rules! assert_abs_diff_ne_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"816":{"id":816,"crate_id":0,"name":"assert_command_stdout_le_x","span":{"filename":"src/assert_command/assert_command_stdout_le_x.rs","begin":[270,0],"end":[283,1]},"visibility":"public","docs":"Assert a command stdout string is less than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_le_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stdout_le_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stdout_le_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_le_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[97, 97]`,\n//     expr value: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_le_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_le_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[97, 97]`,\\n\",\n#     \"    expr value: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)\n* [`assert_command_stdout_le_x_as_result`](macro@crate::assert_command_stdout_le_x_as_result)\n* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)\n","links":{"macro@crate::assert_command_stdout_le_x":816,"macro@crate::assert_command_stdout_le_x_as_result":817,"macro@crate::debug_assert_command_stdout_le_x":818,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_le_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"539":{"id":539,"crate_id":0,"name":"debug_assert_fn_ne","span":{"filename":"src/assert_fn/assert_fn_ne.rs","begin":[430,0],"end":[436,1]},"visibility":"public","docs":"Assert a function output is not equal to another.\n\nPseudocode:<br>\na_function(a) ≠ b_function(b)\n\nThis macro provides the same statements as [`assert_fn_ne`](macro.assert_fn_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_ne`](macro@crate::assert_fn_ne)\n* [`assert_fn_ne`](macro@crate::assert_fn_ne)\n* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)\n","links":{"macro@crate::debug_assert_fn_ne":539,"macro@crate::assert_fn_ne":537},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"262":{"id":262,"crate_id":0,"name":"debug_assert_not_empty","span":{"filename":"src/assert_is_empty/assert_not_empty.rs","begin":[244,0],"end":[250,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is not empty.\n\nPseudocode:<br>\n¬ a.is_empty()\n\nThis macro provides the same statements as [`assert_not_empty`](macro.assert_not_empty.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_not_empty`](macro@crate::assert_not_empty)\n* [`assert_not_empty`](macro@crate::assert_not_empty)\n* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)\n","links":{"macro@crate::debug_assert_not_empty":262,"macro@crate::assert_not_empty":260},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_not_empty {\n    ($($arg:tt)*) => { ... };\n}"}},"1143":{"id":1143,"crate_id":0,"name":"debug_assert_command_stdout_contains","span":{"filename":"src/assert_command/assert_command_stdout_contains.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a command stdout string contains a given containee.\n\nDeprecated. Please rename from `debug_assert_command_stdout_contains` into `debug_assert_command_stdout_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_command_stdout_contains` into `debug_assert_command_stdout_string_contains`."},"inner":{"macro":"macro_rules! debug_assert_command_stdout_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"866":{"id":866,"crate_id":0,"name":"assert_command_stderr_ge_x","span":{"filename":"src/assert_command/assert_command_stderr_ge_x.rs","begin":[1,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stderr_ge_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)\n* [`assert_command_stderr_ge_x_as_result`](macro@crate::assert_command_stderr_ge_x_as_result)\n* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)","links":{"macro@crate::assert_command_stderr_ge_x":863,"macro@crate::assert_command_stderr_ge_x_as_result":864,"macro@crate::debug_assert_command_stderr_ge_x":865},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"589":{"id":589,"crate_id":0,"name":"assert_fn_err_ne","span":{"filename":"src/assert_fn_err/assert_fn_err_ne.rs","begin":[1,0],"end":[497,1]},"visibility":"public","docs":"Assert a function Err(…) is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_ne!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)\n* [`assert_fn_err_ne_as_result`](macro@crate::assert_fn_err_ne_as_result)\n* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)","links":{"macro@crate::assert_fn_err_ne":586,"macro@crate::assert_fn_err_ne_as_result":587,"macro@crate::debug_assert_fn_err_ne":588},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"312":{"id":312,"crate_id":0,"name":"debug_assert_len_le_x","span":{"filename":"src/assert_len/assert_len_le_x.rs","begin":[332,0],"end":[338,1]},"visibility":"public","docs":"Assert a length is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\nThis macro provides the same statements as [`assert_len_le_x`](macro.assert_len_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_le_x`](macro@crate::assert_len_le_x)\n* [`assert_len_le_x`](macro@crate::assert_len_le_x)\n* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)\n","links":{"macro@crate::assert_len_le_x":310,"macro@crate::debug_assert_len_le_x":312},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"916":{"id":916,"crate_id":0,"name":"assert_program_args_stdout_ne","span":{"filename":"src/assert_program_args/assert_program_args_stdout_ne.rs","begin":[356,0],"end":[369,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is not equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≠ (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\" ];\nassert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"];\nassert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_ne.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stdout\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s%s%s%s\\\", \\\"a\\\", \\\"l\\\", \\\"f\\\", \\\"a\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 108, 102, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_ne.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s%s%s%s\\\", \\\"a\\\", \\\"l\\\", \\\"f\\\", \\\"a\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 108, 102, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)\n* [`assert_program_args_stdout_ne_as_result`](macro@crate::assert_program_args_stdout_ne_as_result)\n* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)\n","links":{"macro@crate::debug_assert_program_args_stdout_ne":918,"macro@crate::assert_program_args_stdout_ne_as_result":917,"macro@crate::assert_program_args_stdout_ne":916,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_ne {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"35":{"id":35,"crate_id":0,"name":"assert_f32_ge_as_result","span":{"filename":"src/assert_f32/assert_f32_ge.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na ≥ b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f32_ge`](macro@crate::assert_f32_ge)\n* [`assert_f32_ge_as_result`](macro@crate::assert_f32_ge_as_result)\n* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)\n","links":{"macro@crate::assert_f32_ge":34,"macro@crate::assert_f32_ge_as_result":35,"macro@crate::debug_assert_f32_ge":36},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_ge_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"639":{"id":639,"crate_id":0,"name":"assert_fn_ok_eq_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_eq_x.rs","begin":[307,0],"end":[340,1]},"visibility":"public","docs":"Assert a function Ok(…) is equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr\n\n* If true, return `a`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b = String::from(\"1\");\nassert_fn_ok_eq_x!(f, a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_eq_x!(f, a, b);\n# });\n// assertion failed: `assert_fn_ok_eq_x!(a_function, a_param, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_eq_x.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//      b_expr label: `b`,\n//      b_expr debug: `\\\"2\\\"`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"2\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_eq_x!(a_function, a_param, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_eq_x.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \"     b_expr label: `b`,\\n\",\n#     \"     b_expr debug: `\\\"2\\\"`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"2\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)\n* [`assert_fn_ok_eq_x_as_result`](macro@crate::assert_fn_ok_eq_x_as_result)\n* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)\n","links":{"macro@crate::assert_fn_ok_eq_x":639,"macro@crate::debug_assert_fn_ok_eq_x":641,"macro@crate::assert_fn_ok_eq_x_as_result":640,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_eq_x {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"362":{"id":362,"crate_id":0,"name":"assert_ok","span":{"filename":"src/assert_ok/assert_ok.rs","begin":[156,0],"end":[169,1]},"visibility":"public","docs":"Assert expression is Ok.\n\nPseudocode:<br>\na is Ok.\n\n* If true, return `a1`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a: Result<i8, i8> = Ok(1);\nassert_ok!(a);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: Result<i8, i8> = Err(1);\nassert_ok!(a);\n# });\n// assertion failed: `assert_ok!(a)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ok.html\n//  a label: `a`,\n//  a debug: `Err(1)`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ok!(a)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ok.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `Err(1)`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ok`](macro@crate::assert_ok)\n* [`assert_ok_as_result`](macro@crate::assert_ok_as_result)\n* [`debug_assert_ok`](macro@crate::debug_assert_ok)\n","links":{"macro@crate::assert_ok_as_result":363,"macro@crate::assert_ok":362,"macro@crate::debug_assert_ok":364,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ok {\n    ($a:expr $(,)?) => { ... };\n    ($a:expr, $($message:tt)+) => { ... };\n}"}},"966":{"id":966,"crate_id":0,"name":"assert_program_args_stderr_le","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le.rs","begin":[355,0],"end":[368,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_le!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"aa\"];\nassert_program_args_stderr_le!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stderr_le!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_le.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stderr\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s\\\", \\\"aa\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_le!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_le.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s\\\", \\\"aa\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)\n* [`assert_program_args_stderr_le_as_result`](macro@crate::assert_program_args_stderr_le_as_result)\n* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)\n","links":{"macro@crate::assert_program_args_stderr_le":966,"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_le":968,"macro@crate::assert_program_args_stderr_le_as_result":967},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_le {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"85":{"id":85,"crate_id":0,"name":"assert_abs_diff_ge_x_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge_x.rs","begin":[43,0],"end":[105,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nPseudocode:<br>\n|Δ| ≥ x\n\n* If true, return `Ok((lhs, rhs))`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)\n* [`assert_abs_diff_ge_x_as_result`](macro@crate::assert_abs_diff_ge_x_as_result)\n* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)\n","links":{"macro@crate::assert_abs_diff_ge_x":84,"macro@crate::debug_assert_abs_diff_ge_x":86,"`Err`":1082,"macro@crate::assert_abs_diff_ge_x_as_result":85},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_ge_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"689":{"id":689,"crate_id":0,"name":"assert_fs_read_to_string_eq_x_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_eq_x.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) = expr\n\n* If true, return Result `Ok(path_into_string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)\n* [`assert_fs_read_to_string_eq_x_as_result`](macro@crate::assert_fs_read_to_string_eq_x_as_result)\n* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)\n","links":{"macro@crate::assert_fs_read_to_string_eq_x_as_result":689,"macro@crate::assert_fs_read_to_string_eq_x":688,"macro@crate::debug_assert_fs_read_to_string_eq_x":690},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_eq_x_as_result {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"412":{"id":412,"crate_id":0,"name":"debug_assert_some_eq_x","span":{"filename":"src/assert_some/assert_some_eq_x.rs","begin":[345,0],"end":[351,1]},"visibility":"public","docs":"Assert an expression is Some and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = b\n\nThis macro provides the same statements as [`assert_some_eq_x`](macro.assert_some_eq_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)\n* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)\n* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)\n","links":{"macro@crate::assert_some_eq_x":410,"macro@crate::debug_assert_some_eq_x":412},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_some_eq_x {\n    ($($arg:tt)*) => { ... };\n}"}},"135":{"id":135,"crate_id":0,"name":"assert_diff_ge_x","span":{"filename":"src/assert_diff/assert_diff_ge_x.rs","begin":[1,0],"end":[478,1]},"visibility":"public","docs":"Assert a difference is greater than or equal to an expression.\n\nPseudocode:<br>\nΔ ≥ x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 2;\nassert_diff_ge_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)\n* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)\n* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)","links":{"macro@crate::assert_diff_ge_x":132,"macro@crate::assert_diff_ge_x_as_result":133,"macro@crate::debug_assert_diff_ge_x":134},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1016":{"id":1016,"crate_id":0,"name":"assert_status_success_false_as_result","span":{"filename":"src/assert_status/assert_status_success_false.rs","begin":[41,0],"end":[78,1]},"visibility":"public","docs":"Assert a status is a failure.\n\nPseudocode:<br>\na ⇒ status ⇒ success = false\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_success_false`](macro@crate::assert_status_success_false)\n* [`assert_status_success_false_as_result`](macro@crate::assert_status_success_false_as_result)\n* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)\n","links":{"macro@crate::debug_assert_status_success_false":1017,"macro@crate::assert_status_success_false_as_result":1016,"macro@crate::assert_status_success_false":1015},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_success_false_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"739":{"id":739,"crate_id":0,"name":"assert_io_read_to_string_lt_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt.rs","begin":[42,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)\n* [`assert_io_read_to_string_lt_as_result`](macro@crate::assert_io_read_to_string_lt_as_result)\n* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)\n","links":{"macro@crate::assert_io_read_to_string_lt":738,"macro@crate::assert_io_read_to_string_lt_as_result":739,"macro@crate::debug_assert_io_read_to_string_lt":740},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_lt_as_result {\n    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };\n}"}},"462":{"id":462,"crate_id":0,"name":"assert_bag_superbag","span":{"filename":"src/assert_bag/assert_bag_superbag.rs","begin":[231,0],"end":[244,1]},"visibility":"public","docs":"Assert a bag is a superbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] in order to print the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 1, 1];\nlet b = [1, 1];\nassert_bag_superbag!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 1];\nlet b = [1, 1, 1];\nassert_bag_superbag!(a, b);\n# });\n// assertion failed: `assert_bag_superbag!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_bag_superbag.html\n//  a label: `a`,\n//  a debug: `[1, 1]`,\n//  b label: `b`,\n//  b debug: `[1, 1, 1]`,\n//    a bag: `{1: 2}`,\n//    b bag: `{1: 3}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_bag_superbag!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_bag_superbag.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 1]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 1, 1]`,\\n\",\n#     \"   a bag: `{1: 2}`,\\n\",\n#     \"   b bag: `{1: 3}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)\n* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)\n* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)\n","links":{"macro@crate::assert_bag_superbag_as_result":463,"`panic!`":1081,"macro@crate::debug_assert_bag_superbag":464,"macro@crate::assert_bag_superbag":462},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_superbag {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1066":{"id":1066,"crate_id":0,"name":"assert_status_code_value_lt_x","span":{"filename":"src/assert_status/assert_status_code_value_lt_x.rs","begin":[1,0],"end":[380,1]},"visibility":"public","docs":"Assert a status code value is less than an expression.\n\nPseudocode:<br>\na.len() < b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_lt_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)\n* [`assert_status_code_value_lt_x_as_result`](macro@crate::assert_status_code_value_lt_x_as_result)\n* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)","links":{"macro@crate::assert_status_code_value_lt_x_as_result":1064,"macro@crate::debug_assert_status_code_value_lt_x":1065,"macro@crate::assert_status_code_value_lt_x":1063},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"185":{"id":185,"crate_id":0,"name":"assert_not_contains_as_result","span":{"filename":"src/assert_contains/assert_not_contains.rs","begin":[72,0],"end":[99,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not contain an expression (such as a substring).\n\nPseudocode:<br>\n¬ a.contains(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_not_contains`](macro@crate::assert_not_contains)\n* [`assert_not_contains_as_result`](macro@crate::assert_not_contains_as_result)\n* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)\n","links":{"macro@crate::assert_not_contains":184,"macro@crate::assert_not_contains_as_result":185,"macro@crate::debug_assert_not_contains":186},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_not_contains_as_result {\n    ($container:expr, $containee:expr $(,)?) => { ... };\n}"}},"789":{"id":789,"crate_id":0,"name":"assert_command_stdout_gt_as_result","span":{"filename":"src/assert_command/assert_command_stdout_gt.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stdout string is greater than another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_gt`](macro@crate::assert_command_stdout_gt)\n* [`assert_command_stdout_gt_as_result`](macro@crate::assert_command_stdout_gt_as_result)\n* [`debug_assert_command_stdout_gt`](macro@crate::debug_assert_command_stdout_gt)\n","links":{"macro@crate::assert_command_stdout_gt_as_result":789,"macro@crate::assert_command_stdout_gt":788,"macro@crate::debug_assert_command_stdout_gt":790},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_gt_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"512":{"id":512,"crate_id":0,"name":"assert_set_superset","span":{"filename":"src/assert_set/assert_set_superset.rs","begin":[207,0],"end":[220,1]},"visibility":"public","docs":"Assert a set is a superset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)\n\n* If true, return `(a_set, b_set)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2, 3];\nlet b = [1, 2];\nassert_set_superset!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [1, 2, 3];\nassert_set_superset!(a, b);\n# });\n// assertion failed: `assert_set_superset!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_set_superset.html\n//  a label: `a`,\n//  a debug: `[1, 2]`,\n//  b label: `b`,\n//  b debug: `[1, 2, 3]`,\n//        a: `{1, 2}`,\n//        b: `{1, 2, 3}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_set_superset!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_set_superset.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 2, 3]`,\\n\",\n#     \"       a: `{1, 2}`,\\n\",\n#     \"       b: `{1, 2, 3}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_superset`](macro@crate::assert_set_superset)\n* [`assert_set_superset_as_result`](macro@crate::assert_set_superset_as_result)\n* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)\n","links":{"macro@crate::assert_set_superset_as_result":513,"macro@crate::debug_assert_set_superset":514,"macro@crate::assert_set_superset":512,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_superset {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"235":{"id":235,"crate_id":0,"name":"debug_assert_count_ne_x","span":{"filename":"src/assert_count/assert_count_ne_x.rs","begin":[332,0],"end":[338,1]},"visibility":"public","docs":"Assert a count is not equal to an expression.\n\nPseudocode:<br>\na.count() ≠ b\n\nThis macro provides the same statements as [`assert_count_ne_x`](macro.assert_count_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)\n* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)\n* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)\n","links":{"macro@crate::debug_assert_count_ne_x":235,"macro@crate::assert_count_ne_x":233},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1116":{"id":1116,"crate_id":0,"name":"assert_option_some_ne_as_result","span":{"filename":"src/assert_option/assert_option_some_ne.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nDeprecated. Please rename from `assert_option_some_ne_as_result` into `assert_some_ne_as_result` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_some_ne_as_result` into `assert_some_ne_as_result` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_some_ne_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"839":{"id":839,"crate_id":0,"name":"assert_command_stderr_ge","span":{"filename":"src/assert_command/assert_command_stderr_ge.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a command stderr string is greater than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"aa\"]);\nassert_command_stderr_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_ge!(a, b);\n# });\n// assertion failed: `assert_command_stderr_ge!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_ge.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"zz\\\"`,\n//  b value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_ge!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"zz\\\"`,\\n\",\n#     \" b value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_ge`](macro@crate::assert_command_stderr_ge)\n* [`assert_command_stderr_ge_as_result`](macro@crate::assert_command_stderr_ge_as_result)\n* [`debug_assert_command_stderr_ge`](macro@crate::debug_assert_command_stderr_ge)\n","links":{"macro@crate::assert_command_stderr_ge_as_result":840,"macro@crate::assert_command_stderr_ge":839,"macro@crate::debug_assert_command_stderr_ge":841,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_ge {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"562":{"id":562,"crate_id":0,"name":"assert_fn_ne_x_as_result","span":{"filename":"src/assert_fn/assert_fn_ne_x.rs","begin":[41,0],"end":[107,1]},"visibility":"public","docs":"Assert a function output is not equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≠ b\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)\n* [`assert_fn_ne_x_as_result`](macro@crate::assert_fn_ne_x_as_result)\n* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)\n","links":{"macro@crate::assert_fn_ne_x":561,"macro@crate::assert_fn_ne_x_as_result":562,"macro@crate::debug_assert_fn_ne_x":563},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ne_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"285":{"id":285,"crate_id":0,"name":"assert_len_gt","span":{"filename":"src/assert_len/assert_len_gt.rs","begin":[1,0],"end":[344,1]},"visibility":"public","docs":"Assert a length is greater than another.\n\nPseudocode:<br>\na.len() > b.len()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\";\nlet b = \"x\";\nassert_len_gt!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_gt`](macro@crate::assert_len_gt)\n* [`assert_len_gt_as_result`](macro@crate::assert_len_gt_as_result)\n* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)","links":{"macro@crate::assert_len_gt_as_result":283,"macro@crate::debug_assert_len_gt":284,"macro@crate::assert_len_gt":282},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1166":{"id":1166,"crate_id":0,"name":"debug_assert_program_args_stderr_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stderr_is_match.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nDeprecated. Please rename from `debug_assert_program_args_stderr_is_match` to `debug_assert_program_args_stderr_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_program_args_stderr_is_match` to `debug_assert_program_args_stderr_string_is_match`."},"inner":{"macro":"macro_rules! debug_assert_program_args_stderr_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"889":{"id":889,"crate_id":0,"name":"assert_command_stderr_string_is_match","span":{"filename":"src/assert_command/assert_command_stderr_string_is_match.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a command stderr string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) is match (expr into string)\n\n* If true, return (command ⇒ stderr ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\nuse regex::Regex;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_command_stderr_string_is_match!(command, matcher);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet matcher = Regex::new(r\"zz\").expect(\"regex\");\nassert_command_stderr_string_is_match!(command, matcher);\n# });\n// assertion failed: `assert_command_stderr_string_is_match!(command, matcher)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_string_is_match.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `\\\"alfa\\\"`,\n//  matcher label: `matcher`,\n//  matcher debug: `Regex(\\\"zz\\\")`,\n//  matcher value: `Regex(\\\"zz\\\")`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_string_is_match!(command, matcher)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_string_is_match.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `\\\"alfa\\\"`,\\n\",\n#     \" matcher label: `matcher`,\\n\",\n#     \" matcher debug: `Regex(\\\"zz\\\")`,\\n\",\n#     \" matcher value: `Regex(\\\"zz\\\")`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)\n* [`assert_command_stderr_string_is_match_as_result`](macro@crate::assert_command_stderr_string_is_match_as_result)\n* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)\n","links":{"macro@crate::assert_command_stderr_string_is_match":889,"macro@crate::assert_command_stderr_string_is_match_as_result":890,"macro@crate::debug_assert_command_stderr_string_is_match":891,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_string_is_match {\n    ($command:expr, $matcher:expr $(,)?) => { ... };\n    ($command:expr, $matcher:expr, $($message:tt)+) => { ... };\n}"}},"8":{"id":8,"crate_id":0,"name":"assert_gt","span":{"filename":"src/assert_gt.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert an expression is greater than another.\n\nPseudocode:<br>\na > b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 2;\nlet b = 1;\nassert_gt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 1;\nlet b = 2;\nassert_gt!(a, b);\n# });\n// assertion failed: `assert_gt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_gt.html\n//  a label: `a`,\n//  a debug: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_gt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_gt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_gt`](macro@crate::assert_gt)\n* [`assert_gt_as_result`](macro@crate::assert_gt_as_result)\n* [`debug_assert_gt`](macro@crate::debug_assert_gt)\n","links":{"macro@crate::assert_gt_as_result":9,"macro@crate::assert_gt":8,"macro@crate::debug_assert_gt":10,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_gt {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"612":{"id":612,"crate_id":0,"name":"debug_assert_fn_err_ne_x","span":{"filename":"src/assert_fn_err/assert_fn_err_ne_x.rs","begin":[471,0],"end":[477,1]},"visibility":"public","docs":"Assert a function error is not equal to an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) ≠ expr\n\nThis macro provides the same statements as [`assert_fn_err_ne_x`](macro.assert_fn_err_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)\n* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)\n* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)\n","links":{"macro@crate::assert_fn_err_ne_x":610,"macro@crate::debug_assert_fn_err_ne_x":612},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}},"335":{"id":335,"crate_id":0,"name":"assert_not_starts_with","span":{"filename":"src/assert_starts_with/assert_not_starts_with.rs","begin":[1,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not start with an expression (such as a string).\n\nPseudocode:<br>\n¬ a.starts_with(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String starts with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"z\";\nassert_not_starts_with!(sequence, subsequence);\n\n// Vector starts with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [3];\nassert_not_starts_with!(sequence, subsequence);\n```\n\n# Module macros\n\n* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)\n* [`assert_not_starts_with_as_result`](macro@crate::assert_not_starts_with_as_result)\n* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)","links":{"macro@crate::assert_not_starts_with":332,"macro@crate::debug_assert_not_starts_with":334,"macro@crate::assert_not_starts_with_as_result":333},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"939":{"id":939,"crate_id":0,"name":"assert_program_args_stdout_lt_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt_x.rs","begin":[1,0],"end":[406,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_lt_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)\n* [`assert_program_args_stdout_lt_x_as_result`](macro@crate::assert_program_args_stdout_lt_x_as_result)\n* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)","links":{"macro@crate::assert_program_args_stdout_lt_x_as_result":937,"macro@crate::assert_program_args_stdout_lt_x":936,"macro@crate::debug_assert_program_args_stdout_lt_x":938},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"58":{"id":58,"crate_id":0,"name":"assert_f64_eq","span":{"filename":"src/assert_f64/assert_f64_eq.rs","begin":[1,0],"end":[367,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is equal to another within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f64 = 1.0 / 3.0;\nlet b: f64 = 0.3333333333333334;\nassert_f64_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_f64_eq`](macro@crate::assert_f64_eq)\n* [`assert_f64_eq_as_result`](macro@crate::assert_f64_eq_as_result)\n* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)","links":{"macro@crate::assert_f64_eq_as_result":56,"macro@crate::debug_assert_f64_eq":57,"macro@crate::assert_f64_eq":55},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"662":{"id":662,"crate_id":0,"name":"assert_fn_ok_ne_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne_x.rs","begin":[1,0],"end":[476,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_ne_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)\n* [`assert_fn_ok_ne_x_as_result`](macro@crate::assert_fn_ok_ne_x_as_result)\n* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)","links":{"macro@crate::assert_fn_ok_ne_x":659,"macro@crate::debug_assert_fn_ok_ne_x":661,"macro@crate::assert_fn_ok_ne_x_as_result":660},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"385":{"id":385,"crate_id":0,"name":"assert_result_ok_eq","span":{"filename":"src/assert_result/assert_result_ok_eq.rs","begin":[1,0],"end":[45,1]},"visibility":"public","docs":"Assert two expressions are Ok and their values are equal.\n\nDeprecated. Please rename from `assert_result_ok_eq` into `assert_ok_eq` because more developers prefer the shorter name.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"989":{"id":989,"crate_id":0,"name":"assert_program_args_stderr_le_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_le_x.rs","begin":[305,0],"end":[318,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_le_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stderr_le_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stderr_le_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_le_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[97, 97]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_le_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_le_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[97, 97]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)\n* [`assert_program_args_stderr_le_x_as_result`](macro@crate::assert_program_args_stderr_le_x_as_result)\n* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)\n","links":{"macro@crate::assert_program_args_stderr_le_x_as_result":990,"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_le_x":991,"macro@crate::assert_program_args_stderr_le_x":989},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_le_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"108":{"id":108,"crate_id":0,"name":"assert_abs_diff_lt","span":{"filename":"src/assert_abs_diff/assert_abs_diff_lt.rs","begin":[1,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is less than an expression.\n\nDeprecated. Please rename from `assert_abs_diff_lt` into `assert_abs_diff_lt_x`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"712":{"id":712,"crate_id":0,"name":"assert_fs_read_to_string_contains","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_contains.rs","begin":[231,0],"end":[244,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) contains a pattern.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) contains expr\n\n* If true, return `path_into_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"alfa.txt\";\nlet containee = \"alfa\";\nassert_fs_read_to_string_contains!(path, containee);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"alfa.txt\";\nlet containee = \"zz\";\nassert_fs_read_to_string_contains!(path, containee);\n# });\n// assertion failed: `assert_fs_read_to_string_contains!(path, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_contains.html\n//       path label: `path`,\n//       path debug: `\\\"alfa.txt\\\"`,\n//  containee label: `containee`,\n//  containee debug: `\\\"zz\\\"`,\n//           string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_contains!(path, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_contains.html\\n\",\n#     \"      path label: `path`,\\n\",\n#     \"      path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" containee label: `containee`,\\n\",\n#     \" containee debug: `\\\"zz\\\"`,\\n\",\n#     \"          string: `\\\"alfa\\\\n\\\"`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)\n* [`assert_fs_read_to_string_contains_as_result`](macro@crate::assert_fs_read_to_string_contains_as_result)\n* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)\n","links":{"macro@crate::assert_fs_read_to_string_contains_as_result":713,"macro@crate::assert_fs_read_to_string_contains":712,"macro@crate::debug_assert_fs_read_to_string_contains":714,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_contains {\n    ($path:expr, $containee:expr $(,)?) => { ... };\n    ($path:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"435":{"id":435,"crate_id":0,"name":"debug_assert_ready_eq","span":{"filename":"src/assert_ready/assert_ready_eq.rs","begin":[327,0],"end":[333,1]},"visibility":"public","docs":"Assert two expressions are Ready and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)\n\nThis macro provides the same statements as [`assert_ready_eq`](macro.assert_ready_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ready_eq`](macro@crate::assert_ready_eq)\n* [`assert_ready_eq`](macro@crate::assert_ready_eq)\n* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)\n","links":{"macro@crate::assert_ready_eq":433,"macro@crate::debug_assert_ready_eq":435},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ready_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"1039":{"id":1039,"crate_id":0,"name":"assert_status_code_value_lt","span":{"filename":"src/assert_status/assert_status_code_value_lt.rs","begin":[263,0],"end":[276,1]},"visibility":"public","docs":"Assert a status code value is less than another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_lt!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_lt!(a, b);\n# });\n// assertion failed: `assert_status_code_value_lt!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_lt.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `2`\",\n//  b label: `b`,\n//  b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  b value: `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_lt!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_lt.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`,\\n\",\n#     \"  a code: `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`\\n\",\n#     \"  b code: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)\n* [`assert_status_code_value_lt_as_result`](macro@crate::assert_status_code_value_lt_as_result)\n* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)\n","links":{"macro@crate::assert_status_code_value_lt_as_result":1040,"macro@crate::debug_assert_status_code_value_lt":1041,"macro@crate::assert_status_code_value_lt":1039,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_lt {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };\n}"}},"158":{"id":158,"crate_id":0,"name":"debug_assert_in_delta","span":{"filename":"src/assert_in/assert_in_delta.rs","begin":[378,0],"end":[384,1]},"visibility":"public","docs":"Assert a number is within delta of another.\n\nPseudocode:<br>\n| a - b | ≤ Δ\n\nThis macro provides the same statements as [`assert_in_delta`](macro.assert_in_delta.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_in_delta`](macro@crate::assert_in_delta)\n* [`assert_in_delta`](macro@crate::assert_in_delta)\n* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)\n","links":{"macro@crate::assert_in_delta":119,"macro@crate::debug_assert_in_delta":158},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_in_delta {\n    ($($arg:tt)*) => { ... };\n}"}},"762":{"id":762,"crate_id":0,"name":"assert_io_read_to_string_lt_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_lt_x.rs","begin":[244,0],"end":[257,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_lt_x!(reader, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"aa\");\nassert_io_read_to_string_lt_x!(reader, x);\n# });\n// assertion failed: `assert_io_read_to_string_lt_x!(a_reader, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_lt_x.html\n//  a_reader label: `reader`,\n//  a_reader debug: `[97, 108, 102, 97]`,\n//    b_expr label: `x`,\n//    b_expr debug: `\\\"aa\\\"`,\n//               a: `\\\"alfa\\\"`,\n//               b: `\\\"aa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_lt_x!(a_reader, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_lt_x.html\\n\",\n#     \" a_reader label: `reader`,\\n\",\n#     \" a_reader debug: `[97, 108, 102, 97]`,\\n\",\n#     \"   b_expr label: `x`,\\n\",\n#     \"   b_expr debug: `\\\"aa\\\"`,\\n\",\n#     \"              a: `\\\"alfa\\\"`,\\n\",\n#     \"              b: `\\\"aa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)\n* [`assert_io_read_to_string_lt_x_as_result`](macro@crate::assert_io_read_to_string_lt_x_as_result)\n* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)\n","links":{"macro@crate::debug_assert_io_read_to_string_lt_x":764,"macro@crate::assert_io_read_to_string_lt_x":762,"macro@crate::assert_io_read_to_string_lt_x_as_result":763,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_lt_x {\n    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"485":{"id":485,"crate_id":0,"name":"debug_assert_iter_lt","span":{"filename":"src/assert_iter/assert_iter_lt.rs","begin":[298,0],"end":[304,1]},"visibility":"public","docs":"Assert an iterable is less than another.\n\nPseudocode:<br>\n(collection1 into iter) < (collection2 into iter)\n\nThis macro provides the same statements as [`assert_iter_lt`](macro.assert_iter_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_iter_lt`](macro@crate::assert_iter_lt)\n* [`assert_iter_lt`](macro@crate::assert_iter_lt)\n* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)\n","links":{"macro@crate::assert_iter_lt":483,"macro@crate::debug_assert_iter_lt":485},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_iter_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"1089":{"id":1089,"crate_id":0,"name":"assert_abs_diff_le_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_le.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an absolute difference is less than or equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_le_as_result` into `assert_abs_diff_le_x_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_le_as_result` into `assert_abs_diff_le_x_as_result`."},"inner":{"macro":"macro_rules! assert_abs_diff_le_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"208":{"id":208,"crate_id":0,"name":"assert_count_lt","span":{"filename":"src/assert_count/assert_count_lt.rs","begin":[1,0],"end":[344,1]},"visibility":"public","docs":"Assert a count is less than another.\n\nPseudocode:<br>\na.count() < b.count()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_lt!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_lt`](macro@crate::assert_count_lt)\n* [`assert_count_lt_as_result`](macro@crate::assert_count_lt_as_result)\n* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)","links":{"macro@crate::assert_count_lt":205,"macro@crate::assert_count_lt_as_result":206,"macro@crate::debug_assert_count_lt":207},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"812":{"id":812,"crate_id":0,"name":"assert_command_stdout_gt_x","span":{"filename":"src/assert_command/assert_command_stdout_gt_x.rs","begin":[248,0],"end":[261,1]},"visibility":"public","docs":"Assert a command stdout string is greater than an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stdout_gt_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_gt_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stdout_gt_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_gt_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[122, 122]`,\n//     expr value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_gt_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_gt_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[122, 122]`,\\n\",\n#     \"    expr value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)\n* [`assert_command_stdout_gt_x_as_result`](macro@crate::assert_command_stdout_gt_x_as_result)\n* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)\n","links":{"macro@crate::assert_command_stdout_gt_x_as_result":813,"macro@crate::debug_assert_command_stdout_gt_x":814,"macro@crate::assert_command_stdout_gt_x":812,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_gt_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"535":{"id":535,"crate_id":0,"name":"debug_assert_fn_lt","span":{"filename":"src/assert_fn/assert_fn_lt.rs","begin":[524,0],"end":[530,1]},"visibility":"public","docs":"Assert a function output is less than another.\n\nPseudocode:<br>\na_function(a) < b_function(b)\n\nThis macro provides the same statements as [`assert_fn_lt`](macro.assert_fn_lt.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_lt`](macro@crate::assert_fn_lt)\n* [`assert_fn_lt`](macro@crate::assert_fn_lt)\n* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)\n","links":{"macro@crate::assert_fn_lt":533,"macro@crate::debug_assert_fn_lt":535},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_lt {\n    ($($arg:tt)*) => { ... };\n}"}},"1139":{"id":1139,"crate_id":0,"name":"assert_command_stdout_ne_x_as_result","span":{"filename":"src/assert_command/assert_command_stdout_ne_x.rs","begin":[37,0],"end":[89,1]},"visibility":"public","docs":"Assert a command stdout string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)\n* [`assert_command_stdout_ne_x_as_result`](macro@crate::assert_command_stdout_ne_x_as_result)\n* [`debug_assert_command_stdout_ne_x`](macro@crate::debug_assert_command_stdout_ne_x)\n","links":{"macro@crate::assert_command_stdout_ne_x_as_result":1139,"macro@crate::debug_assert_command_stdout_ne_x":1140,"macro@crate::assert_command_stdout_ne_x":894},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ne_x_as_result {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n}"}},"258":{"id":258,"crate_id":0,"name":"debug_assert_is_empty","span":{"filename":"src/assert_is_empty/assert_is_empty.rs","begin":[244,0],"end":[250,1]},"visibility":"public","docs":"Assert an expression (such as a string or array) is empty.\n\nPseudocode:<br>\na.is_empty()\n\nThis macro provides the same statements as [`assert_is_empty`](macro.assert_is_empty.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_is_empty`](macro@crate::assert_is_empty)\n* [`assert_is_empty`](macro@crate::assert_is_empty)\n* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)\n","links":{"macro@crate::assert_is_empty":256,"macro@crate::debug_assert_is_empty":258},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_is_empty {\n    ($($arg:tt)*) => { ... };\n}"}},"862":{"id":862,"crate_id":0,"name":"assert_command_stderr_eq_x","span":{"filename":"src/assert_command/assert_command_stderr_eq_x.rs","begin":[1,0],"end":[378,1]},"visibility":"public","docs":"Assert a command stderr string is equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'l', b'f', b'a'];\nassert_command_stderr_eq_x!(command, bytes);\n```\n\n# Module macros\n\n* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)\n* [`assert_command_stderr_eq_x_as_result`](macro@crate::assert_command_stderr_eq_x_as_result)\n* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)","links":{"macro@crate::assert_command_stderr_eq_x_as_result":860,"macro@crate::debug_assert_command_stderr_eq_x":861,"macro@crate::assert_command_stderr_eq_x":859},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"585":{"id":585,"crate_id":0,"name":"assert_fn_err_lt","span":{"filename":"src/assert_fn_err/assert_fn_err_lt.rs","begin":[1,0],"end":[582,1]},"visibility":"public","docs":"Assert a function Err(…) is less than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) < (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_lt!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)\n* [`assert_fn_err_lt_as_result`](macro@crate::assert_fn_err_lt_as_result)\n* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)","links":{"macro@crate::assert_fn_err_lt":582,"macro@crate::assert_fn_err_lt_as_result":583,"macro@crate::debug_assert_fn_err_lt":584},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"308":{"id":308,"crate_id":0,"name":"debug_assert_len_gt_x","span":{"filename":"src/assert_len/assert_len_gt_x.rs","begin":[329,0],"end":[335,1]},"visibility":"public","docs":"Assert a length is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\nThis macro provides the same statements as [`assert_len_gt_x`](macro.assert_len_gt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)\n* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)\n* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)\n","links":{"macro@crate::assert_len_gt_x":306,"macro@crate::debug_assert_len_gt_x":308},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_gt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"31":{"id":31,"crate_id":0,"name":"assert_f32_eq_as_result","span":{"filename":"src/assert_f32/assert_f32_eq.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"\nPseudocode:<br>\na = b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_f32_eq`](macro@crate::assert_f32_eq)\n* [`assert_f32_eq_as_result`](macro@crate::assert_f32_eq_as_result)\n* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)\n","links":{"macro@crate::assert_f32_eq":30,"macro@crate::debug_assert_f32_eq":32,"macro@crate::assert_f32_eq_as_result":31},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_f32_eq_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"912":{"id":912,"crate_id":0,"name":"assert_program_args_stdout_lt","span":{"filename":"src/assert_program_args/assert_program_args_stdout_lt.rs","begin":[313,0],"end":[326,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\"];\nassert_program_args_stdout_lt!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"a\", \"a\"];\nassert_program_args_stdout_lt!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_lt.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stdout\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s%s\\\", \\\"a\\\", \\\"a\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_lt.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s%s\\\", \\\"a\\\", \\\"a\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)\n* [`assert_program_args_stdout_lt_as_result`](macro@crate::assert_program_args_stdout_lt_as_result)\n* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)\n","links":{"macro@crate::assert_program_args_stdout_lt_as_result":913,"macro@crate::debug_assert_program_args_stdout_lt":914,"macro@crate::assert_program_args_stdout_lt":912,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_lt {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"635":{"id":635,"crate_id":0,"name":"assert_fn_ok_ne","span":{"filename":"src/assert_fn_ok/assert_fn_ok_ne.rs","begin":[321,0],"end":[354,1]},"visibility":"public","docs":"Assert a function Ok(…) is not equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_ne!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 1;\nlet b: i8 = 1;\nassert_fn_ok_ne!(f, a, f, b);\n# });\n// assertion failed: `assert_fn_ok_ne!(a_function, a_param, b_function, b_param)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fn_ok_ne.html\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `1`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `1`,\n//                 a: `\\\"1\\\"`,\n//                 b: `\\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_ne!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_ne.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `1`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `1`,\\n\",\n#     \"                a: `\\\"1\\\"`,\\n\",\n#     \"                b: `\\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)\n* [`assert_fn_ok_ne_as_result`](macro@crate::assert_fn_ok_ne_as_result)\n* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)\n","links":{"`panic!`":1081,"macro@crate::assert_fn_ok_ne":635,"macro@crate::debug_assert_fn_ok_ne":637,"macro@crate::assert_fn_ok_ne_as_result":636},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_ne {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"358":{"id":358,"crate_id":0,"name":"assert_err_ne_x_as_result","span":{"filename":"src/assert_err/assert_err_ne_x.rs","begin":[41,0],"end":[88,1]},"visibility":"public","docs":"Assert an expression is Err and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = b\n\n* e, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)\n* [`assert_err_ne_x_as_result`](macro@crate::assert_err_ne_x_as_result)\n* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)\n","links":{"macro@crate::assert_err_ne_x":357,"macro@crate::assert_err_ne_x_as_result":358,"macro@crate::debug_assert_err_ne_x":359},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_ne_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"81":{"id":81,"crate_id":0,"name":"assert_abs_diff_eq_x_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq_x.rs","begin":[43,0],"end":[105,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nPseudocode:<br>\n|Δ| = x\n\n* If true, return `Ok((lhs, rhs))`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)\n* [`assert_abs_diff_eq_x_as_result`](macro@crate::assert_abs_diff_eq_x_as_result)\n* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)\n","links":{"macro@crate::assert_abs_diff_eq_x":80,"`Err`":1082,"macro@crate::assert_abs_diff_eq_x_as_result":81,"macro@crate::debug_assert_abs_diff_eq_x":82},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_abs_diff_eq_x_as_result {\n    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };\n}"}},"962":{"id":962,"crate_id":0,"name":"assert_program_args_stderr_gt","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt.rs","begin":[313,0],"end":[326,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"aa\"];\nassert_program_args_stderr_gt!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_gt!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_gt.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stderr\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s\\\", \\\"zz\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_gt.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s\\\", \\\"zz\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)\n* [`assert_program_args_stderr_gt_as_result`](macro@crate::assert_program_args_stderr_gt_as_result)\n* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_gt":964,"macro@crate::assert_program_args_stderr_gt":962,"macro@crate::assert_program_args_stderr_gt_as_result":963},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_gt {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"685":{"id":685,"crate_id":0,"name":"assert_fs_read_to_string_ne_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)\n\n* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)\n* [`assert_fs_read_to_string_ne_as_result`](macro@crate::assert_fs_read_to_string_ne_as_result)\n* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)\n","links":{"macro@crate::assert_fs_read_to_string_ne_as_result":685,"macro@crate::debug_assert_fs_read_to_string_ne":686,"macro@crate::assert_fs_read_to_string_ne":684},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ne_as_result {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n}"}},"408":{"id":408,"crate_id":0,"name":"debug_assert_some_ne","span":{"filename":"src/assert_some/assert_some_ne.rs","begin":[391,0],"end":[397,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are not equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)\n\nThis macro provides the same statements as [`assert_some_ne`](macro.assert_some_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_some_ne`](macro@crate::assert_some_ne)\n* [`assert_some_ne`](macro@crate::assert_some_ne)\n* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)\n","links":{"macro@crate::debug_assert_some_ne":408,"macro@crate::assert_some_ne":406},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_some_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"1012":{"id":1012,"crate_id":0,"name":"assert_status_success_as_result","span":{"filename":"src/assert_status/assert_status_success.rs","begin":[41,0],"end":[78,1]},"visibility":"public","docs":"Assert a status is a success.\n\nPseudocode:<br>\na ⇒ status ⇒ success = true\n\n* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_status_success`](macro@crate::assert_status_success)\n* [`assert_status_success_as_result`](macro@crate::assert_status_success_as_result)\n* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)\n","links":{"macro@crate::debug_assert_status_success":1013,"macro@crate::assert_status_success":1011,"macro@crate::assert_status_success_as_result":1012},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_success_as_result {\n    ($a:expr $(,)?) => { ... };\n}"}},"131":{"id":131,"crate_id":0,"name":"assert_diff_eq_x","span":{"filename":"src/assert_diff/assert_diff_eq_x.rs","begin":[1,0],"end":[469,1]},"visibility":"public","docs":"Assert a difference is equal to an expression.\n\nPseudocode:<br>\nΔ = x\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: i8 = 10;\nlet b: i8 = 13;\nlet x: i8 = 3;\nassert_diff_eq_x!(a, b, x);\n```\n\n# Module macros\n\n* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)\n* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)\n* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)","links":{"macro@crate::assert_diff_eq_x":128,"macro@crate::debug_assert_diff_eq_x":130,"macro@crate::assert_diff_eq_x_as_result":129},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"735":{"id":735,"crate_id":0,"name":"assert_io_read_to_string_le_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le.rs","begin":[42,0],"end":[98,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)\n* [`assert_io_read_to_string_le_as_result`](macro@crate::assert_io_read_to_string_le_as_result)\n* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)\n","links":{"macro@crate::debug_assert_io_read_to_string_le":736,"macro@crate::assert_io_read_to_string_le":734,"macro@crate::assert_io_read_to_string_le_as_result":735},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_le_as_result {\n    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };\n}"}},"458":{"id":458,"crate_id":0,"name":"assert_bag_subbag","span":{"filename":"src/assert_bag/assert_bag_subbag.rs","begin":[231,0],"end":[244,1]},"visibility":"public","docs":"Assert a bag is a subbag of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] in order to print the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 1];\nlet b = [1, 1, 1];\nassert_bag_subbag!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 1, 1];\nlet b = [1, 1];\nassert_bag_subbag!(a, b);\n# });\n// assertion failed: `assert_bag_subbag!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_bag_subbag.html\n//  a label: `a`,\n//  a debug: `[1, 1, 1]`,\n//  b label: `b`,\n//  b debug: `[1, 1]`,\n//    a bag: `{1: 3}`,\n//    b bag: `{1: 2}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_bag_subbag!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_bag_subbag.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 1, 1]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 1]`,\\n\",\n#     \"   a bag: `{1: 3}`,\\n\",\n#     \"   b bag: `{1: 2}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)\n* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)\n* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)\n","links":{"macro@crate::assert_bag_subbag":458,"macro@crate::assert_bag_subbag_as_result":459,"macro@crate::debug_assert_bag_subbag":460,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_subbag {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1062":{"id":1062,"crate_id":0,"name":"assert_status_code_value_le_x","span":{"filename":"src/assert_status/assert_status_code_value_le_x.rs","begin":[1,0],"end":[385,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to an expression.\n\nPseudocode:<br>\na.len() ≤ b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet b = 2;\nassert_status_code_value_le_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)\n* [`assert_status_code_value_le_x_as_result`](macro@crate::assert_status_code_value_le_x_as_result)\n* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)","links":{"macro@crate::debug_assert_status_code_value_le_x":1061,"macro@crate::assert_status_code_value_le_x_as_result":1060,"macro@crate::assert_status_code_value_le_x":1059},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"181":{"id":181,"crate_id":0,"name":"assert_contains_as_result","span":{"filename":"src/assert_contains/assert_contains.rs","begin":[72,0],"end":[99,1]},"visibility":"public","docs":"Assert an expression (such as a string) contains an expression (such as a substring).\n\nPseudocode:<br>\na.contains(b)\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_contains`](macro@crate::assert_contains)\n* [`assert_contains_as_result`](macro@crate::assert_contains_as_result)\n* [`debug_assert_contains`](macro@crate::debug_assert_contains)\n","links":{"macro@crate::assert_contains":180,"macro@crate::assert_contains_as_result":181,"macro@crate::debug_assert_contains":182},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_contains_as_result {\n    ($container:expr, $containee:expr $(,)?) => { ... };\n}"}},"785":{"id":785,"crate_id":0,"name":"assert_command_stdout_ge_as_result","span":{"filename":"src/assert_command/assert_command_stdout_ge.rs","begin":[44,0],"end":[97,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_ge`](macro@crate::assert_command_stdout_ge)\n* [`assert_command_stdout_ge_as_result`](macro@crate::assert_command_stdout_ge_as_result)\n* [`debug_assert_command_stdout_ge`](macro@crate::debug_assert_command_stdout_ge)\n","links":{"macro@crate::assert_command_stdout_ge_as_result":785,"macro@crate::debug_assert_command_stdout_ge":786,"macro@crate::assert_command_stdout_ge":784},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ge_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"508":{"id":508,"crate_id":0,"name":"assert_set_subset","span":{"filename":"src/assert_set/assert_set_subset.rs","begin":[205,0],"end":[218,1]},"visibility":"public","docs":"Assert a set is a subset of another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)\n\n* If true, return `(a_set, b_set)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [1, 2, 3];\nassert_set_subset!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2, 3];\nlet b = [1, 2];\nassert_set_subset!(a, b);\n# });\n// assertion failed: `assert_set_subset!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_set_subset.html\n//  a label: `a`,\n//  a debug: `[1, 2, 3]`,\n//  b label: `b`,\n//  b debug: `[1, 2]`,\n//        a: `{1, 2, 3}`,\n//        b: `{1, 2}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_set_subset!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_set_subset.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 2, 3]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 2]`,\\n\",\n#     \"       a: `{1, 2, 3}`,\\n\",\n#     \"       b: `{1, 2}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_subset`](macro@crate::assert_set_subset)\n* [`assert_set_subset_as_result`](macro@crate::assert_set_subset_as_result)\n* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)\n","links":{"macro@crate::debug_assert_set_subset":510,"macro@crate::assert_set_subset_as_result":509,"macro@crate::assert_set_subset":508,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_subset {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1112":{"id":1112,"crate_id":0,"name":"debug_assert_option_some","span":{"filename":"src/assert_option/assert_option_some.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert expression is Some.\n\nDeprecated. Please rename from `debug_assert_option_some` into `debug_assert_some` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_option_some` into `debug_assert_some` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! debug_assert_option_some {\n    ($($arg:tt)*) => { ... };\n}"}},"231":{"id":231,"crate_id":0,"name":"debug_assert_count_lt_x","span":{"filename":"src/assert_count/assert_count_lt_x.rs","begin":[329,0],"end":[335,1]},"visibility":"public","docs":"Assert a count is less than an expression.\n\nPseudocode:<br>\na.count() < b\n\nThis macro provides the same statements as [`assert_count_lt_x`](macro.assert_count_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)\n* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)\n* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)\n","links":{"macro@crate::assert_count_lt_x":229,"macro@crate::debug_assert_count_lt_x":231},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"835":{"id":835,"crate_id":0,"name":"assert_command_stderr_eq","span":{"filename":"src/assert_command/assert_command_stderr_eq.rs","begin":[260,0],"end":[273,1]},"visibility":"public","docs":"Assert a command stderr string is equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"alfa\"]);\nassert_command_stderr_eq!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_eq!(a, b);\n# });\n// assertion failed: `assert_command_stderr_eq!(a_command, b_command)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_eq.html\n//  a label: `a`,\n//  a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  a value: `[97, 108, 102, 97]`,\n//  b label: `b`,\n//  b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"zz\\\"`,\n//  b value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_eq!(a_command, b_command)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_eq.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" a value: `[97, 108, 102, 97]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"zz\\\"`,\\n\",\n#     \" b value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_eq`](macro@crate::assert_command_stderr_eq)\n* [`assert_command_stderr_eq_as_result`](macro@crate::assert_command_stderr_eq_as_result)\n* [`debug_assert_command_stderr_eq`](macro@crate::debug_assert_command_stderr_eq)\n","links":{"macro@crate::debug_assert_command_stderr_eq":837,"macro@crate::assert_command_stderr_eq_as_result":836,"macro@crate::assert_command_stderr_eq":835,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_eq {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };\n}"}},"558":{"id":558,"crate_id":0,"name":"assert_fn_lt_x_as_result","span":{"filename":"src/assert_fn/assert_fn_lt_x.rs","begin":[41,0],"end":[107,1]},"visibility":"public","docs":"Assert a function output is less than an expression.\n\nPseudocode:<br>\na_function(a) < b\n\n* If true, return Result `Ok(a)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)\n* [`assert_fn_lt_x_as_result`](macro@crate::assert_fn_lt_x_as_result)\n* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)\n","links":{"macro@crate::assert_fn_lt_x_as_result":558,"macro@crate::debug_assert_fn_lt_x":559,"macro@crate::assert_fn_lt_x":557},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_lt_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"1162":{"id":1162,"crate_id":0,"name":"assert_program_args_stderr_contains","span":{"filename":"src/assert_program_args/assert_program_args_stderr_contains.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string contains a given containee.\n\nDeprecated. Please rename from `assert_program_args_stderr_contains` to `assert_program_args_stderr_string_contains`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stderr_contains` to `assert_program_args_stderr_string_contains`."},"inner":{"macro":"macro_rules! assert_program_args_stderr_contains {\n    ($($arg:tt)*) => { ... };\n}"}},"281":{"id":281,"crate_id":0,"name":"assert_len_ge","span":{"filename":"src/assert_len/assert_len_ge.rs","begin":[1,0],"end":[345,1]},"visibility":"public","docs":"Assert a length is greater than or equal to another.\n\nPseudocode:<br>\na.len() ≥ b.len()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"xx\";\nlet b = \"x\";\nassert_len_ge!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_ge`](macro@crate::assert_len_ge)\n* [`assert_len_ge_as_result`](macro@crate::assert_len_ge_as_result)\n* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)","links":{"macro@crate::assert_len_ge_as_result":279,"macro@crate::assert_len_ge":278,"macro@crate::debug_assert_len_ge":280},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"4":{"id":4,"crate_id":0,"name":"assert_ge","span":{"filename":"src/assert_ge.rs","begin":[332,0],"end":[345,1]},"visibility":"public","docs":"Assert an expression is greater than or equal to another.\n\nPseudocode:<br>\na ≥ b\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = 2;\nlet b = 1;\nassert_ge!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = 1;\nlet b = 2;\nassert_ge!(a, b);\n# });\n// assertion failed: `assert_ge!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_ge.html\n//  a label: `a`,\n//  a debug: `1`,\n//  b label: `b`,\n//  b debug: `2`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_ge!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_ge.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `1`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `2`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_ge`](macro@crate::assert_ge)\n* [`assert_ge_as_result`](macro@crate::assert_ge_as_result)\n* [`debug_assert_ge`](macro@crate::debug_assert_ge)\n","links":{"macro@crate::assert_ge_as_result":5,"macro@crate::debug_assert_ge":6,"macro@crate::assert_ge":4,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_ge {\n    ($a:expr, $b:expr $(,)?) => { ... };\n    ($a:expr, $b:expr, $($message:tt)+) => { ... };\n}"}},"885":{"id":885,"crate_id":0,"name":"assert_command_stderr_string_contains","span":{"filename":"src/assert_command/assert_command_stderr_string_contains.rs","begin":[234,0],"end":[247,1]},"visibility":"public","docs":"Assert a command stderr string contains a given containee.\n\nPseudocode:<br>\n(command ⇒ stderr ⇒ string) contains (expr into string)\n\n* If true, return (command ⇒ stderr ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\nThis uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.\n\n* The containee can be a &str, char, a slice of chars, or a function or\nclosure that determines if a character contains.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet containee = \"lf\";\nassert_command_stderr_string_contains!(command, containee);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stderr\");\ncommand.args([\"%s\", \"alfa\"]);\nlet containee = \"zz\";\nassert_command_stderr_string_contains!(command, containee);\n# });\n// assertion failed: `assert_command_stderr_string_contains!(command, containee)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stderr_string_contains.html\n//    command label: `command`,\n//    command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//    command value: `\\\"alfa\\\"`,\n//  containee label: `containee`,\n//  containee debug: `\\\"zz\\\"`,\n//  containee value: `\\\"zz\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stderr_string_contains!(command, containee)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stderr_string_contains.html\\n\",\n#     \"   command label: `command`,\\n\",\n#     \"   command debug: `\\\"bin/printf-stderr\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \"   command value: `\\\"alfa\\\"`,\\n\",\n#     \" containee label: `containee`,\\n\",\n#     \" containee debug: `\\\"zz\\\"`,\\n\",\n#     \" containee value: `\\\"zz\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)\n* [`assert_command_stderr_string_contains_as_result`](macro@crate::assert_command_stderr_string_contains_as_result)\n* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_command_stderr_string_contains":887,"macro@crate::assert_command_stderr_string_contains":885,"macro@crate::assert_command_stderr_string_contains_as_result":886},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stderr_string_contains {\n    ($command:expr, $containee:expr $(,)?) => { ... };\n    ($command:expr, $containee:expr, $($message:tt)+) => { ... };\n}"}},"608":{"id":608,"crate_id":0,"name":"debug_assert_fn_err_lt_x","span":{"filename":"src/assert_fn_err/assert_fn_err_lt_x.rs","begin":[567,0],"end":[573,1]},"visibility":"public","docs":"Assert a function error is less than an expression.\n\nPseudocode:<br>\n(function(param) ⇒ Err(a) ⇒ a) < expr\n\nThis macro provides the same statements as [`assert_fn_err_lt_x`](macro.assert_fn_err_lt_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)\n* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)\n* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)\n","links":{"macro@crate::assert_fn_err_lt_x":606,"macro@crate::debug_assert_fn_err_lt_x":608},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_err_lt_x {\n    ($($arg:tt)*) => { ... };\n}"}},"331":{"id":331,"crate_id":0,"name":"assert_matches","span":{"filename":"src/assert_matches/mod.rs","begin":[1,0],"end":[17,27]},"visibility":"public","docs":"Assert matches for verifying an item matches a case.\n\n* [`assert_matches!(a, b)`](macro@crate::assert_matches) ≈ match(a) { b }\n\n* [`assert_not_matches!(a, b)`](macro@crate::assert_matches) ≈ match(a) { b }\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = 'a';\nassert_matches!(a, 'a'..='z');\n```","links":{"macro@crate::assert_matches":323},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[326,330],"is_stripped":false}}},"54":{"id":54,"crate_id":0,"name":"assert_f32","span":{"filename":"src/assert_f32/mod.rs","begin":[1,0],"end":[33,22]},"visibility":"public","docs":"Assert for comparing floating-point 32-bit numbers within 2.0 * EPSILON.\n\nThese macros are available:\n\n* [`assert_f32_eq!(a, b)`](macro@crate::assert_f32_eq) ≈ a = b (within 2ε)\n* [`assert_f32_ne!(a, b)`](macro@crate::assert_f32_ne) ≈ a ≠ b (within 2ε)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333333;\nassert_f32_eq!(a, b);\n\nlet a: f32 = 1.0 / 3.0;\nlet b: f32 = 0.3333336;\nassert_f32_ne!(a, b);\n```","links":{"macro@crate::assert_f32_eq":30,"macro@crate::assert_f32_ne":50},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[33,37,41,45,49,53],"is_stripped":false}}},"935":{"id":935,"crate_id":0,"name":"assert_program_args_stdout_le_x","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le_x.rs","begin":[1,0],"end":[417,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet program = \"bin/printf-stdout\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stdout_le_x!(program, args, bytes);\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)\n* [`assert_program_args_stdout_le_x_as_result`](macro@crate::assert_program_args_stdout_le_x_as_result)\n* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)","links":{"macro@crate::assert_program_args_stdout_le_x":932,"macro@crate::assert_program_args_stdout_le_x_as_result":933,"macro@crate::debug_assert_program_args_stdout_le_x":934},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"658":{"id":658,"crate_id":0,"name":"assert_fn_ok_lt_x","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt_x.rs","begin":[1,0],"end":[479,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than an expression.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 1;\nlet b = String::from(\"2\");\nassert_fn_ok_lt_x!(f, a, b);\n```\n\n# Module macros\n\n* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)\n* [`assert_fn_ok_lt_x_as_result`](macro@crate::assert_fn_ok_lt_x_as_result)\n* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)","links":{"macro@crate::assert_fn_ok_lt_x":655,"macro@crate::assert_fn_ok_lt_x_as_result":656,"macro@crate::debug_assert_fn_ok_lt_x":657},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"381":{"id":381,"crate_id":0,"name":"assert_ok_ne_x","span":{"filename":"src/assert_ok/assert_ok_ne_x.rs","begin":[1,0],"end":[390,1]},"visibility":"public","docs":"Assert an expression is Ok and its value is not equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Ok(a1) ⇒ a1) ≠ b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: Result<i8, i8> = Ok(1);\nlet b: i8 = 2;\nassert_ok_ne_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)\n* [`assert_ok_ne_x_as_result`](macro@crate::assert_ok_ne_x_as_result)\n* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)","links":{"macro@crate::assert_ok_ne_x":378,"macro@crate::debug_assert_ok_ne_x":380,"macro@crate::assert_ok_ne_x_as_result":379},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"104":{"id":104,"crate_id":0,"name":"assert_abs_diff_eq","span":{"filename":"src/assert_abs_diff/assert_abs_diff_eq.rs","begin":[1,0],"end":[43,1]},"visibility":"public","docs":"Assert an absolute difference is equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_eq_as_resul` into `assert_abs_diff_eq_x`.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"985":{"id":985,"crate_id":0,"name":"assert_program_args_stderr_gt_x","span":{"filename":"src/assert_program_args/assert_program_args_stderr_gt_x.rs","begin":[275,0],"end":[288,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than an expression.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'a', b'a'];\nassert_program_args_stderr_gt_x!(program, args, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet program = \"bin/printf-stderr\";\nlet args = [\"%s\", \"alfa\"];\nlet bytes = vec![b'z', b'z'];\nassert_program_args_stderr_gt_x!(program, args, bytes);\n# });\n// assertion failed: `assert_program_args_stderr_gt_x!(a_program, a_args, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_gt_x.html\n//  a_program label: `program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//     b_expr label: `bytes`,\n//     b_expr debug: `[122, 122]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_gt_x!(a_program, a_args, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_gt_x.html\\n\",\n#     \" a_program label: `program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \"    b_expr label: `bytes`,\\n\",\n#     \"    b_expr debug: `[122, 122]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)\n* [`assert_program_args_stderr_gt_x_as_result`](macro@crate::assert_program_args_stderr_gt_x_as_result)\n* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)\n","links":{"macro@crate::debug_assert_program_args_stderr_gt_x":987,"macro@crate::assert_program_args_stderr_gt_x_as_result":986,"macro@crate::assert_program_args_stderr_gt_x":985,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_gt_x {\n    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"708":{"id":708,"crate_id":0,"name":"assert_fs_read_to_string_ne_x","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_ne_x.rs","begin":[277,0],"end":[290,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is not equal to an expression.\n\nPseudocode:<br>\nstd::fs::read_to_string(path) ≠ expr\n\n* If true, return (path_into_string, expr_into_string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet path = \"alfa.txt\";\nlet x = \"bravo\\n\";\nassert_fs_read_to_string_ne_x!(path, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet path = \"alfa.txt\";\nlet x = \"alfa\\n\";\nassert_fs_read_to_string_ne_x!(path, x);\n# });\n// assertion failed: `assert_fs_read_to_string_ne_x!(a_path, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_fs_read_to_string_ne_x.html\n//  a_path label: `path`,\n//  a_path debug: `\\\"alfa.txt\\\"`,\n//  b_expr label: `x`,\n//  b_expr debug: `\\\"alfa\\\\n\\\"`,\n//      a string: `\\\"alfa\\\\n\\\"`,\n//      b string: `\\\"alfa\\\\n\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fs_read_to_string_ne_x!(a_path, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fs_read_to_string_ne_x.html\\n\",\n#     \" a_path label: `path`,\\n\",\n#     \" a_path debug: `\\\"alfa.txt\\\"`,\\n\",\n#     \" b_expr label: `x`,\\n\",\n#     \" b_expr debug: `\\\"alfa\\\\n\\\"`,\\n\",\n#     \"     a string: `alfa\\n`,\\n\",\n#     \"     b string: `alfa\\n`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)\n* [`assert_fs_read_to_string_ne_x_as_result`](macro@crate::assert_fs_read_to_string_ne_x_as_result)\n* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_fs_read_to_string_ne_x":710,"macro@crate::assert_fs_read_to_string_ne_x":708,"macro@crate::assert_fs_read_to_string_ne_x_as_result":709},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_ne_x {\n    ($a_path:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"431":{"id":431,"crate_id":0,"name":"debug_assert_ready","span":{"filename":"src/assert_ready/assert_ready.rs","begin":[228,0],"end":[234,1]},"visibility":"public","docs":"Assert an expression is Ready.\n\nPseudocode:<br>\na is Ready(a1)\n\nThis macro provides the same statements as [`assert_ready`](macro.assert_ready.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_ready`](macro@crate::assert_ready)\n* [`assert_ready`](macro@crate::assert_ready)\n* [`debug_assert_ready`](macro@crate::debug_assert_ready)\n","links":{"macro@crate::assert_ready":429,"macro@crate::debug_assert_ready":431},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_ready {\n    ($($arg:tt)*) => { ... };\n}"}},"154":{"id":154,"crate_id":0,"name":"assert_in_as_result","span":{"filename":"src/assert_in/assert_in.rs","begin":[41,0],"end":[68,1]},"visibility":"public","docs":"Assert an item is in a container.\n\nPseudocode:<br>\na is in container\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_in`](macro@crate::assert_in)\n* [`assert_in_as_result`](macro@crate::assert_in_as_result)\n* [`debug_assert_in`](macro@crate::debug_assert_in)\n","links":{"macro@crate::debug_assert_in":155,"macro@crate::assert_in_as_result":154,"macro@crate::assert_in":153},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_in_as_result {\n    ($a:expr, $container:expr $(,)?) => { ... };\n}"}},"1035":{"id":1035,"crate_id":0,"name":"assert_status_code_value_le","span":{"filename":"src/assert_status/assert_status_code_value_le.rs","begin":[287,0],"end":[300,1]},"visibility":"public","docs":"Assert a status code value is less than or equal to another.\n\nPseudocode:<br>\na ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value\n\n* If true, return `(a value, b value)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n# use std::panic;\n\n# fn main() {\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"1\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"2\");\nassert_status_code_value_le!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet mut b = Command::new(\"bin/exit-with-arg\"); b.arg(\"1\");\nassert_status_code_value_le!(a, b);\n# });\n// assertion failed: `assert_status_code_value_le!(a, b)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_status_code_value_le.html\n//  a label: `a`,\n//  a debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  a value: `2`\",\n//  b label: `b`,\n//  b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`,\n//  b value: `1`\"\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_status_code_value_le!(a, b)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_status_code_value_le.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `\\\"bin/exit-with-arg\\\" \\\"2\\\"`,\\n\",\n#     \"  a code: `2`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `\\\"bin/exit-with-arg\\\" \\\"1\\\"`\\n\",\n#     \"  b code: `1`\",\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)\n* [`assert_status_code_value_le_as_result`](macro@crate::assert_status_code_value_le_as_result)\n* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)\n","links":{"macro@crate::assert_status_code_value_le_as_result":1036,"macro@crate::debug_assert_status_code_value_le":1037,"macro@crate::assert_status_code_value_le":1035,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_status_code_value_le {\n    ($a_process:expr, $b_process:expr $(,)?) => { ... };\n    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };\n}"}},"758":{"id":758,"crate_id":0,"name":"assert_io_read_to_string_le_x","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_le_x.rs","begin":[264,0],"end":[277,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.\n\nPseudocode:<br>\n(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)\n\n* If true, return `a_string`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::io::Read;\n\n# fn main() {\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"zz\");\nassert_io_read_to_string_le_x!(reader, x);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet reader = \"alfa\".as_bytes();\nlet x = String::from(\"aa\");\nassert_io_read_to_string_le_x!(reader, x);\n# });\n// assertion failed: `assert_io_read_to_string_le_x!(a_reader, b_expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_io_read_to_string_le_x.html\n//  a_reader label: `reader`,\n//  a_reader debug: `[97, 108, 102, 97]`,\n//    b_expr label: `x`,\n//    b_expr debug: `\\\"aa\\\"`,\n//               a: `\\\"alfa\\\"`,\n//               b: `\\\"aa\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_io_read_to_string_le_x!(a_reader, b_expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_io_read_to_string_le_x.html\\n\",\n#     \" a_reader label: `reader`,\\n\",\n#     \" a_reader debug: `[97, 108, 102, 97]`,\\n\",\n#     \"   b_expr label: `x`,\\n\",\n#     \"   b_expr debug: `\\\"aa\\\"`,\\n\",\n#     \"              a: `\\\"alfa\\\"`,\\n\",\n#     \"              b: `\\\"aa\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)\n* [`assert_io_read_to_string_le_x_as_result`](macro@crate::assert_io_read_to_string_le_x_as_result)\n* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)\n","links":{"macro@crate::assert_io_read_to_string_le_x":758,"macro@crate::assert_io_read_to_string_le_x_as_result":759,"macro@crate::debug_assert_io_read_to_string_le_x":760,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_le_x {\n    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };\n    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"481":{"id":481,"crate_id":0,"name":"debug_assert_iter_le","span":{"filename":"src/assert_iter/assert_iter_le.rs","begin":[273,0],"end":[279,1]},"visibility":"public","docs":"Assert an iterable is less than or equal to another.\n\nPseudocode:<br>\n(collection1 into iter) ≤ (collection2 into iter)\n\nThis macro provides the same statements as [`assert_iter_le`](macro.assert_iter_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_iter_le`](macro@crate::assert_iter_le)\n* [`assert_iter_le`](macro@crate::assert_iter_le)\n* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)\n","links":{"macro@crate::assert_iter_le":479,"macro@crate::debug_assert_iter_le":481},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_iter_le {\n    ($($arg:tt)*) => { ... };\n}"}},"204":{"id":204,"crate_id":0,"name":"assert_count_le","span":{"filename":"src/assert_count/assert_count_le.rs","begin":[1,0],"end":[345,1]},"visibility":"public","docs":"Assert a count is less than or equal to another.\n\nPseudocode:<br>\na.count() ≤ b.count()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\".chars();\nlet b = \"xx\".chars();\nassert_count_le!(a, b);\n```\n\n# Module macros\n\n* [`assert_count_le`](macro@crate::assert_count_le)\n* [`assert_count_le_as_result`](macro@crate::assert_count_le_as_result)\n* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)","links":{"macro@crate::assert_count_le":201,"macro@crate::assert_count_le_as_result":202,"macro@crate::debug_assert_count_le":203},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1085":{"id":1085,"crate_id":0,"name":"assert_abs_diff_ge_as_result","span":{"filename":"src/assert_abs_diff/assert_abs_diff_ge.rs","begin":[13,0],"end":[17,1]},"visibility":"public","docs":"Assert an absolute difference is greater than or equal to an expression.\n\nDeprecated. Please rename from `assert_abs_diff_ge_as_result` into `assert_abs_diff_ge_x_as_result`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_abs_diff_ge_as_result` into `assert_abs_diff_ge_x_as_result`."},"inner":{"macro":"macro_rules! assert_abs_diff_ge_as_result {\n    ($($arg:tt)*) => { ... };\n}"}},"808":{"id":808,"crate_id":0,"name":"assert_command_stdout_ge_x","span":{"filename":"src/assert_command/assert_command_stdout_ge_x.rs","begin":[270,0],"end":[283,1]},"visibility":"public","docs":"Assert a command stdout string is greater than or equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stdout) = (expr into string)\n\n* If true, return `(stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'a', b'a'];\nassert_command_stdout_ge_x!(command, bytes);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet bytes = vec![b'z', b'z'];\nassert_command_stdout_ge_x!(command, bytes);\n# });\n// assertion failed: `assert_command_stdout_ge_x!(command, expr)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_ge_x.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `[97, 108, 102, 97]`,\n//     expr label: `bytes`,\n//     expr debug: `[122, 122]`,\n//     expr value: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_ge_x!(command, expr)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_ge_x.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `[97, 108, 102, 97]`,\\n\",\n#     \"    expr label: `bytes`,\\n\",\n#     \"    expr debug: `[122, 122]`,\\n\",\n#     \"    expr value: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)\n* [`assert_command_stdout_ge_x_as_result`](macro@crate::assert_command_stdout_ge_x_as_result)\n* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_command_stdout_ge_x":810,"macro@crate::assert_command_stdout_ge_x_as_result":809,"macro@crate::assert_command_stdout_ge_x":808},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_ge_x {\n    ($a_command:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };\n}"}},"531":{"id":531,"crate_id":0,"name":"debug_assert_fn_le","span":{"filename":"src/assert_fn/assert_fn_le.rs","begin":[468,0],"end":[474,1]},"visibility":"public","docs":"Assert a function output is less than or equal to another.\n\nPseudocode:<br>\na_function(a) ≤ b_function(b)\n\nThis macro provides the same statements as [`assert_fn_le`](macro.assert_fn_le.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_fn_le`](macro@crate::assert_fn_le)\n* [`assert_fn_le`](macro@crate::assert_fn_le)\n* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)\n","links":{"macro@crate::debug_assert_fn_le":531,"macro@crate::assert_fn_le":529},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_fn_le {\n    ($($arg:tt)*) => { ... };\n}"}},"254":{"id":254,"crate_id":0,"name":"assert_not_ends_with","span":{"filename":"src/assert_ends_with/assert_not_ends_with.rs","begin":[1,0],"end":[293,1]},"visibility":"public","docs":"Assert an expression (such as a string) does not end with an expression (such as a string).\n\nPseudocode:<br>\n¬ a.ends_with(b)\n\n# Example\n\n```rust\nuse assertables::*;\n\n// String ends with substring?\nlet sequence: &str = \"alfa\";\nlet subsequence: &str = \"al\";\nassert_not_ends_with!(sequence, subsequence);\n\n// Vector ends with element?\nlet sequence = vec![1, 2, 3];\nlet subsequence = [1];\nassert_not_ends_with!(sequence, subsequence);\n```\n\n# Module macros\n\n* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)\n* [`assert_not_ends_with_as_result`](macro@crate::assert_not_ends_with_as_result)\n* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)","links":{"macro@crate::assert_not_ends_with":251,"macro@crate::debug_assert_not_ends_with":253,"macro@crate::assert_not_ends_with_as_result":252},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1135":{"id":1135,"crate_id":0,"name":"debug_assert_fs_read_to_string_matches","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_matches.rs","begin":[41,0],"end":[45,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) is a match to a regex.\n\nDeprecated. Please rename from `debug_assert_fs_read_to_string_matches` into `debug_assert_fs_read_to_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `debug_assert_fs_read_to_string_matches` into `debug_assert_fs_read_to_string_is_match`."},"inner":{"macro":"macro_rules! debug_assert_fs_read_to_string_matches {\n    ($($arg:tt)*) => { ... };\n}"}},"858":{"id":858,"crate_id":0,"name":"assert_command_stderr_ne","span":{"filename":"src/assert_command/assert_command_stderr_ne.rs","begin":[1,0],"end":[398,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stderr) = (b_command ⇒ stderr)\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/printf-stderr\");\na.args([\"%s\", \"alfa\"]);\nlet mut b = Command::new(\"bin/printf-stderr\");\nb.args([\"%s\", \"zz\"]);\nassert_command_stderr_ne!(a, b);\n```\n\n# Module macros\n\n* [`assert_command_stderr_ne`](macro@crate::assert_command_stderr_ne)\n* [`assert_command_stderr_ne_as_result`](macro@crate::assert_command_stderr_ne_as_result)\n* [`debug_assert_command_stderr_ne`](macro@crate::debug_assert_command_stderr_ne)","links":{"macro@crate::assert_command_stderr_ne":855,"macro@crate::assert_command_stderr_ne_as_result":856,"macro@crate::debug_assert_command_stderr_ne":857},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"581":{"id":581,"crate_id":0,"name":"assert_fn_err_le","span":{"filename":"src/assert_fn_err/assert_fn_err_le.rs","begin":[1,0],"end":[533,1]},"visibility":"public","docs":"Assert a function Err(…) is less than or equal to another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)\n\n# Example\n\n```rust\nuse assertables::*;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\nlet a: i8 = 10;\nlet b: i8 = 20;\nassert_fn_err_le!(f, a, f, b);\n```\n\n# Module macros\n\n* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)\n* [`assert_fn_err_le_as_result`](macro@crate::assert_fn_err_le_as_result)\n* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)","links":{"macro@crate::assert_fn_err_le":578,"macro@crate::assert_fn_err_le_as_result":579,"macro@crate::debug_assert_fn_err_le":580},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"304":{"id":304,"crate_id":0,"name":"debug_assert_len_ge_x","span":{"filename":"src/assert_len/assert_len_ge_x.rs","begin":[332,0],"end":[338,1]},"visibility":"public","docs":"Assert a length is greater than or equal to an expression.\n\nPseudocode:<br>\na.len() ≥ b\n\nThis macro provides the same statements as [`assert_len_ge_x`](macro.assert_len_ge_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)\n* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)\n* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)\n","links":{"macro@crate::assert_len_ge_x":302,"macro@crate::debug_assert_len_ge_x":304},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_len_ge_x {\n    ($($arg:tt)*) => { ... };\n}"}},"27":{"id":27,"crate_id":0,"name":"assert_eq_f64_as_result","span":{"filename":"src/assert_eq_f64.rs","begin":[41,0],"end":[72,1]},"visibility":"public","docs":"Assert two floating point numbers are equal within f64::EPSILON.\n\nPseudocode:<br>\na = b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_eq_f64`](macro@crate::assert_eq_f64)\n* [`assert_eq_f64_as_result`](macro@crate::assert_eq_f64_as_result)\n* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)\n","links":{"macro@crate::assert_eq_f64":26,"macro@crate::assert_eq_f64_as_result":27,"macro@crate::debug_assert_eq_f64":28},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_eq_f64_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"908":{"id":908,"crate_id":0,"name":"assert_program_args_stdout_le","span":{"filename":"src/assert_program_args/assert_program_args_stdout_le.rs","begin":[356,0],"end":[369,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout is less than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)\n\n* If true, return `(a_stdout, b_stdout)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"z\", \"z\"];\nassert_program_args_stdout_le!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stdout\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stdout\";\nlet b_args = [\"%s%s\", \"a\", \"a\"];\nassert_program_args_stdout_le!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stdout_le!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stdout_le.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stdout\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stdout\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s%s\\\", \\\"a\\\", \\\"a\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[97, 97]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stdout_le!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stdout_le.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stdout\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s%s\\\", \\\"a\\\", \\\"a\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[97, 97]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)\n* [`assert_program_args_stdout_le_as_result`](macro@crate::assert_program_args_stdout_le_as_result)\n* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)\n","links":{"`panic!`":1081,"macro@crate::assert_program_args_stdout_le_as_result":909,"macro@crate::debug_assert_program_args_stdout_le":910,"macro@crate::assert_program_args_stdout_le":908},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stdout_le {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"631":{"id":631,"crate_id":0,"name":"assert_fn_ok_lt","span":{"filename":"src/assert_fn_ok/assert_fn_ok_lt.rs","begin":[357,0],"end":[390,1]},"visibility":"public","docs":"Assert a function Ok(…) is less than another.\n\nPseudocode:<br>\n(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nfn f(i: i8) -> Result<String, String> {\n    match i {\n        0..=9 => Ok(format!(\"{}\", i)),\n        _ => Err(format!(\"{:?} is out of range\", i)),\n    }\n}\n\n# fn main() {\nlet a: i8 = 1;\nlet b: i8 = 2;\nassert_fn_ok_lt!(f, a, f, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a: i8 = 2;\nlet b: i8 = 1;\nassert_fn_ok_lt!(f, a, f, b);\n# });\n//  a_function label: `f`,\n//     a_param label: `a`,\n//     a_param debug: `2`,\n//  b_function label: `f`,\n//     b_param label: `b`,\n//     b_param debug: `1`,\n//                 a: `\\\"2\\\"`,\n//                 b: `\\\"1\\\"`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_fn_ok_lt!(a_function, a_param, b_function, b_param)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_fn_ok_lt.html\\n\",\n#     \" a_function label: `f`,\\n\",\n#     \"    a_param label: `a`,\\n\",\n#     \"    a_param debug: `2`,\\n\",\n#     \" b_function label: `f`,\\n\",\n#     \"    b_param label: `b`,\\n\",\n#     \"    b_param debug: `1`,\\n\",\n#     \"                a: `\\\"2\\\"`,\\n\",\n#     \"                b: `\\\"1\\\"`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)\n* [`assert_fn_ok_lt_as_result`](macro@crate::assert_fn_ok_lt_as_result)\n* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)\n","links":{"`panic!`":1081,"macro@crate::assert_fn_ok_lt_as_result":632,"macro@crate::debug_assert_fn_ok_lt":633,"macro@crate::assert_fn_ok_lt":631},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_ok_lt {\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };\n    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };\n    ($a_function:path, $b_function:path) => { ... };\n    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };\n}"}},"354":{"id":354,"crate_id":0,"name":"assert_err_eq_x_as_result","span":{"filename":"src/assert_err/assert_err_eq_x.rs","begin":[41,0],"end":[88,1]},"visibility":"public","docs":"Assert an expression is Err and its value is equal to an expression.\n\nPseudocode:<br>\n(a ⇒ Err(a1) ⇒ a1) = b\n\n* If true, return Result `Ok(a1)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)\n* [`assert_err_eq_x_as_result`](macro@crate::assert_err_eq_x_as_result)\n* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)\n","links":{"macro@crate::assert_err_eq_x":353,"macro@crate::assert_err_eq_x_as_result":354,"macro@crate::debug_assert_err_eq_x":355},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_err_eq_x_as_result {\n    ($a:expr, $b:expr $(,)?) => { ... };\n}"}},"77":{"id":77,"crate_id":0,"name":"debug_assert_f64_ne","span":{"filename":"src/assert_f64/assert_f64_ne.rs","begin":[341,0],"end":[347,1]},"visibility":"public","docs":"Assert a floating point 64-bit number is not equal to another within f64::EPSILON.\n\nPseudocode:<br>\na ≠ b\n\nThis macro provides the same statements as [`assert_f64_ne`](macro.assert_f64_ne.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_f64_ne`](macro@crate::assert_f64_ne)\n* [`assert_f64_ne`](macro@crate::assert_f64_ne)\n* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)\n","links":{"macro@crate::assert_f64_ne":75,"macro@crate::debug_assert_f64_ne":77},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_f64_ne {\n    ($($arg:tt)*) => { ... };\n}"}},"958":{"id":958,"crate_id":0,"name":"assert_program_args_stderr_ge","span":{"filename":"src/assert_program_args/assert_program_args_stderr_ge.rs","begin":[356,0],"end":[369,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr is greater than or equal to another.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)\n\n* If true, return `()`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"aa\"];\nassert_program_args_stderr_ge!(a_program, a_args, b_program, b_args);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a_program = \"bin/printf-stderr\";\nlet a_args = [\"%s\", \"alfa\"];\nlet b_program = \"bin/printf-stderr\";\nlet b_args = [\"%s\", \"zz\"];\nassert_program_args_stderr_ge!(a_program, a_args, b_program, b_args);\n# });\n// assertion failed: `assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_program_args_stderr_ge.html\n//  a_program label: `a_program`,\n//  a_program debug: `\\\"bin/printf-stderr\\\"`,\n//     a_args label: `a_args`,\n//     a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\n//  b_program label: `b_program`,\n//  b_program debug: `\\\"bin/printf-stderr\\\"`,\n//     b_args label: `b_args`,\n//     b_args debug: `[\\\"%s\\\", \\\"zz\\\"]`,\n//                a: `[97, 108, 102, 97]`,\n//                b: `[122, 122]`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_program_args_stderr_ge.html\\n\",\n#     \" a_program label: `a_program`,\\n\",\n#     \" a_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    a_args label: `a_args`,\\n\",\n#     \"    a_args debug: `[\\\"%s\\\", \\\"alfa\\\"]`,\\n\",\n#     \" b_program label: `b_program`,\\n\",\n#     \" b_program debug: `\\\"bin/printf-stderr\\\"`,\\n\",\n#     \"    b_args label: `b_args`,\\n\",\n#     \"    b_args debug: `[\\\"%s\\\", \\\"zz\\\"]`,\\n\",\n#     \"               a: `[97, 108, 102, 97]`,\\n\",\n#     \"               b: `[122, 122]`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n/// # Module macros\n\n* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)\n* [`assert_program_args_stderr_ge_as_result`](macro@crate::assert_program_args_stderr_ge_as_result)\n* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_program_args_stderr_ge":960,"macro@crate::assert_program_args_stderr_ge_as_result":959,"macro@crate::assert_program_args_stderr_ge":958},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_ge {\n    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };\n    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };\n}"}},"681":{"id":681,"crate_id":0,"name":"assert_fs_read_to_string_lt_as_result","span":{"filename":"src/assert_fs_read_to_string/assert_fs_read_to_string_lt.rs","begin":[41,0],"end":[97,1]},"visibility":"public","docs":"Assert a ::std::fs::read_to_string(path) value is less than another.\n\nPseudocode:<br>\nstd::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)\n\n* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)\n* [`assert_fs_read_to_string_lt_as_result`](macro@crate::assert_fs_read_to_string_lt_as_result)\n* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)\n","links":{"macro@crate::debug_assert_fs_read_to_string_lt":682,"macro@crate::assert_fs_read_to_string_lt_as_result":681,"macro@crate::assert_fs_read_to_string_lt":680},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fs_read_to_string_lt_as_result {\n    ($a_path:expr, $b_path:expr $(,)?) => { ... };\n}"}},"404":{"id":404,"crate_id":0,"name":"debug_assert_some_eq","span":{"filename":"src/assert_some/assert_some_eq.rs","begin":[351,0],"end":[357,1]},"visibility":"public","docs":"Assert two expressions are Some and their values are equal.\n\nPseudocode:<br>\n(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)\n\nThis macro provides the same statements as [`assert_some_eq`](macro.assert_some_eq.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_some_eq`](macro@crate::assert_some_eq)\n* [`assert_some_eq`](macro@crate::assert_some_eq)\n* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)\n","links":{"macro@crate::assert_some_eq":402,"macro@crate::debug_assert_some_eq":404},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_some_eq {\n    ($($arg:tt)*) => { ... };\n}"}},"127":{"id":127,"crate_id":0,"name":"assert_approx","span":{"filename":"src/assert_approx/mod.rs","begin":[1,0],"end":[21,25]},"visibility":"public","docs":"Assert for approximations.\n\nThese macros compare numbers, such as two floating point numbers,\nwhere one number may be very close to another number but not quite equal.\n\n* [`assert_approx_eq!(a, b)`](macro@crate::assert_approx_eq) ≈ a is approximately equal to b\n\n* [`assert_approx_ne!(a, b)`](macro@crate::assert_approx_ne) ≈ a is approximately not equal to b\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a: f32 = 1.0000001;\nlet b: f32 = 1.0000011;\nassert_approx_eq!(a, b);\n```","links":{"macro@crate::assert_approx_eq":117,"macro@crate::assert_approx_ne":118},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[123,126],"is_stripped":false}}},"1008":{"id":1008,"crate_id":0,"name":"assert_program_args_stderr_string_is_match_as_result","span":{"filename":"src/assert_program_args/assert_program_args_stderr_string_is_match.rs","begin":[43,0],"end":[107,1]},"visibility":"public","docs":"Assert a command (built with program and args) stderr into a string is a match to a regex.\n\nPseudocode:<br>\n(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)\n\n* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stderr ⇒ string)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)\n* [`assert_program_args_stderr_string_is_match_as_result`](macro@crate::assert_program_args_stderr_string_is_match_as_result)\n* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)\n","links":{"macro@crate::assert_program_args_stderr_string_is_match_as_result":1008,"macro@crate::debug_assert_program_args_stderr_string_is_match":1009,"macro@crate::assert_program_args_stderr_string_is_match":1007},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_program_args_stderr_string_is_match_as_result {\n    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };\n}"}},"731":{"id":731,"crate_id":0,"name":"assert_io_read_to_string_gt_as_result","span":{"filename":"src/assert_io_read_to_string/assert_io_read_to_string_gt.rs","begin":[42,0],"end":[99,1]},"visibility":"public","docs":"Assert a ::std::io::Read read_to_string() value is greater than another.\n\nPseudocode:<br>\n(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)\n\n* If true, return Result `Ok((a_string, b_string))`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)\n* [`assert_io_read_to_string_gt_as_result`](macro@crate::assert_io_read_to_string_gt_as_result)\n* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)\n","links":{"macro@crate::debug_assert_io_read_to_string_gt":732,"macro@crate::assert_io_read_to_string_gt_as_result":731,"macro@crate::assert_io_read_to_string_gt":730},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_io_read_to_string_gt_as_result {\n    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };\n}"}},"454":{"id":454,"crate_id":0,"name":"assert_bag_ne","span":{"filename":"src/assert_bag/assert_bag_ne.rs","begin":[251,0],"end":[264,1]},"visibility":"public","docs":"Assert a bag is not equal to another.\n\nPseudocode:<br>\n(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)\n\n* If true, return `(a, b)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 1];\nlet b = [1, 1, 1];\nassert_bag_ne!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 1];\nlet b = [1, 1];\nassert_bag_ne!(a, b);\n# });\n// assertion failed: `assert_bag_ne!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_bag_ne.html\n//  a label: `a`,\n//  a debug: `[1, 1]`,\n//  b label: `b`,\n//  b debug: `[1, 1]`,\n//    a bag: `{1: 2}`,\n//    b bag: `{1: 2}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_bag_ne!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_bag_ne.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 1]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[1, 1]`,\\n\",\n#     \"   a bag: `{1: 2}`,\\n\",\n#     \"   b bag: `{1: 2}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_bag_ne`](macro@crate::assert_bag_ne)\n* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)\n* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)\n","links":{"`panic!`":1081,"macro@crate::assert_bag_ne_as_result":455,"macro@crate::debug_assert_bag_ne":456,"macro@crate::assert_bag_ne":454},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_bag_ne {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"1058":{"id":1058,"crate_id":0,"name":"assert_status_code_value_gt_x","span":{"filename":"src/assert_status/assert_status_code_value_gt_x.rs","begin":[1,0],"end":[380,1]},"visibility":"public","docs":"Assert a status code value is greater than an expression.\n\nPseudocode:<br>\na.len() > b\n\n# Example\n\n```rust\nuse assertables::*;\nuse std::process::Command;\n\nlet mut a = Command::new(\"bin/exit-with-arg\"); a.arg(\"2\");\nlet b = 1;\nassert_status_code_value_gt_x!(a, b);\n```\n\n# Module macros\n\n* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)\n* [`assert_status_code_value_gt_x_as_result`](macro@crate::assert_status_code_value_gt_x_as_result)\n* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)","links":{"macro@crate::debug_assert_status_code_value_gt_x":1057,"macro@crate::assert_status_code_value_gt_x":1055,"macro@crate::assert_status_code_value_gt_x_as_result":1056},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"177":{"id":177,"crate_id":0,"name":"assert_infix_as_result","span":{"filename":"src/assert_infix.rs","begin":[87,0],"end":[111,1]},"visibility":"public","docs":"Assert a infix operator, such as assert_infix!(a == b).\n\nPseudocode:<br>\na infix b\n\n* If true, return Result `Ok(())`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_infix`](macro@crate::assert_infix)\n* [`assert_infix_as_result`](macro@crate::assert_infix_as_result)\n* [`debug_assert_infix`](macro@crate::debug_assert_infix)\n","links":{"macro@crate::debug_assert_infix":178,"macro@crate::assert_infix":176,"macro@crate::assert_infix_as_result":177},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_infix_as_result {\n    ($a:tt $infix:tt $b:tt) => { ... };\n}"}},"781":{"id":781,"crate_id":0,"name":"assert_command_stdout_eq_as_result","span":{"filename":"src/assert_command/assert_command_stdout_eq.rs","begin":[44,0],"end":[99,1]},"visibility":"public","docs":"Assert a command stdout string is equal to another.\n\nPseudocode:<br>\n(a_command ⇒ stdout) = (b_command ⇒ stdout)\n\n* If true, return Result `Ok(stdout)`.\n\n* Otherwise, return Result `Err(message)`.\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_command_stdout_eq`](macro@crate::assert_command_stdout_eq)\n* [`assert_command_stdout_eq_as_result`](macro@crate::assert_command_stdout_eq_as_result)\n* [`debug_assert_command_stdout_eq`](macro@crate::debug_assert_command_stdout_eq)\n","links":{"macro@crate::assert_command_stdout_eq_as_result":781,"macro@crate::assert_command_stdout_eq":780,"macro@crate::debug_assert_command_stdout_eq":782},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_eq_as_result {\n    ($a_command:expr, $b_command:expr $(,)?) => { ... };\n}"}},"504":{"id":504,"crate_id":0,"name":"assert_set_joint","span":{"filename":"src/assert_set/assert_set_joint.rs","begin":[205,0],"end":[218,1]},"visibility":"public","docs":"Assert a set is joint with another.\n\nPseudocode:<br>\n(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)\n\n* If true, return `(a_set, b_set)`.\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\n\n# fn main() {\nlet a = [1, 2];\nlet b = [2, 3];\nassert_set_joint!(a, b);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet a = [1, 2];\nlet b = [3, 4];\nassert_set_joint!(a, b);\n# });\n// assertion failed: `assert_set_joint!(a_collection, b_collection)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_set_joint.html\n//  a label: `a`,\n//  a debug: `[1, 2]`,\n//  b label: `b`,\n//  b debug: `[3, 4]`,\n//        a: `{1, 2}`,\n//        b: `{3, 4}`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_set_joint!(a_collection, b_collection)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_set_joint.html\\n\",\n#     \" a label: `a`,\\n\",\n#     \" a debug: `[1, 2]`,\\n\",\n#     \" b label: `b`,\\n\",\n#     \" b debug: `[3, 4]`,\\n\",\n#     \"       a: `{1, 2}`,\\n\",\n#     \"       b: `{3, 4}`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\nThis implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.\n\n# Module macros\n\n* [`assert_set_joint`](macro@crate::assert_set_joint)\n* [`assert_set_joint_as_result`](macro@crate::assert_set_joint_as_result)\n* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)\n","links":{"`panic!`":1081,"macro@crate::debug_assert_set_joint":506,"macro@crate::assert_set_joint_as_result":505,"macro@crate::assert_set_joint":504},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_set_joint {\n    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };\n    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };\n}"}},"227":{"id":227,"crate_id":0,"name":"debug_assert_count_le_x","span":{"filename":"src/assert_count/assert_count_le_x.rs","begin":[330,0],"end":[336,1]},"visibility":"public","docs":"Assert a count is less than or equal to an expression.\n\nPseudocode:<br>\na.count() ≤ b\n\nThis macro provides the same statements as [`assert_count_le_x`](macro.assert_count_le_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_count_le_x`](macro@crate::assert_count_le_x)\n* [`assert_count_le_x`](macro@crate::assert_count_le_x)\n* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)\n","links":{"macro@crate::assert_count_le_x":225,"macro@crate::debug_assert_count_le_x":227},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_count_le_x {\n    ($($arg:tt)*) => { ... };\n}"}},"1108":{"id":1108,"crate_id":0,"name":"assert_option_none","span":{"filename":"src/assert_option/assert_option_none.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert expression is None.\n\nDeprecated. Please rename from `assert_option_none` into `assert_none` because more developers prefer the shorter name.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_option_none` into `assert_none` because more developers prefer the shorter name."},"inner":{"macro":"macro_rules! assert_option_none {\n    ($($arg:tt)*) => { ... };\n}"}},"831":{"id":831,"crate_id":0,"name":"assert_command_stdout_string_is_match","span":{"filename":"src/assert_command/assert_command_stdout_string_is_match.rs","begin":[232,0],"end":[245,1]},"visibility":"public","docs":"Assert a command stdout string is a match to a regex.\n\nPseudocode:<br>\n(command ⇒ stdout ⇒ string) is match (expr into string)\n\n* If true, return (command ⇒ stdout ⇒ string).\n\n* Otherwise, call [`panic!`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\n```rust\nuse assertables::*;\n# use std::panic;\nuse std::process::Command;\nuse regex::Regex;\n\n# fn main() {\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet matcher = Regex::new(r\"lf\").expect(\"regex\");\nassert_command_stdout_string_is_match!(command, matcher);\n\n# let result = panic::catch_unwind(|| {\n// This will panic\nlet mut command = Command::new(\"bin/printf-stdout\");\ncommand.args([\"%s\", \"alfa\"]);\nlet matcher = Regex::new(r\"zz\").expect(\"regex\");\nassert_command_stdout_string_is_match!(command, matcher);\n# });\n// assertion failed: `assert_command_stdout_string_is_match!(command, matcher)`\n// https://docs.rs/assertables/9.7.0/assertables/macro.assert_command_stdout_string_is_match.html\n//  command label: `command`,\n//  command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\n//  command value: `\\\"alfa\\\"`,\n//  matcher label: `matcher`,\n//  matcher debug: `Regex(\\\"zz\\\")`,\n//  matcher value: `Regex(\\\"zz\\\")`\n# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();\n# let message = concat!(\n#     \"assertion failed: `assert_command_stdout_string_is_match!(command, matcher)`\\n\",\n#     \"https://docs.rs/assertables/\", env!(\"CARGO_PKG_VERSION\"), \"/assertables/macro.assert_command_stdout_string_is_match.html\\n\",\n#     \" command label: `command`,\\n\",\n#     \" command debug: `\\\"bin/printf-stdout\\\" \\\"%s\\\" \\\"alfa\\\"`,\\n\",\n#     \" command value: `\\\"alfa\\\"`,\\n\",\n#     \" matcher label: `matcher`,\\n\",\n#     \" matcher debug: `Regex(\\\"zz\\\")`,\\n\",\n#     \" matcher value: `Regex(\\\"zz\\\")`\"\n# );\n# assert_eq!(actual, message);\n# }\n```\n\n# Module macros\n\n* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)\n* [`assert_command_stdout_string_is_match_as_result`](macro@crate::assert_command_stdout_string_is_match_as_result)\n* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)\n","links":{"macro@crate::assert_command_stdout_string_is_match":831,"macro@crate::debug_assert_command_stdout_string_is_match":833,"macro@crate::assert_command_stdout_string_is_match_as_result":832,"`panic!`":1081},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_command_stdout_string_is_match {\n    ($command:expr, $matcher:expr $(,)?) => { ... };\n    ($command:expr, $matcher:expr, $($message:tt)+) => { ... };\n}"}},"554":{"id":554,"crate_id":0,"name":"assert_fn_le_x_as_result","span":{"filename":"src/assert_fn/assert_fn_le_x.rs","begin":[44,0],"end":[110,1]},"visibility":"public","docs":"Assert a function output is less than or equal to an expression.\n\nPseudocode:<br>\nfunction(a) ≤ b\n\n* If true, return `Ok(a)`.\n\n* Otherwise, return [`Err`] with a message and the values of the\n  expressions with their debug representations.\n\n# Examples\n\nThis macro is useful for runtime checks, such as checking parameters,\nor sanitizing inputs, or handling different results in different ways.\n\n# Module macros\n\n* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)\n* [`assert_fn_le_x_as_result`](macro@crate::assert_fn_le_x_as_result)\n* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)\n","links":{"macro@crate::assert_fn_le_x_as_result":554,"macro@crate::assert_fn_le_x":553,"`Err`":1082,"macro@crate::debug_assert_fn_le_x":555},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! assert_fn_le_x_as_result {\n    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };\n    ($a_function:path, $b_expr:expr $(,)?) => { ... };\n}"}},"277":{"id":277,"crate_id":0,"name":"assert_len_eq","span":{"filename":"src/assert_len/assert_len_eq.rs","begin":[1,0],"end":[344,1]},"visibility":"public","docs":"Assert a length is equal to another.\n\nPseudocode:<br>\na.len() = b.len()\n\n# Example\n\n```rust\nuse assertables::*;\n\nlet a = \"x\";\nlet b = \"x\";\nassert_len_eq!(a, b);\n```\n\n# Module macros\n\n* [`assert_len_eq`](macro@crate::assert_len_eq)\n* [`assert_len_eq_as_result`](macro@crate::assert_len_eq_as_result)\n* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)","links":{"macro@crate::assert_len_eq_as_result":275,"macro@crate::assert_len_eq":274,"macro@crate::debug_assert_len_eq":276},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"1158":{"id":1158,"crate_id":0,"name":"assert_program_args_stdout_is_match","span":{"filename":"src/assert_program_args/assert_program_args_stdout_is_match.rs","begin":[27,0],"end":[31,1]},"visibility":"public","docs":"Assert a command (built with program and args) stdout into a string is a match to a regex.\n\nDeprecated. Please rename from `assert_program_args_stdout_is_match` to `assert_program_args_stdout_string_is_match`.\n","links":{},"attrs":["#[macro_export]"],"deprecation":{"since":null,"note":"Please rename from `assert_program_args_stdout_is_match` to `assert_program_args_stdout_string_is_match`."},"inner":{"macro":"macro_rules! assert_program_args_stdout_is_match {\n    ($($arg:tt)*) => { ... };\n}"}},"881":{"id":881,"crate_id":0,"name":"debug_assert_command_stderr_ne_x","span":{"filename":"src/assert_command/assert_command_stderr_ne_x.rs","begin":[375,0],"end":[381,1]},"visibility":"public","docs":"Assert a command stderr string is not equal to an expression.\n\nPseudocode:<br>\n(command ⇒ stderr) = (expr into string)\n\nThis macro provides the same statements as [`assert_command_stderr_ne_x`](macro.assert_command_stderr_ne_x.html),\nexcept this macro's statements are only enabled in non-optimized\nbuilds by default. An optimized build will not execute this macro's\nstatements unless `-C debug-assertions` is passed to the compiler.\n\nThis macro is useful for checks that are too expensive to be present\nin a release build but may be helpful during development.\n\nThe result of expanding this macro is always type checked.\n\nAn unchecked assertion allows a program in an inconsistent state to\nkeep running, which might have unexpected consequences but does not\nintroduce unsafety as long as this only happens in safe code. The\nperformance cost of assertions, however, is not measurable in general.\nReplacing `assert*!` with `debug_assert*!` is thus only encouraged\nafter thorough profiling, and more importantly, only in safe code!\n\nThis macro is intended to work in a similar way to\n[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).\n\n# Module macros\n\n* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)\n* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)\n* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)\n","links":{"macro@crate::debug_assert_command_stderr_ne_x":881,"macro@crate::assert_command_stderr_ne_x":879},"attrs":["#[macro_export]"],"deprecation":null,"inner":{"macro":"macro_rules! debug_assert_command_stderr_ne_x {\n    ($($arg:tt)*) => { ... };\n}"}}},"paths":{"0":{"crate_id":2,"path":["core","assert"],"kind":"macro"},"1762":{"crate_id":11,"path":["hashbrown","set","IntoIter"],"kind":"struct"},"2089":{"crate_id":18,"path":["memchr","arch","all","memchr","TwoIter"],"kind":"struct"},"327":{"crate_id":0,"path":["assertables","assert_not_matches"],"kind":"macro"},"1208":{"crate_id":2,"path":["core","num","dec2flt","FloatErrorKind"],"kind":"enum"},"2970":{"crate_id":17,"path":["object","read","Error"],"kind":"struct"},"3297":{"crate_id":17,"path":["object","read","archive","ArchiveOffset"],"kind":"struct"},"1535":{"crate_id":3,"path":["alloc","bstr","ByteString"],"kind":"struct"},"654":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_le_x"],"kind":"module"},"2416":{"crate_id":2,"path":["core","ops","function","FnOnce"],"kind":"trait"},"2743":{"crate_id":1,"path":["std","path","Ancestors"],"kind":"struct"},"981":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_eq_x"],"kind":"module"},"100":{"crate_id":0,"path":["assertables","assert_abs_diff_ne_x"],"kind":"macro"},"1862":{"crate_id":3,"path":["alloc","string","FromUtf16Error"],"kind":"struct"},"2189":{"crate_id":17,"path":["object","read","RelocationMapEntry"],"kind":"struct"},"427":{"crate_id":0,"path":["assertables","assert_poll","assert_poll_ready_ne"],"kind":"module"},"1308":{"crate_id":17,"path":["object","macho","Section32"],"kind":"struct"},"3070":{"crate_id":17,"path":["object","elf","Dyn64"],"kind":"struct"},"3397":{"crate_id":3,"path":["alloc","collections","btree","borrow","DormantMutRef"],"kind":"struct"},"754":{"crate_id":0,"path":["assertables","assert_io_read_to_string_gt_x"],"kind":"macro"},"1635":{"crate_id":3,"path":["alloc","collections","linked_list","LinkedList"],"kind":"struct"},"2516":{"crate_id":1,"path":["std","fn"],"kind":"primitive"},"2843":{"crate_id":16,"path":["gimli","constants","DwForm"],"kind":"struct"},"200":{"crate_id":0,"path":["assertables","assert_count","assert_count_gt"],"kind":"module"},"1962":{"crate_id":1,"path":["std","io","IoSliceMut"],"kind":"struct"},"1081":{"crate_id":1,"path":["std","panic"],"kind":"macro"},"1408":{"crate_id":2,"path":["core","core_simd","cast","SimdCast"],"kind":"trait"},"527":{"crate_id":0,"path":["assertables","debug_assert_fn_gt"],"kind":"macro"},"2289":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x4x3_t"],"kind":"struct"},"3170":{"crate_id":2,"path":["core","core_arch","simd","i8x32"],"kind":"struct"},"854":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_lt"],"kind":"module"},"1735":{"crate_id":2,"path":["core","num","niche_types","NonZeroI32Inner"],"kind":"struct"},"2616":{"crate_id":2,"path":["core","iter","adapters","flatten","Flatten"],"kind":"struct"},"2943":{"crate_id":17,"path":["object","xcoff","SymbolBytes"],"kind":"struct"},"300":{"crate_id":0,"path":["assertables","debug_assert_len_eq_x"],"kind":"macro"},"1181":{"crate_id":3,"path":["alloc","task","LocalWake"],"kind":"trait"},"2062":{"crate_id":16,"path":["gimli","read","cfi","AugmentationData"],"kind":"struct"},"1508":{"crate_id":2,"path":["core","alloc","layout","LayoutError"],"kind":"struct"},"627":{"crate_id":0,"path":["assertables","assert_fn_ok_le"],"kind":"macro"},"2389":{"crate_id":6,"path":["libc","unix","group"],"kind":"struct"},"3270":{"crate_id":16,"path":["gimli","read","cfi","EhHdrTableIter"],"kind":"struct"},"954":{"crate_id":0,"path":["assertables","assert_program_args_stderr_eq"],"kind":"macro"},"73":{"crate_id":0,"path":["assertables","debug_assert_f64_lt"],"kind":"macro"},"1835":{"crate_id":2,"path":["core","core_arch","simd","u8x8"],"kind":"struct"},"2716":{"crate_id":1,"path":["std","sys","process","unix","unix","posix_spawn","PosixSpawnattr"],"kind":"struct"},"2162":{"crate_id":1,"path":["std","os","unix","net","datagram","UnixDatagram"],"kind":"struct"},"400":{"crate_id":0,"path":["assertables","debug_assert_some"],"kind":"macro"},"1281":{"crate_id":1,"path":["std","sync","poison","rwlock","MappedRwLockReadGuard"],"kind":"struct"},"3043":{"crate_id":17,"path":["object","read","elf","version","VerneedIterator"],"kind":"struct"},"1608":{"crate_id":6,"path":["libc","unix","bsd","apple","icmp6_ifstat"],"kind":"struct"},"727":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ge_as_result"],"kind":"macro"},"2489":{"crate_id":1,"path":["std","collections","hash","set","Drain"],"kind":"struct"},"3370":{"crate_id":17,"path":["object","read","elf","note","GnuPropertyIterator"],"kind":"struct"},"2816":{"crate_id":17,"path":["object","elf","Verdef"],"kind":"struct"},"1054":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_ge_x"],"kind":"module"},"173":{"crate_id":0,"path":["assertables","assert_any_as_result"],"kind":"macro"},"1935":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","max_align_t"],"kind":"struct"},"2262":{"crate_id":1,"path":["std","collections","hash","map","Drain"],"kind":"struct"},"500":{"crate_id":0,"path":["assertables","assert_set_disjoint"],"kind":"macro"},"1381":{"crate_id":6,"path":["libc","unix","bsd","apple","sembuf"],"kind":"struct"},"3143":{"crate_id":17,"path":["object","pe","NonPagedDebugInfo"],"kind":"struct"},"1708":{"crate_id":1,"path":["std","io","pipe","PipeWriter"],"kind":"struct"},"827":{"crate_id":0,"path":["assertables","assert_command_stdout_string_contains"],"kind":"macro"},"2589":{"crate_id":3,"path":["alloc","ffi","c_str","FromBytesWithNulErrorKind"],"kind":"enum"},"2916":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Reason_Code"],"kind":"enum"},"273":{"crate_id":0,"path":["assertables","assert_is_match"],"kind":"module"},"1154":{"crate_id":0,"path":["assertables","assert_program_args_stdout_contains_as_result"],"kind":"macro"},"2035":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_identifier_info"],"kind":"struct"},"2362":{"crate_id":6,"path":["libc","unix","bsd","apple","attrlist"],"kind":"struct"},"600":{"crate_id":0,"path":["assertables","debug_assert_fn_err_gt_x"],"kind":"macro"},"1481":{"crate_id":2,"path":["core","slice","iter","RChunksExact"],"kind":"struct"},"3243":{"crate_id":9,"path":["miniz_oxide","inflate","core","State"],"kind":"enum"},"927":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_ge_x"],"kind":"module"},"46":{"crate_id":0,"path":["assertables","assert_f32_lt"],"kind":"macro"},"1808":{"crate_id":2,"path":["core","str","iter","RMatches"],"kind":"struct"},"2689":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x4x2_t"],"kind":"struct"},"3016":{"crate_id":2,"path":["core","char","decode","DecodeUtf16Error"],"kind":"struct"},"373":{"crate_id":0,"path":["assertables","assert_ok","assert_ok_ne"],"kind":"module"},"1254":{"crate_id":16,"path":["gimli","constants","DwVis"],"kind":"struct"},"2135":{"crate_id":17,"path":["object","pe","ImageArchitectureEntry"],"kind":"struct"},"2462":{"crate_id":1,"path":["std","os","unix","fs","DirBuilderExt"],"kind":"trait"},"700":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_le_x"],"kind":"macro"},"1581":{"crate_id":16,"path":["gimli","read","str","DebugLineStr"],"kind":"struct"},"3343":{"crate_id":1,"path":["std","process","Stdio"],"kind":"struct"},"1027":{"crate_id":0,"path":["assertables","assert_status_code_value_ge"],"kind":"macro"},"146":{"crate_id":0,"path":["assertables","debug_assert_diff_lt_x"],"kind":"macro"},"1908":{"crate_id":11,"path":["hashbrown"],"kind":"module"},"2789":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3116":{"crate_id":1,"path":["std","sync","mpsc","TryRecvError"],"kind":"enum"},"473":{"crate_id":0,"path":["assertables","debug_assert_iter_ge"],"kind":"macro"},"1354":{"crate_id":16,"path":["gimli","constants","DwChildren"],"kind":"struct"},"2235":{"crate_id":17,"path":["object","common","SectionFlags"],"kind":"enum"},"1681":{"crate_id":2,"path":["core","ascii","EscapeDefault"],"kind":"struct"},"800":{"crate_id":0,"path":["assertables","assert_command_stdout_ne"],"kind":"macro"},"2562":{"crate_id":10,"path":["adler2","algo","U32X4"],"kind":"struct"},"3443":{"crate_id":2,"path":["core","convert","From"],"kind":"trait"},"1127":{"crate_id":0,"path":["assertables","debug_assert_poll_ready_eq"],"kind":"macro"},"246":{"crate_id":0,"path":["assertables","assert_email_address"],"kind":"module"},"2008":{"crate_id":17,"path":["object","xcoff","FunAux64"],"kind":"struct"},"2889":{"crate_id":2,"path":["core","convert","Infallible"],"kind":"enum"},"2335":{"crate_id":2,"path":["core","slice","iter","SplitInclusiveMut"],"kind":"struct"},"573":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_ge"],"kind":"module"},"1454":{"crate_id":9,"path":["miniz_oxide","DataFormat"],"kind":"enum"},"3216":{"crate_id":2,"path":["core","core_arch","aarch64","neon","splat","JustOne"],"kind":"struct"},"1781":{"crate_id":1,"path":["std","sys","pal","unix","time","Timespec"],"kind":"struct"},"19":{"crate_id":0,"path":["assertables","assert_lt"],"kind":"module"},"900":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ge"],"kind":"macro"},"2662":{"crate_id":2,"path":["core","iter","sources","empty","Empty"],"kind":"struct"},"2989":{"crate_id":2,"path":["core","option","IntoIter"],"kind":"struct"},"1227":{"crate_id":16,"path":["gimli","common","RangeListsOffset"],"kind":"struct"},"346":{"crate_id":0,"path":["assertables","assert_err_eq_as_result"],"kind":"macro"},"2108":{"crate_id":3,"path":["alloc","slice","Join"],"kind":"trait"},"2435":{"crate_id":6,"path":["libc","unix","bsd","sockaddr_in6"],"kind":"struct"},"673":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_gt_as_result"],"kind":"macro"},"1554":{"crate_id":17,"path":["object","macho","EncryptionInfoCommand64"],"kind":"struct"},"3316":{"crate_id":11,"path":["hashbrown","control","bitmask","BitMaskIter"],"kind":"struct"},"1881":{"crate_id":1,"path":["std","os","fd","owned","BorrowedFd"],"kind":"struct"},"1000":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_ne_x"],"kind":"module"},"119":{"crate_id":0,"path":["assertables","assert_in_delta"],"kind":"macro"},"2762":{"crate_id":2,"path":["core","core_arch","simd","i8x8"],"kind":"struct"},"3089":{"crate_id":3,"path":["alloc","alloc","alloc"],"kind":"function"},"446":{"crate_id":0,"path":["assertables","assert_ready_ne_x_as_result"],"kind":"macro"},"1327":{"crate_id":2,"path":["core","marker","variance","PhantomInvariant"],"kind":"struct"},"2208":{"crate_id":17,"path":["object","elf","CompressionHeader64"],"kind":"struct"},"2535":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x2x4_t"],"kind":"struct"},"773":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_contains"],"kind":"module"},"1654":{"crate_id":2,"path":["core","ops","async_function","AsyncFnMut"],"kind":"trait"},"3416":{"crate_id":17,"path":["object","pe","Guid"],"kind":"struct"},"1100":{"crate_id":0,"path":["assertables","debug_assert_result_ok"],"kind":"macro"},"219":{"crate_id":0,"path":["assertables","debug_assert_count_ge_x"],"kind":"macro"},"1981":{"crate_id":18,"path":["memchr","memmem","Finder"],"kind":"struct"},"2862":{"crate_id":17,"path":["object","read","Export"],"kind":"struct"},"3189":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x8x3_t"],"kind":"struct"},"546":{"crate_id":0,"path":["assertables","assert_fn_ge_x_as_result"],"kind":"macro"},"1427":{"crate_id":17,"path":["object","pe","ImageRelocation"],"kind":"struct"},"2308":{"crate_id":17,"path":["object","read","pe","import","ImportTable"],"kind":"struct"},"2635":{"crate_id":1,"path":["std","backtrace_rs","print","BacktraceFrameFmt"],"kind":"struct"},"873":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_le_x"],"kind":"macro"},"1754":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8"],"kind":"struct"},"1200":{"crate_id":2,"path":["core","iter","adapters","zip","Zip"],"kind":"struct"},"319":{"crate_id":0,"path":["assertables","assert_len_ne_x_as_result"],"kind":"macro"},"2081":{"crate_id":17,"path":["object","read","any","File"],"kind":"enum"},"2962":{"crate_id":1,"path":["std","i8"],"kind":"primitive"},"3289":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x1x3_t"],"kind":"struct"},"646":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_ge_x"],"kind":"module"},"1527":{"crate_id":2,"path":["core","str","pattern","Pattern"],"kind":"trait"},"2408":{"crate_id":1,"path":["std","process","Child"],"kind":"struct"},"1854":{"crate_id":2,"path":["core","str","iter","RMatchIndices"],"kind":"struct"},"973":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_lt"],"kind":"module"},"92":{"crate_id":0,"path":["assertables","assert_abs_diff_le_x"],"kind":"macro"},"2735":{"crate_id":1,"path":["std","fs","FileType"],"kind":"struct"},"1300":{"crate_id":18,"path":["memchr","memmem","FinderRev"],"kind":"struct"},"419":{"crate_id":0,"path":["assertables","assert_pending"],"kind":"macro"},"2181":{"crate_id":18,"path":["memchr","arch","all","twoway","FinderRev"],"kind":"struct"},"3062":{"crate_id":2,"path":["core","ops","arith","Mul"],"kind":"trait"},"2508":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"746":{"crate_id":0,"path":["assertables","assert_io_read_to_string_eq_x"],"kind":"macro"},"1627":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","__darwin_arm_thread_state64"],"kind":"struct"},"3389":{"crate_id":1,"path":["std","unit"],"kind":"primitive"},"1954":{"crate_id":16,"path":["gimli","read","op","Expression"],"kind":"struct"},"192":{"crate_id":0,"path":["assertables","assert_count","assert_count_eq"],"kind":"module"},"1073":{"crate_id":0,"path":["assertables","debug_assert_success"],"kind":"macro"},"2835":{"crate_id":2,"path":["core","ops","arith","Rem"],"kind":"trait"},"1400":{"crate_id":17,"path":["object","pe","ImageBoundImportDescriptor"],"kind":"struct"},"519":{"crate_id":0,"path":["assertables","debug_assert_fn_eq"],"kind":"macro"},"2281":{"crate_id":1,"path":["std","thread","JoinHandle"],"kind":"struct"},"3162":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2608":{"crate_id":17,"path":["object","pe","ImageDebugDirectory"],"kind":"struct"},"846":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_gt"],"kind":"module"},"1727":{"crate_id":2,"path":["core","ops","bit","Shl"],"kind":"trait"},"2054":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x8x4_t"],"kind":"struct"},"292":{"crate_id":0,"path":["assertables","debug_assert_len_lt"],"kind":"macro"},"1173":{"crate_id":1,"path":["std","sys","pal","unix","args","Args"],"kind":"struct"},"2935":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_ctl"],"kind":"struct"},"3262":{"crate_id":3,"path":["alloc","boxed","Box"],"kind":"struct"},"619":{"crate_id":0,"path":["assertables","assert_fn_ok_ge"],"kind":"macro"},"1500":{"crate_id":2,"path":["core","cmp","Eq"],"kind":"trait"},"2381":{"crate_id":1,"path":["std","sync","poison","mutex","MutexGuard"],"kind":"struct"},"2708":{"crate_id":2,"path":["core","iter"],"kind":"module"},"65":{"crate_id":0,"path":["assertables","debug_assert_f64_gt"],"kind":"macro"},"946":{"crate_id":0,"path":["assertables","assert_program_args_stdout_string_contains"],"kind":"macro"},"1827":{"crate_id":2,"path":["core","num","niche_types","NonZeroI16Inner"],"kind":"struct"},"2154":{"crate_id":1,"path":["std","sys","pal","unix","fd","FileDesc"],"kind":"struct"},"392":{"crate_id":0,"path":["assertables","assert_none"],"kind":"module"},"1273":{"crate_id":16,"path":["gimli","constants","DwAccess"],"kind":"struct"},"3035":{"crate_id":2,"path":["core","error","Error"],"kind":"trait"},"3362":{"crate_id":2,"path":["core","str","error","ParseBoolError"],"kind":"struct"},"719":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_is_match"],"kind":"module"},"1600":{"crate_id":1,"path":["std","sys","sync","mutex","pthread","Mutex"],"kind":"struct"},"2481":{"crate_id":1,"path":["std","panicking","begin_panic_handler","StaticStrPayload"],"kind":"struct"},"2808":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x4_t"],"kind":"struct"},"1046":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_ne"],"kind":"module"},"165":{"crate_id":0,"path":["assertables","debug_assert_in_range"],"kind":"macro"},"1927":{"crate_id":6,"path":["libc","unix","iovec"],"kind":"struct"},"1373":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x16_t"],"kind":"struct"},"492":{"crate_id":0,"path":["assertables","assert_set_eq"],"kind":"macro"},"2254":{"crate_id":1,"path":["std","os","darwin","raw","stat"],"kind":"struct"},"3135":{"crate_id":2,"path":["core","slice","iter","IterMut"],"kind":"struct"},"819":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_le_x"],"kind":"module"},"1700":{"crate_id":2,"path":["core","iter","adapters","copied","Copied"],"kind":"struct"},"2581":{"crate_id":17,"path":["object","read","pe","resource","ResourceDirectory"],"kind":"struct"},"2027":{"crate_id":2,"path":["core","array","TryFromSliceError"],"kind":"struct"},"265":{"crate_id":0,"path":["assertables","assert_is_match"],"kind":"macro"},"1146":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_is_match"],"kind":"macro"},"2908":{"crate_id":17,"path":["object","macho","IdentCommand"],"kind":"struct"},"1473":{"crate_id":2,"path":["core","hash","sip","SipHasher13"],"kind":"struct"},"592":{"crate_id":0,"path":["assertables","debug_assert_fn_err_eq_x"],"kind":"macro"},"2354":{"crate_id":1,"path":["std","panic","PanicHookInfo"],"kind":"struct"},"3235":{"crate_id":17,"path":["object","macho","SymtabCommand"],"kind":"struct"},"2681":{"crate_id":17,"path":["object","read","elf","note","GnuProperty"],"kind":"struct"},"919":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_ne"],"kind":"module"},"38":{"crate_id":0,"path":["assertables","assert_f32_gt"],"kind":"macro"},"1800":{"crate_id":2,"path":["core","str","traits","FromStr"],"kind":"trait"},"2127":{"crate_id":1,"path":["std","sync","mpsc","RecvError"],"kind":"struct"},"365":{"crate_id":0,"path":["assertables","assert_ok","assert_ok"],"kind":"module"},"1246":{"crate_id":2,"path":["core","ops","try_trait","Try"],"kind":"trait"},"3008":{"crate_id":1,"path":["std","io","buffered","bufwriter","flush_buf","BufGuard"],"kind":"struct"},"1573":{"crate_id":17,"path":["object","read","any","SectionRelocationIterator"],"kind":"struct"},"692":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ge_x"],"kind":"macro"},"2454":{"crate_id":3,"path":["alloc","collections","btree","set","entry","VacantEntry"],"kind":"struct"},"3335":{"crate_id":3,"path":["alloc","collections","btree","map","RangeMut"],"kind":"struct"},"2781":{"crate_id":17,"path":["object","macho","RpathCommand"],"kind":"struct"},"138":{"crate_id":0,"path":["assertables","debug_assert_diff_gt_x"],"kind":"macro"},"1019":{"crate_id":0,"path":["assertables","assert_status_failure"],"kind":"macro"},"1900":{"crate_id":2,"path":["core","ops","try_trait","NeverShortCircuit"],"kind":"struct"},"2227":{"crate_id":2,"path":["core","core_arch","simd","m16x16"],"kind":"struct"},"465":{"crate_id":0,"path":["assertables","assert_bag","assert_bag_superbag"],"kind":"module"},"1346":{"crate_id":1,"path":["std","process","ExitStatusError"],"kind":"struct"},"3108":{"crate_id":1,"path":["std","panic","BacktraceStyle"],"kind":"enum"},"3435":{"crate_id":16,"path":["gimli","common","DebugAddrIndex"],"kind":"struct"},"792":{"crate_id":0,"path":["assertables","assert_command_stdout_le"],"kind":"macro"},"1673":{"crate_id":2,"path":["core","ops","bit","BitOr"],"kind":"trait"},"2554":{"crate_id":1,"path":["std","sys","pal","unix","thread","Thread"],"kind":"struct"},"2881":{"crate_id":2,"path":["core","default","Default"],"kind":"trait"},"238":{"crate_id":0,"path":["assertables","assert_email_address"],"kind":"macro"},"1119":{"crate_id":0,"path":["assertables","assert_poll_pending_as_result"],"kind":"macro"},"2000":{"crate_id":2,"path":["core","cell","BorrowRef"],"kind":"struct"},"2327":{"crate_id":6,"path":["libc","unix","bsd","fd_set"],"kind":"struct"},"565":{"crate_id":0,"path":["assertables","assert_fn"],"kind":"module"},"1446":{"crate_id":1,"path":["std","env","Vars"],"kind":"struct"},"3208":{"crate_id":1,"path":["std","sys_common","wtf8","CodePoint"],"kind":"struct"},"892":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_string_is_match"],"kind":"module"},"11":{"crate_id":0,"path":["assertables","assert_gt"],"kind":"module"},"1773":{"crate_id":1,"path":["std","process","ExitStatus"],"kind":"struct"},"2654":{"crate_id":13,"path":["std_detect"],"kind":"module"},"2981":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"338":{"crate_id":0,"path":["assertables","debug_assert_starts_with"],"kind":"macro"},"1219":{"crate_id":17,"path":["object","read","RelocationTarget"],"kind":"enum"},"2100":{"crate_id":1,"path":["std","collections","hash","map","ValuesMut"],"kind":"struct"},"1546":{"crate_id":15,"path":["addr2line","unit","LocationRangeIter"],"kind":"struct"},"665":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_eq_as_result"],"kind":"macro"},"2427":{"crate_id":2,"path":["core","cell","lazy","LazyCell"],"kind":"struct"},"3308":{"crate_id":6,"path":["libc","unix","timespec"],"kind":"struct"},"992":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_le_x"],"kind":"module"},"111":{"crate_id":0,"path":["assertables","assert_abs_diff_ne"],"kind":"macro"},"1873":{"crate_id":2,"path":["core","sync","exclusive","Exclusive"],"kind":"struct"},"2754":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"2200":{"crate_id":6,"path":["libc","unix","bsd","apple","pthread_rwlock_t"],"kind":"struct"},"438":{"crate_id":0,"path":["assertables","assert_ready_ne_as_result"],"kind":"macro"},"1319":{"crate_id":2,"path":["core","core_arch","simd","u32x16"],"kind":"struct"},"3081":{"crate_id":17,"path":["object","read","coff","file","CoffFile"],"kind":"struct"},"1646":{"crate_id":16,"path":["gimli","constants","DwDsc"],"kind":"struct"},"765":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_lt_x"],"kind":"module"},"2527":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3408":{"crate_id":17,"path":["object","common","ComdatKind"],"kind":"enum"},"1092":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_lt"],"kind":"macro"},"211":{"crate_id":0,"path":["assertables","debug_assert_count_ne"],"kind":"macro"},"1973":{"crate_id":3,"path":["alloc","collections","binary_heap","Drain"],"kind":"struct"},"2854":{"crate_id":1,"path":["std","process","ChildStdin"],"kind":"struct"},"2300":{"crate_id":16,"path":["gimli","read","unit","EntriesRaw"],"kind":"struct"},"538":{"crate_id":0,"path":["assertables","assert_fn_ne_as_result"],"kind":"macro"},"1419":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3181":{"crate_id":3,"path":["alloc","collections","btree","map","entry","OccupiedEntry"],"kind":"struct"},"1746":{"crate_id":17,"path":["object","macho","DyldCacheHeader"],"kind":"struct"},"865":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_ge_x"],"kind":"macro"},"2627":{"crate_id":2,"path":["core","fmt","Result"],"kind":"type_alias"},"2954":{"crate_id":16,"path":["gimli","read","abbrev","Abbreviations"],"kind":"struct"},"311":{"crate_id":0,"path":["assertables","assert_len_le_x_as_result"],"kind":"macro"},"1192":{"crate_id":2,"path":["core","core_arch","simd","i64x2"],"kind":"struct"},"2073":{"crate_id":16,"path":["gimli","read","lookup","PubStuffHeader"],"kind":"struct"},"2400":{"crate_id":17,"path":["object","read","macho","symbol","SymbolTable"],"kind":"struct"},"638":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_ne"],"kind":"module"},"1519":{"crate_id":17,"path":["object","read","any","SymbolTable"],"kind":"struct"},"3281":{"crate_id":2,"path":["core","str","lossy","Debug"],"kind":"struct"},"1846":{"crate_id":16,"path":["gimli","common","DebugLineStrOffset"],"kind":"struct"},"965":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_gt"],"kind":"module"},"84":{"crate_id":0,"path":["assertables","assert_abs_diff_ge_x"],"kind":"macro"},"2727":{"crate_id":17,"path":["object","read","read_cache","ReadCache"],"kind":"struct"},"3054":{"crate_id":1,"path":["std","os","unix","process","ExitStatusExt"],"kind":"trait"},"411":{"crate_id":0,"path":["assertables","assert_some_eq_x_as_result"],"kind":"macro"},"1292":{"crate_id":1,"path":["std","process","ChildStderr"],"kind":"struct"},"2173":{"crate_id":16,"path":["gimli","common","Vendor"],"kind":"enum"},"2500":{"crate_id":1,"path":["std","sync","mpsc","Sender"],"kind":"struct"},"738":{"crate_id":0,"path":["assertables","assert_io_read_to_string_lt"],"kind":"macro"},"1619":{"crate_id":17,"path":["object","elf","Relr32"],"kind":"struct"},"3381":{"crate_id":3,"path":["alloc","rc","UniqueRcUninit"],"kind":"struct"},"1065":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_lt_x"],"kind":"macro"},"184":{"crate_id":0,"path":["assertables","assert_not_contains"],"kind":"macro"},"1946":{"crate_id":1,"path":["std","os","fd","owned","AsFd"],"kind":"trait"},"2827":{"crate_id":6,"path":["libc","unix","timeval"],"kind":"struct"},"3154":{"crate_id":2,"path":["core","net","parser","AddrParseError"],"kind":"struct"},"511":{"crate_id":0,"path":["assertables","assert_set","assert_set_subset"],"kind":"module"},"1392":{"crate_id":6,"path":["libc","unix","bsd","apple","__c_anonymous_ifr_ifru6"],"kind":"union"},"2273":{"crate_id":1,"path":["std","sync","lazy_lock","force_mut","really_init_mut","PoisonOnPanic"],"kind":"struct"},"1719":{"crate_id":2,"path":["core","core_arch","aarch64","neon","splat","JustOne"],"kind":"struct"},"838":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_eq"],"kind":"module"},"2600":{"crate_id":17,"path":["object","macho","DyldInfoCommand"],"kind":"struct"},"1165":{"crate_id":0,"path":["assertables","assert_program_args_stderr_is_match"],"kind":"macro"},"284":{"crate_id":0,"path":["assertables","debug_assert_len_gt"],"kind":"macro"},"2046":{"crate_id":1,"path":["std","io","pipe","PipeReader"],"kind":"struct"},"2927":{"crate_id":16,"path":["gimli","constants","DwAddr"],"kind":"struct"},"2373":{"crate_id":2,"path":["core","str","IsNotEmpty"],"kind":"struct"},"611":{"crate_id":0,"path":["assertables","assert_fn_err_ne_x_as_result"],"kind":"macro"},"1492":{"crate_id":1,"path":["std","collections","hash","set","Difference"],"kind":"struct"},"3254":{"crate_id":17,"path":["object","read","pe","relocation","Relocation"],"kind":"struct"},"1819":{"crate_id":6,"path":["libc","unix","bsd","apple","statfs"],"kind":"struct"},"57":{"crate_id":0,"path":["assertables","debug_assert_f64_eq"],"kind":"macro"},"938":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_lt_x"],"kind":"macro"},"2700":{"crate_id":2,"path":["core","range","Range"],"kind":"struct"},"1265":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_in"],"kind":"struct"},"384":{"crate_id":0,"path":["assertables","assert_result","assert_result_ok"],"kind":"module"},"2146":{"crate_id":2,"path":["core","core_simd","vector","Simd"],"kind":"struct"},"3027":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldSubCache"],"kind":"struct"},"2473":{"crate_id":2,"path":["core","core_simd","simd","num","uint","SimdUint"],"kind":"trait"},"711":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_ne_x"],"kind":"module"},"1592":{"crate_id":6,"path":["libc","unix","bsd","apple","rusage_info_v3"],"kind":"struct"},"3354":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandIterator"],"kind":"struct"},"1919":{"crate_id":11,"path":["hashbrown","map","IterMut"],"kind":"struct"},"1038":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_le"],"kind":"module"},"157":{"crate_id":0,"path":["assertables","assert_in_delta_as_result"],"kind":"macro"},"2800":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x2x4_t"],"kind":"struct"},"3127":{"crate_id":17,"path":["object","read","RelocationMap"],"kind":"struct"},"484":{"crate_id":0,"path":["assertables","assert_iter_lt_as_result"],"kind":"macro"},"1365":{"crate_id":1,"path":["std","hash","random","RandomState"],"kind":"struct"},"2246":{"crate_id":1,"path":["std","sys","fs","unix","Mode"],"kind":"struct"},"2573":{"crate_id":2,"path":["core","task","wake","LocalWaker"],"kind":"struct"},"811":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_ge_x"],"kind":"module"},"1692":{"crate_id":11,"path":["hashbrown","map","Keys"],"kind":"struct"},"3454":{"crate_id":6,"path":["libc","unix","bsd","apple","vnode_info"],"kind":"struct"},"2019":{"crate_id":17,"path":["object","common","SectionKind"],"kind":"enum"},"257":{"crate_id":0,"path":["assertables","assert_is_empty_as_result"],"kind":"macro"},"1138":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_matches"],"kind":"macro"},"2900":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdatSectionIterator"],"kind":"struct"},"3227":{"crate_id":6,"path":["libc","unix","bsd","if_nameindex"],"kind":"struct"},"584":{"crate_id":0,"path":["assertables","debug_assert_fn_err_lt"],"kind":"macro"},"1465":{"crate_id":2,"path":["core","ptr","alignment","Alignment"],"kind":"struct"},"2346":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_dl"],"kind":"struct"},"2673":{"crate_id":1,"path":["std","sync","reentrant_lock","ReentrantLockGuard"],"kind":"struct"},"911":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_le"],"kind":"module"},"30":{"crate_id":0,"path":["assertables","assert_f32_eq"],"kind":"macro"},"1792":{"crate_id":4,"path":["compiler_builtins","math","libm","support","env","Round"],"kind":"enum"},"1238":{"crate_id":2,"path":["core","num","fmt","Part"],"kind":"enum"},"357":{"crate_id":0,"path":["assertables","assert_err_ne_x"],"kind":"macro"},"2119":{"crate_id":1,"path":["std","f128"],"kind":"primitive"},"3000":{"crate_id":17,"path":["object","read","xcoff","section","SectionTable"],"kind":"struct"},"3327":{"crate_id":17,"path":["object","read","coff","import","ImportType"],"kind":"enum"},"684":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ne"],"kind":"macro"},"1565":{"crate_id":16,"path":["gimli","read","pubtypes","PubTypesEntry"],"kind":"struct"},"2446":{"crate_id":17,"path":["object","pe","ImageHotPatchBase"],"kind":"struct"},"1892":{"crate_id":3,"path":["alloc","collections","binary_heap","PeekMut"],"kind":"struct"},"130":{"crate_id":0,"path":["assertables","debug_assert_diff_eq_x"],"kind":"macro"},"1011":{"crate_id":0,"path":["assertables","assert_status_success"],"kind":"macro"},"2773":{"crate_id":2,"path":["core","slice","iter","SplitN"],"kind":"struct"},"1338":{"crate_id":2,"path":["core","iter","adapters","scan","Scan"],"kind":"struct"},"457":{"crate_id":0,"path":["assertables","assert_bag","assert_bag_ne"],"kind":"module"},"2219":{"crate_id":18,"path":["memchr","arch","all","packedpair","Finder"],"kind":"struct"},"3100":{"crate_id":17,"path":["object","read","any","SymbolTableInternal"],"kind":"enum"},"3427":{"crate_id":16,"path":["gimli","read","abbrev","AttributeSpecification"],"kind":"struct"},"784":{"crate_id":0,"path":["assertables","assert_command_stdout_ge"],"kind":"macro"},"1665":{"crate_id":2,"path":["core","alloc","AllocError"],"kind":"struct"},"2546":{"crate_id":1,"path":["std","char"],"kind":"primitive"},"1992":{"crate_id":2,"path":["core","async_iter","async_iter","IntoAsyncIterator"],"kind":"trait"},"230":{"crate_id":0,"path":["assertables","assert_count_lt_x_as_result"],"kind":"macro"},"1111":{"crate_id":0,"path":["assertables","assert_option_some"],"kind":"macro"},"2873":{"crate_id":17,"path":["object","xcoff","SectionHeader64"],"kind":"struct"},"1438":{"crate_id":2,"path":["core","mem","Discriminant"],"kind":"struct"},"557":{"crate_id":0,"path":["assertables","assert_fn_lt_x"],"kind":"macro"},"2319":{"crate_id":18,"path":["memchr","arch","aarch64","neon","memchr","OneIter"],"kind":"struct"},"3200":{"crate_id":17,"path":["object","read","pe","data_directory","DataDirectories"],"kind":"struct"},"2646":{"crate_id":2,"path":["core","escape","EscapeIterInner"],"kind":"struct"},"3":{"crate_id":0,"path":["assertables","assert_eq"],"kind":"module"},"884":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_is_match"],"kind":"module"},"1765":{"crate_id":1,"path":["std","i128"],"kind":"primitive"},"2092":{"crate_id":16,"path":["gimli","read","line","LineRow"],"kind":"struct"},"330":{"crate_id":0,"path":["assertables","assert_matches","assert_not_matches"],"kind":"module"},"1211":{"crate_id":6,"path":["libc","unix","bsd","apple","in_addr"],"kind":"struct"},"2973":{"crate_id":1,"path":["std","net","tcp","IntoIncoming"],"kind":"struct"},"3300":{"crate_id":2,"path":["core","asserting","TryCaptureWithoutDebug"],"kind":"struct"},"1538":{"crate_id":17,"path":["object","read","pe","resource","ResourceNameOrId"],"kind":"enum"},"657":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_lt_x"],"kind":"macro"},"2419":{"crate_id":3,"path":["alloc","collections","btree","node","NodeRef"],"kind":"struct"},"2746":{"crate_id":3,"path":["alloc","vec","dedup_by","FillGapOnDrop"],"kind":"struct"},"103":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_ne_x"],"kind":"module"},"984":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_ge_x"],"kind":"module"},"1865":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2192":{"crate_id":17,"path":["object","macho","Fvmlib"],"kind":"struct"},"430":{"crate_id":0,"path":["assertables","assert_ready_as_result"],"kind":"macro"},"1311":{"crate_id":2,"path":["core","slice","iter","SplitNMut"],"kind":"struct"},"3073":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_latency_qos_policy"],"kind":"struct"},"3400":{"crate_id":1,"path":["std","sys","pal","unix","time","SystemTime"],"kind":"struct"},"757":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_gt_x"],"kind":"module"},"1638":{"crate_id":16,"path":["gimli","read","cfi","CommonInformationEntry"],"kind":"struct"},"2519":{"crate_id":2,"path":["core","slice","index","SliceIndex"],"kind":"trait"},"2846":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandData"],"kind":"struct"},"1084":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_eq"],"kind":"macro"},"203":{"crate_id":0,"path":["assertables","debug_assert_count_le"],"kind":"macro"},"1965":{"crate_id":16,"path":["gimli","read","aranges","ArangeHeaderIter"],"kind":"struct"},"1411":{"crate_id":2,"path":["core","ops","try_trait","Residual"],"kind":"trait"},"530":{"crate_id":0,"path":["assertables","assert_fn_le_as_result"],"kind":"macro"},"2292":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3173":{"crate_id":2,"path":["core","ops","try_trait","FromResidual"],"kind":"trait"},"857":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_ne"],"kind":"macro"},"1738":{"crate_id":17,"path":["object","pe","ImageRuntimeFunctionEntry"],"kind":"struct"},"2619":{"crate_id":16,"path":["gimli","read","unit","DebugInfoUnitHeadersIter"],"kind":"struct"},"2946":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"303":{"crate_id":0,"path":["assertables","assert_len_ge_x_as_result"],"kind":"macro"},"1184":{"crate_id":16,"path":["gimli","common","DebugTypeSignature"],"kind":"struct"},"2065":{"crate_id":16,"path":["gimli","read","addr","DebugAddr"],"kind":"struct"},"1511":{"crate_id":17,"path":["object","read","coff","symbol","SymbolIterator"],"kind":"struct"},"630":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_le"],"kind":"module"},"2392":{"crate_id":14,"path":["rustc_demangle","legacy","Demangle"],"kind":"struct"},"3273":{"crate_id":16,"path":["gimli","common","DebugFrameOffset"],"kind":"struct"},"957":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_eq"],"kind":"module"},"76":{"crate_id":0,"path":["assertables","assert_f64_ne_as_result"],"kind":"macro"},"1838":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x4x3_t"],"kind":"struct"},"2719":{"crate_id":16,"path":["gimli","read","op","Piece"],"kind":"struct"},"2165":{"crate_id":2,"path":["core","core_simd","to_bytes","sealed","Sealed"],"kind":"trait"},"403":{"crate_id":0,"path":["assertables","assert_some_eq_as_result"],"kind":"macro"},"1284":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3046":{"crate_id":17,"path":["object","read","pe","section","PeRelocationIterator"],"kind":"struct"},"1611":{"crate_id":2,"path":["core","core_arch","simd","i16x2"],"kind":"struct"},"730":{"crate_id":0,"path":["assertables","assert_io_read_to_string_gt"],"kind":"macro"},"2492":{"crate_id":17,"path":["object","read","any","ComdatIteratorInternal"],"kind":"enum"},"3373":{"crate_id":2,"path":["core","str","pattern","Utf8Pattern"],"kind":"enum"},"2819":{"crate_id":16,"path":["gimli","arch","MIPS"],"kind":"struct"},"176":{"crate_id":0,"path":["assertables","assert_infix"],"kind":"macro"},"1057":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_gt_x"],"kind":"macro"},"1938":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_storage"],"kind":"struct"},"2265":{"crate_id":17,"path":["object","macho","DyldSubCacheEntryV1"],"kind":"struct"},"503":{"crate_id":0,"path":["assertables","assert_set","assert_set_disjoint"],"kind":"module"},"1384":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x8x4_t"],"kind":"struct"},"3146":{"crate_id":17,"path":["object","read","xcoff","segment","XcoffSegment"],"kind":"struct"},"1711":{"crate_id":2,"path":["core","clone","uninit","InitializingSlice"],"kind":"struct"},"830":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_string_contains"],"kind":"module"},"2592":{"crate_id":17,"path":["object","read","xcoff","section","XcoffSection"],"kind":"struct"},"2919":{"crate_id":6,"path":["libc","unix","bsd","apple","rusage_info_v4"],"kind":"struct"},"276":{"crate_id":0,"path":["assertables","debug_assert_len_eq"],"kind":"macro"},"1157":{"crate_id":0,"path":["assertables","assert_program_args_stdout_is_match_as_result"],"kind":"macro"},"2038":{"crate_id":17,"path":["object","xcoff","DwarfAux64"],"kind":"struct"},"2365":{"crate_id":1,"path":["std","path","Path"],"kind":"struct"},"603":{"crate_id":0,"path":["assertables","assert_fn_err_le_x_as_result"],"kind":"macro"},"1484":{"crate_id":2,"path":["core","str","CharEscapeDebugContinue"],"kind":"struct"},"3246":{"crate_id":3,"path":["alloc","collections","binary_heap","IntoIterSorted"],"kind":"struct"},"930":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_gt_x"],"kind":"macro"},"49":{"crate_id":0,"path":["assertables","assert_f32","assert_f32_lt"],"kind":"module"},"1811":{"crate_id":2,"path":["core","iter","traits","iterator","Iterator"],"kind":"trait"},"2692":{"crate_id":17,"path":["object","pe","ImageSectionHeader"],"kind":"struct"},"3019":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x1x4_t"],"kind":"struct"},"376":{"crate_id":0,"path":["assertables","debug_assert_ok_eq_x"],"kind":"macro"},"1257":{"crate_id":2,"path":["core","str","pattern","StrSearcher"],"kind":"struct"},"2138":{"crate_id":6,"path":["libc","unix","bsd","apple","rusage_info_v1"],"kind":"struct"},"1584":{"crate_id":6,"path":["libc","unix","bsd","apple","xsw_usage"],"kind":"struct"},"703":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_le_x"],"kind":"module"},"2465":{"crate_id":18,"path":["memchr","memmem","searcher","TwoWayWithPrefilter"],"kind":"struct"},"3346":{"crate_id":2,"path":["core","ops","arith","Sub"],"kind":"trait"},"1030":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_ge"],"kind":"module"},"149":{"crate_id":0,"path":["assertables","assert_diff_ne_x_as_result"],"kind":"macro"},"1911":{"crate_id":8,"path":["cfg_if"],"kind":"module"},"2792":{"crate_id":1,"path":["std","process","Termination"],"kind":"trait"},"3119":{"crate_id":17,"path":["object","macho","DylinkerCommand"],"kind":"struct"},"476":{"crate_id":0,"path":["assertables","assert_iter_gt_as_result"],"kind":"macro"},"1357":{"crate_id":17,"path":["object","pe","ImageAuxSymbolFunctionBeginEnd"],"kind":"struct"},"2238":{"crate_id":2,"path":["core","task","wake","Waker"],"kind":"struct"},"1684":{"crate_id":16,"path":["gimli","read","endian_slice","DebugByte"],"kind":"struct"},"803":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_ne"],"kind":"module"},"2565":{"crate_id":2,"path":["core","str","CharEscapeUnicode"],"kind":"struct"},"3446":{"crate_id":17,"path":["object","pe","ImageLoadConfigDirectory64"],"kind":"struct"},"1130":{"crate_id":0,"path":["assertables","debug_assert_poll_ready_ne"],"kind":"macro"},"249":{"crate_id":0,"path":["assertables","debug_assert_ends_with"],"kind":"macro"},"2011":{"crate_id":2,"path":["core","core_arch","simd","i64x8"],"kind":"struct"},"2892":{"crate_id":17,"path":["object","common","BinaryFormat"],"kind":"enum"},"2338":{"crate_id":6,"path":["libc","unix","bsd","apple","pthread_rwlockattr_t"],"kind":"struct"},"576":{"crate_id":0,"path":["assertables","debug_assert_fn_err_gt"],"kind":"macro"},"1457":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3219":{"crate_id":16,"path":["gimli","common","DebugRngListsBase"],"kind":"struct"},"1784":{"crate_id":16,"path":["gimli","read","cfi","Pointer"],"kind":"enum"},"903":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_ge"],"kind":"module"},"22":{"crate_id":0,"path":["assertables","assert_eq_f32"],"kind":"macro"},"2665":{"crate_id":6,"path":["libc","unix","bsd","apple","proc_vnodepathinfo"],"kind":"struct"},"2992":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x8x3_t"],"kind":"struct"},"1230":{"crate_id":6,"path":["libc","unix","bsd","apple","ipc_perm"],"kind":"struct"},"349":{"crate_id":0,"path":["assertables","assert_err_ne"],"kind":"macro"},"2111":{"crate_id":1,"path":["std","time","Instant"],"kind":"struct"},"2438":{"crate_id":16,"path":["gimli","read","op","EvaluationState"],"kind":"enum"},"676":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_le"],"kind":"macro"},"1557":{"crate_id":6,"path":["libc","unix","bsd","apple","fpunchhole_t"],"kind":"struct"},"3319":{"crate_id":1,"path":["std","io","buffered","bufwriter","WriterPanicked"],"kind":"struct"},"1884":{"crate_id":2,"path":["core","range","iter","IterRangeInclusive"],"kind":"struct"},"122":{"crate_id":0,"path":["assertables","debug_assert_approx_eq"],"kind":"macro"},"1003":{"crate_id":0,"path":["assertables","assert_program_args_stderr_string_contains"],"kind":"macro"},"2765":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x4x3_t"],"kind":"struct"},"3092":{"crate_id":16,"path":["gimli","read","index","DebugTuIndex"],"kind":"struct"},"449":{"crate_id":0,"path":["assertables","assert_ready"],"kind":"module"},"1330":{"crate_id":16,"path":["gimli","read","line","LineInstructions"],"kind":"struct"},"2211":{"crate_id":16,"path":["gimli","constants","DwCfa"],"kind":"struct"},"2538":{"crate_id":16,"path":["gimli","constants","DwCc"],"kind":"struct"},"776":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_is_match"],"kind":"macro"},"1657":{"crate_id":6,"path":["libc","unix","bsd","apple","mach_header"],"kind":"struct"},"3419":{"crate_id":16,"path":["gimli","read","line","LineInstruction"],"kind":"enum"},"1103":{"crate_id":0,"path":["assertables","debug_assert_result_ok_eq"],"kind":"macro"},"222":{"crate_id":0,"path":["assertables","assert_count_gt_x_as_result"],"kind":"macro"},"1984":{"crate_id":2,"path":["core","iter","adapters","array_chunks","ArrayChunks"],"kind":"struct"},"2865":{"crate_id":11,"path":["hashbrown","raw","TableLayout"],"kind":"struct"},"3192":{"crate_id":1,"path":["std","path","fmt","DebugHelper"],"kind":"struct"},"549":{"crate_id":0,"path":["assertables","assert_fn_gt_x"],"kind":"macro"},"1430":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x1_t"],"kind":"struct"},"2311":{"crate_id":11,"path":["hashbrown","set","HashSet"],"kind":"struct"},"2638":{"crate_id":16,"path":["gimli","read","relocate","RelocateReader"],"kind":"struct"},"876":{"crate_id":0,"path":["assertables","assert_command_stderr_lt_x_as_result"],"kind":"macro"},"1757":{"crate_id":16,"path":["gimli","common","DebugMacroOffset"],"kind":"struct"},"1203":{"crate_id":2,"path":["core","str","BytesIsNotEmpty"],"kind":"struct"},"322":{"crate_id":0,"path":["assertables","assert_len"],"kind":"module"},"2084":{"crate_id":1,"path":["std","thread","spawnhook","ChildSpawnHooks"],"kind":"struct"},"2965":{"crate_id":2,"path":["core","slice","index","private_slice_index","Sealed"],"kind":"trait"},"3292":{"crate_id":17,"path":["object","read","elf","attributes","AttributeReader"],"kind":"struct"},"649":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_gt_x"],"kind":"macro"},"1530":{"crate_id":11,"path":["hashbrown","table","Drain"],"kind":"struct"},"2411":{"crate_id":17,"path":["object","endian","I64Bytes"],"kind":"struct"},"1857":{"crate_id":2,"path":["core","core_arch","simd","u8x16"],"kind":"struct"},"95":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_le_x"],"kind":"module"},"976":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_ne"],"kind":"macro"},"2738":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_throughput_qos_policy"],"kind":"struct"},"1303":{"crate_id":3,"path":["alloc","collections","btree","append","MergeIter"],"kind":"struct"},"422":{"crate_id":0,"path":["assertables","assert_pending","assert_pending"],"kind":"module"},"2184":{"crate_id":2,"path":["core","num","bignum","Big32x40"],"kind":"struct"},"3065":{"crate_id":16,"path":["gimli","constants","DwRle"],"kind":"struct"},"2511":{"crate_id":17,"path":["object","common","SegmentFlags"],"kind":"enum"},"749":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_eq_x"],"kind":"module"},"1630":{"crate_id":11,"path":["hashbrown","map","OccupiedEntry"],"kind":"struct"},"3392":{"crate_id":1,"path":["std","sys","sync","once_box","OnceBox"],"kind":"struct"},"1957":{"crate_id":1,"path":["std","io","Lines"],"kind":"struct"},"195":{"crate_id":0,"path":["assertables","debug_assert_count_ge"],"kind":"macro"},"1076":{"crate_id":0,"path":["assertables","assert_success_false_as_result"],"kind":"macro"},"2838":{"crate_id":2,"path":["core","slice","iter","Windows"],"kind":"struct"},"3165":{"crate_id":17,"path":["object","macho","FatArch64"],"kind":"struct"},"1403":{"crate_id":2,"path":["core","core_arch","simd","f32x2"],"kind":"struct"},"522":{"crate_id":0,"path":["assertables","assert_fn_ge_as_result"],"kind":"macro"},"2284":{"crate_id":2,"path":["core","core_arch","simd","u32x2"],"kind":"struct"},"2611":{"crate_id":3,"path":["alloc","collections","btree","set","IntoIter"],"kind":"struct"},"849":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_le"],"kind":"macro"},"1730":{"crate_id":1,"path":["std","io","Chain"],"kind":"struct"},"2057":{"crate_id":2,"path":["core","core_simd","swizzle","interleave","Hi"],"kind":"struct"},"295":{"crate_id":0,"path":["assertables","assert_len_ne_as_result"],"kind":"macro"},"1176":{"crate_id":6,"path":["libc","unix","hostent"],"kind":"struct"},"2938":{"crate_id":6,"path":["libc","unix","bsd","apple","ip_mreqn"],"kind":"struct"},"3265":{"crate_id":17,"path":["object","pe","ImageDynamicRelocationTable"],"kind":"struct"},"622":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_ge"],"kind":"module"},"1503":{"crate_id":1,"path":["std","alloc","System"],"kind":"struct"},"2384":{"crate_id":2,"path":["core","sync","atomic","AtomicI64"],"kind":"struct"},"2711":{"crate_id":2,"path":["core","core_arch","simd","u32x8"],"kind":"struct"},"949":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_string_contains"],"kind":"module"},"68":{"crate_id":0,"path":["assertables","assert_f64_le_as_result"],"kind":"macro"},"1830":{"crate_id":1,"path":["std","sync","mpmc","array","ArrayToken"],"kind":"struct"},"1276":{"crate_id":1,"path":["std","fs","metadata"],"kind":"function"},"395":{"crate_id":0,"path":["assertables","assert_option","assert_option_some_eq"],"kind":"module"},"2157":{"crate_id":2,"path":["core","slice","iter","RChunksMut"],"kind":"struct"},"3038":{"crate_id":11,"path":["hashbrown","rustc_entry","RustcEntry"],"kind":"enum"},"3365":{"crate_id":2,"path":["core","num","niche_types","U64NotAllOnes"],"kind":"struct"},"722":{"crate_id":0,"path":["assertables","assert_io_read_to_string_eq"],"kind":"macro"},"1603":{"crate_id":17,"path":["object","macho","BuildToolVersion"],"kind":"struct"},"2484":{"crate_id":18,"path":["memchr","memchr","Memchr3"],"kind":"struct"},"2811":{"crate_id":2,"path":["core","ops","try_trait","Yeet"],"kind":"struct"},"168":{"crate_id":0,"path":["assertables","assert_all"],"kind":"macro"},"1049":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_eq_x"],"kind":"macro"},"1930":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"1376":{"crate_id":2,"path":["core","hash","Hash"],"kind":"trait"},"495":{"crate_id":0,"path":["assertables","assert_set","assert_set_eq"],"kind":"module"},"2257":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbol"],"kind":"struct"},"3138":{"crate_id":6,"path":["libc","unix","bsd","apple","sysdir_search_path_directory_t"],"kind":"enum"},"822":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_lt_x"],"kind":"macro"},"1703":{"crate_id":6,"path":["libc","unix","bsd","sockaddr"],"kind":"struct"},"2584":{"crate_id":2,"path":["core","random","RandomSource"],"kind":"trait"},"2030":{"crate_id":16,"path":["gimli","common","DebugMacinfoOffset"],"kind":"struct"},"268":{"crate_id":0,"path":["assertables","assert_is_match","assert_is_match"],"kind":"module"},"1149":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_contains"],"kind":"macro"},"2911":{"crate_id":17,"path":["object","pe","ImageVxdHeader"],"kind":"struct"},"1476":{"crate_id":2,"path":["core","iter","adapters","take","Take"],"kind":"struct"},"595":{"crate_id":0,"path":["assertables","assert_fn_err_ge_x_as_result"],"kind":"macro"},"2357":{"crate_id":17,"path":["object","macho","UuidCommand"],"kind":"struct"},"3238":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2684":{"crate_id":2,"path":["core","slice","sort","shared","smallsort","CopyOnDrop"],"kind":"struct"},"922":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_eq_x"],"kind":"macro"},"41":{"crate_id":0,"path":["assertables","assert_f32","assert_f32_gt"],"kind":"module"},"1803":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2130":{"crate_id":17,"path":["object","pe","ImageOptionalHeader64"],"kind":"struct"},"368":{"crate_id":0,"path":["assertables","debug_assert_ok_eq"],"kind":"macro"},"1249":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x2x3_t"],"kind":"struct"},"3011":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x2x3_t"],"kind":"struct"},"1576":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x2x2_t"],"kind":"struct"},"695":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_ge_x"],"kind":"module"},"2457":{"crate_id":3,"path":["alloc","vec","drain","drop","DropGuard"],"kind":"struct"},"3338":{"crate_id":6,"path":["libc","unix","bsd","apple","aiocb"],"kind":"struct"},"2784":{"crate_id":1,"path":["std","fs","canonicalize"],"kind":"function"},"1022":{"crate_id":0,"path":["assertables","assert_status","assert_status_failure"],"kind":"module"},"141":{"crate_id":0,"path":["assertables","assert_diff_le_x_as_result"],"kind":"macro"},"1903":{"crate_id":17,"path":["object","pe","ImageOptionalHeader32"],"kind":"struct"},"2230":{"crate_id":1,"path":["std","fs","read"],"kind":"function"},"468":{"crate_id":0,"path":["assertables","assert_iter_eq_as_result"],"kind":"macro"},"1349":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3111":{"crate_id":1,"path":["std","env","VarsOs"],"kind":"struct"},"3438":{"crate_id":1,"path":["std","backtrace_rs","symbolize","SymbolName"],"kind":"struct"},"795":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_le"],"kind":"module"},"1676":{"crate_id":16,"path":["gimli","read","StoreOnHeap"],"kind":"struct"},"2557":{"crate_id":17,"path":["object","macho","MachHeader64"],"kind":"struct"},"2884":{"crate_id":2,"path":["core","char","convert","CharErrorKind"],"kind":"enum"},"241":{"crate_id":0,"path":["assertables","assert_email_address","assert_email_address"],"kind":"module"},"1122":{"crate_id":0,"path":["assertables","assert_poll_ready_as_result"],"kind":"macro"},"2003":{"crate_id":17,"path":["object","pe","ImageNtHeaders64"],"kind":"struct"},"2330":{"crate_id":17,"path":["object","macho","LinkeditDataCommand"],"kind":"struct"},"568":{"crate_id":0,"path":["assertables","debug_assert_fn_err_eq"],"kind":"macro"},"1449":{"crate_id":17,"path":["object","xcoff","CsectAux64"],"kind":"struct"},"3211":{"crate_id":1,"path":["std","sync","poison","rwlock","MappedRwLockWriteGuard"],"kind":"struct"},"895":{"crate_id":0,"path":["assertables","assert_command"],"kind":"module"},"14":{"crate_id":0,"path":["assertables","debug_assert_le"],"kind":"macro"},"1776":{"crate_id":3,"path":["alloc","collections","btree","set","ExtractIf"],"kind":"struct"},"2657":{"crate_id":6,"path":["libc","unix","bsd","apple","sigaction"],"kind":"struct"},"2984":{"crate_id":16,"path":["gimli","common","DebugInfoOffset"],"kind":"struct"},"341":{"crate_id":0,"path":["assertables","assert_err"],"kind":"macro"},"1222":{"crate_id":17,"path":["object","read","elf","version","VersionTable"],"kind":"struct"},"2103":{"crate_id":17,"path":["object","read","macho","section","MachOSectionInternal"],"kind":"struct"},"1549":{"crate_id":16,"path":["gimli","read","rnglists","RngListIter"],"kind":"struct"},"668":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ge"],"kind":"macro"},"2430":{"crate_id":16,"path":["gimli","read","abbrev","AbbreviationsCache"],"kind":"struct"},"3311":{"crate_id":2,"path":["core","str","iter","MatchesInternal"],"kind":"struct"},"995":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_lt_x"],"kind":"macro"},"114":{"crate_id":0,"path":["assertables","assert_abs_diff_gt"],"kind":"macro"},"1876":{"crate_id":6,"path":["libc","unix","bsd","apple","radvisory"],"kind":"struct"},"2757":{"crate_id":16,"path":["gimli","arch","LoongArch"],"kind":"struct"},"2203":{"crate_id":16,"path":["gimli","read","unit","DebugInfo"],"kind":"struct"},"441":{"crate_id":0,"path":["assertables","assert_ready_eq_x"],"kind":"macro"},"1322":{"crate_id":17,"path":["object","read","coff","import","ImportName"],"kind":"enum"},"3084":{"crate_id":6,"path":["libc","unix","bsd","apple","if_msghdr"],"kind":"struct"},"1649":{"crate_id":1,"path":["std","collections","hash","set","Union"],"kind":"struct"},"768":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_ne_x"],"kind":"macro"},"2530":{"crate_id":17,"path":["object","read","archive","SymbolIteratorInternal"],"kind":"enum"},"3411":{"crate_id":17,"path":["object","read","xcoff","comdat","XcoffComdatSectionIterator"],"kind":"struct"},"2857":{"crate_id":17,"path":["object","elf","ProgramHeader64"],"kind":"struct"},"1095":{"crate_id":0,"path":["assertables","assert_result_err_as_result"],"kind":"macro"},"214":{"crate_id":0,"path":["assertables","assert_count_eq_x_as_result"],"kind":"macro"},"1976":{"crate_id":6,"path":["libc","unix","bsd","apple","lconv"],"kind":"struct"},"2303":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x8_t"],"kind":"struct"},"541":{"crate_id":0,"path":["assertables","assert_fn_eq_x"],"kind":"macro"},"1422":{"crate_id":2,"path":["core","str","iter","EscapeDefault"],"kind":"struct"},"3184":{"crate_id":2,"path":["core","marker","FnPtr"],"kind":"trait"},"1749":{"crate_id":6,"path":["libc","unix","bsd","apple","termios"],"kind":"struct"},"868":{"crate_id":0,"path":["assertables","assert_command_stderr_gt_x_as_result"],"kind":"macro"},"2630":{"crate_id":2,"path":["core","fmt","Sign"],"kind":"enum"},"2957":{"crate_id":11,"path":["hashbrown","set","Iter"],"kind":"struct"},"314":{"crate_id":0,"path":["assertables","assert_len_lt_x"],"kind":"macro"},"1195":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x2x3_t"],"kind":"struct"},"2076":{"crate_id":6,"path":["libc","unix","tms"],"kind":"struct"},"2403":{"crate_id":17,"path":["object","elf","NoteHeader32"],"kind":"struct"},"641":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_eq_x"],"kind":"macro"},"1522":{"crate_id":17,"path":["object","pe","ImageArm64RuntimeFunctionEntry"],"kind":"struct"},"3284":{"crate_id":18,"path":["memchr","arch","all","memchr","One"],"kind":"struct"},"968":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_le"],"kind":"macro"},"87":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_ge_x"],"kind":"module"},"1849":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2730":{"crate_id":2,"path":["core","core_arch","simd","u8x2"],"kind":"struct"},"3057":{"crate_id":3,"path":["alloc","alloc","Global"],"kind":"struct"},"414":{"crate_id":0,"path":["assertables","assert_some_ne_x"],"kind":"macro"},"1295":{"crate_id":16,"path":["gimli","read","aranges","ArangeHeader"],"kind":"struct"},"2176":{"crate_id":2,"path":["core","fmt","rt","ArgumentType"],"kind":"enum"},"2503":{"crate_id":2,"path":["core","iter","traits","collect","FromIterator"],"kind":"trait"},"741":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_lt"],"kind":"module"},"1622":{"crate_id":17,"path":["object","read","macho","segment","MachOSegmentInternal"],"kind":"struct"},"3384":{"crate_id":2,"path":["core","fmt","UpperExp"],"kind":"trait"},"1068":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_ne_x"],"kind":"module"},"187":{"crate_id":0,"path":["assertables","assert_contains","assert_not_contains"],"kind":"module"},"1949":{"crate_id":16,"path":["gimli","read","cfi","EhFrameHdr"],"kind":"struct"},"2830":{"crate_id":2,"path":["core","future","async_drop","AsyncDropInPlace"],"kind":"struct"},"3157":{"crate_id":2,"path":["core","core_arch","simd","u32x32"],"kind":"struct"},"514":{"crate_id":0,"path":["assertables","debug_assert_set_superset"],"kind":"macro"},"1395":{"crate_id":1,"path":["std","sys","fs","unix","DirBuilder"],"kind":"struct"},"2276":{"crate_id":3,"path":["alloc","rc","UniqueRc"],"kind":"struct"},"1722":{"crate_id":6,"path":["libc","unix","bsd","apple","timezone"],"kind":"enum"},"841":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_ge"],"kind":"macro"},"2603":{"crate_id":16,"path":["gimli","read","util","ArrayVec"],"kind":"struct"},"1168":{"crate_id":0,"path":["assertables"],"kind":"module"},"287":{"crate_id":0,"path":["assertables","assert_len_le_as_result"],"kind":"macro"},"2049":{"crate_id":2,"path":["core","core_arch","simd","m32x4"],"kind":"struct"},"2930":{"crate_id":17,"path":["object","read","pe","file","PeComdatSectionIterator"],"kind":"struct"},"2376":{"crate_id":2,"path":["core","fmt","Octal"],"kind":"trait"},"614":{"crate_id":0,"path":["assertables","assert_fn_err"],"kind":"module"},"1495":{"crate_id":2,"path":["core","sync","atomic","AtomicUsize"],"kind":"struct"},"3257":{"crate_id":2,"path":["core","slice","iter","ChunkByMut"],"kind":"struct"},"1822":{"crate_id":1,"path":["std","sync","mpmc","list","Channel"],"kind":"struct"},"60":{"crate_id":0,"path":["assertables","assert_f64_ge_as_result"],"kind":"macro"},"941":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ne_x_as_result"],"kind":"macro"},"2703":{"crate_id":1,"path":["std","sys_common","process","CommandEnvs"],"kind":"struct"},"1268":{"crate_id":16,"path":["gimli","read","cfi","PartialFrameDescriptionEntry"],"kind":"struct"},"387":{"crate_id":0,"path":["assertables","assert_result"],"kind":"module"},"2149":{"crate_id":1,"path":["std","io"],"kind":"module"},"3030":{"crate_id":13,"path":["std_detect","detect","cache","Initializer"],"kind":"struct"},"2476":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x1x2_t"],"kind":"struct"},"714":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_contains"],"kind":"macro"},"1595":{"crate_id":6,"path":["libc","unix","bsd","apple","shmid_ds"],"kind":"struct"},"3357":{"crate_id":16,"path":["gimli","constants","DwInl"],"kind":"struct"},"1922":{"crate_id":1,"path":["std","sync","mpmc","utils","CachePadded"],"kind":"struct"},"160":{"crate_id":0,"path":["assertables","assert_in_epsilon_as_result"],"kind":"macro"},"1041":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_lt"],"kind":"macro"},"2803":{"crate_id":16,"path":["gimli","common","DebugAbbrevOffset"],"kind":"struct"},"3130":{"crate_id":2,"path":["core","iter","sources","successors","Successors"],"kind":"struct"},"487":{"crate_id":0,"path":["assertables","assert_iter_ne"],"kind":"macro"},"1368":{"crate_id":16,"path":["gimli","constants","DwLne"],"kind":"struct"},"2249":{"crate_id":2,"path":["core","net","ip_addr","Ipv6Addr"],"kind":"struct"},"2576":{"crate_id":2,"path":["core","ops","range","Bound"],"kind":"enum"},"814":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_gt_x"],"kind":"macro"},"1695":{"crate_id":17,"path":["object","pe","ImageThunkData64"],"kind":"struct"},"3457":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x4x3_t"],"kind":"struct"},"2022":{"crate_id":1,"path":["std","sync","poison","mutex","Mutex"],"kind":"struct"},"260":{"crate_id":0,"path":["assertables","assert_not_empty"],"kind":"macro"},"1141":{"crate_id":0,"path":["assertables","assert_command_stdout_contains_as_result"],"kind":"macro"},"2903":{"crate_id":1,"path":["std","io","Split"],"kind":"struct"},"3230":{"crate_id":6,"path":["libc","unix","in6_addr"],"kind":"struct"},"587":{"crate_id":0,"path":["assertables","assert_fn_err_ne_as_result"],"kind":"macro"},"1468":{"crate_id":2,"path":["core","iter","adapters","zip","zip"],"kind":"function"},"2349":{"crate_id":17,"path":["object","pe","ImageResourceDataEntry"],"kind":"struct"},"2676":{"crate_id":17,"path":["object","read","archive","Members"],"kind":"enum"},"33":{"crate_id":0,"path":["assertables","assert_f32","assert_f32_eq"],"kind":"module"},"914":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_lt"],"kind":"macro"},"1795":{"crate_id":2,"path":["core","str","iter","RSplitN"],"kind":"struct"},"1241":{"crate_id":1,"path":["std","io","stdio","StdinRaw"],"kind":"struct"},"360":{"crate_id":0,"path":["assertables","assert_err","assert_err_ne_x"],"kind":"module"},"2122":{"crate_id":2,"path":["core","ops","range","RangeTo"],"kind":"struct"},"3003":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation32V2"],"kind":"struct"},"3330":{"crate_id":1,"path":["std","sync","mpmc","error","SendTimeoutError"],"kind":"enum"},"687":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_ne"],"kind":"module"},"1568":{"crate_id":1,"path":["std","sync","mpmc","zero","ZeroToken"],"kind":"struct"},"2449":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x2x2_t"],"kind":"struct"},"1895":{"crate_id":1,"path":["std","sync","poison","rwlock","RwLock"],"kind":"struct"},"1014":{"crate_id":0,"path":["assertables","assert_status","assert_status_success"],"kind":"module"},"133":{"crate_id":0,"path":["assertables","assert_diff_ge_x_as_result"],"kind":"macro"},"2776":{"crate_id":16,"path":["gimli","endianity","LittleEndian"],"kind":"struct"},"1341":{"crate_id":2,"path":["core","core_simd","swizzle","reverse","Reverse"],"kind":"struct"},"460":{"crate_id":0,"path":["assertables","debug_assert_bag_subbag"],"kind":"macro"},"2222":{"crate_id":9,"path":["miniz_oxide","inflate","output_buffer","InputWrapper"],"kind":"struct"},"3103":{"crate_id":1,"path":["std","os","unix","fs","MetadataExt"],"kind":"trait"},"2549":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","__darwin_arm_exception_state64"],"kind":"struct"},"787":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_ge"],"kind":"module"},"1668":{"crate_id":6,"path":["libc","unix","bsd","apple","in_pktinfo"],"kind":"struct"},"3430":{"crate_id":6,"path":["libc","unix","bsd","apple","if_msghdr2"],"kind":"struct"},"1995":{"crate_id":2,"path":["core","error","tags","MaybeSizedValue"],"kind":"struct"},"233":{"crate_id":0,"path":["assertables","assert_count_ne_x"],"kind":"macro"},"1114":{"crate_id":0,"path":["assertables","assert_option_some_eq"],"kind":"macro"},"2876":{"crate_id":6,"path":["libc","unix","bsd","apple","ifdevmtu"],"kind":"struct"},"1441":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"560":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_lt_x"],"kind":"module"},"2322":{"crate_id":17,"path":["object","read","any","DynamicRelocationIteratorInternal"],"kind":"enum"},"3203":{"crate_id":2,"path":["core","convert","num","private","Sealed"],"kind":"trait"},"2649":{"crate_id":6,"path":["libc","unix","bsd","msghdr"],"kind":"struct"},"6":{"crate_id":0,"path":["assertables","debug_assert_ge"],"kind":"macro"},"887":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_string_contains"],"kind":"macro"},"1768":{"crate_id":16,"path":["gimli","read","cfi","RegisterRuleIter"],"kind":"struct"},"2095":{"crate_id":11,"path":["hashbrown","table","HashTable"],"kind":"struct"},"333":{"crate_id":0,"path":["assertables","assert_not_starts_with_as_result"],"kind":"macro"},"1214":{"crate_id":17,"path":["object","read","any","ComdatSectionIterator"],"kind":"struct"},"2976":{"crate_id":1,"path":["std","io","error","Custom"],"kind":"struct"},"3303":{"crate_id":16,"path":["gimli","read","pubtypes","PubTypesEntryIter"],"kind":"struct"},"660":{"crate_id":0,"path":["assertables","assert_fn_ok_ne_x_as_result"],"kind":"macro"},"1541":{"crate_id":2,"path":["core","ops","deref","Deref"],"kind":"trait"},"2422":{"crate_id":6,"path":["libc","unix","bsd","apple","pthread_condattr_t"],"kind":"struct"},"2749":{"crate_id":16,"path":["gimli","common","UnitSectionOffset"],"kind":"enum"},"106":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_gt"],"kind":"module"},"987":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_gt_x"],"kind":"macro"},"1868":{"crate_id":17,"path":["object","macho","PreboundDylibCommand"],"kind":"struct"},"2195":{"crate_id":1,"path":["std","slice"],"kind":"primitive"},"433":{"crate_id":0,"path":["assertables","assert_ready_eq"],"kind":"macro"},"1314":{"crate_id":1,"path":["std","collections","hash","set","ExtractIf"],"kind":"struct"},"3076":{"crate_id":6,"path":["libc","unix","bsd","apple","fstore_t"],"kind":"struct"},"3403":{"crate_id":1,"path":["std","backtrace_rs","types","BytesOrWideString"],"kind":"enum"},"760":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_le_x"],"kind":"macro"},"1641":{"crate_id":17,"path":["object","xcoff","DwarfAux32"],"kind":"struct"},"2522":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x8x3_t"],"kind":"struct"},"2849":{"crate_id":17,"path":["object","read","elf","section","ElfSectionIterator"],"kind":"struct"},"1087":{"crate_id":0,"path":["assertables","assert_abs_diff_gt_as_result"],"kind":"macro"},"206":{"crate_id":0,"path":["assertables","assert_count_lt_as_result"],"kind":"macro"},"1968":{"crate_id":1,"path":["std","sync","poison","condvar","Condvar"],"kind":"struct"},"1414":{"crate_id":16,"path":["gimli","read","rnglists","RawRngListIter"],"kind":"struct"},"533":{"crate_id":0,"path":["assertables","assert_fn_lt"],"kind":"macro"},"2295":{"crate_id":6,"path":["libc","unix","bsd","apple","mstats"],"kind":"struct"},"3176":{"crate_id":2,"path":["core","write"],"kind":"macro"},"860":{"crate_id":0,"path":["assertables","assert_command_stderr_eq_x_as_result"],"kind":"macro"},"1741":{"crate_id":2,"path":["core","ops","index_range","IndexRange"],"kind":"struct"},"2622":{"crate_id":2,"path":["core","str","iter","MatchIndices"],"kind":"struct"},"2068":{"crate_id":2,"path":["core","ascii","ascii_char","AsciiChar"],"kind":"enum"},"306":{"crate_id":0,"path":["assertables","assert_len_gt_x"],"kind":"macro"},"1187":{"crate_id":18,"path":["memchr","arch","generic","memchr","Three"],"kind":"struct"},"2949":{"crate_id":2,"path":["core","char","REPLACEMENT_CHARACTER"],"kind":"constant"},"1514":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x4_t"],"kind":"struct"},"633":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_lt"],"kind":"macro"},"2395":{"crate_id":2,"path":["core","fmt","builders","FromFn"],"kind":"struct"},"3276":{"crate_id":1,"path":["std","error","Report"],"kind":"struct"},"960":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_ge"],"kind":"macro"},"79":{"crate_id":0,"path":["assertables","assert_f64"],"kind":"module"},"1841":{"crate_id":1,"path":["std","sys","pal","unix","sync","condvar","Condvar"],"kind":"struct"},"2722":{"crate_id":1,"path":["std","os","unix","process","CommandExt"],"kind":"trait"},"2168":{"crate_id":1,"path":["std","sys","fs","unix","ReadDir"],"kind":"struct"},"406":{"crate_id":0,"path":["assertables","assert_some_ne"],"kind":"macro"},"1287":{"crate_id":1,"path":["std","backtrace_rs","print","PrintFmt"],"kind":"enum"},"3049":{"crate_id":2,"path":["core","ops","deref","DerefPure"],"kind":"trait"},"1614":{"crate_id":1,"path":["std","tuple"],"kind":"primitive"},"733":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_gt"],"kind":"module"},"2495":{"crate_id":16,"path":["gimli","read","line","CompleteLineProgram"],"kind":"struct"},"3376":{"crate_id":2,"path":["core","time","Duration"],"kind":"struct"},"2822":{"crate_id":6,"path":["libc","unix","bsd","apple","segment_command"],"kind":"struct"},"179":{"crate_id":0,"path":["assertables","assert_infix"],"kind":"module"},"1060":{"crate_id":0,"path":["assertables","assert_status_code_value_le_x_as_result"],"kind":"macro"},"1941":{"crate_id":3,"path":["alloc","collections","TryReserveErrorKind"],"kind":"enum"},"2268":{"crate_id":2,"path":["core","num","niche_types","NonZeroU16Inner"],"kind":"struct"},"506":{"crate_id":0,"path":["assertables","debug_assert_set_joint"],"kind":"macro"},"1387":{"crate_id":1,"path":["std","backtrace","BacktraceFrame"],"kind":"struct"},"3149":{"crate_id":16,"path":["gimli","read","cfi","UnwindExpression"],"kind":"struct"},"1714":{"crate_id":2,"path":["core","panic","location","Location"],"kind":"struct"},"833":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_string_is_match"],"kind":"macro"},"2595":{"crate_id":3,"path":["alloc","collections","btree","map","Range"],"kind":"struct"},"2922":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"279":{"crate_id":0,"path":["assertables","assert_len_ge_as_result"],"kind":"macro"},"1160":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ge_x_as_result"],"kind":"macro"},"2041":{"crate_id":1,"path":["std","io","stdio","Stderr"],"kind":"struct"},"2368":{"crate_id":2,"path":["core","iter","traits","accum","Sum"],"kind":"trait"},"606":{"crate_id":0,"path":["assertables","assert_fn_err_lt_x"],"kind":"macro"},"1487":{"crate_id":2,"path":["core","iter","adapters","inspect","Inspect"],"kind":"struct"},"3249":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","pthread_once_t"],"kind":"struct"},"933":{"crate_id":0,"path":["assertables","assert_program_args_stdout_le_x_as_result"],"kind":"macro"},"52":{"crate_id":0,"path":["assertables","debug_assert_f32_ne"],"kind":"macro"},"1814":{"crate_id":2,"path":["core","char","TryFromCharError"],"kind":"struct"},"2695":{"crate_id":1,"path":["std","f32"],"kind":"primitive"},"3022":{"crate_id":18,"path":["memchr","memchr","Memchr"],"kind":"struct"},"379":{"crate_id":0,"path":["assertables","assert_ok_ne_x_as_result"],"kind":"macro"},"1260":{"crate_id":15,"path":["addr2line","RangeAttributes"],"kind":"struct"},"2141":{"crate_id":3,"path":["alloc","collections","linked_list","drop","DropGuard"],"kind":"struct"},"1587":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"706":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_lt_x"],"kind":"macro"},"2468":{"crate_id":2,"path":["core","mem","transmutability","Assume"],"kind":"struct"},"3349":{"crate_id":6,"path":["libc","unix","bsd","apple","proc_taskallinfo"],"kind":"struct"},"1033":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_gt"],"kind":"macro"},"152":{"crate_id":0,"path":["assertables","assert_diff"],"kind":"module"},"1914":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8CodePoints"],"kind":"struct"},"2795":{"crate_id":17,"path":["object","read","elf","segment","ElfSegmentIterator"],"kind":"struct"},"3122":{"crate_id":2,"path":["core","core_simd","masks","MaskElement"],"kind":"trait"},"479":{"crate_id":0,"path":["assertables","assert_iter_le"],"kind":"macro"},"1360":{"crate_id":17,"path":["object","macho","ScatteredRelocationInfo"],"kind":"struct"},"2241":{"crate_id":9,"path":["miniz_oxide","inflate","core","LocalVars"],"kind":"struct"},"1687":{"crate_id":1,"path":["std","io","Seek"],"kind":"trait"},"806":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_eq_x"],"kind":"macro"},"2568":{"crate_id":2,"path":["core","iter","adapters","map_windows","Buffer"],"kind":"struct"},"3449":{"crate_id":16,"path":["gimli","read","endian_slice","EndianSlice"],"kind":"struct"},"1133":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_matches_as_result"],"kind":"macro"},"252":{"crate_id":0,"path":["assertables","assert_not_ends_with_as_result"],"kind":"macro"},"2014":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"2895":{"crate_id":18,"path":["memchr","arch","all","rabinkarp","Finder"],"kind":"struct"},"2341":{"crate_id":16,"path":["gimli","read","line","DebugLine"],"kind":"struct"},"579":{"crate_id":0,"path":["assertables","assert_fn_err_le_as_result"],"kind":"macro"},"1460":{"crate_id":2,"path":["core","str","iter","Lines"],"kind":"struct"},"3222":{"crate_id":6,"path":["libc","unix","bsd","apple","mach_task_basic_info"],"kind":"struct"},"1787":{"crate_id":3,"path":["alloc","collections","btree","node","marker","Dying"],"kind":"enum"},"25":{"crate_id":0,"path":["assertables","assert_eq_f32"],"kind":"module"},"906":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_gt"],"kind":"macro"},"2668":{"crate_id":1,"path":["std","env","VarError"],"kind":"enum"},"2995":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"352":{"crate_id":0,"path":["assertables","assert_err","assert_err_ne"],"kind":"module"},"1233":{"crate_id":2,"path":["core","slice","iter","SplitInclusive"],"kind":"struct"},"2114":{"crate_id":1,"path":["std","backtrace","BacktraceStatus"],"kind":"enum"},"2441":{"crate_id":2,"path":["core","ptr","alignment","AlignmentEnum"],"kind":"enum"},"679":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_le"],"kind":"module"},"1560":{"crate_id":1,"path":["std","path","Display"],"kind":"struct"},"3322":{"crate_id":11,"path":["hashbrown","raw","RawIterRange"],"kind":"struct"},"1887":{"crate_id":6,"path":["libc","unix","bsd","fsid_t"],"kind":"struct"},"1006":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_string_contains"],"kind":"module"},"125":{"crate_id":0,"path":["assertables","debug_assert_approx_ne"],"kind":"macro"},"2768":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3095":{"crate_id":1,"path":["std","sys","fs","unix","File"],"kind":"struct"},"452":{"crate_id":0,"path":["assertables","debug_assert_bag_eq"],"kind":"macro"},"1333":{"crate_id":17,"path":["object","macho","Dylib"],"kind":"struct"},"2214":{"crate_id":16,"path":["gimli","read","value","ValueType"],"kind":"enum"},"2541":{"crate_id":17,"path":["object","pe","ImageEnclaveImport"],"kind":"struct"},"779":{"crate_id":0,"path":["assertables","assert_io_read_to_string"],"kind":"module"},"1660":{"crate_id":17,"path":["object","read","pe","section","PeSegmentIterator"],"kind":"struct"},"3422":{"crate_id":16,"path":["gimli","common","Encoding"],"kind":"struct"},"1106":{"crate_id":0,"path":["assertables","debug_assert_result_ok_ne"],"kind":"macro"},"225":{"crate_id":0,"path":["assertables","assert_count_le_x"],"kind":"macro"},"1987":{"crate_id":1,"path":["std","sync","mpmc","context","Inner"],"kind":"struct"},"2868":{"crate_id":11,"path":["hashbrown","rustc_entry","RustcOccupiedEntry"],"kind":"struct"},"3195":{"crate_id":18,"path":["memchr","arch","all","memchr","OneIter"],"kind":"struct"},"552":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_gt_x"],"kind":"module"},"1433":{"crate_id":17,"path":["object","pe","ImageAlpha64RuntimeFunctionEntry"],"kind":"struct"},"2314":{"crate_id":17,"path":["object","macho","RoutinesCommand64"],"kind":"struct"},"1760":{"crate_id":2,"path":["core","iter","adapters","enumerate","Enumerate"],"kind":"struct"},"879":{"crate_id":0,"path":["assertables","assert_command_stderr_ne_x"],"kind":"macro"},"2641":{"crate_id":2,"path":["core","str","LinesMap"],"kind":"struct"},"1206":{"crate_id":16,"path":["gimli","read","abbrev","AbbreviationsCacheStrategy"],"kind":"enum"},"325":{"crate_id":0,"path":["assertables","debug_assert_matches"],"kind":"macro"},"2087":{"crate_id":2,"path":["core","iter","traits","collect","Extend"],"kind":"trait"},"2968":{"crate_id":2,"path":["core","core_arch","simd","i8x2"],"kind":"struct"},"3295":{"crate_id":1,"path":["std","sys","fs","unix","FileAttr"],"kind":"struct"},"652":{"crate_id":0,"path":["assertables","assert_fn_ok_le_x_as_result"],"kind":"macro"},"1533":{"crate_id":2,"path":["core","num","flt2dec","decoder","Decoded"],"kind":"struct"},"2414":{"crate_id":17,"path":["object","pe","ImageFileHeader"],"kind":"struct"},"1860":{"crate_id":16,"path":["gimli","common","DebugRngListsIndex"],"kind":"struct"},"98":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_lt_x"],"kind":"macro"},"979":{"crate_id":0,"path":["assertables","assert_program_args_stderr_eq_x_as_result"],"kind":"macro"},"2741":{"crate_id":2,"path":["core","str","converts","from_utf8_unchecked"],"kind":"function"},"1306":{"crate_id":3,"path":["alloc","collections","btree","map","IterMut"],"kind":"struct"},"425":{"crate_id":0,"path":["assertables","assert_poll","assert_poll_ready"],"kind":"module"},"2187":{"crate_id":11,"path":["hashbrown","map","VacantEntry"],"kind":"struct"},"3068":{"crate_id":17,"path":["object","pe","ImageAuxSymbolTokenDef"],"kind":"struct"},"2514":{"crate_id":17,"path":["object","read","SymbolMap"],"kind":"struct"},"752":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_ge_x"],"kind":"macro"},"1633":{"crate_id":2,"path":["core","ops","bit","BitAnd"],"kind":"trait"},"3395":{"crate_id":16,"path":["gimli","common","DebugLocListsIndex"],"kind":"struct"},"1960":{"crate_id":2,"path":["core","iter","adapters","zip","TrustedRandomAccessNoCoerce"],"kind":"trait"},"1079":{"crate_id":0,"path":["assertables","assert_success"],"kind":"module"},"198":{"crate_id":0,"path":["assertables","assert_count_gt_as_result"],"kind":"macro"},"2841":{"crate_id":2,"path":["core","alloc","Allocator"],"kind":"trait"},"3168":{"crate_id":2,"path":["core","slice","iter","RSplitN"],"kind":"struct"},"1406":{"crate_id":2,"path":["core","slice","iter","RChunks"],"kind":"struct"},"525":{"crate_id":0,"path":["assertables","assert_fn_gt"],"kind":"macro"},"2287":{"crate_id":16,"path":["gimli","read","rnglists","RawRange"],"kind":"struct"},"2614":{"crate_id":17,"path":["object","pe","ImageImportByName"],"kind":"struct"},"852":{"crate_id":0,"path":["assertables","assert_command_stderr_lt_as_result"],"kind":"macro"},"1733":{"crate_id":16,"path":["gimli","read","unit","AttrsIter"],"kind":"struct"},"2060":{"crate_id":2,"path":["core","cmp","Reverse"],"kind":"struct"},"298":{"crate_id":0,"path":["assertables","assert_len_eq_x"],"kind":"macro"},"1179":{"crate_id":3,"path":["alloc","rc","Rc"],"kind":"struct"},"2941":{"crate_id":2,"path":["core","core_arch","simd","i32x32"],"kind":"struct"},"3268":{"crate_id":1,"path":["std","sys","fs","unix","cfm","CachedFileMetadata"],"kind":"struct"},"625":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_gt"],"kind":"macro"},"1506":{"crate_id":1,"path":["std","panicking","begin_panic_handler","FormatStringPayload"],"kind":"struct"},"2387":{"crate_id":16,"path":["gimli","read","loclists","RawLocListIter"],"kind":"struct"},"2714":{"crate_id":2,"path":["core","mem","forget"],"kind":"function"},"71":{"crate_id":0,"path":["assertables","assert_f64_lt"],"kind":"macro"},"952":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_string_is_match"],"kind":"macro"},"1833":{"crate_id":2,"path":["core","slice","iter","ArrayChunksMut"],"kind":"struct"},"1279":{"crate_id":6,"path":["libc","unix","bsd","apple","sched_param"],"kind":"struct"},"398":{"crate_id":0,"path":["assertables","assert_some"],"kind":"macro"},"2160":{"crate_id":17,"path":["object","pe","ImageFunctionEntry"],"kind":"struct"},"3041":{"crate_id":2,"path":["core","asserting","Capture"],"kind":"struct"},"3368":{"crate_id":3,"path":["alloc","rc","Weak"],"kind":"struct"},"725":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_eq"],"kind":"module"},"1606":{"crate_id":17,"path":["object","pe","ImageArmRuntimeFunctionEntry"],"kind":"struct"},"2487":{"crate_id":11,"path":["hashbrown","raw_entry","RawOccupiedEntryMut"],"kind":"struct"},"2814":{"crate_id":6,"path":["libc","unix","bsd","apple","proc_taskinfo"],"kind":"struct"},"171":{"crate_id":0,"path":["assertables","assert_all"],"kind":"module"},"1052":{"crate_id":0,"path":["assertables","assert_status_code_value_ge_x_as_result"],"kind":"macro"},"1933":{"crate_id":17,"path":["object","read","util","ByteString"],"kind":"struct"},"1379":{"crate_id":18,"path":["memchr","arch","aarch64","neon","memchr","Three"],"kind":"struct"},"498":{"crate_id":0,"path":["assertables","debug_assert_set_ne"],"kind":"macro"},"2260":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x4_t"],"kind":"struct"},"3141":{"crate_id":16,"path":["gimli","read","cfi","UnwindTable"],"kind":"struct"},"825":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_contains"],"kind":"module"},"1706":{"crate_id":2,"path":["core","fmt","LowerExp"],"kind":"trait"},"2587":{"crate_id":1,"path":["std","fs","File"],"kind":"struct"},"2033":{"crate_id":2,"path":["core","hash","sip","Hasher"],"kind":"struct"},"271":{"crate_id":0,"path":["assertables","debug_assert_not_match"],"kind":"macro"},"1152":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_is_match"],"kind":"macro"},"2914":{"crate_id":16,"path":["gimli","read","unit","DebugTypesUnitHeadersIter"],"kind":"struct"},"1479":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","Cache"],"kind":"struct"},"598":{"crate_id":0,"path":["assertables","assert_fn_err_gt_x"],"kind":"macro"},"2360":{"crate_id":17,"path":["object","read","xcoff","relocation","XcoffRelocationIterator"],"kind":"struct"},"3241":{"crate_id":2,"path":["core","core_simd","simd","ptr","mut_ptr","SimdMutPtr","with_exposed_provenance"],"kind":"function"},"2687":{"crate_id":1,"path":["std","net","tcp","TcpStream"],"kind":"struct"},"44":{"crate_id":0,"path":["assertables","debug_assert_f32_le"],"kind":"macro"},"925":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ge_x_as_result"],"kind":"macro"},"1806":{"crate_id":2,"path":["core","ptr","with_exposed_provenance"],"kind":"function"},"2133":{"crate_id":2,"path":["core","clone","Clone"],"kind":"trait"},"371":{"crate_id":0,"path":["assertables","assert_ok_ne_as_result"],"kind":"macro"},"1252":{"crate_id":3,"path":["alloc","collections","btree","node","Handle"],"kind":"struct"},"3014":{"crate_id":14,"path":["rustc_demangle","v0","ParseError"],"kind":"enum"},"3341":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbolTable"],"kind":"struct"},"1579":{"crate_id":2,"path":["core","iter","adapters","skip_while","SkipWhile"],"kind":"struct"},"698":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_gt_x"],"kind":"macro"},"2460":{"crate_id":2,"path":["core","str","IsWhitespace"],"kind":"struct"},"2787":{"crate_id":2,"path":["core","ffi","va_list","VaList"],"kind":"struct"},"144":{"crate_id":0,"path":["assertables","assert_diff_lt_x"],"kind":"macro"},"1025":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_eq"],"kind":"macro"},"1906":{"crate_id":2,"path":["core","char","CaseMappingIter"],"kind":"struct"},"2233":{"crate_id":1,"path":["std","io","stdio","Stdout"],"kind":"struct"},"471":{"crate_id":0,"path":["assertables","assert_iter_ge"],"kind":"macro"},"1352":{"crate_id":17,"path":["object","xcoff","Rel32"],"kind":"struct"},"3114":{"crate_id":18,"path":["memchr","memmem","searcher","PrefilterKind"],"kind":"union"},"3441":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"798":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_lt"],"kind":"macro"},"1679":{"crate_id":2,"path":["core","str","pattern","StrSearcherImpl"],"kind":"enum"},"2560":{"crate_id":2,"path":["core","intrinsics","fallback","CarryingMulAdd"],"kind":"trait"},"2887":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x8_t"],"kind":"struct"},"244":{"crate_id":0,"path":["assertables","debug_assert_not_email_address"],"kind":"macro"},"1125":{"crate_id":0,"path":["assertables","assert_poll_ready_eq_as_result"],"kind":"macro"},"2006":{"crate_id":18,"path":["memchr","arch","generic","packedpair","Finder"],"kind":"struct"},"1452":{"crate_id":16,"path":["gimli","read","lists","ListsHeader"],"kind":"struct"},"571":{"crate_id":0,"path":["assertables","assert_fn_err_ge_as_result"],"kind":"macro"},"2333":{"crate_id":1,"path":["std","io","IoSlice"],"kind":"struct"},"3214":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"898":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_eq"],"kind":"macro"},"17":{"crate_id":0,"path":["assertables","assert_lt_as_result"],"kind":"macro"},"1779":{"crate_id":2,"path":["core","task","wake","RawWakerVTable"],"kind":"struct"},"2660":{"crate_id":11,"path":["hashbrown","TryReserveError"],"kind":"enum"},"2987":{"crate_id":2,"path":["core","str","iter","RSplit"],"kind":"struct"},"344":{"crate_id":0,"path":["assertables","assert_err","assert_err"],"kind":"module"},"1225":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2106":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x1x4_t"],"kind":"struct"},"1552":{"crate_id":1,"path":["std","collections","hash","map","VacantEntry"],"kind":"struct"},"671":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_ge"],"kind":"module"},"2433":{"crate_id":2,"path":["core","core_arch","simd","i8x64"],"kind":"struct"},"3314":{"crate_id":17,"path":["object","pe","ImagePrologueDynamicRelocationHeader"],"kind":"struct"},"998":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ne_x_as_result"],"kind":"macro"},"117":{"crate_id":0,"path":["assertables","assert_approx_eq"],"kind":"macro"},"1879":{"crate_id":1,"path":["std","sync","mpmc","list","ListToken"],"kind":"struct"},"2760":{"crate_id":1,"path":["std","collections","hash","map","IntoValues"],"kind":"struct"},"2206":{"crate_id":6,"path":["libc","unix","bsd","apple","in6_ifstat"],"kind":"struct"},"444":{"crate_id":0,"path":["assertables","assert_ready","assert_ready_eq_x"],"kind":"module"},"1325":{"crate_id":2,"path":["core","iter","traits","collect","IntoIterator"],"kind":"trait"},"3087":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation64"],"kind":"struct"},"1652":{"crate_id":3,"path":["alloc","string","retain","SetLenOnDrop"],"kind":"struct"},"771":{"crate_id":0,"path":["assertables","assert_io_read_to_string_contains_as_result"],"kind":"macro"},"2533":{"crate_id":1,"path":["std","process","exit"],"kind":"function"},"3414":{"crate_id":2,"path":["core","str","pattern","TwoWaySearcher"],"kind":"struct"},"2860":{"crate_id":17,"path":["object","endian","Endianness"],"kind":"enum"},"1098":{"crate_id":0,"path":["assertables","assert_result_ok_as_result"],"kind":"macro"},"217":{"crate_id":0,"path":["assertables","assert_count_ge_x"],"kind":"macro"},"1979":{"crate_id":1,"path":["std","sys","thread_local","native","eager","State"],"kind":"enum"},"2306":{"crate_id":6,"path":["libc","unix","utimbuf"],"kind":"struct"},"544":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_eq_x"],"kind":"module"},"1425":{"crate_id":17,"path":["object","read","xcoff","comdat","XcoffComdatIterator"],"kind":"struct"},"3187":{"crate_id":11,"path":["hashbrown","raw","ProbeSeq"],"kind":"struct"},"1752":{"crate_id":17,"path":["object","read","elf","hash","HashTable"],"kind":"struct"},"871":{"crate_id":0,"path":["assertables","assert_command_stderr_le_x"],"kind":"macro"},"2633":{"crate_id":2,"path":["core","marker","variance","PhantomCovariantLifetime"],"kind":"struct"},"2960":{"crate_id":2,"path":["core","mem","replace"],"kind":"function"},"317":{"crate_id":0,"path":["assertables","assert_len","assert_len_lt_x"],"kind":"module"},"1198":{"crate_id":1,"path":["std","backtrace_rs","backtrace","libunwind","Bomb"],"kind":"struct"},"2079":{"crate_id":17,"path":["object","endian","LittleEndian"],"kind":"struct"},"2406":{"crate_id":16,"path":["gimli","read","op","OperationEvaluationResult"],"kind":"enum"},"644":{"crate_id":0,"path":["assertables","assert_fn_ok_ge_x_as_result"],"kind":"macro"},"1525":{"crate_id":2,"path":["core","task","wake","ContextBuilder"],"kind":"struct"},"3287":{"crate_id":1,"path":["std","sync","mpmc","select","Selected"],"kind":"enum"},"971":{"crate_id":0,"path":["assertables","assert_program_args_stderr_lt_as_result"],"kind":"macro"},"90":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_gt_x"],"kind":"macro"},"1852":{"crate_id":2,"path":["core","core_simd","simd","ptr","const_ptr","SimdConstPtr","with_exposed_provenance"],"kind":"function"},"2733":{"crate_id":1,"path":["std","env","ArgsOs"],"kind":"struct"},"3060":{"crate_id":16,"path":["gimli","read","abbrev","DebugAbbrev"],"kind":"struct"},"417":{"crate_id":0,"path":["assertables","assert_some","assert_some_ne_x"],"kind":"module"},"1298":{"crate_id":16,"path":["gimli","read","dwarf","DwarfPackage"],"kind":"struct"},"2179":{"crate_id":2,"path":["core","ops","function","FnMut"],"kind":"trait"},"2506":{"crate_id":16,"path":["gimli","constants","DwLle"],"kind":"struct"},"744":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_ne"],"kind":"macro"},"1625":{"crate_id":1,"path":["std","os","darwin","fs","MetadataExt"],"kind":"trait"},"3387":{"crate_id":3,"path":["alloc","collections","btree","node","marker","ValMut"],"kind":"struct"},"1071":{"crate_id":0,"path":["assertables","assert_success"],"kind":"macro"},"190":{"crate_id":0,"path":["assertables","assert_count_eq_as_result"],"kind":"macro"},"1952":{"crate_id":17,"path":["object","common","SymbolKind"],"kind":"enum"},"2833":{"crate_id":6,"path":["libc","unix","bsd","cmsghdr"],"kind":"struct"},"3160":{"crate_id":2,"path":["core","future","join","MaybeDone"],"kind":"enum"},"517":{"crate_id":0,"path":["assertables","assert_fn_eq"],"kind":"macro"},"1398":{"crate_id":2,"path":["core","task","poll","Poll"],"kind":"enum"},"2279":{"crate_id":17,"path":["object","read","pe","rich","RichHeaderInfo"],"kind":"struct"},"1725":{"crate_id":2,"path":["core","marker","ConstParamTy_"],"kind":"trait"},"844":{"crate_id":0,"path":["assertables","assert_command_stderr_gt_as_result"],"kind":"macro"},"2606":{"crate_id":17,"path":["object","read","xcoff","file","XcoffFile"],"kind":"struct"},"1171":{"crate_id":2,"path":["core","hash","BuildHasher"],"kind":"trait"},"290":{"crate_id":0,"path":["assertables","assert_len_lt"],"kind":"macro"},"2052":{"crate_id":2,"path":["core","iter","traits","marker","TrustedStep"],"kind":"trait"},"2933":{"crate_id":2,"path":["core","ops","index","Index"],"kind":"trait"},"2379":{"crate_id":11,"path":["hashbrown","map","Entry"],"kind":"enum"},"617":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_eq"],"kind":"macro"},"1498":{"crate_id":1,"path":["std","io","stdio","StdoutRaw"],"kind":"struct"},"3260":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"1825":{"crate_id":1,"path":["std","sys","sync","once","queue","Once"],"kind":"struct"},"944":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_contains"],"kind":"module"},"63":{"crate_id":0,"path":["assertables","assert_f64_gt"],"kind":"macro"},"2706":{"crate_id":11,"path":["hashbrown","raw","RawIter"],"kind":"struct"},"3033":{"crate_id":2,"path":["core","net","display_buffer","DisplayBuffer"],"kind":"struct"},"1271":{"crate_id":1,"path":["std","f64"],"kind":"primitive"},"390":{"crate_id":0,"path":["assertables","debug_assert_none"],"kind":"macro"},"2152":{"crate_id":11,"path":["hashbrown","map","OccupiedError"],"kind":"struct"},"2479":{"crate_id":17,"path":["object","pe","ImageEnclaveConfig32"],"kind":"struct"},"717":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_is_match_as_result"],"kind":"macro"},"1598":{"crate_id":2,"path":["core","str","iter","EncodeUtf16"],"kind":"struct"},"3360":{"crate_id":17,"path":["object","read","pe","export","ExportTarget"],"kind":"enum"},"1925":{"crate_id":2,"path":["core","ops","function","Fn"],"kind":"trait"},"163":{"crate_id":0,"path":["assertables","assert_in_range"],"kind":"macro"},"1044":{"crate_id":0,"path":["assertables","assert_status_code_value_ne_as_result"],"kind":"macro"},"2806":{"crate_id":2,"path":["core","core_simd","lane_count","LaneCount"],"kind":"struct"},"3133":{"crate_id":2,"path":["core","iter","sources","once","once"],"kind":"function"},"490":{"crate_id":0,"path":["assertables","assert_iter","assert_iter_ne"],"kind":"module"},"1371":{"crate_id":2,"path":["core","iter","adapters","chain","Chain"],"kind":"struct"},"2252":{"crate_id":16,"path":["gimli","arch","AArch64"],"kind":"struct"},"2579":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"817":{"crate_id":0,"path":["assertables","assert_command_stdout_le_x_as_result"],"kind":"macro"},"1698":{"crate_id":16,"path":["gimli","read","cfi","CfiEntriesIter"],"kind":"struct"},"1144":{"crate_id":0,"path":["assertables","assert_command_stdout_is_match_as_result"],"kind":"macro"},"263":{"crate_id":0,"path":["assertables","assert_is_empty","assert_not_empty"],"kind":"module"},"2025":{"crate_id":2,"path":["core","core_arch","simd","m64x2"],"kind":"struct"},"2906":{"crate_id":6,"path":["libc","unix","bsd","apple","processor_set_load_info"],"kind":"struct"},"3233":{"crate_id":2,"path":["core","core_arch","simd","i32x4"],"kind":"struct"},"590":{"crate_id":0,"path":["assertables","assert_fn_err_eq_x"],"kind":"macro"},"1471":{"crate_id":6,"path":["libc","unix","bsd","apple","ftrimactivefile_t"],"kind":"struct"},"2352":{"crate_id":2,"path":["core","mem","drop"],"kind":"function"},"2679":{"crate_id":16,"path":["gimli","constants","DwDefaulted"],"kind":"struct"},"36":{"crate_id":0,"path":["assertables","debug_assert_f32_ge"],"kind":"macro"},"917":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ne_as_result"],"kind":"macro"},"1798":{"crate_id":17,"path":["object","read","coff","section","SectionTable"],"kind":"struct"},"1244":{"crate_id":1,"path":["std","thread","thread_name_string","ThreadNameString"],"kind":"struct"},"363":{"crate_id":0,"path":["assertables","assert_ok_as_result"],"kind":"macro"},"2125":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_vm"],"kind":"struct"},"3006":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x2_t"],"kind":"struct"},"3333":{"crate_id":17,"path":["object","pe","ImageSymbolEx"],"kind":"struct"},"690":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_eq_x"],"kind":"macro"},"1571":{"crate_id":1,"path":["std","sys","pal","unix","stack_overflow","Handler"],"kind":"struct"},"2452":{"crate_id":3,"path":["alloc","collections","vec_deque","shrink_to","Guard"],"kind":"struct"},"1898":{"crate_id":2,"path":["core","ptr","without_provenance"],"kind":"function"},"136":{"crate_id":0,"path":["assertables","assert_diff_gt_x"],"kind":"macro"},"1017":{"crate_id":0,"path":["assertables","debug_assert_status_success_false"],"kind":"macro"},"2779":{"crate_id":16,"path":["gimli","common","DebugStrOffset"],"kind":"struct"},"1344":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8Buf"],"kind":"struct"},"463":{"crate_id":0,"path":["assertables","assert_bag_superbag_as_result"],"kind":"macro"},"2225":{"crate_id":1,"path":["std","path","Iter"],"kind":"struct"},"3106":{"crate_id":2,"path":["core","hash","BuildHasherDefault"],"kind":"struct"},"2552":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x4x3_t"],"kind":"struct"},"790":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_gt"],"kind":"macro"},"1671":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3433":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x4x4_t"],"kind":"struct"},"1998":{"crate_id":1,"path":["std","collections","hash","set","IntoIter"],"kind":"struct"},"236":{"crate_id":0,"path":["assertables","assert_count","assert_count_ne_x"],"kind":"module"},"1117":{"crate_id":0,"path":["assertables","assert_option_some_ne"],"kind":"macro"},"2879":{"crate_id":1,"path":["std","sync","poison","PoisonError"],"kind":"struct"},"1444":{"crate_id":1,"path":["std","u128"],"kind":"primitive"},"563":{"crate_id":0,"path":["assertables","debug_assert_fn_ne_x"],"kind":"macro"},"2325":{"crate_id":2,"path":["core","range","iter","IterRange"],"kind":"struct"},"3206":{"crate_id":17,"path":["object","read","pe","import","DelayLoadImportTable"],"kind":"struct"},"2652":{"crate_id":1,"path":["std","collections","hash","map","Entry"],"kind":"enum"},"9":{"crate_id":0,"path":["assertables","assert_gt_as_result"],"kind":"macro"},"890":{"crate_id":0,"path":["assertables","assert_command_stderr_string_is_match_as_result"],"kind":"macro"},"1771":{"crate_id":17,"path":["object","read","elf","note","Note"],"kind":"struct"},"2098":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x8x3_t"],"kind":"struct"},"336":{"crate_id":0,"path":["assertables","assert_starts_with"],"kind":"macro"},"1217":{"crate_id":2,"path":["core","num","fmt","Formatted"],"kind":"struct"},"2979":{"crate_id":11,"path":["hashbrown","table","IntoIter"],"kind":"struct"},"3306":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbolIterator"],"kind":"struct"},"663":{"crate_id":0,"path":["assertables","assert_fn_ok"],"kind":"module"},"1544":{"crate_id":17,"path":["object","read","elf","attributes","AttributesSubsubsection"],"kind":"struct"},"2425":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x8x2_t"],"kind":"struct"},"2752":{"crate_id":17,"path":["object","elf","Rel32"],"kind":"struct"},"109":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_ne"],"kind":"module"},"990":{"crate_id":0,"path":["assertables","assert_program_args_stderr_le_x_as_result"],"kind":"macro"},"1871":{"crate_id":17,"path":["object","xcoff","CsectAux32"],"kind":"struct"},"2198":{"crate_id":2,"path":["core","slice","iter","SplitMut"],"kind":"struct"},"436":{"crate_id":0,"path":["assertables","assert_ready","assert_ready_eq"],"kind":"module"},"1317":{"crate_id":6,"path":["libc","unix","bsd","apple","flock"],"kind":"struct"},"3079":{"crate_id":16,"path":["gimli","constants","DwOp"],"kind":"struct"},"3406":{"crate_id":1,"path":["std","sync","mpsc","Iter"],"kind":"struct"},"763":{"crate_id":0,"path":["assertables","assert_io_read_to_string_lt_x_as_result"],"kind":"macro"},"1644":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2525":{"crate_id":6,"path":["libc","unix","bsd","utsname"],"kind":"struct"},"2852":{"crate_id":2,"path":["core","net","parser","AddrKind"],"kind":"enum"},"1090":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_le"],"kind":"macro"},"209":{"crate_id":0,"path":["assertables","assert_count_ne"],"kind":"macro"},"1971":{"crate_id":2,"path":["core","cell","RefCell"],"kind":"struct"},"1417":{"crate_id":17,"path":["object","read","elf","relocation","RelocationSections"],"kind":"struct"},"536":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_lt"],"kind":"module"},"2298":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x8x4_t"],"kind":"struct"},"3179":{"crate_id":17,"path":["object","read","any","ComdatIterator"],"kind":"struct"},"863":{"crate_id":0,"path":["assertables","assert_command_stderr_ge_x"],"kind":"macro"},"1744":{"crate_id":16,"path":["gimli","endianity","BigEndian"],"kind":"struct"},"2625":{"crate_id":16,"path":["gimli","read","rnglists","DebugRanges"],"kind":"struct"},"2071":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x8x3_t"],"kind":"struct"},"309":{"crate_id":0,"path":["assertables","assert_len","assert_len_gt_x"],"kind":"module"},"1190":{"crate_id":2,"path":["core","iter","traits","accum","Product"],"kind":"trait"},"2952":{"crate_id":17,"path":["object","macho","SegmentCommand32"],"kind":"struct"},"1517":{"crate_id":6,"path":["libc","unix","bsd","apple","__c_anonymous_ifr_ifru"],"kind":"union"},"636":{"crate_id":0,"path":["assertables","assert_fn_ok_ne_as_result"],"kind":"macro"},"2398":{"crate_id":1,"path":["std","sys","pal","unix","sync","mutex","Mutex"],"kind":"struct"},"3279":{"crate_id":16,"path":["gimli","constants","DwLnct"],"kind":"struct"},"2725":{"crate_id":2,"path":["core","cell","BorrowMutError"],"kind":"struct"},"963":{"crate_id":0,"path":["assertables","assert_program_args_stderr_gt_as_result"],"kind":"macro"},"82":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_eq_x"],"kind":"macro"},"1844":{"crate_id":2,"path":["core","marker","Freeze"],"kind":"trait"},"2171":{"crate_id":3,"path":["alloc","vec","retain_mut","BackshiftOnDrop"],"kind":"struct"},"409":{"crate_id":0,"path":["assertables","assert_some","assert_some_ne"],"kind":"module"},"1290":{"crate_id":1,"path":["std","sys","net","connection","socket","TcpListener"],"kind":"struct"},"3052":{"crate_id":2,"path":["core","str","iter","LinesAny"],"kind":"struct"},"1617":{"crate_id":1,"path":["std","collections","hash","map","Values"],"kind":"struct"},"736":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_le"],"kind":"macro"},"2498":{"crate_id":1,"path":["std","panic","always_abort"],"kind":"function"},"3379":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x4x2_t"],"kind":"struct"},"2825":{"crate_id":17,"path":["object","read","elf","symbol","SymbolTable"],"kind":"struct"},"182":{"crate_id":0,"path":["assertables","debug_assert_contains"],"kind":"macro"},"1063":{"crate_id":0,"path":["assertables","assert_status_code_value_lt_x"],"kind":"macro"},"1944":{"crate_id":17,"path":["object","endian","I32Bytes"],"kind":"struct"},"2271":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x16x4_t"],"kind":"struct"},"509":{"crate_id":0,"path":["assertables","assert_set_subset_as_result"],"kind":"macro"},"1390":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3152":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x4x2_t"],"kind":"struct"},"836":{"crate_id":0,"path":["assertables","assert_command_stderr_eq_as_result"],"kind":"macro"},"1717":{"crate_id":16,"path":["gimli","read","pubtypes","DebugPubTypes"],"kind":"struct"},"2598":{"crate_id":18,"path":["memchr","memmem","FindIter"],"kind":"struct"},"2925":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x16_t"],"kind":"struct"},"282":{"crate_id":0,"path":["assertables","assert_len_gt"],"kind":"macro"},"1163":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_contains"],"kind":"macro"},"2044":{"crate_id":17,"path":["object","read","macho","segment","MachOSegment"],"kind":"struct"},"2371":{"crate_id":6,"path":["libc","unix","bsd","apple","statvfs"],"kind":"struct"},"609":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_lt_x"],"kind":"module"},"1490":{"crate_id":2,"path":["core","marker","variance","Variance"],"kind":"trait"},"3252":{"crate_id":1,"path":["std","io","error","repr_bitpacked","Repr"],"kind":"struct"},"936":{"crate_id":0,"path":["assertables","assert_program_args_stdout_lt_x"],"kind":"macro"},"55":{"crate_id":0,"path":["assertables","assert_f64_eq"],"kind":"macro"},"1817":{"crate_id":2,"path":["core","core_simd","to_bytes","ToBytes"],"kind":"trait"},"2698":{"crate_id":3,"path":["alloc","collections","btree","set","Union"],"kind":"struct"},"3025":{"crate_id":2,"path":["core","panic"],"kind":"macro"},"382":{"crate_id":0,"path":["assertables","assert_ok"],"kind":"module"},"1263":{"crate_id":2,"path":["core","fmt","rt","Placeholder"],"kind":"struct"},"2144":{"crate_id":9,"path":["miniz_oxide","inflate","stream","InflateState"],"kind":"struct"},"1590":{"crate_id":11,"path":["hashbrown","set","Intersection"],"kind":"struct"},"709":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ne_x_as_result"],"kind":"macro"},"2471":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdat"],"kind":"struct"},"3352":{"crate_id":2,"path":["core","ops","arith","MulAssign"],"kind":"trait"},"1036":{"crate_id":0,"path":["assertables","assert_status_code_value_le_as_result"],"kind":"macro"},"155":{"crate_id":0,"path":["assertables","debug_assert_in"],"kind":"macro"},"1917":{"crate_id":5,"path":["rustc_std_workspace_core"],"kind":"module"},"2798":{"crate_id":2,"path":["core","sync","atomic","AtomicU64"],"kind":"struct"},"2244":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_extended_policy"],"kind":"struct"},"482":{"crate_id":0,"path":["assertables","assert_iter","assert_iter_le"],"kind":"module"},"1363":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3125":{"crate_id":6,"path":["libc","unix","bsd","apple","proc_bsdinfo"],"kind":"struct"},"1690":{"crate_id":1,"path":["std","reference"],"kind":"primitive"},"809":{"crate_id":0,"path":["assertables","assert_command_stdout_ge_x_as_result"],"kind":"macro"},"2571":{"crate_id":2,"path":["core","ops","bit","BitAndAssign"],"kind":"trait"},"3452":{"crate_id":17,"path":["object","elf","Vernaux"],"kind":"struct"},"1136":{"crate_id":0,"path":["assertables","assert_io_read_to_string_matches_as_result"],"kind":"macro"},"255":{"crate_id":0,"path":["assertables","assert_ends_with"],"kind":"module"},"2017":{"crate_id":1,"path":["std","u32"],"kind":"primitive"},"2898":{"crate_id":16,"path":["gimli","read","line","LineProgramHeader"],"kind":"struct"},"2344":{"crate_id":17,"path":["object","xcoff","FileHeader64"],"kind":"struct"},"582":{"crate_id":0,"path":["assertables","assert_fn_err_lt"],"kind":"macro"},"1463":{"crate_id":1,"path":["std","sync","mpsc","SendError"],"kind":"struct"},"3225":{"crate_id":17,"path":["object","read","read_cache","ReadCacheInternal"],"kind":"struct"},"1790":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x4x2_t"],"kind":"struct"},"28":{"crate_id":0,"path":["assertables","debug_assert_eq_f64"],"kind":"macro"},"909":{"crate_id":0,"path":["assertables","assert_program_args_stdout_le_as_result"],"kind":"macro"},"2671":{"crate_id":2,"path":["core","core_arch","simd","u8x64"],"kind":"struct"},"2998":{"crate_id":16,"path":["gimli","read","util","sealed","CapacityFull"],"kind":"struct"},"355":{"crate_id":0,"path":["assertables","debug_assert_err_eq_x"],"kind":"macro"},"1236":{"crate_id":2,"path":["core","sync","atomic","AtomicU16"],"kind":"struct"},"2117":{"crate_id":1,"path":["std","ffi","os_str","OsStr"],"kind":"struct"},"2444":{"crate_id":3,"path":["alloc","vec","Vec"],"kind":"struct"},"682":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_lt"],"kind":"macro"},"1563":{"crate_id":9,"path":["miniz_oxide","MZError"],"kind":"enum"},"3325":{"crate_id":1,"path":["std","io","Take"],"kind":"struct"},"1890":{"crate_id":2,"path":["core","ops","bit","BitXorAssign"],"kind":"trait"},"128":{"crate_id":0,"path":["assertables","assert_diff_eq_x"],"kind":"macro"},"1009":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_string_is_match"],"kind":"macro"},"2771":{"crate_id":16,"path":["gimli","read","pubnames","PubNamesEntry"],"kind":"struct"},"3098":{"crate_id":16,"path":["gimli","read","unit","Attribute"],"kind":"struct"},"455":{"crate_id":0,"path":["assertables","assert_bag_ne_as_result"],"kind":"macro"},"1336":{"crate_id":17,"path":["object","elf","ProgramHeader32"],"kind":"struct"},"2217":{"crate_id":17,"path":["object","macho","TwolevelHintsCommand"],"kind":"struct"},"2544":{"crate_id":17,"path":["object","read","xcoff","symbol","XcoffSymbolTable"],"kind":"struct"},"782":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_eq"],"kind":"macro"},"1663":{"crate_id":2,"path":["core","char","EscapeUnicode"],"kind":"struct"},"3425":{"crate_id":12,"path":["rustc_std_workspace_alloc"],"kind":"module"},"1109":{"crate_id":0,"path":["assertables","debug_assert_option_none"],"kind":"macro"},"228":{"crate_id":0,"path":["assertables","assert_count","assert_count_le_x"],"kind":"module"},"1990":{"crate_id":2,"path":["core","core_simd","simd","ptr","mut_ptr","SimdMutPtr"],"kind":"trait"},"2871":{"crate_id":2,"path":["core","fmt","FormattingOptions"],"kind":"struct"},"3198":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x16x4_t"],"kind":"struct"},"555":{"crate_id":0,"path":["assertables","debug_assert_fn_le_x"],"kind":"macro"},"1436":{"crate_id":6,"path":["libc","unix","bsd","apple","kevent64_s"],"kind":"struct"},"2317":{"crate_id":17,"path":["object","xcoff","BlockAux32"],"kind":"struct"},"1763":{"crate_id":6,"path":["libc","unix","bsd","passwd"],"kind":"struct"},"1":{"crate_id":0,"path":["assertables","assert"],"kind":"module"},"882":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_ne_x"],"kind":"module"},"2644":{"crate_id":18,"path":["memchr","arch","all","memchr","ThreeIter"],"kind":"struct"},"1209":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"328":{"crate_id":0,"path":["assertables","assert_not_matches_as_result"],"kind":"macro"},"2090":{"crate_id":16,"path":["gimli","read","unit","EntriesTreeIter"],"kind":"struct"},"2971":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x16x3_t"],"kind":"struct"},"2417":{"crate_id":6,"path":["libc","unix","pollfd"],"kind":"struct"},"655":{"crate_id":0,"path":["assertables","assert_fn_ok_lt_x"],"kind":"macro"},"1536":{"crate_id":17,"path":["object","read","Relocation"],"kind":"struct"},"3298":{"crate_id":1,"path":["std","hash","random","DefaultHasher"],"kind":"struct"},"1863":{"crate_id":6,"path":["libc","unix","bsd","apple","kevent"],"kind":"struct"},"101":{"crate_id":0,"path":["assertables","assert_abs_diff_ne_x_as_result"],"kind":"macro"},"982":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ge_x"],"kind":"macro"},"2744":{"crate_id":1,"path":["std","sys","pal","unix","os","Env"],"kind":"struct"},"1309":{"crate_id":1,"path":["std","os","unix","net","listener","Incoming"],"kind":"struct"},"428":{"crate_id":0,"path":["assertables","assert_poll"],"kind":"module"},"2190":{"crate_id":2,"path":["core","result","IntoIter"],"kind":"struct"},"3071":{"crate_id":1,"path":["std","collections","hash","map","OccupiedEntry"],"kind":"struct"},"2517":{"crate_id":2,"path":["core","slice","SlicePattern"],"kind":"trait"},"755":{"crate_id":0,"path":["assertables","assert_io_read_to_string_gt_x_as_result"],"kind":"macro"},"1636":{"crate_id":2,"path":["core","cmp","PartialOrd"],"kind":"trait"},"3398":{"crate_id":2,"path":["core","cmp","Ord"],"kind":"trait"},"1963":{"crate_id":2,"path":["core","str","pattern","CharArraySearcher"],"kind":"struct"},"201":{"crate_id":0,"path":["assertables","assert_count_le"],"kind":"macro"},"2844":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3171":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x2x2_t"],"kind":"struct"},"528":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_gt"],"kind":"module"},"1409":{"crate_id":1,"path":["std","collections","hash","set","VacantEntry"],"kind":"struct"},"2290":{"crate_id":17,"path":["object","macho","SubLibraryCommand"],"kind":"struct"},"2617":{"crate_id":1,"path":["std","io","buffered","linewritershim","LineWriterShim"],"kind":"struct"},"855":{"crate_id":0,"path":["assertables","assert_command_stderr_ne"],"kind":"macro"},"1736":{"crate_id":1,"path":["std","ffi"],"kind":"module"},"2063":{"crate_id":16,"path":["gimli","read","unit","DebuggingInformationEntry"],"kind":"struct"},"301":{"crate_id":0,"path":["assertables","assert_len","assert_len_eq_x"],"kind":"module"},"1182":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","__darwin_arm_neon_state64"],"kind":"struct"},"2944":{"crate_id":2,"path":["core","str","iter","EscapeDebug"],"kind":"struct"},"3271":{"crate_id":2,"path":["core","num","niche_types","I64NotAllOnes"],"kind":"struct"},"628":{"crate_id":0,"path":["assertables","assert_fn_ok_le_as_result"],"kind":"macro"},"1509":{"crate_id":11,"path":["hashbrown","map","IntoIter"],"kind":"struct"},"2390":{"crate_id":2,"path":["core","iter","adapters","map_windows","MapWindows"],"kind":"struct"},"2717":{"crate_id":2,"path":["core","sync","atomic","AtomicU8"],"kind":"struct"},"74":{"crate_id":0,"path":["assertables","assert_f64","assert_f64_lt"],"kind":"module"},"955":{"crate_id":0,"path":["assertables","assert_program_args_stderr_eq_as_result"],"kind":"macro"},"1836":{"crate_id":2,"path":["core","iter","adapters","filter_map","FilterMap"],"kind":"struct"},"1282":{"crate_id":2,"path":["core","hash","sip","SipHasher"],"kind":"struct"},"401":{"crate_id":0,"path":["assertables","assert_some","assert_some"],"kind":"module"},"2163":{"crate_id":1,"path":["std","env","SplitPaths"],"kind":"struct"},"3044":{"crate_id":16,"path":["gimli","read","rnglists","DebugRngLists"],"kind":"struct"},"3371":{"crate_id":1,"path":["std","path","Component"],"kind":"enum"},"728":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_ge"],"kind":"macro"},"1609":{"crate_id":2,"path":["core","fmt","builders","PadAdapter"],"kind":"struct"},"2490":{"crate_id":1,"path":["std","sys","fs","unix","copy","FreeOnDrop"],"kind":"struct"},"1936":{"crate_id":11,"path":["hashbrown","table","Entry"],"kind":"enum"},"174":{"crate_id":0,"path":["assertables","debug_assert_any"],"kind":"macro"},"1055":{"crate_id":0,"path":["assertables","assert_status_code_value_gt_x"],"kind":"macro"},"2817":{"crate_id":18,"path":["memchr","vector","SensibleMoveMask"],"kind":"struct"},"1382":{"crate_id":3,"path":["alloc","collections","btree","set","SymmetricDifference"],"kind":"struct"},"501":{"crate_id":0,"path":["assertables","assert_set_disjoint_as_result"],"kind":"macro"},"2263":{"crate_id":18,"path":["memchr","arch","all","twoway","Finder"],"kind":"struct"},"3144":{"crate_id":9,"path":["miniz_oxide","inflate","TINFLStatus"],"kind":"enum"},"828":{"crate_id":0,"path":["assertables","assert_command_stdout_string_contains_as_result"],"kind":"macro"},"1709":{"crate_id":6,"path":["libc","unix","bsd","apple","stat"],"kind":"struct"},"2590":{"crate_id":2,"path":["core","str","iter","Matches"],"kind":"struct"},"2036":{"crate_id":17,"path":["object","macho","EntryPointCommand"],"kind":"struct"},"274":{"crate_id":0,"path":["assertables","assert_len_eq"],"kind":"macro"},"1155":{"crate_id":0,"path":["assertables","assert_program_args_stdout_contains"],"kind":"macro"},"2917":{"crate_id":2,"path":["core","core_arch","simd","i16x32"],"kind":"struct"},"1482":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt"],"kind":"trait"},"601":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_gt_x"],"kind":"module"},"2363":{"crate_id":2,"path":["core","net","ip_addr","IpAddr"],"kind":"enum"},"3244":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x2x4_t"],"kind":"struct"},"2690":{"crate_id":1,"path":["std","os","unix","fs","PermissionsExt"],"kind":"trait"},"47":{"crate_id":0,"path":["assertables","assert_f32_lt_as_result"],"kind":"macro"},"928":{"crate_id":0,"path":["assertables","assert_program_args_stdout_gt_x"],"kind":"macro"},"1809":{"crate_id":16,"path":["gimli","read","line","ColumnType"],"kind":"enum"},"2136":{"crate_id":2,"path":["core","num","error","ParseIntError"],"kind":"struct"},"374":{"crate_id":0,"path":["assertables","assert_ok_eq_x"],"kind":"macro"},"1255":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x2_t"],"kind":"struct"},"3017":{"crate_id":17,"path":["object","read","xcoff","section","XcoffSectionIterator"],"kind":"struct"},"3344":{"crate_id":1,"path":["std","thread","local","LocalKey"],"kind":"struct"},"1582":{"crate_id":1,"path":["std","thread","spawnhook","SpawnHooks"],"kind":"struct"},"701":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_le_x_as_result"],"kind":"macro"},"2463":{"crate_id":16,"path":["gimli","read","cfi","DebugFrame"],"kind":"struct"},"2790":{"crate_id":1,"path":["std","sync","poison","once","Once"],"kind":"struct"},"147":{"crate_id":0,"path":["assertables","assert_diff","assert_diff_lt_x"],"kind":"module"},"1028":{"crate_id":0,"path":["assertables","assert_status_code_value_ge_as_result"],"kind":"macro"},"1909":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_time_constraint_policy"],"kind":"struct"},"2236":{"crate_id":3,"path":["alloc","collections","btree","set","Difference"],"kind":"struct"},"474":{"crate_id":0,"path":["assertables","assert_iter","assert_iter_ge"],"kind":"module"},"1355":{"crate_id":1,"path":["std","array"],"kind":"primitive"},"3117":{"crate_id":1,"path":["std","io","util","Empty"],"kind":"struct"},"3444":{"crate_id":16,"path":["gimli","read","str","DebugStrOffsets"],"kind":"struct"},"801":{"crate_id":0,"path":["assertables","assert_command_stdout_ne_as_result"],"kind":"macro"},"1682":{"crate_id":2,"path":["core","slice","sort","stable","merge","MergeState"],"kind":"struct"},"2563":{"crate_id":13,"path":["std_detect","detect","arch","aarch64","Feature"],"kind":"enum"},"2890":{"crate_id":2,"path":["core","ops","arith","DivAssign"],"kind":"trait"},"247":{"crate_id":0,"path":["assertables","assert_ends_with"],"kind":"macro"},"1128":{"crate_id":0,"path":["assertables","assert_poll_ready_ne_as_result"],"kind":"macro"},"2009":{"crate_id":16,"path":["gimli","constants","DwUt"],"kind":"struct"},"1455":{"crate_id":3,"path":["alloc","collections","btree","map","Keys"],"kind":"struct"},"574":{"crate_id":0,"path":["assertables","assert_fn_err_gt"],"kind":"macro"},"2336":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3217":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x4x4_t"],"kind":"struct"},"901":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ge_as_result"],"kind":"macro"},"20":{"crate_id":0,"path":["assertables","assert_ne_as_result"],"kind":"macro"},"1782":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2663":{"crate_id":2,"path":["core","panicking","AssertKind"],"kind":"enum"},"2990":{"crate_id":2,"path":["core","core_arch","simd","i16x4"],"kind":"struct"},"347":{"crate_id":0,"path":["assertables","debug_assert_err_eq"],"kind":"macro"},"1228":{"crate_id":2,"path":["core","ptr","with_exposed_provenance_mut"],"kind":"function"},"2109":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"1555":{"crate_id":2,"path":["core","core_arch","simd","f16x32"],"kind":"struct"},"674":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_gt"],"kind":"macro"},"2436":{"crate_id":16,"path":["gimli","read","cfi","PointerEncodingParameters"],"kind":"struct"},"3317":{"crate_id":2,"path":["core","str","converts","from_utf8"],"kind":"function"},"1001":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_contains"],"kind":"module"},"120":{"crate_id":0,"path":["assertables","assert_in_epsilon"],"kind":"macro"},"1882":{"crate_id":2,"path":["core","core_arch","simd","f32x4"],"kind":"struct"},"2763":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x2_t"],"kind":"struct"},"2209":{"crate_id":17,"path":["object","read","coff","section","CoffSegmentIterator"],"kind":"struct"},"447":{"crate_id":0,"path":["assertables","debug_assert_ready_ne_x"],"kind":"macro"},"1328":{"crate_id":17,"path":["object","pe","ImageSymbol"],"kind":"struct"},"3090":{"crate_id":11,"path":["hashbrown","map","Drain"],"kind":"struct"},"1655":{"crate_id":3,"path":["alloc","collections","btree","node","drop_key_val","Dropper"],"kind":"struct"},"774":{"crate_id":0,"path":["assertables","assert_io_read_to_string_is_match"],"kind":"macro"},"2536":{"crate_id":1,"path":["std","io","stdio","Stdin"],"kind":"struct"},"3417":{"crate_id":15,"path":["addr2line"],"kind":"module"},"2863":{"crate_id":17,"path":["object","read","util","StringTable"],"kind":"struct"},"220":{"crate_id":0,"path":["assertables","assert_count","assert_count_ge_x"],"kind":"module"},"1101":{"crate_id":0,"path":["assertables","assert_result_ok_eq_as_result"],"kind":"macro"},"1982":{"crate_id":16,"path":["gimli","read","UnitOffset"],"kind":"struct"},"2309":{"crate_id":17,"path":["object","archive","AixMemberOffset"],"kind":"struct"},"547":{"crate_id":0,"path":["assertables","debug_assert_fn_ge_x"],"kind":"macro"},"1428":{"crate_id":2,"path":["core","ops","arith","Add"],"kind":"trait"},"3190":{"crate_id":17,"path":["object","read","pe","file","PeComdatIterator"],"kind":"struct"},"1755":{"crate_id":14,"path":["rustc_demangle","SizeLimitedFmtAdapter"],"kind":"struct"},"874":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_le_x"],"kind":"module"},"2636":{"crate_id":1,"path":["std","ffi","os_str","Display"],"kind":"struct"},"2963":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"320":{"crate_id":0,"path":["assertables","debug_assert_len_ne_x"],"kind":"macro"},"1201":{"crate_id":6,"path":["libc","unix","bsd","apple","segment_command_64"],"kind":"struct"},"2082":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x4x4_t"],"kind":"struct"},"2409":{"crate_id":16,"path":["gimli","read","rnglists","RangeListsFormat"],"kind":"enum"},"647":{"crate_id":0,"path":["assertables","assert_fn_ok_gt_x"],"kind":"macro"},"1528":{"crate_id":2,"path":["core","str","error","Utf8Error"],"kind":"struct"},"3290":{"crate_id":2,"path":["core","core_simd","lane_count","SupportedLaneCount"],"kind":"trait"},"974":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ne"],"kind":"macro"},"93":{"crate_id":0,"path":["assertables","assert_abs_diff_le_x_as_result"],"kind":"macro"},"1855":{"crate_id":6,"path":["libc","unix","bsd","apple","load_command"],"kind":"struct"},"2736":{"crate_id":1,"path":["std","os","unix","thread","JoinHandleExt"],"kind":"trait"},"3063":{"crate_id":2,"path":["core","iter","adapters","take_while","TakeWhile"],"kind":"struct"},"420":{"crate_id":0,"path":["assertables","assert_pending_as_result"],"kind":"macro"},"1301":{"crate_id":2,"path":["core","slice","iter","Chunks"],"kind":"struct"},"2182":{"crate_id":3,"path":["alloc","collections","btree","mem","replace","PanicGuard"],"kind":"struct"},"1628":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"747":{"crate_id":0,"path":["assertables","assert_io_read_to_string_eq_x_as_result"],"kind":"macro"},"2509":{"crate_id":11,"path":["hashbrown","set","ExtractIf"],"kind":"struct"},"3390":{"crate_id":17,"path":["object","read","coff","relocation","CoffRelocationIterator"],"kind":"struct"},"1074":{"crate_id":0,"path":["assertables","assert_success","assert_success"],"kind":"module"},"193":{"crate_id":0,"path":["assertables","assert_count_ge"],"kind":"macro"},"1955":{"crate_id":17,"path":["object","pe","ImageExportDirectory"],"kind":"struct"},"2836":{"crate_id":11,"path":["hashbrown","control","bitmask","BitMask"],"kind":"struct"},"3163":{"crate_id":6,"path":["libc","unix","bsd","apple","__c_anonymous_ifc_ifcu"],"kind":"union"},"520":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_eq"],"kind":"module"},"1401":{"crate_id":16,"path":["gimli","read","cfi","Augmentation"],"kind":"struct"},"2282":{"crate_id":2,"path":["core","str","UnsafeBytesToStr"],"kind":"struct"},"1728":{"crate_id":1,"path":["std","fs","Permissions"],"kind":"struct"},"847":{"crate_id":0,"path":["assertables","assert_command_stderr_le"],"kind":"macro"},"2609":{"crate_id":1,"path":["std","u8"],"kind":"primitive"},"1174":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x4x4_t"],"kind":"struct"},"293":{"crate_id":0,"path":["assertables","assert_len","assert_len_lt"],"kind":"module"},"2055":{"crate_id":2,"path":["core","slice","iter","ChunksMut"],"kind":"struct"},"2936":{"crate_id":11,"path":["hashbrown","set","Difference"],"kind":"struct"},"2382":{"crate_id":1,"path":["std","io","Bytes"],"kind":"struct"},"620":{"crate_id":0,"path":["assertables","assert_fn_ok_ge_as_result"],"kind":"macro"},"1501":{"crate_id":17,"path":["object","elf","SectionHeader64"],"kind":"struct"},"3263":{"crate_id":2,"path":["core","num","niche_types","NonZeroIsizeInner"],"kind":"struct"},"1828":{"crate_id":2,"path":["core","net","ip_addr","Ipv6MulticastScope"],"kind":"enum"},"66":{"crate_id":0,"path":["assertables","assert_f64","assert_f64_gt"],"kind":"module"},"947":{"crate_id":0,"path":["assertables","assert_program_args_stdout_string_contains_as_result"],"kind":"macro"},"2709":{"crate_id":2,"path":["core","core_simd","swizzle","deinterleave","Odd"],"kind":"struct"},"3036":{"crate_id":1,"path":["std","os","fd","raw","FromRawFd"],"kind":"trait"},"1274":{"crate_id":2,"path":["core","iter","adapters","peekable","Peekable"],"kind":"struct"},"393":{"crate_id":0,"path":["assertables","assert_option","assert_option_none"],"kind":"module"},"2155":{"crate_id":17,"path":["object","pe","ImageBoundForwarderRef"],"kind":"struct"},"2482":{"crate_id":16,"path":["gimli","read","unit","DebugTypes"],"kind":"struct"},"720":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_matches"],"kind":"module"},"1601":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3363":{"crate_id":2,"path":["core","marker","Unpin"],"kind":"trait"},"1928":{"crate_id":3,"path":["alloc","collections","btree","map","entry","VacantEntry"],"kind":"struct"},"166":{"crate_id":0,"path":["assertables","assert_in","assert_in_range"],"kind":"module"},"1047":{"crate_id":0,"path":["assertables","assert_status_code_value_eq_x"],"kind":"macro"},"2809":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdatIterator"],"kind":"struct"},"3136":{"crate_id":1,"path":["std","bool"],"kind":"primitive"},"493":{"crate_id":0,"path":["assertables","assert_set_eq_as_result"],"kind":"macro"},"1374":{"crate_id":2,"path":["core","num","nonzero","private","Sealed"],"kind":"trait"},"2255":{"crate_id":2,"path":["core","hash","sip","Sip24Rounds"],"kind":"struct"},"2582":{"crate_id":2,"path":["core","str","iter","SplitN"],"kind":"struct"},"820":{"crate_id":0,"path":["assertables","assert_command_stdout_lt_x"],"kind":"macro"},"1701":{"crate_id":2,"path":["core","core_simd","vector","SimdElement"],"kind":"trait"},"1147":{"crate_id":0,"path":["assertables","assert_command_stderr_contains_as_result"],"kind":"macro"},"266":{"crate_id":0,"path":["assertables","assert_is_match_as_result"],"kind":"macro"},"2028":{"crate_id":1,"path":["std","io","buffered","linewriter","LineWriter"],"kind":"struct"},"2909":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x8x2_t"],"kind":"struct"},"3236":{"crate_id":17,"path":["object","pe","AnonObjectHeader"],"kind":"struct"},"593":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_eq_x"],"kind":"module"},"1474":{"crate_id":1,"path":["std","backtrace_rs","backtrace","Frame"],"kind":"struct"},"2355":{"crate_id":1,"path":["std","sync","mpmc","Sender"],"kind":"struct"},"2682":{"crate_id":17,"path":["object","read","pe","relocation","RelocationBlockIterator"],"kind":"struct"},"39":{"crate_id":0,"path":["assertables","assert_f32_gt_as_result"],"kind":"macro"},"920":{"crate_id":0,"path":["assertables","assert_program_args_stdout_eq_x"],"kind":"macro"},"1801":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x1_t"],"kind":"struct"},"1247":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"366":{"crate_id":0,"path":["assertables","assert_ok_eq"],"kind":"macro"},"2128":{"crate_id":2,"path":["core","alloc","global","GlobalAlloc"],"kind":"trait"},"3009":{"crate_id":17,"path":["object","macho","FatArch32"],"kind":"struct"},"3336":{"crate_id":2,"path":["core","error","tags","Ref"],"kind":"struct"},"693":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ge_x_as_result"],"kind":"macro"},"1574":{"crate_id":1,"path":["std","backtrace","Backtrace"],"kind":"struct"},"2455":{"crate_id":2,"path":["core","fmt","num","Binary"],"kind":"struct"},"1901":{"crate_id":14,"path":["rustc_demangle"],"kind":"module"},"139":{"crate_id":0,"path":["assertables","assert_diff","assert_diff_gt_x"],"kind":"module"},"1020":{"crate_id":0,"path":["assertables","assert_status_failure_as_result"],"kind":"macro"},"2782":{"crate_id":2,"path":["core","ptr","metadata","metadata"],"kind":"function"},"1347":{"crate_id":1,"path":["std","os","fd","raw","AsRawFd"],"kind":"trait"},"466":{"crate_id":0,"path":["assertables","assert_bag"],"kind":"module"},"2228":{"crate_id":14,"path":["rustc_demangle","SizeLimitExhausted"],"kind":"struct"},"3109":{"crate_id":2,"path":["core","sync","atomic","AtomicI16"],"kind":"struct"},"2555":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"793":{"crate_id":0,"path":["assertables","assert_command_stdout_le_as_result"],"kind":"macro"},"1674":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3436":{"crate_id":17,"path":["object","pe","ImageDebugMisc"],"kind":"struct"},"2001":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x4x2_t"],"kind":"struct"},"239":{"crate_id":0,"path":["assertables","assert_email_address_as_result"],"kind":"macro"},"1120":{"crate_id":0,"path":["assertables","assert_poll_pending"],"kind":"macro"},"2882":{"crate_id":17,"path":["object","pe","ImageHotPatchHashes"],"kind":"struct"},"3209":{"crate_id":2,"path":["core","core_arch","simd","i32x2"],"kind":"struct"},"1447":{"crate_id":2,"path":["core","net","socket_addr","SocketAddrV6"],"kind":"struct"},"566":{"crate_id":0,"path":["assertables","assert_fn_err_eq"],"kind":"macro"},"2328":{"crate_id":17,"path":["object","archive","AixFileHeader"],"kind":"struct"},"2655":{"crate_id":2,"path":["core","ops","arith","Neg"],"kind":"trait"},"893":{"crate_id":0,"path":["assertables","assert_program_args"],"kind":"module"},"12":{"crate_id":0,"path":["assertables","assert_le"],"kind":"macro"},"1774":{"crate_id":14,"path":["rustc_demangle","Demangle"],"kind":"struct"},"2101":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"339":{"crate_id":0,"path":["assertables","assert_starts_with","assert_starts_with"],"kind":"module"},"1220":{"crate_id":2,"path":["core","iter","sources","once","Once"],"kind":"struct"},"2982":{"crate_id":18,"path":["memchr","arch","all","packedpair","Pair"],"kind":"struct"},"3309":{"crate_id":17,"path":["object","read","any","Symbol"],"kind":"struct"},"666":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_eq"],"kind":"macro"},"1547":{"crate_id":2,"path":["core","str","pattern","CharPredicateSearcher"],"kind":"struct"},"2428":{"crate_id":2,"path":["core","core_simd","simd","ptr","const_ptr","SimdConstPtr","with_addr"],"kind":"function"},"2755":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"112":{"crate_id":0,"path":["assertables","assert_abs_diff_lt"],"kind":"macro"},"993":{"crate_id":0,"path":["assertables","assert_program_args_stderr_lt_x"],"kind":"macro"},"1874":{"crate_id":16,"path":["gimli","read","line","FileEntryFormat"],"kind":"struct"},"1320":{"crate_id":2,"path":["core","cell","Ref"],"kind":"struct"},"439":{"crate_id":0,"path":["assertables","debug_assert_ready_ne"],"kind":"macro"},"2201":{"crate_id":2,"path":["core","core_simd","vector","splat","splat_rt","Splat"],"kind":"struct"},"3082":{"crate_id":1,"path":["std","os","unix","net","addr","SocketAddr"],"kind":"struct"},"3409":{"crate_id":18,"path":["memchr","arch","all","twoway","SuffixOrdering"],"kind":"enum"},"766":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ne_x"],"kind":"macro"},"1647":{"crate_id":1,"path":["std","sync","mpmc","counter","Receiver"],"kind":"struct"},"2528":{"crate_id":6,"path":["libc","unix","bsd","apple","pthread_mutexattr_t"],"kind":"struct"},"2855":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x2x4_t"],"kind":"struct"},"212":{"crate_id":0,"path":["assertables","assert_count","assert_count_ne"],"kind":"module"},"1093":{"crate_id":0,"path":["assertables","assert_abs_diff_ne_as_result"],"kind":"macro"},"1974":{"crate_id":1,"path":["std","collections","hash","set","SymmetricDifference"],"kind":"struct"},"1420":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x8x4_t"],"kind":"struct"},"539":{"crate_id":0,"path":["assertables","debug_assert_fn_ne"],"kind":"macro"},"2301":{"crate_id":16,"path":["gimli","read","loclists","RawLocListEntry"],"kind":"enum"},"3182":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldSubCacheSlice"],"kind":"enum"},"866":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_ge_x"],"kind":"module"},"1747":{"crate_id":17,"path":["object","macho","DylibCommand"],"kind":"struct"},"2628":{"crate_id":1,"path":["std","io","error","ErrorKind"],"kind":"enum"},"2074":{"crate_id":2,"path":["core","core_arch","simd","m16x8"],"kind":"struct"},"312":{"crate_id":0,"path":["assertables","debug_assert_len_le_x"],"kind":"macro"},"1193":{"crate_id":3,"path":["alloc","collections","linked_list","Iter"],"kind":"struct"},"2955":{"crate_id":2,"path":["core","core_arch","simd","u64x4"],"kind":"struct"},"1520":{"crate_id":6,"path":["libc","unix","bsd","apple","utmpx"],"kind":"struct"},"639":{"crate_id":0,"path":["assertables","assert_fn_ok_eq_x"],"kind":"macro"},"2401":{"crate_id":2,"path":["core","ops","range","IntoBounds"],"kind":"trait"},"3282":{"crate_id":2,"path":["core","core_simd","swizzle","extract","Extract"],"kind":"struct"},"2728":{"crate_id":17,"path":["object","elf","FileHeader32"],"kind":"struct"},"966":{"crate_id":0,"path":["assertables","assert_program_args_stderr_le"],"kind":"macro"},"85":{"crate_id":0,"path":["assertables","assert_abs_diff_ge_x_as_result"],"kind":"macro"},"1847":{"crate_id":2,"path":["core","str","iter","RSplitTerminator"],"kind":"struct"},"2174":{"crate_id":17,"path":["object","pe","ImageOs2Header"],"kind":"struct"},"412":{"crate_id":0,"path":["assertables","debug_assert_some_eq_x"],"kind":"macro"},"1293":{"crate_id":2,"path":["core","sync","atomic","AtomicU128"],"kind":"struct"},"3055":{"crate_id":3,"path":["alloc","borrow","Cow"],"kind":"enum"},"1620":{"crate_id":6,"path":["libc","unix","bsd","apple","sa_endpoints_t"],"kind":"struct"},"739":{"crate_id":0,"path":["assertables","assert_io_read_to_string_lt_as_result"],"kind":"macro"},"2501":{"crate_id":17,"path":["object","pe","ImageTlsDirectory32"],"kind":"struct"},"3382":{"crate_id":2,"path":["core","future","async_drop","Fuse"],"kind":"struct"},"2828":{"crate_id":6,"path":["libc","unix","bsd","apple","qos_class_t"],"kind":"enum"},"1066":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_lt_x"],"kind":"module"},"185":{"crate_id":0,"path":["assertables","assert_not_contains_as_result"],"kind":"macro"},"1947":{"crate_id":2,"path":["core","intrinsics","AggregateRawPtr"],"kind":"trait"},"2274":{"crate_id":2,"path":["core","ops","coroutine","CoroutineState"],"kind":"enum"},"512":{"crate_id":0,"path":["assertables","assert_set_superset"],"kind":"macro"},"1393":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCacheImage"],"kind":"struct"},"3155":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation64V2"],"kind":"struct"},"839":{"crate_id":0,"path":["assertables","assert_command_stderr_ge"],"kind":"macro"},"1720":{"crate_id":3,"path":["alloc","collections","vec_deque","into_iter","try_rfold","Guard"],"kind":"struct"},"2601":{"crate_id":1,"path":["std","sys","process","unix","common","ExitCode"],"kind":"struct"},"2928":{"crate_id":16,"path":["gimli","read","pubnames","DebugPubNames"],"kind":"struct"},"285":{"crate_id":0,"path":["assertables","assert_len","assert_len_gt"],"kind":"module"},"1166":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_is_match"],"kind":"macro"},"2047":{"crate_id":2,"path":["core","marker","Unsize"],"kind":"trait"},"2374":{"crate_id":11,"path":["hashbrown","map","IntoValues"],"kind":"struct"},"612":{"crate_id":0,"path":["assertables","debug_assert_fn_err_ne_x"],"kind":"macro"},"1493":{"crate_id":2,"path":["core","str","iter","Split"],"kind":"struct"},"3255":{"crate_id":2,"path":["core","ops","bit","ShrAssign"],"kind":"trait"},"939":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_lt_x"],"kind":"module"},"58":{"crate_id":0,"path":["assertables","assert_f64","assert_f64_eq"],"kind":"module"},"1820":{"crate_id":2,"path":["core","str","pattern","EmptyNeedle"],"kind":"struct"},"2701":{"crate_id":2,"path":["core","num","nonzero","NonZero"],"kind":"struct"},"3028":{"crate_id":16,"path":["gimli","read","str","DebugStr"],"kind":"struct"},"385":{"crate_id":0,"path":["assertables","assert_result","assert_result_ok_eq"],"kind":"module"},"1266":{"crate_id":16,"path":["gimli","endianity","RunTimeEndian"],"kind":"enum"},"2147":{"crate_id":18,"path":["memchr","arch","all","twoway","ApproximateByteSet"],"kind":"struct"},"1593":{"crate_id":2,"path":["core","sync","atomic","AtomicBool"],"kind":"struct"},"712":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_contains"],"kind":"macro"},"2474":{"crate_id":16,"path":["gimli","common","DebugLocListsBase"],"kind":"struct"},"3355":{"crate_id":2,"path":["core","iter","adapters","filter","Filter"],"kind":"struct"},"1039":{"crate_id":0,"path":["assertables","assert_status_code_value_lt"],"kind":"macro"},"158":{"crate_id":0,"path":["assertables","debug_assert_in_delta"],"kind":"macro"},"1920":{"crate_id":17,"path":["object","xcoff","AuxHeader32"],"kind":"struct"},"2801":{"crate_id":17,"path":["object","pe","ImageDosHeader"],"kind":"struct"},"2247":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x2x2_t"],"kind":"struct"},"485":{"crate_id":0,"path":["assertables","debug_assert_iter_lt"],"kind":"macro"},"1366":{"crate_id":2,"path":["core","slice","iter","ChunksExact"],"kind":"struct"},"3128":{"crate_id":2,"path":["core","slice","iter","ArrayWindows"],"kind":"struct"},"1693":{"crate_id":16,"path":["gimli","read","op","EvaluationWaiting"],"kind":"enum"},"812":{"crate_id":0,"path":["assertables","assert_command_stdout_gt_x"],"kind":"macro"},"2574":{"crate_id":11,"path":["hashbrown","raw_entry","RawVacantEntryMut"],"kind":"struct"},"3455":{"crate_id":3,"path":["alloc"],"kind":"module"},"2901":{"crate_id":18,"path":["memchr","memmem","FinderBuilder"],"kind":"struct"},"1139":{"crate_id":0,"path":["assertables","assert_command_stdout_ne_x_as_result"],"kind":"macro"},"258":{"crate_id":0,"path":["assertables","debug_assert_is_empty"],"kind":"macro"},"2020":{"crate_id":17,"path":["object","pe","ImageAuxSymbolWeak"],"kind":"struct"},"2347":{"crate_id":1,"path":["std","io","Write"],"kind":"trait"},"585":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_lt"],"kind":"module"},"1466":{"crate_id":3,"path":["alloc","collections","btree","set","CursorMutKey"],"kind":"struct"},"3228":{"crate_id":1,"path":["std","path","State"],"kind":"enum"},"1793":{"crate_id":17,"path":["object","elf","Versym"],"kind":"struct"},"31":{"crate_id":0,"path":["assertables","assert_f32_eq_as_result"],"kind":"macro"},"912":{"crate_id":0,"path":["assertables","assert_program_args_stdout_lt"],"kind":"macro"},"2674":{"crate_id":4,"path":["compiler_builtins"],"kind":"module"},"3001":{"crate_id":2,"path":["core","iter","adapters","fuse","Fuse"],"kind":"struct"},"358":{"crate_id":0,"path":["assertables","assert_err_ne_x_as_result"],"kind":"macro"},"1239":{"crate_id":16,"path":["gimli","constants","DwVirtuality"],"kind":"struct"},"2120":{"crate_id":2,"path":["core","core_arch","simd","f64x2"],"kind":"struct"},"2447":{"crate_id":1,"path":["std","net","tcp","Incoming"],"kind":"struct"},"685":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ne_as_result"],"kind":"macro"},"1566":{"crate_id":17,"path":["object","read","CompressedData"],"kind":"struct"},"3328":{"crate_id":1,"path":["std","sys","io","io_slice","iovec","IoSlice"],"kind":"struct"},"1012":{"crate_id":0,"path":["assertables","assert_status_success_as_result"],"kind":"macro"},"131":{"crate_id":0,"path":["assertables","assert_diff","assert_diff_eq_x"],"kind":"module"},"1893":{"crate_id":18,"path":["memchr","arch","aarch64","neon","memchr","Two"],"kind":"struct"},"2774":{"crate_id":18,"path":["memchr","arch","all","memchr","Two"],"kind":"struct"},"3101":{"crate_id":17,"path":["object","read","pe","relocation","RelocationIterator"],"kind":"struct"},"458":{"crate_id":0,"path":["assertables","assert_bag_subbag"],"kind":"macro"},"1339":{"crate_id":16,"path":["gimli","read","line","IncompleteLineProgram"],"kind":"struct"},"2220":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbol"],"kind":"struct"},"2547":{"crate_id":2,"path":["core","core_arch","simd","u64x2"],"kind":"struct"},"785":{"crate_id":0,"path":["assertables","assert_command_stdout_ge_as_result"],"kind":"macro"},"1666":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x2x3_t"],"kind":"struct"},"3428":{"crate_id":1,"path":["std","collections","hash","map","Iter"],"kind":"struct"},"1112":{"crate_id":0,"path":["assertables","debug_assert_option_some"],"kind":"macro"},"231":{"crate_id":0,"path":["assertables","debug_assert_count_lt_x"],"kind":"macro"},"1993":{"crate_id":11,"path":["hashbrown","set","SymmetricDifference"],"kind":"struct"},"2874":{"crate_id":16,"path":["gimli","read","cfi","ParsedEhFrameHdr"],"kind":"struct"},"3201":{"crate_id":1,"path":["std","i64"],"kind":"primitive"},"558":{"crate_id":0,"path":["assertables","assert_fn_lt_x_as_result"],"kind":"macro"},"1439":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x1x3_t"],"kind":"struct"},"2320":{"crate_id":17,"path":["object","read","CompressedFileRange"],"kind":"struct"},"1766":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCache"],"kind":"struct"},"4":{"crate_id":0,"path":["assertables","assert_ge"],"kind":"macro"},"885":{"crate_id":0,"path":["assertables","assert_command_stderr_string_contains"],"kind":"macro"},"2647":{"crate_id":17,"path":["object","macho","Nlist64"],"kind":"struct"},"1212":{"crate_id":6,"path":["libc","unix","bsd","apple","mach_timebase_info"],"kind":"struct"},"331":{"crate_id":0,"path":["assertables","assert_matches"],"kind":"module"},"2093":{"crate_id":1,"path":["std","thread","scoped","Scope"],"kind":"struct"},"2974":{"crate_id":2,"path":["core","slice","iter","ChunksExactMut"],"kind":"struct"},"2420":{"crate_id":2,"path":["core","range","RangeInclusive"],"kind":"struct"},"658":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_lt_x"],"kind":"module"},"1539":{"crate_id":2,"path":["core","fmt","num","Octal"],"kind":"struct"},"3301":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_basic_info"],"kind":"struct"},"1866":{"crate_id":6,"path":["libc","unix","bsd","apple","image_offset"],"kind":"struct"},"104":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_eq"],"kind":"module"},"985":{"crate_id":0,"path":["assertables","assert_program_args_stderr_gt_x"],"kind":"macro"},"2747":{"crate_id":3,"path":["alloc","raw_vec","RawVec"],"kind":"struct"},"1312":{"crate_id":16,"path":["gimli","read","rnglists","RawRngListEntry"],"kind":"enum"},"431":{"crate_id":0,"path":["assertables","debug_assert_ready"],"kind":"macro"},"2193":{"crate_id":3,"path":["alloc","boxed","convert","from","StringError"],"kind":"struct"},"3074":{"crate_id":3,"path":["alloc","collections","binary_heap","BinaryHeap"],"kind":"struct"},"2520":{"crate_id":2,"path":["core","ptr","metadata","Pointee"],"kind":"trait"},"758":{"crate_id":0,"path":["assertables","assert_io_read_to_string_le_x"],"kind":"macro"},"1639":{"crate_id":17,"path":["object","macho","FvmfileCommand"],"kind":"struct"},"3401":{"crate_id":3,"path":["alloc","collections","btree","map","IntoIter"],"kind":"struct"},"1966":{"crate_id":17,"path":["object","common","SymbolFlags"],"kind":"enum"},"204":{"crate_id":0,"path":["assertables","assert_count","assert_count_le"],"kind":"module"},"1085":{"crate_id":0,"path":["assertables","assert_abs_diff_ge_as_result"],"kind":"macro"},"2847":{"crate_id":3,"path":["alloc","rc","from_iter_exact","Guard"],"kind":"struct"},"3174":{"crate_id":3,"path":["alloc","collections","btree","set","Iter"],"kind":"struct"},"531":{"crate_id":0,"path":["assertables","debug_assert_fn_le"],"kind":"macro"},"1412":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2293":{"crate_id":17,"path":["object","endian","U16Bytes"],"kind":"struct"},"2620":{"crate_id":1,"path":["std","net","Shutdown"],"kind":"enum"},"858":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_ne"],"kind":"module"},"1739":{"crate_id":17,"path":["object","read","util","DebugByte"],"kind":"struct"},"2066":{"crate_id":2,"path":["core","core_arch","simd","u16x4"],"kind":"struct"},"304":{"crate_id":0,"path":["assertables","debug_assert_len_ge_x"],"kind":"macro"},"1185":{"crate_id":2,"path":["core","ffi","c_str","Bytes"],"kind":"struct"},"2947":{"crate_id":2,"path":["core","core_simd","swizzle","rotate_elements_left","Rotate"],"kind":"struct"},"3274":{"crate_id":11,"path":["hashbrown","raw","Fallibility"],"kind":"enum"},"631":{"crate_id":0,"path":["assertables","assert_fn_ok_lt"],"kind":"macro"},"1512":{"crate_id":11,"path":["hashbrown","raw_entry","RawEntryMut"],"kind":"enum"},"2393":{"crate_id":2,"path":["core","ops","arith","RemAssign"],"kind":"trait"},"2720":{"crate_id":16,"path":["gimli","arch","Arm"],"kind":"struct"},"77":{"crate_id":0,"path":["assertables","debug_assert_f64_ne"],"kind":"macro"},"958":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ge"],"kind":"macro"},"1839":{"crate_id":1,"path":["std","backtrace_rs","symbolize","Symbol"],"kind":"struct"},"1285":{"crate_id":18,"path":["memchr","arch","aarch64","neon","memchr","ThreeIter"],"kind":"struct"},"404":{"crate_id":0,"path":["assertables","debug_assert_some_eq"],"kind":"macro"},"2166":{"crate_id":17,"path":["object","pe","ImageLinenumber"],"kind":"struct"},"3047":{"crate_id":1,"path":["std","str"],"kind":"primitive"},"3374":{"crate_id":17,"path":["object","common","FileFlags"],"kind":"enum"},"731":{"crate_id":0,"path":["assertables","assert_io_read_to_string_gt_as_result"],"kind":"macro"},"1612":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x16x3_t"],"kind":"struct"},"2493":{"crate_id":2,"path":["core","iter","adapters","flatten","FlatMap"],"kind":"struct"},"1939":{"crate_id":16,"path":["gimli","read","unit","UnitType"],"kind":"enum"},"1058":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_gt_x"],"kind":"module"},"177":{"crate_id":0,"path":["assertables","assert_infix_as_result"],"kind":"macro"},"2820":{"crate_id":17,"path":["object","pe","AnonObjectHeaderV2"],"kind":"struct"},"1385":{"crate_id":16,"path":["gimli","read","cfi","UnwindContext"],"kind":"struct"},"504":{"crate_id":0,"path":["assertables","assert_set_joint"],"kind":"macro"},"2266":{"crate_id":16,"path":["gimli","read","op","Operation"],"kind":"enum"},"3147":{"crate_id":1,"path":["std","fs","DirBuilder"],"kind":"struct"},"2593":{"crate_id":2,"path":["core","iter","adapters","flatten","FlattenCompat"],"kind":"struct"},"831":{"crate_id":0,"path":["assertables","assert_command_stdout_string_is_match"],"kind":"macro"},"1712":{"crate_id":3,"path":["alloc","vec","extract_if","ExtractIf"],"kind":"struct"},"2039":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"277":{"crate_id":0,"path":["assertables","assert_len","assert_len_eq"],"kind":"module"},"1158":{"crate_id":0,"path":["assertables","assert_program_args_stdout_is_match"],"kind":"macro"},"2920":{"crate_id":17,"path":["object","pe","ImageFunctionEntry64"],"kind":"struct"},"1485":{"crate_id":16,"path":["gimli","common","DwarfFileType"],"kind":"enum"},"604":{"crate_id":0,"path":["assertables","debug_assert_fn_err_le_x"],"kind":"macro"},"2366":{"crate_id":3,"path":["alloc","vec","splice","Splice"],"kind":"struct"},"3247":{"crate_id":3,"path":["alloc","vec","into_iter","IntoIter"],"kind":"struct"},"2693":{"crate_id":2,"path":["core","core_arch","simd","u16x64"],"kind":"struct"},"931":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_gt_x"],"kind":"module"},"50":{"crate_id":0,"path":["assertables","assert_f32_ne"],"kind":"macro"},"1812":{"crate_id":2,"path":["core","ops","index","IndexMut"],"kind":"trait"},"2139":{"crate_id":17,"path":["object","archive","Header"],"kind":"struct"},"377":{"crate_id":0,"path":["assertables","assert_ok","assert_ok_eq_x"],"kind":"module"},"1258":{"crate_id":2,"path":["core","core_simd","simd","num","int","SimdInt"],"kind":"trait"},"3020":{"crate_id":17,"path":["object","read","elf","attributes","AttributesSection"],"kind":"struct"},"3347":{"crate_id":2,"path":["core","future","into_future","IntoFuture"],"kind":"trait"},"704":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_lt_x"],"kind":"macro"},"1585":{"crate_id":11,"path":["hashbrown","set","Entry"],"kind":"enum"},"2466":{"crate_id":17,"path":["object","read","macho","segment","MachOSegmentIterator"],"kind":"struct"},"2793":{"crate_id":2,"path":["core","panic","panic_info","PanicInfo"],"kind":"struct"},"150":{"crate_id":0,"path":["assertables","debug_assert_diff_ne_x"],"kind":"macro"},"1031":{"crate_id":0,"path":["assertables","assert_status_code_value_gt"],"kind":"macro"},"1912":{"crate_id":11,"path":["hashbrown","raw","RawIterHashInner"],"kind":"struct"},"2239":{"crate_id":2,"path":["core","format_args"],"kind":"macro"},"477":{"crate_id":0,"path":["assertables","debug_assert_iter_gt"],"kind":"macro"},"1358":{"crate_id":17,"path":["object","xcoff","SectionHeader32"],"kind":"struct"},"3120":{"crate_id":16,"path":["gimli","arch","X86"],"kind":"struct"},"3447":{"crate_id":6,"path":["libc"],"kind":"module"},"804":{"crate_id":0,"path":["assertables","assert_command_stdout_eq_x"],"kind":"macro"},"1685":{"crate_id":1,"path":["std","std_float","StdFloat"],"kind":"trait"},"2566":{"crate_id":2,"path":["core","ops","range","Range"],"kind":"struct"},"2893":{"crate_id":6,"path":["libc","unix","bsd","apple","rt_metrics"],"kind":"struct"},"250":{"crate_id":0,"path":["assertables","assert_ends_with","assert_ends_with"],"kind":"module"},"1131":{"crate_id":0,"path":["assertables","assert_bag_impl_prep"],"kind":"macro"},"2012":{"crate_id":17,"path":["object","macho","DylibModule32"],"kind":"struct"},"1458":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"577":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_gt"],"kind":"module"},"2339":{"crate_id":16,"path":["gimli","constants","DwLang"],"kind":"struct"},"3220":{"crate_id":1,"path":["std","collections","hash","map","Keys"],"kind":"struct"},"904":{"crate_id":0,"path":["assertables","assert_program_args_stdout_gt"],"kind":"macro"},"23":{"crate_id":0,"path":["assertables","assert_eq_f32_as_result"],"kind":"macro"},"1785":{"crate_id":17,"path":["object","pe","ImageAuxSymbolFunction"],"kind":"struct"},"2666":{"crate_id":10,"path":["adler2"],"kind":"module"},"2112":{"crate_id":1,"path":["std","sync","mpmc","waker","Waker"],"kind":"struct"},"350":{"crate_id":0,"path":["assertables","assert_err_ne_as_result"],"kind":"macro"},"1231":{"crate_id":18,"path":["memchr","memmem","searcher","Searcher"],"kind":"struct"},"2993":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStringExt"],"kind":"trait"},"1558":{"crate_id":17,"path":["object","common","RelocationEncoding"],"kind":"enum"},"677":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_le_as_result"],"kind":"macro"},"2439":{"crate_id":6,"path":["libc","unix","bsd","apple","os_unfair_lock_s"],"kind":"struct"},"3320":{"crate_id":16,"path":["gimli","read","cfi","CieOffsetEncoding"],"kind":"enum"},"1004":{"crate_id":0,"path":["assertables","assert_program_args_stderr_string_contains_as_result"],"kind":"macro"},"123":{"crate_id":0,"path":["assertables","assert_approx","assert_approx_eq"],"kind":"module"},"1885":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2766":{"crate_id":1,"path":["std","os","darwin","fs","FileTimesExt"],"kind":"trait"},"2212":{"crate_id":1,"path":["std","sys","process","unix","unix","posix_spawn","PosixSpawnFileActions"],"kind":"struct"},"450":{"crate_id":0,"path":["assertables","assert_bag_eq"],"kind":"macro"},"1331":{"crate_id":17,"path":["object","read","coff","symbol","SymbolTable"],"kind":"struct"},"3093":{"crate_id":17,"path":["object","macho","FatHeader"],"kind":"struct"},"1658":{"crate_id":2,"path":["core","num","niche_types","NonZeroI64Inner"],"kind":"struct"},"777":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_is_match"],"kind":"module"},"2539":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x1x2_t"],"kind":"struct"},"3420":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x16x3_t"],"kind":"struct"},"2866":{"crate_id":2,"path":["core","cell","lazy","force_mut","really_init_mut","PoisonOnPanic"],"kind":"struct"},"223":{"crate_id":0,"path":["assertables","debug_assert_count_gt_x"],"kind":"macro"},"1104":{"crate_id":0,"path":["assertables","assert_result_ok_ne_as_result"],"kind":"macro"},"1985":{"crate_id":2,"path":["core","random","Random"],"kind":"trait"},"2312":{"crate_id":16,"path":["gimli","common","DebugStrOffsetsIndex"],"kind":"struct"},"550":{"crate_id":0,"path":["assertables","assert_fn_gt_x_as_result"],"kind":"macro"},"1431":{"crate_id":2,"path":["core","ffi","primitives","c_char"],"kind":"type_alias"},"3193":{"crate_id":3,"path":["alloc","ffi","c_str","CString"],"kind":"struct"},"1758":{"crate_id":2,"path":["core","panic","unwind_safe","AssertUnwindSafe"],"kind":"struct"},"877":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_lt_x"],"kind":"macro"},"2639":{"crate_id":2,"path":["core","net","ip_addr","fmt","Span"],"kind":"struct"},"2966":{"crate_id":17,"path":["object","read","any","Segment"],"kind":"struct"},"323":{"crate_id":0,"path":["assertables","assert_matches"],"kind":"macro"},"1204":{"crate_id":2,"path":["core","core_simd","simd","ptr","sealed","Sealed"],"kind":"trait"},"2085":{"crate_id":2,"path":["core","cmp","Ordering"],"kind":"enum"},"2412":{"crate_id":6,"path":["libc","unix","bsd","apple","ip_mreq"],"kind":"struct"},"650":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_gt_x"],"kind":"module"},"1531":{"crate_id":2,"path":["core","char","ToLowercase"],"kind":"struct"},"3293":{"crate_id":17,"path":["object","macho","DyldCacheImageInfo"],"kind":"struct"},"977":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_ne"],"kind":"module"},"96":{"crate_id":0,"path":["assertables","assert_abs_diff_lt_x"],"kind":"macro"},"1858":{"crate_id":2,"path":["core","array","drain","Drain"],"kind":"struct"},"2739":{"crate_id":16,"path":["gimli","read","index","UnitIndexSectionIterator"],"kind":"struct"},"3066":{"crate_id":2,"path":["core","slice","iter","RChunksExactMut"],"kind":"struct"},"423":{"crate_id":0,"path":["assertables","assert_pending"],"kind":"module"},"1304":{"crate_id":11,"path":["hashbrown","raw","Bucket"],"kind":"struct"},"2185":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x1_t"],"kind":"struct"},"1631":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"750":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ge_x"],"kind":"macro"},"2512":{"crate_id":2,"path":["core","str","pattern","Searcher"],"kind":"trait"},"3393":{"crate_id":6,"path":["libc","unix","bsd","apple","semun"],"kind":"union"},"1077":{"crate_id":0,"path":["assertables","debug_assert_success_false"],"kind":"macro"},"196":{"crate_id":0,"path":["assertables","assert_count","assert_count_ge"],"kind":"module"},"1958":{"crate_id":1,"path":["std","sync","poison","rwlock","RwLockReadGuard"],"kind":"struct"},"2839":{"crate_id":2,"path":["core","result","Result"],"kind":"enum"},"3166":{"crate_id":17,"path":["object","read","ObjectKind"],"kind":"enum"},"523":{"crate_id":0,"path":["assertables","debug_assert_fn_ge"],"kind":"macro"},"1404":{"crate_id":11,"path":["hashbrown","set","OccupiedEntry"],"kind":"struct"},"2285":{"crate_id":2,"path":["core","ffi","va_list","sealed_trait","VaArgSafe"],"kind":"trait"},"1731":{"crate_id":6,"path":["libc","unix","bsd","apple","stack_t"],"kind":"struct"},"850":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_le"],"kind":"module"},"2612":{"crate_id":2,"path":["core","str","iter","SplitTerminator"],"kind":"struct"},"1177":{"crate_id":17,"path":["object","common","RelocationFlags"],"kind":"enum"},"296":{"crate_id":0,"path":["assertables","debug_assert_len_ne"],"kind":"macro"},"2058":{"crate_id":17,"path":["object","read","pe","resource","ResourceDirectoryEntryData"],"kind":"enum"},"2939":{"crate_id":1,"path":["std","collections","hash","set","Iter"],"kind":"struct"},"2385":{"crate_id":6,"path":["libc","unix","bsd","apple","processor_set_basic_info"],"kind":"struct"},"623":{"crate_id":0,"path":["assertables","assert_fn_ok_gt"],"kind":"macro"},"1504":{"crate_id":1,"path":["std","sync","mpmc","context","Context"],"kind":"struct"},"3266":{"crate_id":2,"path":["core","time","TryFromFloatSecsErrorKind"],"kind":"enum"},"1831":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"69":{"crate_id":0,"path":["assertables","debug_assert_f64_le"],"kind":"macro"},"950":{"crate_id":0,"path":["assertables","assert_program_args_stdout_string_is_match"],"kind":"macro"},"2712":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x2x2_t"],"kind":"struct"},"3039":{"crate_id":3,"path":["alloc","collections","linked_list","IterMut"],"kind":"struct"},"396":{"crate_id":0,"path":["assertables","assert_option","assert_option_some_ne"],"kind":"module"},"1277":{"crate_id":4,"path":["compiler_builtins","math","libm","support","env","Status"],"kind":"struct"},"2158":{"crate_id":1,"path":["std","os","unix","fs","FileTypeExt"],"kind":"trait"},"2485":{"crate_id":2,"path":["core","str","pattern","CharSliceSearcher"],"kind":"struct"},"723":{"crate_id":0,"path":["assertables","assert_io_read_to_string_eq_as_result"],"kind":"macro"},"1604":{"crate_id":17,"path":["object","pe","ImageThunkData32"],"kind":"struct"},"3366":{"crate_id":2,"path":["core","ops","bit","BitOrAssign"],"kind":"trait"},"1931":{"crate_id":2,"path":["core","ptr","metadata","Thin"],"kind":"trait_alias"},"1050":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_eq_x"],"kind":"module"},"169":{"crate_id":0,"path":["assertables","assert_all_as_result"],"kind":"macro"},"2812":{"crate_id":1,"path":["std","io","util","Repeat"],"kind":"struct"},"3139":{"crate_id":2,"path":["core","bstr","ByteStr"],"kind":"struct"},"496":{"crate_id":0,"path":["assertables","assert_set_ne"],"kind":"macro"},"1377":{"crate_id":17,"path":["object","pe","ImageEnclaveConfig64"],"kind":"struct"},"2258":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2585":{"crate_id":1,"path":["std","sys","os_str","bytes","Slice"],"kind":"struct"},"823":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_lt_x"],"kind":"module"},"1704":{"crate_id":1,"path":["std","never"],"kind":"primitive"},"1150":{"crate_id":0,"path":["assertables","assert_command_stderr_is_match_as_result"],"kind":"macro"},"269":{"crate_id":0,"path":["assertables","assert_not_match"],"kind":"macro"},"2031":{"crate_id":3,"path":["alloc","collections","vec_deque","truncate","Dropper"],"kind":"struct"},"2912":{"crate_id":17,"path":["object","xcoff","StatAux"],"kind":"struct"},"3239":{"crate_id":6,"path":["libc","unix","bsd","apple","task_thread_times_info"],"kind":"struct"},"596":{"crate_id":0,"path":["assertables","debug_assert_fn_err_ge_x"],"kind":"macro"},"1477":{"crate_id":6,"path":["libc","unix","bsd","apple","rusage_info_v0"],"kind":"struct"},"2358":{"crate_id":2,"path":["core","str","iter","SplitWhitespace"],"kind":"struct"},"1804":{"crate_id":1,"path":["std","os","unix","net","ucred","UCred"],"kind":"struct"},"923":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_eq_x"],"kind":"module"},"42":{"crate_id":0,"path":["assertables","assert_f32_le"],"kind":"macro"},"2685":{"crate_id":16,"path":["gimli","read","op","Evaluation"],"kind":"struct"},"1250":{"crate_id":2,"path":["core","sync","atomic","AtomicPtr"],"kind":"struct"},"369":{"crate_id":0,"path":["assertables","assert_ok","assert_ok_eq"],"kind":"module"},"2131":{"crate_id":1,"path":["std","sys","fs","unix","OpenOptions"],"kind":"struct"},"3012":{"crate_id":16,"path":["gimli","common","EhFrameOffset"],"kind":"struct"},"3339":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","pthread_attr_t"],"kind":"struct"},"696":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_gt_x"],"kind":"macro"},"1577":{"crate_id":6,"path":["libc","unix","itimerval"],"kind":"struct"},"2458":{"crate_id":17,"path":["object","macho","Section64"],"kind":"struct"},"1904":{"crate_id":17,"path":["object","read","elf","relocation","RelrIterator"],"kind":"struct"},"142":{"crate_id":0,"path":["assertables","debug_assert_diff_le_x"],"kind":"macro"},"1023":{"crate_id":0,"path":["assertables","assert_status_code_value_eq"],"kind":"macro"},"2785":{"crate_id":17,"path":["object","common","SymbolScope"],"kind":"enum"},"1350":{"crate_id":6,"path":["libc","unix","bsd","apple","Dl_info"],"kind":"struct"},"469":{"crate_id":0,"path":["assertables","debug_assert_iter_eq"],"kind":"macro"},"2231":{"crate_id":2,"path":["core","core_arch","simd","u64x8"],"kind":"struct"},"3112":{"crate_id":2,"path":["core","str","iter","SplitAsciiWhitespace"],"kind":"struct"},"2558":{"crate_id":17,"path":["object","common","Architecture"],"kind":"enum"},"796":{"crate_id":0,"path":["assertables","assert_command_stdout_lt"],"kind":"macro"},"1677":{"crate_id":17,"path":["object","read","archive","ArchiveFile"],"kind":"struct"},"3439":{"crate_id":4,"path":["compiler_builtins","math","libm","support","big","u256"],"kind":"struct"},"2004":{"crate_id":17,"path":["object","read","any","Section"],"kind":"struct"},"242":{"crate_id":0,"path":["assertables","assert_not_email_address"],"kind":"macro"},"1123":{"crate_id":0,"path":["assertables","assert_poll_ready"],"kind":"macro"},"2885":{"crate_id":3,"path":["alloc","sync","Weak"],"kind":"struct"},"3212":{"crate_id":2,"path":["core","iter","sources","repeat_with","RepeatWith"],"kind":"struct"},"1450":{"crate_id":2,"path":["core","future","poll_fn","PollFn"],"kind":"struct"},"569":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_eq"],"kind":"module"},"2331":{"crate_id":2,"path":["core","option","Option"],"kind":"enum"},"2658":{"crate_id":1,"path":["std","sys","pal","unix","os","SplitPaths"],"kind":"struct"},"15":{"crate_id":0,"path":["assertables","assert_le"],"kind":"module"},"896":{"crate_id":0,"path":["assertables","assert_program_args_stdout_eq"],"kind":"macro"},"1777":{"crate_id":2,"path":["core","core_arch","simd","f32x16"],"kind":"struct"},"2104":{"crate_id":1,"path":["std","sync","mpsc","RecvTimeoutError"],"kind":"enum"},"342":{"crate_id":0,"path":["assertables","assert_err_as_result"],"kind":"macro"},"1223":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandVariant"],"kind":"enum"},"2985":{"crate_id":2,"path":["core","str","pattern","MultiCharEqPattern"],"kind":"struct"},"3312":{"crate_id":2,"path":["core","fmt","Debug"],"kind":"trait"},"669":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ge_as_result"],"kind":"macro"},"1550":{"crate_id":16,"path":["gimli","read","lookup","PubStuffParser"],"kind":"struct"},"2431":{"crate_id":2,"path":["core","iter","adapters","cycle","Cycle"],"kind":"struct"},"2758":{"crate_id":2,"path":["core","slice","GetDisjointMutIndex"],"kind":"trait"},"996":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_lt_x"],"kind":"module"},"115":{"crate_id":0,"path":["assertables","assert_abs_diff_ge"],"kind":"macro"},"1877":{"crate_id":11,"path":["hashbrown","table","Iter"],"kind":"struct"},"1323":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"442":{"crate_id":0,"path":["assertables","assert_ready_eq_x_as_result"],"kind":"macro"},"2204":{"crate_id":2,"path":["core","str","lossy","Utf8Chunks"],"kind":"struct"},"3085":{"crate_id":6,"path":["libc","unix","bsd","apple","ifmibdata"],"kind":"struct"},"3412":{"crate_id":18,"path":["memchr"],"kind":"module"},"769":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_ne_x"],"kind":"module"},"1650":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x2x4_t"],"kind":"struct"},"2531":{"crate_id":1,"path":["std","io","buffered","IntoInnerError"],"kind":"struct"},"2858":{"crate_id":1,"path":["std","collections","hash","map","IntoKeys"],"kind":"struct"},"215":{"crate_id":0,"path":["assertables","debug_assert_count_eq_x"],"kind":"macro"},"1096":{"crate_id":0,"path":["assertables","assert_result_err"],"kind":"macro"},"1977":{"crate_id":17,"path":["object","pe","ImageArchiveMemberHeader"],"kind":"struct"},"1423":{"crate_id":1,"path":["std","fs","ReadDir"],"kind":"struct"},"542":{"crate_id":0,"path":["assertables","assert_fn_eq_x_as_result"],"kind":"macro"},"2304":{"crate_id":2,"path":["core","ops","coroutine","Coroutine"],"kind":"trait"},"3185":{"crate_id":1,"path":["std","sys","fs","unix","FileType"],"kind":"struct"},"869":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_gt_x"],"kind":"macro"},"1750":{"crate_id":1,"path":["std","fs","Metadata"],"kind":"struct"},"2631":{"crate_id":17,"path":["object","macho","TwolevelHint"],"kind":"struct"},"2077":{"crate_id":17,"path":["object","elf","Dyn32"],"kind":"struct"},"315":{"crate_id":0,"path":["assertables","assert_len_lt_x_as_result"],"kind":"macro"},"1196":{"crate_id":2,"path":["core","fmt","Write"],"kind":"trait"},"2958":{"crate_id":17,"path":["object","xcoff","Rel64"],"kind":"struct"},"1523":{"crate_id":11,"path":["hashbrown","map","Iter"],"kind":"struct"},"642":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_eq_x"],"kind":"module"},"2404":{"crate_id":1,"path":["std","sys_common","wtf8","EncodeWide"],"kind":"struct"},"3285":{"crate_id":17,"path":["object","pe","ImageResourceDirStringU"],"kind":"struct"},"2731":{"crate_id":11,"path":["hashbrown","map","ValuesMut"],"kind":"struct"},"969":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_le"],"kind":"module"},"88":{"crate_id":0,"path":["assertables","assert_abs_diff_gt_x"],"kind":"macro"},"1850":{"crate_id":11,"path":["hashbrown","raw","FullBucketsIndices"],"kind":"struct"},"2177":{"crate_id":1,"path":["std","sys","sync","rwlock","queue","PanicGuard"],"kind":"struct"},"415":{"crate_id":0,"path":["assertables","assert_some_ne_x_as_result"],"kind":"macro"},"1296":{"crate_id":3,"path":["alloc","collections","binary_heap","DrainSorted"],"kind":"struct"},"3058":{"crate_id":6,"path":["libc","unix","bsd","apple","vm_range_t"],"kind":"struct"},"3385":{"crate_id":3,"path":["alloc","task","Wake"],"kind":"trait"},"1623":{"crate_id":1,"path":["std","env"],"kind":"module"},"742":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ne"],"kind":"macro"},"2504":{"crate_id":9,"path":["miniz_oxide","inflate","core","HuffmanTable"],"kind":"struct"},"2831":{"crate_id":17,"path":["object","read","ObjectMapEntry"],"kind":"struct"},"188":{"crate_id":0,"path":["assertables","assert_contains"],"kind":"module"},"1069":{"crate_id":0,"path":["assertables","assert_status_code_value_ne_x"],"kind":"macro"},"1950":{"crate_id":2,"path":["core","marker","Sync"],"kind":"trait"},"2277":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"515":{"crate_id":0,"path":["assertables","assert_set","assert_set_superset"],"kind":"module"},"1396":{"crate_id":2,"path":["core","ops","async_function","AsyncFn"],"kind":"trait"},"3158":{"crate_id":2,"path":["core","option","Iter"],"kind":"struct"},"842":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_ge"],"kind":"module"},"1723":{"crate_id":18,"path":["memchr","memmem","searcher","SearcherKind"],"kind":"union"},"2604":{"crate_id":1,"path":["std","os","unix","fs","OpenOptionsExt"],"kind":"trait"},"2931":{"crate_id":2,"path":["core","cell","SyncUnsafeCell"],"kind":"struct"},"288":{"crate_id":0,"path":["assertables","debug_assert_len_le"],"kind":"macro"},"1169":{"crate_id":2,"path":["core","num","niche_types","UsizeNoHighBit"],"kind":"struct"},"2050":{"crate_id":3,"path":["alloc","collections","binary_heap","drop","DropGuard"],"kind":"struct"},"1496":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_affinity_policy"],"kind":"struct"},"615":{"crate_id":0,"path":["assertables","assert_fn_ok_eq"],"kind":"macro"},"2377":{"crate_id":17,"path":["object","pe","ImageEpilogueDynamicRelocationHeader"],"kind":"struct"},"3258":{"crate_id":16,"path":["gimli","read","unit","UnitHeader"],"kind":"struct"},"942":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_ne_x"],"kind":"macro"},"61":{"crate_id":0,"path":["assertables","debug_assert_f64_ge"],"kind":"macro"},"1823":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCacheImageIterator"],"kind":"struct"},"2704":{"crate_id":2,"path":["core","slice","sort","stable","drift","DriftsortRun"],"kind":"struct"},"3031":{"crate_id":1,"path":["std","sys","fs","unix","FileTimes"],"kind":"struct"},"388":{"crate_id":0,"path":["assertables","assert_none"],"kind":"macro"},"1269":{"crate_id":2,"path":["core","iter","traits","exact_size","ExactSizeIterator"],"kind":"trait"},"2150":{"crate_id":1,"path":["std","sys","pal","unix","os","EnvStrDebug"],"kind":"struct"},"1596":{"crate_id":1,"path":["std","collections","hash","map","ExtractIf"],"kind":"struct"},"715":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_contains"],"kind":"module"},"2477":{"crate_id":17,"path":["object","macho","SymsegCommand"],"kind":"struct"},"3358":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x4x2_t"],"kind":"struct"},"1042":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_lt"],"kind":"module"},"161":{"crate_id":0,"path":["assertables","debug_assert_in_epsilon"],"kind":"macro"},"1923":{"crate_id":2,"path":["core"],"kind":"module"},"2804":{"crate_id":17,"path":["object","xcoff","FileHeader32"],"kind":"struct"},"2250":{"crate_id":2,"path":["core","core_arch","simd","u8x32"],"kind":"struct"},"488":{"crate_id":0,"path":["assertables","assert_iter_ne_as_result"],"kind":"macro"},"1369":{"crate_id":2,"path":["core","hash","sip","SipHasher24"],"kind":"struct"},"3131":{"crate_id":17,"path":["object","read","any","Comdat"],"kind":"struct"},"1696":{"crate_id":16,"path":["gimli","read","op","OperationIter"],"kind":"struct"},"815":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_gt_x"],"kind":"module"},"2577":{"crate_id":17,"path":["object","macho","EncryptionInfoCommand32"],"kind":"struct"},"3458":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2904":{"crate_id":1,"path":["std","path","StripPrefixError"],"kind":"struct"},"1142":{"crate_id":0,"path":["assertables","assert_command_stdout_contains"],"kind":"macro"},"261":{"crate_id":0,"path":["assertables","assert_not_empty_as_result"],"kind":"macro"},"2023":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x2_t"],"kind":"struct"},"2350":{"crate_id":2,"path":["core","ptr","unique","Unique"],"kind":"struct"},"588":{"crate_id":0,"path":["assertables","debug_assert_fn_err_ne"],"kind":"macro"},"1469":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x2_t"],"kind":"struct"},"3231":{"crate_id":17,"path":["object","read","macho","fat","MachOFatFile"],"kind":"struct"},"1796":{"crate_id":6,"path":["libc","unix","bsd","apple","mach_header_64"],"kind":"struct"},"915":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_lt"],"kind":"module"},"34":{"crate_id":0,"path":["assertables","assert_f32_ge"],"kind":"macro"},"2677":{"crate_id":2,"path":["core","convert","AsRef"],"kind":"trait"},"3004":{"crate_id":1,"path":["std","sync","mpmc","TryIter"],"kind":"struct"},"361":{"crate_id":0,"path":["assertables","assert_err"],"kind":"module"},"1242":{"crate_id":17,"path":["object","read","elf","version","VersionIndex"],"kind":"struct"},"2123":{"crate_id":11,"path":["hashbrown","scopeguard","ScopeGuard"],"kind":"struct"},"2450":{"crate_id":2,"path":["core","panic","panic_info","PanicMessage"],"kind":"struct"},"688":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_eq_x"],"kind":"macro"},"1569":{"crate_id":2,"path":["core","char","EscapeDefault"],"kind":"struct"},"3331":{"crate_id":2,"path":["core","cell","once","OnceCell"],"kind":"struct"},"1015":{"crate_id":0,"path":["assertables","assert_status_success_false"],"kind":"macro"},"134":{"crate_id":0,"path":["assertables","debug_assert_diff_ge_x"],"kind":"macro"},"1896":{"crate_id":16,"path":["gimli","read","cfi","CallFrameInstructionIter"],"kind":"struct"},"2777":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_inarp"],"kind":"struct"},"3104":{"crate_id":2,"path":["core","alloc","layout","Layout"],"kind":"struct"},"461":{"crate_id":0,"path":["assertables","assert_bag","assert_bag_subbag"],"kind":"module"},"1342":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdatSectionIterator"],"kind":"struct"},"2223":{"crate_id":2,"path":["core","slice","iter","RSplit"],"kind":"struct"},"2550":{"crate_id":16,"path":["gimli","read","op","DieReference"],"kind":"enum"},"788":{"crate_id":0,"path":["assertables","assert_command_stdout_gt"],"kind":"macro"},"1669":{"crate_id":16,"path":["gimli","common","DwoId"],"kind":"struct"},"3431":{"crate_id":16,"path":["gimli","read","cfi","FrameDescriptionEntry"],"kind":"struct"},"1115":{"crate_id":0,"path":["assertables","debug_assert_option_some_eq"],"kind":"macro"},"234":{"crate_id":0,"path":["assertables","assert_count_ne_x_as_result"],"kind":"macro"},"1996":{"crate_id":6,"path":["libc","unix","bsd","apple","ip_mreq_source"],"kind":"struct"},"2877":{"crate_id":2,"path":["core","iter","adapters","rev","Rev"],"kind":"struct"},"3204":{"crate_id":18,"path":["memchr","memmem","searcher","Prefilter"],"kind":"struct"},"561":{"crate_id":0,"path":["assertables","assert_fn_ne_x"],"kind":"macro"},"1442":{"crate_id":2,"path":["core","slice","iter","Split"],"kind":"struct"},"2323":{"crate_id":2,"path":["core","str","iter","SplitNInternal"],"kind":"struct"},"1769":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x8x2_t"],"kind":"struct"},"7":{"crate_id":0,"path":["assertables","assert_ge"],"kind":"module"},"888":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_string_contains"],"kind":"module"},"2650":{"crate_id":17,"path":["object","xcoff","Symbol64"],"kind":"struct"},"1215":{"crate_id":6,"path":["libc","unix","bsd","apple","dirent"],"kind":"struct"},"334":{"crate_id":0,"path":["assertables","debug_assert_not_starts_with"],"kind":"macro"},"2096":{"crate_id":2,"path":["core","core_simd","simd","cmp","ord","SimdOrd"],"kind":"trait"},"2977":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x8x4_t"],"kind":"struct"},"2423":{"crate_id":17,"path":["object","pe","ImageCor20Header"],"kind":"struct"},"661":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_ne_x"],"kind":"macro"},"1542":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x4_t"],"kind":"struct"},"3304":{"crate_id":1,"path":["std","io","error","SimpleMessage"],"kind":"struct"},"1869":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x4x4_t"],"kind":"struct"},"107":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_le"],"kind":"module"},"988":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_gt_x"],"kind":"module"},"2750":{"crate_id":2,"path":["core","iter","traits","double_ended","DoubleEndedIterator"],"kind":"trait"},"3077":{"crate_id":11,"path":["hashbrown","table","VacantEntry"],"kind":"struct"},"1315":{"crate_id":2,"path":["core","marker","Tuple"],"kind":"trait"},"434":{"crate_id":0,"path":["assertables","assert_ready_eq_as_result"],"kind":"macro"},"2196":{"crate_id":2,"path":["core","net","socket_addr","SocketAddrV4"],"kind":"struct"},"2523":{"crate_id":3,"path":["alloc","collections","btree","set","Range"],"kind":"struct"},"761":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_le_x"],"kind":"module"},"1642":{"crate_id":1,"path":["std","panicking","rust_panic_without_hook","RewrapBox"],"kind":"struct"},"3404":{"crate_id":6,"path":["libc","unix","bsd","apple","ifma_msghdr"],"kind":"struct"},"1969":{"crate_id":17,"path":["object","read","elf","relocation","ElfDynamicRelocationIterator"],"kind":"struct"},"1088":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_gt"],"kind":"macro"},"207":{"crate_id":0,"path":["assertables","debug_assert_count_lt"],"kind":"macro"},"2850":{"crate_id":1,"path":["std","time","SystemTimeError"],"kind":"struct"},"3177":{"crate_id":16,"path":["gimli","read","dwarf","Dwarf"],"kind":"struct"},"534":{"crate_id":0,"path":["assertables","assert_fn_lt_as_result"],"kind":"macro"},"1415":{"crate_id":2,"path":["core","ptr","drop_in_place"],"kind":"function"},"2296":{"crate_id":16,"path":["gimli","read","cfi","BaseAddresses"],"kind":"struct"},"2623":{"crate_id":16,"path":["gimli","constants","DwEhPe"],"kind":"struct"},"861":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_eq_x"],"kind":"macro"},"1742":{"crate_id":17,"path":["object","elf","Syminfo64"],"kind":"struct"},"1188":{"crate_id":2,"path":["core","any","Any"],"kind":"trait"},"307":{"crate_id":0,"path":["assertables","assert_len_gt_x_as_result"],"kind":"macro"},"2069":{"crate_id":3,"path":["alloc","sync","UniqueArcUninit"],"kind":"struct"},"2950":{"crate_id":1,"path":["std","io","Guard"],"kind":"struct"},"3277":{"crate_id":18,"path":["memchr","arch","generic","memchr","Iter"],"kind":"struct"},"634":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_lt"],"kind":"module"},"1515":{"crate_id":3,"path":["alloc","collections","btree","merge_iter","MergeIterInner"],"kind":"struct"},"2396":{"crate_id":17,"path":["object","read","xcoff","comdat","XcoffComdat"],"kind":"struct"},"2723":{"crate_id":2,"path":["core","iter","sources","repeat_n","RepeatN"],"kind":"struct"},"961":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_ge"],"kind":"module"},"80":{"crate_id":0,"path":["assertables","assert_abs_diff_eq_x"],"kind":"macro"},"1842":{"crate_id":6,"path":["libc","unix","bsd","apple","ntptimeval"],"kind":"struct"},"1288":{"crate_id":2,"path":["core","str","IsAsciiWhitespace"],"kind":"struct"},"407":{"crate_id":0,"path":["assertables","assert_some_ne_as_result"],"kind":"macro"},"2169":{"crate_id":2,"path":["core","async_iter","from_iter","FromIter"],"kind":"struct"},"3050":{"crate_id":3,"path":["alloc","vec","in_place_drop","InPlaceDrop"],"kind":"struct"},"3377":{"crate_id":2,"path":["core","slice","GetDisjointMutError"],"kind":"enum"},"734":{"crate_id":0,"path":["assertables","assert_io_read_to_string_le"],"kind":"macro"},"1615":{"crate_id":2,"path":["core","fmt","DebugAsHex"],"kind":"enum"},"2496":{"crate_id":6,"path":["libc","unix","bsd","apple","tcp_connection_info"],"kind":"struct"},"1942":{"crate_id":1,"path":["std","io","stdio","StdinLock"],"kind":"struct"},"180":{"crate_id":0,"path":["assertables","assert_contains"],"kind":"macro"},"1061":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_le_x"],"kind":"macro"},"2823":{"crate_id":1,"path":["std","backtrace_rs","backtrace","libunwind","Frame"],"kind":"enum"},"1388":{"crate_id":2,"path":["core","ffi","c_str","CStr"],"kind":"struct"},"507":{"crate_id":0,"path":["assertables","assert_set","assert_set_joint"],"kind":"module"},"2269":{"crate_id":2,"path":["core","num","error","IntErrorKind"],"kind":"enum"},"3150":{"crate_id":2,"path":["core","fmt","Error"],"kind":"struct"},"2596":{"crate_id":17,"path":["object","read","pe","export","Export"],"kind":"struct"},"834":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_string_is_match"],"kind":"module"},"1715":{"crate_id":1,"path":["std","io","error","Error"],"kind":"struct"},"2042":{"crate_id":6,"path":["libc","unix","rusage"],"kind":"struct"},"280":{"crate_id":0,"path":["assertables","debug_assert_len_ge"],"kind":"macro"},"1161":{"crate_id":0,"path":["assertables","assert_program_args_stderr_contains_as_result"],"kind":"macro"},"2923":{"crate_id":1,"path":["std","path","Components"],"kind":"struct"},"1488":{"crate_id":17,"path":["object","common","AddressSize"],"kind":"enum"},"607":{"crate_id":0,"path":["assertables","assert_fn_err_lt_x_as_result"],"kind":"macro"},"2369":{"crate_id":2,"path":["core","result","Iter"],"kind":"struct"},"3250":{"crate_id":11,"path":["hashbrown","map","ExtractIf"],"kind":"struct"},"2696":{"crate_id":16,"path":["gimli","read","value","Value"],"kind":"enum"},"53":{"crate_id":0,"path":["assertables","assert_f32","assert_f32_ne"],"kind":"module"},"934":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_le_x"],"kind":"macro"},"1815":{"crate_id":2,"path":["core","borrow","BorrowMut"],"kind":"trait"},"2142":{"crate_id":14,"path":["rustc_demangle","v0","Demangle"],"kind":"struct"},"380":{"crate_id":0,"path":["assertables","debug_assert_ok_ne_x"],"kind":"macro"},"1261":{"crate_id":2,"path":["core","panic","unwind_safe","UnwindSafe"],"kind":"trait"},"3023":{"crate_id":2,"path":["core","str","pattern","ReverseSearcher"],"kind":"trait"},"3350":{"crate_id":17,"path":["object","read","archive","ArchiveSymbol"],"kind":"struct"},"707":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_lt_x"],"kind":"module"},"1588":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x8_t"],"kind":"struct"},"2469":{"crate_id":6,"path":["libc","unix","bsd","apple","addrinfo"],"kind":"struct"},"2796":{"crate_id":17,"path":["object","read","pe","file","PeFile"],"kind":"struct"},"1034":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_gt"],"kind":"module"},"153":{"crate_id":0,"path":["assertables","assert_in"],"kind":"macro"},"1915":{"crate_id":17,"path":["object","read","pe","file","PeComdat"],"kind":"struct"},"2242":{"crate_id":17,"path":["object","xcoff","Symbol32"],"kind":"struct"},"480":{"crate_id":0,"path":["assertables","assert_iter_le_as_result"],"kind":"macro"},"1361":{"crate_id":6,"path":["libc","unix","bsd","regmatch_t"],"kind":"struct"},"3123":{"crate_id":2,"path":["core","array","Guard"],"kind":"struct"},"3450":{"crate_id":1,"path":["std","sync","mpsc","Receiver"],"kind":"struct"},"807":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_eq_x"],"kind":"module"},"1688":{"crate_id":17,"path":["object","pe","ImageLoadConfigCodeIntegrity"],"kind":"struct"},"2569":{"crate_id":2,"path":["core","ops","try_trait","NeverShortCircuitResidual"],"kind":"enum"},"2896":{"crate_id":14,"path":["rustc_demangle","v0","Ident"],"kind":"struct"},"253":{"crate_id":0,"path":["assertables","debug_assert_not_ends_with"],"kind":"macro"},"1134":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_matches"],"kind":"macro"},"2015":{"crate_id":17,"path":["object","macho","DataInCodeEntry"],"kind":"struct"},"1461":{"crate_id":18,"path":["memchr","memmem","searcher","SearcherRevKind"],"kind":"enum"},"580":{"crate_id":0,"path":["assertables","debug_assert_fn_err_le"],"kind":"macro"},"2342":{"crate_id":17,"path":["object","read","macho","file","MachOComdatSectionIterator"],"kind":"struct"},"3223":{"crate_id":2,"path":["core","iter","adapters","map","Map"],"kind":"struct"},"907":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_gt"],"kind":"module"},"26":{"crate_id":0,"path":["assertables","assert_eq_f64"],"kind":"macro"},"1788":{"crate_id":2,"path":["core","fmt","Binary"],"kind":"trait"},"2669":{"crate_id":2,"path":["core","num","FpCategory"],"kind":"enum"},"2115":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x8_t"],"kind":"struct"},"353":{"crate_id":0,"path":["assertables","assert_err_eq_x"],"kind":"macro"},"1234":{"crate_id":6,"path":["libc","unix","bsd","apple","glob_t"],"kind":"struct"},"2996":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"1561":{"crate_id":2,"path":["core","num","niche_types","NonZeroI128Inner"],"kind":"struct"},"680":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_lt"],"kind":"macro"},"2442":{"crate_id":17,"path":["object","elf","FileHeader64"],"kind":"struct"},"3323":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbolTable"],"kind":"struct"},"2769":{"crate_id":2,"path":["core","mem","maybe_uninit","Guard"],"kind":"struct"},"1007":{"crate_id":0,"path":["assertables","assert_program_args_stderr_string_is_match"],"kind":"macro"},"126":{"crate_id":0,"path":["assertables","assert_approx","assert_approx_ne"],"kind":"module"},"1888":{"crate_id":17,"path":["object","read","macho","relocation","MachORelocationIterator"],"kind":"struct"},"2215":{"crate_id":1,"path":["std","collections","hash","map","IntoIter"],"kind":"struct"},"453":{"crate_id":0,"path":["assertables","assert_bag","assert_bag_eq"],"kind":"module"},"1334":{"crate_id":1,"path":["std","sys","process","unix","unix","ExitStatus"],"kind":"struct"},"3096":{"crate_id":2,"path":["core","marker","variance","PhantomInvariantLifetime"],"kind":"struct"},"1661":{"crate_id":2,"path":["core","core_arch","simd","f16x8"],"kind":"struct"},"780":{"crate_id":0,"path":["assertables","assert_command_stdout_eq"],"kind":"macro"},"2542":{"crate_id":3,"path":["alloc","string","FromUtf8Error"],"kind":"struct"},"3423":{"crate_id":16,"path":["gimli","read","loclists","LocListsFormat"],"kind":"enum"},"2869":{"crate_id":1,"path":["std","sys","net","connection","socket","LookupHost"],"kind":"struct"},"226":{"crate_id":0,"path":["assertables","assert_count_le_x_as_result"],"kind":"macro"},"1107":{"crate_id":0,"path":["assertables","assert_option_none_as_result"],"kind":"macro"},"1988":{"crate_id":1,"path":["std","fs","DirEntry"],"kind":"struct"},"2315":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x2x4_t"],"kind":"struct"},"553":{"crate_id":0,"path":["assertables","assert_fn_le_x"],"kind":"macro"},"1434":{"crate_id":2,"path":["core","core_arch","simd","f16x4"],"kind":"struct"},"3196":{"crate_id":1,"path":["std","sys","os_str","bytes","Buf"],"kind":"struct"},"880":{"crate_id":0,"path":["assertables","assert_command_stderr_ne_x_as_result"],"kind":"macro"},"1761":{"crate_id":6,"path":["libc","unix","bsd","apple","if_data64"],"kind":"struct"},"2642":{"crate_id":19,"path":["panic_unwind"],"kind":"module"},"2969":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x1_t"],"kind":"struct"},"326":{"crate_id":0,"path":["assertables","assert_matches","assert_matches"],"kind":"module"},"1207":{"crate_id":3,"path":["alloc","collections","btree","node","marker","Immut"],"kind":"struct"},"2088":{"crate_id":3,"path":["alloc","collections","vec_deque","into_iter","try_fold","Guard"],"kind":"struct"},"2415":{"crate_id":2,"path":["core","core_simd","simd","cmp","ord","SimdPartialOrd"],"kind":"trait"},"653":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_le_x"],"kind":"macro"},"1534":{"crate_id":2,"path":["core","core_simd","masks","sealed","Sealed"],"kind":"trait"},"3296":{"crate_id":3,"path":["alloc","slice","to_vec_in","to_vec","DropGuard"],"kind":"struct"},"980":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_eq_x"],"kind":"macro"},"99":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_lt_x"],"kind":"module"},"1861":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x4x3_t"],"kind":"struct"},"2742":{"crate_id":17,"path":["object","read","pe","resource","ResourceDirectoryTable"],"kind":"struct"},"3069":{"crate_id":2,"path":["core","cell","BorrowError"],"kind":"struct"},"426":{"crate_id":0,"path":["assertables","assert_poll","assert_poll_ready_eq"],"kind":"module"},"1307":{"crate_id":1,"path":["std","sys_common","wstr","WStrUnits"],"kind":"struct"},"2188":{"crate_id":17,"path":["object","elf","Verneed"],"kind":"struct"},"1634":{"crate_id":1,"path":["std","sync","poison","rwlock","RwLockWriteGuard"],"kind":"struct"},"753":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_ge_x"],"kind":"module"},"2515":{"crate_id":17,"path":["object","pe","MaskedRichHeaderEntry"],"kind":"struct"},"3396":{"crate_id":2,"path":["core","iter","adapters","zip","TrustedRandomAccess"],"kind":"trait"},"1080":{"crate_id":0,"path":["assertables","assert_as_result"],"kind":"macro"},"199":{"crate_id":0,"path":["assertables","debug_assert_count_gt"],"kind":"macro"},"1961":{"crate_id":6,"path":["libc","unix","bsd","apple","fspecread_t"],"kind":"struct"},"2842":{"crate_id":17,"path":["object","read","elf","version","Version"],"kind":"struct"},"2288":{"crate_id":3,"path":["alloc","borrow","ToOwned"],"kind":"trait"},"526":{"crate_id":0,"path":["assertables","assert_fn_gt_as_result"],"kind":"macro"},"1407":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x2x3_t"],"kind":"struct"},"3169":{"crate_id":17,"path":["object","macho","DylibModule64"],"kind":"struct"},"1734":{"crate_id":1,"path":["std","thread","local","AccessError"],"kind":"struct"},"853":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_lt"],"kind":"macro"},"2615":{"crate_id":3,"path":["alloc","collections","linked_list","ExtractIf"],"kind":"struct"},"1180":{"crate_id":2,"path":["core","num","niche_types","I32NotAllOnes"],"kind":"struct"},"299":{"crate_id":0,"path":["assertables","assert_len_eq_x_as_result"],"kind":"macro"},"2061":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"2942":{"crate_id":16,"path":["gimli","read","lookup","DebugLookup"],"kind":"struct"},"2388":{"crate_id":17,"path":["object","read","elf","section","ElfSection"],"kind":"struct"},"626":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_gt"],"kind":"module"},"1507":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3269":{"crate_id":2,"path":["core","panicking","assert_matches_failed","Pattern"],"kind":"struct"},"1834":{"crate_id":16,"path":["gimli","read","abbrev","Attributes"],"kind":"enum"},"953":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_string_is_match"],"kind":"module"},"72":{"crate_id":0,"path":["assertables","assert_f64_lt_as_result"],"kind":"macro"},"2715":{"crate_id":17,"path":["object","read","SymbolIndex"],"kind":"struct"},"3042":{"crate_id":2,"path":["core","str","iter","SplitInternal"],"kind":"struct"},"399":{"crate_id":0,"path":["assertables","assert_some_as_result"],"kind":"macro"},"1280":{"crate_id":16,"path":["gimli","read","cfi","CallFrameInstruction"],"kind":"enum"},"2161":{"crate_id":2,"path":["core","marker","PointerLike"],"kind":"trait"},"2488":{"crate_id":16,"path":["gimli","read","lookup","LookupEntryIter"],"kind":"struct"},"726":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ge"],"kind":"macro"},"1607":{"crate_id":17,"path":["object","read","any","SegmentIterator"],"kind":"struct"},"3369":{"crate_id":17,"path":["object","read","pe","import","DelayLoadDescriptorIterator"],"kind":"struct"},"1934":{"crate_id":17,"path":["object","read","Import"],"kind":"struct"},"172":{"crate_id":0,"path":["assertables","assert_any"],"kind":"macro"},"1053":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_ge_x"],"kind":"macro"},"2815":{"crate_id":17,"path":["object","read","macho","file","MachOFile"],"kind":"struct"},"3142":{"crate_id":2,"path":["core","core_arch","simd","u16x32"],"kind":"struct"},"499":{"crate_id":0,"path":["assertables","assert_set","assert_set_ne"],"kind":"module"},"1380":{"crate_id":2,"path":["core","iter","adapters","filter_map","next_chunk","Guard"],"kind":"struct"},"2261":{"crate_id":17,"path":["object","read","xcoff","symbol","XcoffSymbol"],"kind":"struct"},"2588":{"crate_id":2,"path":["core","fmt","rt","Argument"],"kind":"struct"},"826":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_is_match"],"kind":"module"},"1707":{"crate_id":17,"path":["object","read","read_cache","ReadCacheRange"],"kind":"struct"},"1153":{"crate_id":0,"path":["assertables","assert_program_args_impl_prep"],"kind":"macro"},"272":{"crate_id":0,"path":["assertables","assert_is_match","assert_not_match"],"kind":"module"},"2034":{"crate_id":2,"path":["core","asserting","TryCaptureWithDebug"],"kind":"struct"},"2915":{"crate_id":2,"path":["core","iter","adapters","map_windows","MapWindowsInner"],"kind":"struct"},"3242":{"crate_id":6,"path":["libc","unix","bsd","apple","ifa_msghdr"],"kind":"struct"},"599":{"crate_id":0,"path":["assertables","assert_fn_err_gt_x_as_result"],"kind":"macro"},"1480":{"crate_id":2,"path":["core","marker","Send"],"kind":"trait"},"2361":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdat"],"kind":"struct"},"1807":{"crate_id":1,"path":["std","collections","hash","map","IterMut"],"kind":"struct"},"45":{"crate_id":0,"path":["assertables","assert_f32","assert_f32_le"],"kind":"module"},"926":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_ge_x"],"kind":"macro"},"2688":{"crate_id":2,"path":["core","ops","bit","ShlAssign"],"kind":"trait"},"1253":{"crate_id":11,"path":["hashbrown","map","Values"],"kind":"struct"},"372":{"crate_id":0,"path":["assertables","debug_assert_ok_ne"],"kind":"macro"},"2134":{"crate_id":6,"path":["libc","unix","bsd","apple","pthread_mutex_t"],"kind":"struct"},"3015":{"crate_id":3,"path":["alloc","ffi","c_str","NulError"],"kind":"struct"},"2461":{"crate_id":3,"path":["alloc","collections","btree","map","ExtractIf"],"kind":"struct"},"699":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_gt_x"],"kind":"module"},"1580":{"crate_id":18,"path":["memchr","memmem","FindRevIter"],"kind":"struct"},"3342":{"crate_id":1,"path":["std","fs","OpenOptions"],"kind":"struct"},"1907":{"crate_id":6,"path":["libc","unix","sigval"],"kind":"struct"},"1026":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_eq"],"kind":"module"},"145":{"crate_id":0,"path":["assertables","assert_diff_lt_x_as_result"],"kind":"macro"},"2788":{"crate_id":2,"path":["core","slice","ascii","EscapeAscii"],"kind":"struct"},"1353":{"crate_id":17,"path":["object","read","coff","section","CoffSectionIterator"],"kind":"struct"},"472":{"crate_id":0,"path":["assertables","assert_iter_ge_as_result"],"kind":"macro"},"2234":{"crate_id":16,"path":["gimli","arch","PowerPc64"],"kind":"struct"},"3115":{"crate_id":2,"path":["core","slice","iter","GenericSplitN"],"kind":"struct"},"2561":{"crate_id":17,"path":["object","elf","GnuHashHeader"],"kind":"struct"},"799":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_lt"],"kind":"module"},"1680":{"crate_id":2,"path":["core","core_simd","swizzle","rotate_elements_right","Rotate"],"kind":"struct"},"3442":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"2007":{"crate_id":2,"path":["core","num","niche_types","NonZeroU128Inner"],"kind":"struct"},"245":{"crate_id":0,"path":["assertables","assert_email_address","assert_not_email_address"],"kind":"module"},"1126":{"crate_id":0,"path":["assertables","assert_poll_ready_eq"],"kind":"macro"},"2888":{"crate_id":2,"path":["core","fmt","num","LowerHex"],"kind":"struct"},"3215":{"crate_id":2,"path":["core","iter","adapters","cloned","Cloned"],"kind":"struct"},"572":{"crate_id":0,"path":["assertables","debug_assert_fn_err_ge"],"kind":"macro"},"1453":{"crate_id":2,"path":["core","core_simd","swizzle","resize","Resize"],"kind":"struct"},"2334":{"crate_id":2,"path":["core","array","iter","IntoIter"],"kind":"struct"},"2661":{"crate_id":1,"path":["std","error","Indented"],"kind":"struct"},"899":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_eq"],"kind":"module"},"18":{"crate_id":0,"path":["assertables","debug_assert_lt"],"kind":"macro"},"1780":{"crate_id":16,"path":["gimli","common","SectionId"],"kind":"enum"},"2107":{"crate_id":2,"path":["core","num","niche_types","NonZeroU64Inner"],"kind":"struct"},"345":{"crate_id":0,"path":["assertables","assert_err_eq"],"kind":"macro"},"1226":{"crate_id":1,"path":["std","panicking","begin_panic","Payload"],"kind":"struct"},"2988":{"crate_id":2,"path":["core","ffi","c_str","FromBytesWithNulError"],"kind":"enum"},"3315":{"crate_id":1,"path":["std","sync","mpsc","TryIter"],"kind":"struct"},"672":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_gt"],"kind":"macro"},"1553":{"crate_id":2,"path":["core","ops","arith","SubAssign"],"kind":"trait"},"2434":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","timeval32"],"kind":"struct"},"2761":{"crate_id":16,"path":["gimli","read","op","EvaluationResult"],"kind":"enum"},"118":{"crate_id":0,"path":["assertables","assert_approx_ne"],"kind":"macro"},"999":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_ne_x"],"kind":"macro"},"1880":{"crate_id":16,"path":["gimli","common","Register"],"kind":"struct"},"1326":{"crate_id":1,"path":["std","time","SystemTime"],"kind":"struct"},"445":{"crate_id":0,"path":["assertables","assert_ready_ne_x"],"kind":"macro"},"2207":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbol"],"kind":"struct"},"3088":{"crate_id":1,"path":["std","sync","mpmc","Iter"],"kind":"struct"},"3415":{"crate_id":16,"path":["gimli","constants","DwLns"],"kind":"struct"},"772":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_contains"],"kind":"macro"},"1653":{"crate_id":1,"path":["std","sync","barrier","BarrierWaitResult"],"kind":"struct"},"2534":{"crate_id":1,"path":["std","thread","spawn_unchecked_","MaybeDangling"],"kind":"struct"},"1980":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x8x2_t"],"kind":"struct"},"218":{"crate_id":0,"path":["assertables","assert_count_ge_x_as_result"],"kind":"macro"},"1099":{"crate_id":0,"path":["assertables","assert_result_ok"],"kind":"macro"},"2861":{"crate_id":18,"path":["memchr","arch","all","twoway","Shift"],"kind":"enum"},"1426":{"crate_id":16,"path":["gimli","read","cfi","CfaRule"],"kind":"enum"},"545":{"crate_id":0,"path":["assertables","assert_fn_ge_x"],"kind":"macro"},"2307":{"crate_id":2,"path":["core","core_arch","simd","u32x4"],"kind":"struct"},"3188":{"crate_id":1,"path":["std","process","ExitCode"],"kind":"struct"},"872":{"crate_id":0,"path":["assertables","assert_command_stderr_le_x_as_result"],"kind":"macro"},"1753":{"crate_id":3,"path":["alloc","collections","btree","navigate","LazyLeafRange"],"kind":"struct"},"2634":{"crate_id":17,"path":["object","pe","ImageRomOptionalHeader"],"kind":"struct"},"2080":{"crate_id":17,"path":["object","pe","ImageBaseRelocation"],"kind":"struct"},"318":{"crate_id":0,"path":["assertables","assert_len_ne_x"],"kind":"macro"},"1199":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2961":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","if_data"],"kind":"struct"},"1526":{"crate_id":3,"path":["alloc","collections","btree","set","BTreeSet"],"kind":"struct"},"645":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_ge_x"],"kind":"macro"},"2407":{"crate_id":3,"path":["alloc","collections","btree","map","CursorMut"],"kind":"struct"},"3288":{"crate_id":6,"path":["libc","unix","bsd","apple","rusage_info_v2"],"kind":"struct"},"2734":{"crate_id":16,"path":["gimli","constants","DwSect"],"kind":"struct"},"91":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_gt_x"],"kind":"module"},"972":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_lt"],"kind":"macro"},"1853":{"crate_id":2,"path":["core","char","convert","CharTryFromError"],"kind":"struct"},"2180":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"418":{"crate_id":0,"path":["assertables","assert_some"],"kind":"module"},"1299":{"crate_id":2,"path":["core","iter","traits","marker","FusedIterator"],"kind":"trait"},"3061":{"crate_id":17,"path":["object","read","elf","version","VerdefIterator"],"kind":"struct"},"3388":{"crate_id":6,"path":["libc","unix","bsd","apple","log2phys"],"kind":"struct"},"1626":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x4x4_t"],"kind":"struct"},"745":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_ne"],"kind":"module"},"2507":{"crate_id":1,"path":["std","backtrace","RawFrame"],"kind":"enum"},"2834":{"crate_id":1,"path":["std","sys","stdio","unix","Stderr"],"kind":"struct"},"191":{"crate_id":0,"path":["assertables","debug_assert_count_eq"],"kind":"macro"},"1072":{"crate_id":0,"path":["assertables","assert_success_as_result"],"kind":"macro"},"1953":{"crate_id":2,"path":["core","ffi","c_str","FromBytesUntilNulError"],"kind":"struct"},"2280":{"crate_id":2,"path":["core","core_simd","vector","sealed","Sealed"],"kind":"trait"},"518":{"crate_id":0,"path":["assertables","assert_fn_eq_as_result"],"kind":"macro"},"1399":{"crate_id":3,"path":["alloc","boxed","thin","ThinBox"],"kind":"struct"},"3161":{"crate_id":3,"path":["alloc","collections","vec_deque","iter_mut","IterMut"],"kind":"struct"},"845":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_gt"],"kind":"macro"},"1726":{"crate_id":3,"path":["alloc","collections","btree","navigate","LeafRange"],"kind":"struct"},"2607":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x1x4_t"],"kind":"struct"},"2934":{"crate_id":1,"path":["std","collections","hash","set","OccupiedEntry"],"kind":"struct"},"291":{"crate_id":0,"path":["assertables","assert_len_lt_as_result"],"kind":"macro"},"1172":{"crate_id":1,"path":["std","u16"],"kind":"primitive"},"2053":{"crate_id":2,"path":["core","core_arch","simd","f32x8"],"kind":"struct"},"1499":{"crate_id":2,"path":["core","future","ResumeTy"],"kind":"struct"},"618":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_eq"],"kind":"module"},"2380":{"crate_id":6,"path":["libc","unix","bsd","apple","malloc_statistics_t"],"kind":"struct"},"3261":{"crate_id":6,"path":["libc","unix","bsd","apple","dqblk"],"kind":"struct"},"945":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_is_match"],"kind":"module"},"64":{"crate_id":0,"path":["assertables","assert_f64_gt_as_result"],"kind":"macro"},"1826":{"crate_id":2,"path":["core","cmp","PartialEq"],"kind":"trait"},"2707":{"crate_id":18,"path":["memchr","vector","aarch64neon","NeonMoveMask"],"kind":"struct"},"3034":{"crate_id":3,"path":["alloc","collections","btree","map","BTreeMap"],"kind":"struct"},"391":{"crate_id":0,"path":["assertables","assert_none","assert_none"],"kind":"module"},"1272":{"crate_id":16,"path":["gimli","read","aranges","ArangeEntryIter"],"kind":"struct"},"2153":{"crate_id":2,"path":["core","ops","bit","Shr"],"kind":"trait"},"1599":{"crate_id":1,"path":["std","io","util","Sink"],"kind":"struct"},"718":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_is_match"],"kind":"macro"},"2480":{"crate_id":2,"path":["core","fmt","Alignment"],"kind":"enum"},"3361":{"crate_id":1,"path":["std","ascii","AsciiExt"],"kind":"trait"},"1045":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_ne"],"kind":"macro"},"164":{"crate_id":0,"path":["assertables","assert_in_range_as_result"],"kind":"macro"},"1926":{"crate_id":6,"path":["libc","unix","bsd","apple","rt_msghdr2"],"kind":"struct"},"2807":{"crate_id":17,"path":["object","macho","PrebindCksumCommand"],"kind":"struct"},"2253":{"crate_id":2,"path":["core","slice","iter","ArrayChunks"],"kind":"struct"},"491":{"crate_id":0,"path":["assertables","assert_iter"],"kind":"module"},"1372":{"crate_id":1,"path":["std","os","unix","net","stream","UnixStream"],"kind":"struct"},"3134":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x16x2_t"],"kind":"struct"},"1699":{"crate_id":2,"path":["core","ops","bit","BitXor"],"kind":"trait"},"818":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_le_x"],"kind":"macro"},"2580":{"crate_id":1,"path":["std","sync","barrier","Barrier"],"kind":"struct"},"2907":{"crate_id":17,"path":["object","read","SectionIndex"],"kind":"struct"},"264":{"crate_id":0,"path":["assertables","assert_is_empty"],"kind":"module"},"1145":{"crate_id":0,"path":["assertables","assert_command_stdout_is_match"],"kind":"macro"},"2026":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x1x2_t"],"kind":"struct"},"2353":{"crate_id":1,"path":["std","i32"],"kind":"primitive"},"591":{"crate_id":0,"path":["assertables","assert_fn_err_eq_x_as_result"],"kind":"macro"},"1472":{"crate_id":11,"path":["hashbrown","table","AbsentEntry"],"kind":"struct"},"3234":{"crate_id":3,"path":["alloc","sync","Arc"],"kind":"struct"},"1799":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"37":{"crate_id":0,"path":["assertables","assert_f32","assert_f32_ge"],"kind":"module"},"918":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_ne"],"kind":"macro"},"2680":{"crate_id":17,"path":["object","macho","ThreadCommand"],"kind":"struct"},"3007":{"crate_id":4,"path":["compiler_builtins","math","libm","support","big","i256"],"kind":"struct"},"364":{"crate_id":0,"path":["assertables","debug_assert_ok"],"kind":"macro"},"1245":{"crate_id":11,"path":["hashbrown","table","IterHash"],"kind":"struct"},"2126":{"crate_id":16,"path":["gimli","read","rnglists","Range"],"kind":"struct"},"2453":{"crate_id":17,"path":["object","read","pe","resource","ResourceName"],"kind":"struct"},"691":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_eq_x"],"kind":"module"},"1572":{"crate_id":16,"path":["gimli","read","aranges","DebugAranges"],"kind":"struct"},"3334":{"crate_id":2,"path":["core","ptr"],"kind":"module"},"1018":{"crate_id":0,"path":["assertables","assert_status","assert_status_success_false"],"kind":"module"},"137":{"crate_id":0,"path":["assertables","assert_diff_gt_x_as_result"],"kind":"macro"},"1899":{"crate_id":16,"path":["gimli","constants","DwDs"],"kind":"struct"},"2780":{"crate_id":4,"path":["compiler_builtins","int","big","i256"],"kind":"struct"},"3107":{"crate_id":2,"path":["core","time","TryFromFloatSecsError"],"kind":"struct"},"464":{"crate_id":0,"path":["assertables","debug_assert_bag_superbag"],"kind":"macro"},"1345":{"crate_id":17,"path":["object","read","macho","file","MachOComdat"],"kind":"struct"},"2226":{"crate_id":16,"path":["gimli","read","pubnames","PubNamesEntryIter"],"kind":"struct"},"1672":{"crate_id":18,"path":["memchr","arch","all","memchr","Three"],"kind":"struct"},"791":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_gt"],"kind":"module"},"2553":{"crate_id":2,"path":["core","num","error","TryFromIntError"],"kind":"struct"},"3434":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","bpf_hdr"],"kind":"struct"},"1118":{"crate_id":0,"path":["assertables","debug_assert_option_some_ne"],"kind":"macro"},"237":{"crate_id":0,"path":["assertables","assert_count"],"kind":"module"},"1999":{"crate_id":2,"path":["core","ffi","c_void"],"kind":"enum"},"2880":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3207":{"crate_id":2,"path":["core","clone","UseCloned"],"kind":"trait"},"564":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_ne_x"],"kind":"module"},"1445":{"crate_id":2,"path":["core","ops","drop","Drop"],"kind":"trait"},"2326":{"crate_id":2,"path":["core","mem","manually_drop","ManuallyDrop"],"kind":"struct"},"1772":{"crate_id":17,"path":["object","macho","BuildVersionCommand"],"kind":"struct"},"10":{"crate_id":0,"path":["assertables","debug_assert_gt"],"kind":"macro"},"891":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_string_is_match"],"kind":"macro"},"2653":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"1218":{"crate_id":6,"path":["libc","unix","bsd","apple","in6_ifreq"],"kind":"struct"},"337":{"crate_id":0,"path":["assertables","assert_starts_with_as_result"],"kind":"macro"},"2099":{"crate_id":11,"path":["hashbrown","table","ExtractIf"],"kind":"struct"},"2980":{"crate_id":17,"path":["object","read","xcoff","symbol","SymbolIterator"],"kind":"struct"},"2426":{"crate_id":1,"path":["std","os","fd","raw","IntoRawFd"],"kind":"trait"},"664":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_eq"],"kind":"macro"},"1545":{"crate_id":2,"path":["core","ops","unsize","CoerceUnsized"],"kind":"trait"},"3307":{"crate_id":3,"path":["alloc","vec","set_len_on_drop","SetLenOnDrop"],"kind":"struct"},"1872":{"crate_id":17,"path":["object","read","traits","NoDynamicRelocationIterator"],"kind":"struct"},"110":{"crate_id":0,"path":["assertables","assert_abs_diff_eq"],"kind":"macro"},"991":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_le_x"],"kind":"macro"},"2753":{"crate_id":2,"path":["core","num","saturating","Saturating"],"kind":"struct"},"3080":{"crate_id":16,"path":["gimli","read","reader","ReaderOffsetId"],"kind":"struct"},"1318":{"crate_id":3,"path":["alloc","collections","btree","map","entry","OccupiedError"],"kind":"struct"},"437":{"crate_id":0,"path":["assertables","assert_ready_ne"],"kind":"macro"},"2199":{"crate_id":3,"path":["alloc","collections","btree","merge_iter","Peeked"],"kind":"enum"},"2526":{"crate_id":2,"path":["core","core_simd","masks","Mask"],"kind":"struct"},"764":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_lt_x"],"kind":"macro"},"1645":{"crate_id":17,"path":["object","macho","Relocation"],"kind":"struct"},"3407":{"crate_id":1,"path":["std","sys","stdio","unix","Stdout"],"kind":"struct"},"1972":{"crate_id":2,"path":["core","mem","maybe_uninit","MaybeUninit"],"kind":"union"},"1091":{"crate_id":0,"path":["assertables","assert_abs_diff_lt_as_result"],"kind":"macro"},"210":{"crate_id":0,"path":["assertables","assert_count_ne_as_result"],"kind":"macro"},"2853":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x8_t"],"kind":"struct"},"3180":{"crate_id":1,"path":["std","io","stdio","IsTerminal"],"kind":"trait"},"537":{"crate_id":0,"path":["assertables","assert_fn_ne"],"kind":"macro"},"1418":{"crate_id":16,"path":["gimli","common","DebugStrOffsetsBase"],"kind":"struct"},"2299":{"crate_id":6,"path":["libc","unix","bsd","apple","in6_addrlifetime"],"kind":"struct"},"2626":{"crate_id":2,"path":["core","str","pattern","CharArrayRefSearcher"],"kind":"struct"},"864":{"crate_id":0,"path":["assertables","assert_command_stderr_ge_x_as_result"],"kind":"macro"},"1745":{"crate_id":17,"path":["object","pe","ImageSymbolBytes"],"kind":"struct"},"1191":{"crate_id":2,"path":["core","marker","variance","PhantomContravariant"],"kind":"struct"},"310":{"crate_id":0,"path":["assertables","assert_len_le_x"],"kind":"macro"},"2072":{"crate_id":16,"path":["gimli","common","DebugArangesOffset"],"kind":"struct"},"2953":{"crate_id":17,"path":["object","elf","Sym64"],"kind":"struct"},"3280":{"crate_id":2,"path":["core","cell","UnsafeCell"],"kind":"struct"},"637":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_ne"],"kind":"macro"},"1518":{"crate_id":3,"path":["alloc","collections","vec_deque","drop","Dropper"],"kind":"struct"},"2399":{"crate_id":2,"path":["core","option","Item"],"kind":"struct"},"2726":{"crate_id":16,"path":["gimli","read","line","LineSequence"],"kind":"struct"},"83":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_eq_x"],"kind":"module"},"964":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_gt"],"kind":"macro"},"1845":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x8x4_t"],"kind":"struct"},"1291":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x4_t"],"kind":"struct"},"410":{"crate_id":0,"path":["assertables","assert_some_eq_x"],"kind":"macro"},"2172":{"crate_id":17,"path":["object","xcoff","ExpAux"],"kind":"struct"},"3053":{"crate_id":17,"path":["object","read","elf","relocation","ElfSectionRelocationIterator"],"kind":"struct"},"3380":{"crate_id":2,"path":["core","core_simd","lane_count","sealed","Sealed"],"kind":"trait"},"737":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_le"],"kind":"module"},"1618":{"crate_id":2,"path":["core","num","diy_float","Fp"],"kind":"struct"},"2499":{"crate_id":17,"path":["object","read","elf","hash","GnuHashTable"],"kind":"struct"},"1945":{"crate_id":2,"path":["core","fmt","num","UpperHex"],"kind":"struct"},"183":{"crate_id":0,"path":["assertables","assert_contains","assert_contains"],"kind":"module"},"1064":{"crate_id":0,"path":["assertables","assert_status_code_value_lt_x_as_result"],"kind":"macro"},"2826":{"crate_id":2,"path":["core","char","EscapeDebugInner"],"kind":"enum"},"1391":{"crate_id":1,"path":["std","sys","pal","unix","sync","mutex","AttrGuard"],"kind":"struct"},"510":{"crate_id":0,"path":["assertables","debug_assert_set_subset"],"kind":"macro"},"2272":{"crate_id":2,"path":["core","result","IterMut"],"kind":"struct"},"3153":{"crate_id":17,"path":["object","read","any","SectionRelocationIteratorInternal"],"kind":"enum"},"2599":{"crate_id":16,"path":["gimli","read","endian_slice","DebugBytes"],"kind":"struct"},"837":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_eq"],"kind":"macro"},"1718":{"crate_id":3,"path":["alloc","collections","btree","set","entry","OccupiedEntry"],"kind":"struct"},"2045":{"crate_id":2,"path":["core","core_simd","simd","num","float","SimdFloat"],"kind":"trait"},"283":{"crate_id":0,"path":["assertables","assert_len_gt_as_result"],"kind":"macro"},"1164":{"crate_id":0,"path":["assertables","assert_program_args_stderr_is_match_as_result"],"kind":"macro"},"2926":{"crate_id":11,"path":["hashbrown","map","VacantEntryRef"],"kind":"struct"},"3253":{"crate_id":3,"path":["alloc","collections","linked_list","IntoIter"],"kind":"struct"},"1491":{"crate_id":17,"path":["object","elf","Rela32"],"kind":"struct"},"610":{"crate_id":0,"path":["assertables","assert_fn_err_ne_x"],"kind":"macro"},"2372":{"crate_id":16,"path":["gimli","read","unit","AttributeValue"],"kind":"enum"},"2699":{"crate_id":16,"path":["gimli","constants","DwIdx"],"kind":"struct"},"56":{"crate_id":0,"path":["assertables","assert_f64_eq_as_result"],"kind":"macro"},"937":{"crate_id":0,"path":["assertables","assert_program_args_stdout_lt_x_as_result"],"kind":"macro"},"1818":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_precedence_policy"],"kind":"struct"},"2145":{"crate_id":17,"path":["object","read","xcoff","segment","XcoffSegmentIterator"],"kind":"struct"},"383":{"crate_id":0,"path":["assertables","assert_result","assert_result_err"],"kind":"module"},"1264":{"crate_id":2,"path":["core","fmt","builders","PadAdapterState"],"kind":"struct"},"3026":{"crate_id":2,"path":["core","ops","range","RangeInclusive"],"kind":"struct"},"3353":{"crate_id":6,"path":["libc","unix","bsd","apple","vnode_info_path"],"kind":"struct"},"710":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_ne_x"],"kind":"macro"},"1591":{"crate_id":17,"path":["object","macho","NoteCommand"],"kind":"struct"},"2472":{"crate_id":17,"path":["object","read","pe","import","ImportDescriptorIterator"],"kind":"struct"},"2799":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"156":{"crate_id":0,"path":["assertables","assert_in","assert_in"],"kind":"module"},"1037":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_le"],"kind":"macro"},"1918":{"crate_id":1,"path":["std","sync","mpmc","waker","SyncWaker"],"kind":"struct"},"1364":{"crate_id":17,"path":["object","macho","VersionMinCommand"],"kind":"struct"},"483":{"crate_id":0,"path":["assertables","assert_iter_lt"],"kind":"macro"},"2245":{"crate_id":6,"path":["libc","unix","bsd","apple","siginfo_t"],"kind":"struct"},"3126":{"crate_id":11,"path":["hashbrown","control","tag","Tag"],"kind":"struct"},"3453":{"crate_id":2,"path":["core","core_arch","simd","i64x1"],"kind":"struct"},"810":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_ge_x"],"kind":"macro"},"1691":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2572":{"crate_id":1,"path":["std","sys","process","unix","common","Command"],"kind":"struct"},"2899":{"crate_id":3,"path":["alloc","collections","btree","map","UnorderedKeyError"],"kind":"struct"},"256":{"crate_id":0,"path":["assertables","assert_is_empty"],"kind":"macro"},"1137":{"crate_id":0,"path":["assertables","assert_io_read_to_string_matches"],"kind":"macro"},"2018":{"crate_id":2,"path":["core","core_simd","masks","mask_impl","Mask"],"kind":"struct"},"1464":{"crate_id":2,"path":["core","marker","Copy"],"kind":"trait"},"583":{"crate_id":0,"path":["assertables","assert_fn_err_lt_as_result"],"kind":"macro"},"2345":{"crate_id":2,"path":["core","hash","sip","Sip13Rounds"],"kind":"struct"},"3226":{"crate_id":1,"path":["std","sync","mpsc","IntoIter"],"kind":"struct"},"910":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_le"],"kind":"macro"},"29":{"crate_id":0,"path":["assertables","assert_eq_f64"],"kind":"module"},"1791":{"crate_id":3,"path":["alloc","string","IntoChars"],"kind":"struct"},"2672":{"crate_id":2,"path":["core","str","pattern","DoubleEndedSearcher"],"kind":"trait"},"2118":{"crate_id":17,"path":["object","archive","AixHeader"],"kind":"struct"},"356":{"crate_id":0,"path":["assertables","assert_err","assert_err_eq_x"],"kind":"module"},"1237":{"crate_id":16,"path":["gimli","read","index","UnitIndex"],"kind":"struct"},"2999":{"crate_id":17,"path":["object","read","elf","attributes","AttributesSubsection"],"kind":"struct"},"1564":{"crate_id":11,"path":["hashbrown","set","VacantEntry"],"kind":"struct"},"683":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_lt"],"kind":"module"},"2445":{"crate_id":2,"path":["core","ptr","non_null","NonNull"],"kind":"struct"},"3326":{"crate_id":2,"path":["core","marker","variance","PhantomCovariant"],"kind":"struct"},"2772":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x4x4_t"],"kind":"struct"},"1010":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_string_is_match"],"kind":"module"},"129":{"crate_id":0,"path":["assertables","assert_diff_eq_x_as_result"],"kind":"macro"},"1891":{"crate_id":17,"path":["object","macho","MachHeader32"],"kind":"struct"},"2218":{"crate_id":2,"path":["core","iter","adapters","intersperse","Intersperse"],"kind":"struct"},"456":{"crate_id":0,"path":["assertables","debug_assert_bag_ne"],"kind":"macro"},"1337":{"crate_id":2,"path":["core","num","flt2dec","decoder","FullDecoded"],"kind":"enum"},"3099":{"crate_id":17,"path":["object","common","RelocationKind"],"kind":"enum"},"1664":{"crate_id":1,"path":["std","io","stdio","StdoutLock"],"kind":"struct"},"783":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_eq"],"kind":"module"},"2545":{"crate_id":17,"path":["object","read","elf","attributes","AttributeIndexIterator"],"kind":"struct"},"3426":{"crate_id":17,"path":["object","read","elf","relocation","ElfRelaIterator"],"kind":"enum"},"2872":{"crate_id":1,"path":["std","u64"],"kind":"primitive"},"229":{"crate_id":0,"path":["assertables","assert_count_lt_x"],"kind":"macro"},"1110":{"crate_id":0,"path":["assertables","assert_option_some_as_result"],"kind":"macro"},"1991":{"crate_id":1,"path":["std","path","fmt","DebugHelper"],"kind":"struct"},"2318":{"crate_id":3,"path":["alloc","collections","btree","map","Iter"],"kind":"struct"},"556":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_le_x"],"kind":"module"},"1437":{"crate_id":16,"path":["gimli","read","abbrev","Abbreviation"],"kind":"struct"},"3199":{"crate_id":16,"path":["gimli","read","loclists","LocationListEntry"],"kind":"struct"},"883":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_contains"],"kind":"module"},"2":{"crate_id":0,"path":["assertables","assert_eq_as_result"],"kind":"macro"},"1764":{"crate_id":17,"path":["object","macho","FvmlibCommand"],"kind":"struct"},"2645":{"crate_id":1,"path":["std","io","buffered","bufreader","BufReader"],"kind":"struct"},"2972":{"crate_id":1,"path":["std","sys","process","unix","common","Stdio"],"kind":"enum"},"329":{"crate_id":0,"path":["assertables","debug_assert_not_matches"],"kind":"macro"},"1210":{"crate_id":2,"path":["core","fmt","LowerHex"],"kind":"trait"},"2091":{"crate_id":2,"path":["core","iter","adapters","GenericShunt"],"kind":"struct"},"2418":{"crate_id":6,"path":["libc","unix","bsd","apple","ifkpi"],"kind":"struct"},"656":{"crate_id":0,"path":["assertables","assert_fn_ok_lt_x_as_result"],"kind":"macro"},"1537":{"crate_id":16,"path":["gimli","read","unit","EntriesCursor"],"kind":"struct"},"3299":{"crate_id":2,"path":["core","core_simd","swizzle","deinterleave","Even"],"kind":"struct"},"983":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_ge_x"],"kind":"macro"},"102":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_ne_x"],"kind":"macro"},"1864":{"crate_id":17,"path":["object","read","archive","ArchiveKind"],"kind":"enum"},"2745":{"crate_id":1,"path":["std","io","Read"],"kind":"trait"},"3072":{"crate_id":2,"path":["core","option","IterMut"],"kind":"struct"},"429":{"crate_id":0,"path":["assertables","assert_ready"],"kind":"macro"},"1310":{"crate_id":2,"path":["core","ops","range","RangeFull"],"kind":"struct"},"2191":{"crate_id":3,"path":["alloc","collections","btree","map","Values"],"kind":"struct"},"1637":{"crate_id":11,"path":["hashbrown","raw","RawTable"],"kind":"struct"},"756":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_gt_x"],"kind":"macro"},"2518":{"crate_id":2,"path":["core","core_arch","simd","u64x1"],"kind":"struct"},"3399":{"crate_id":17,"path":["object","read","any","SymbolIterator"],"kind":"struct"},"1083":{"crate_id":0,"path":["assertables","assert_abs_diff_eq_as_result"],"kind":"macro"},"202":{"crate_id":0,"path":["assertables","assert_count_le_as_result"],"kind":"macro"},"1964":{"crate_id":2,"path":["core","slice","raw","from_raw_parts"],"kind":"function"},"2845":{"crate_id":1,"path":["std","io","default_write_fmt","Adapter"],"kind":"struct"},"2291":{"crate_id":2,"path":["core","iter","adapters","intersperse","IntersperseWith"],"kind":"struct"},"529":{"crate_id":0,"path":["assertables","assert_fn_le"],"kind":"macro"},"1410":{"crate_id":16,"path":["gimli","read","op","Location"],"kind":"enum"},"3172":{"crate_id":2,"path":["core","sync","atomic","AtomicI128"],"kind":"struct"},"1737":{"crate_id":14,"path":["rustc_demangle","TryDemangleError"],"kind":"struct"},"856":{"crate_id":0,"path":["assertables","assert_command_stderr_ne_as_result"],"kind":"macro"},"2618":{"crate_id":17,"path":["object","read","macho","file","MachOComdatIterator"],"kind":"struct"},"2945":{"crate_id":2,"path":["core","convert","AsMut"],"kind":"trait"},"1183":{"crate_id":16,"path":["gimli","read","dwarf","UnitRef"],"kind":"struct"},"302":{"crate_id":0,"path":["assertables","assert_len_ge_x"],"kind":"macro"},"2064":{"crate_id":17,"path":["object","macho","DylibReference"],"kind":"struct"},"2391":{"crate_id":6,"path":["libc","unix","bsd","apple","vm_statistics64"],"kind":"struct"},"629":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_le"],"kind":"macro"},"1510":{"crate_id":11,"path":["hashbrown","rustc_entry","RustcVacantEntry"],"kind":"struct"},"3272":{"crate_id":16,"path":["gimli","read","dwarf","RangeIterInner"],"kind":"enum"},"1837":{"crate_id":2,"path":["core","error","private","Internal"],"kind":"struct"},"75":{"crate_id":0,"path":["assertables","assert_f64_ne"],"kind":"macro"},"956":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_eq"],"kind":"macro"},"2718":{"crate_id":6,"path":["libc","unix","bsd","apple","ifma_msghdr2"],"kind":"struct"},"3045":{"crate_id":3,"path":["alloc","string","ToString"],"kind":"trait"},"402":{"crate_id":0,"path":["assertables","assert_some_eq"],"kind":"macro"},"1283":{"crate_id":1,"path":["std","thread","Thread"],"kind":"struct"},"2164":{"crate_id":2,"path":["core","str","iter","EscapeUnicode"],"kind":"struct"},"2491":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"729":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_ge"],"kind":"module"},"1610":{"crate_id":16,"path":["gimli","read","unit","EntriesTree"],"kind":"struct"},"3372":{"crate_id":1,"path":["std","fs","read_link"],"kind":"function"},"1056":{"crate_id":0,"path":["assertables","assert_status_code_value_gt_x_as_result"],"kind":"macro"},"175":{"crate_id":0,"path":["assertables","assert_any"],"kind":"module"},"1937":{"crate_id":16,"path":["gimli","read","dwarf","RangeIter"],"kind":"struct"},"2818":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3145":{"crate_id":16,"path":["gimli","read","index","UnitIndexSection"],"kind":"struct"},"502":{"crate_id":0,"path":["assertables","debug_assert_set_disjoint"],"kind":"macro"},"1383":{"crate_id":15,"path":["addr2line","unit","SupUnits"],"kind":"struct"},"2264":{"crate_id":1,"path":["std","isize"],"kind":"primitive"},"2591":{"crate_id":3,"path":["alloc","collections","btree","map","CursorMutKey"],"kind":"struct"},"829":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_string_contains"],"kind":"macro"},"1710":{"crate_id":17,"path":["object","pe","ImageLoadConfigDirectory32"],"kind":"struct"},"1156":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_contains"],"kind":"macro"},"275":{"crate_id":0,"path":["assertables","assert_len_eq_as_result"],"kind":"macro"},"2037":{"crate_id":17,"path":["object","pe","ImageResourceDirectoryEntry"],"kind":"struct"},"2918":{"crate_id":1,"path":["std","sync","mpmc","IntoIter"],"kind":"struct"},"3245":{"crate_id":17,"path":["object","read","ObjectMap"],"kind":"struct"},"602":{"crate_id":0,"path":["assertables","assert_fn_err_le_x"],"kind":"macro"},"1483":{"crate_id":2,"path":["core","char","EscapeDebug"],"kind":"struct"},"2364":{"crate_id":2,"path":["core","num","niche_types","NonZeroU8Inner"],"kind":"struct"},"1810":{"crate_id":1,"path":["std","sync","mpmc","counter","Sender"],"kind":"struct"},"48":{"crate_id":0,"path":["assertables","debug_assert_f32_lt"],"kind":"macro"},"929":{"crate_id":0,"path":["assertables","assert_program_args_stdout_gt_x_as_result"],"kind":"macro"},"2691":{"crate_id":17,"path":["object","read","pe","rich","RichHeaderEntry"],"kind":"struct"},"1256":{"crate_id":18,"path":["memchr","memmem","searcher","Pre"],"kind":"struct"},"375":{"crate_id":0,"path":["assertables","assert_ok_eq_x_as_result"],"kind":"macro"},"2137":{"crate_id":17,"path":["object","read","elf","file","ElfFile"],"kind":"struct"},"3018":{"crate_id":17,"path":["object","read","any","DynamicRelocationIterator"],"kind":"struct"},"2464":{"crate_id":16,"path":["gimli","read","cfi","RegisterRuleMap"],"kind":"struct"},"702":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_le_x"],"kind":"macro"},"1583":{"crate_id":1,"path":["std","sync","mpsc","SyncSender"],"kind":"struct"},"3345":{"crate_id":1,"path":["std","sync","mpsc","TrySendError"],"kind":"enum"},"1910":{"crate_id":2,"path":["core","range","RangeFrom"],"kind":"struct"},"148":{"crate_id":0,"path":["assertables","assert_diff_ne_x"],"kind":"macro"},"1029":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_ge"],"kind":"macro"},"2791":{"crate_id":2,"path":["core","slice","iter","ChunkBy"],"kind":"struct"},"1356":{"crate_id":6,"path":["libc","unix","bsd","apple","ifconf"],"kind":"struct"},"475":{"crate_id":0,"path":["assertables","assert_iter_gt"],"kind":"macro"},"2237":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3118":{"crate_id":1,"path":["std","sync","poison","TryLockError"],"kind":"enum"},"2564":{"crate_id":1,"path":["std","thread","Packet"],"kind":"struct"},"802":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_ne"],"kind":"macro"},"1683":{"crate_id":11,"path":["hashbrown","table","OccupiedEntry"],"kind":"struct"},"3445":{"crate_id":2,"path":["core","iter","adapters","skip","Skip"],"kind":"struct"},"2010":{"crate_id":17,"path":["object","read","CompressionFormat"],"kind":"enum"},"248":{"crate_id":0,"path":["assertables","assert_ends_with_as_result"],"kind":"macro"},"1129":{"crate_id":0,"path":["assertables","assert_poll_ready_ne"],"kind":"macro"},"2891":{"crate_id":17,"path":["object","read","any","SectionIterator"],"kind":"struct"},"3218":{"crate_id":6,"path":["libc","unix","bsd","apple","ctl_info"],"kind":"struct"},"575":{"crate_id":0,"path":["assertables","assert_fn_err_gt_as_result"],"kind":"macro"},"1456":{"crate_id":1,"path":["std","sync","mpmc","select","Operation"],"kind":"struct"},"2337":{"crate_id":3,"path":["alloc","collections","btree","set_val","SetValZST"],"kind":"struct"},"2664":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x16x2_t"],"kind":"struct"},"21":{"crate_id":0,"path":["assertables","assert_ne"],"kind":"module"},"902":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_ge"],"kind":"macro"},"1783":{"crate_id":17,"path":["object","read","coff","section","CoffSegment"],"kind":"struct"},"2110":{"crate_id":2,"path":["core","panic","unwind_safe","RefUnwindSafe"],"kind":"trait"},"348":{"crate_id":0,"path":["assertables","assert_err","assert_err_eq"],"kind":"module"},"1229":{"crate_id":2,"path":["core","str","iter","MatchIndicesInternal"],"kind":"struct"},"2991":{"crate_id":2,"path":["core","str","lossy","Utf8Chunk"],"kind":"struct"},"3318":{"crate_id":1,"path":["std","env","Args"],"kind":"struct"},"675":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_gt"],"kind":"module"},"1556":{"crate_id":2,"path":["core","ops","control_flow","ControlFlow"],"kind":"enum"},"2437":{"crate_id":16,"path":["gimli","read","loclists","LocListIter"],"kind":"struct"},"2764":{"crate_id":16,"path":["gimli","common","LocationListsOffset"],"kind":"struct"},"1002":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stderr_is_match"],"kind":"module"},"121":{"crate_id":0,"path":["assertables","assert_approx_eq_as_result"],"kind":"macro"},"1883":{"crate_id":2,"path":["core","net","socket_addr","SocketAddr"],"kind":"enum"},"1329":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x8_t"],"kind":"struct"},"448":{"crate_id":0,"path":["assertables","assert_ready","assert_ready_ne_x"],"kind":"module"},"2210":{"crate_id":2,"path":["core","core_arch","simd","m32x8"],"kind":"struct"},"3091":{"crate_id":3,"path":["alloc","collections","linked_list","CursorMut"],"kind":"struct"},"3418":{"crate_id":2,"path":["core","core_arch","simd","u16x2"],"kind":"struct"},"775":{"crate_id":0,"path":["assertables","assert_io_read_to_string_is_match_as_result"],"kind":"macro"},"1656":{"crate_id":16,"path":["gimli","arch","X86_64"],"kind":"struct"},"2537":{"crate_id":17,"path":["object","read","SymbolSection"],"kind":"enum"},"1983":{"crate_id":3,"path":["alloc","collections","vec_deque","write_iter_wrapping","Guard"],"kind":"struct"},"221":{"crate_id":0,"path":["assertables","assert_count_gt_x"],"kind":"macro"},"1102":{"crate_id":0,"path":["assertables","assert_result_ok_eq"],"kind":"macro"},"2864":{"crate_id":17,"path":["object","elf","SectionHeader32"],"kind":"struct"},"1429":{"crate_id":17,"path":["object","macho","RoutinesCommand32"],"kind":"struct"},"548":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_ge_x"],"kind":"module"},"2310":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float32x2x3_t"],"kind":"struct"},"3191":{"crate_id":17,"path":["object","read","any","SegmentIteratorInternal"],"kind":"enum"},"2637":{"crate_id":2,"path":["core","core_simd","swizzle","interleave","Lo"],"kind":"struct"},"875":{"crate_id":0,"path":["assertables","assert_command_stderr_lt_x"],"kind":"macro"},"1756":{"crate_id":16,"path":["gimli","read","loclists","DebugLocLists"],"kind":"struct"},"2083":{"crate_id":1,"path":["std","collections","hash","map","HashMap"],"kind":"struct"},"321":{"crate_id":0,"path":["assertables","assert_len","assert_len_ne_x"],"kind":"module"},"1202":{"crate_id":11,"path":["hashbrown","raw","RawIterHash"],"kind":"struct"},"2964":{"crate_id":6,"path":["libc","unix","ipv6_mreq"],"kind":"struct"},"1529":{"crate_id":1,"path":["std","i16"],"kind":"primitive"},"648":{"crate_id":0,"path":["assertables","assert_fn_ok_gt_x_as_result"],"kind":"macro"},"2410":{"crate_id":3,"path":["alloc","collections","btree","map","IntoValues"],"kind":"struct"},"3291":{"crate_id":18,"path":["memchr","arch","all","rabinkarp","Hash"],"kind":"struct"},"2737":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x8x3_t"],"kind":"struct"},"94":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_le_x"],"kind":"macro"},"975":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ne_as_result"],"kind":"macro"},"1856":{"crate_id":1,"path":["std","ffi","os_str","OsString"],"kind":"struct"},"2183":{"crate_id":17,"path":["object","elf","Ident"],"kind":"struct"},"421":{"crate_id":0,"path":["assertables","debug_assert_pending"],"kind":"macro"},"1302":{"crate_id":2,"path":["core","ops","async_function","AsyncFnOnce"],"kind":"trait"},"3064":{"crate_id":1,"path":["std","os","fd","owned","OwnedFd"],"kind":"struct"},"3391":{"crate_id":1,"path":["std","process","CommandArgs"],"kind":"struct"},"748":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_eq_x"],"kind":"macro"},"1629":{"crate_id":2,"path":["core","sync","atomic","AtomicI32"],"kind":"struct"},"2510":{"crate_id":16,"path":["gimli","read","unit","EntriesTreeNode"],"kind":"struct"},"2837":{"crate_id":1,"path":["std","net","socket_addr","ToSocketAddrs"],"kind":"trait"},"194":{"crate_id":0,"path":["assertables","assert_count_ge_as_result"],"kind":"macro"},"1075":{"crate_id":0,"path":["assertables","assert_success_false"],"kind":"macro"},"1956":{"crate_id":17,"path":["object","read","coff","import","ImportObjectData"],"kind":"struct"},"2283":{"crate_id":3,"path":["alloc","collections","btree","node","marker","Mut"],"kind":"struct"},"521":{"crate_id":0,"path":["assertables","assert_fn_ge"],"kind":"macro"},"1402":{"crate_id":2,"path":["core","error","Request"],"kind":"struct"},"3164":{"crate_id":3,"path":["alloc","collections","vec_deque","into_iter","IntoIter"],"kind":"struct"},"848":{"crate_id":0,"path":["assertables","assert_command_stderr_le_as_result"],"kind":"macro"},"1729":{"crate_id":16,"path":["gimli","read","cfi","RegisterRule"],"kind":"enum"},"2610":{"crate_id":17,"path":["object","elf","Relr64"],"kind":"struct"},"2937":{"crate_id":2,"path":["core","error","tags","Value"],"kind":"struct"},"294":{"crate_id":0,"path":["assertables","assert_len_ne"],"kind":"macro"},"1175":{"crate_id":6,"path":["libc","unix","bsd","apple","semid_ds"],"kind":"struct"},"2056":{"crate_id":1,"path":["std","sync","poison","mutex","MappedMutexGuard"],"kind":"struct"},"1502":{"crate_id":17,"path":["object","read","xcoff","symbol","XcoffSymbolIterator"],"kind":"struct"},"621":{"crate_id":0,"path":["assertables","debug_assert_fn_ok_ge"],"kind":"macro"},"2383":{"crate_id":17,"path":["object","elf","CompressionHeader32"],"kind":"struct"},"3264":{"crate_id":1,"path":["std","io","BufRead"],"kind":"trait"},"948":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_string_contains"],"kind":"macro"},"67":{"crate_id":0,"path":["assertables","assert_f64_le"],"kind":"macro"},"1829":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2710":{"crate_id":2,"path":["core","char","convert","ParseCharError"],"kind":"struct"},"2156":{"crate_id":11,"path":["hashbrown","raw","RawDrain"],"kind":"struct"},"394":{"crate_id":0,"path":["assertables","assert_option","assert_option_some"],"kind":"module"},"1275":{"crate_id":2,"path":["core","num","niche_types","U32NotAllOnes"],"kind":"struct"},"3037":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"1602":{"crate_id":1,"path":["std","os","unix","net","listener","UnixListener"],"kind":"struct"},"721":{"crate_id":0,"path":["assertables","assert_fs_read_to_string"],"kind":"module"},"2483":{"crate_id":11,"path":["hashbrown","set","Union"],"kind":"struct"},"3364":{"crate_id":2,"path":["core","sync","atomic","AtomicIsize"],"kind":"struct"},"1048":{"crate_id":0,"path":["assertables","assert_status_code_value_eq_x_as_result"],"kind":"macro"},"167":{"crate_id":0,"path":["assertables","assert_in"],"kind":"module"},"1929":{"crate_id":17,"path":["object","pe","ImageAuxSymbolSection"],"kind":"struct"},"2810":{"crate_id":17,"path":["object","read","any","ComdatSectionIteratorInternal"],"kind":"enum"},"2256":{"crate_id":3,"path":["alloc","collections","btree","map","IntoKeys"],"kind":"struct"},"494":{"crate_id":0,"path":["assertables","debug_assert_set_eq"],"kind":"macro"},"1375":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly8x8x3_t"],"kind":"struct"},"3137":{"crate_id":6,"path":["libc","unix","bsd","apple","proc_fdinfo"],"kind":"struct"},"1702":{"crate_id":2,"path":["core","pin","Pin"],"kind":"struct"},"821":{"crate_id":0,"path":["assertables","assert_command_stdout_lt_x_as_result"],"kind":"macro"},"2583":{"crate_id":6,"path":["libc","unix","bsd","apple","processor_cpu_load_info"],"kind":"struct"},"2910":{"crate_id":17,"path":["object","pe","ImageDelayloadDescriptor"],"kind":"struct"},"267":{"crate_id":0,"path":["assertables","debug_assert_is_match"],"kind":"macro"},"1148":{"crate_id":0,"path":["assertables","assert_command_stderr_contains"],"kind":"macro"},"2029":{"crate_id":6,"path":["libc","unix","bsd","apple","pthread_cond_t"],"kind":"struct"},"2356":{"crate_id":3,"path":["alloc","vec","in_place_drop","InPlaceDstDataSrcBufDrop"],"kind":"struct"},"594":{"crate_id":0,"path":["assertables","assert_fn_err_ge_x"],"kind":"macro"},"1475":{"crate_id":1,"path":["std","sys","pal","unix","pipe","AnonPipe"],"kind":"struct"},"3237":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x1x3_t"],"kind":"struct"},"1802":{"crate_id":16,"path":["gimli","common","LineEncoding"],"kind":"struct"},"40":{"crate_id":0,"path":["assertables","debug_assert_f32_gt"],"kind":"macro"},"921":{"crate_id":0,"path":["assertables","assert_program_args_stdout_eq_x_as_result"],"kind":"macro"},"2683":{"crate_id":2,"path":["core","net","ip_addr","Ipv4Addr"],"kind":"struct"},"3010":{"crate_id":2,"path":["core","core_arch","simd","i16x8"],"kind":"struct"},"367":{"crate_id":0,"path":["assertables","assert_ok_eq_as_result"],"kind":"macro"},"1248":{"crate_id":17,"path":["object","read","SymbolMapName"],"kind":"struct"},"2129":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"2456":{"crate_id":10,"path":["adler2","Adler32"],"kind":"struct"},"694":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_ge_x"],"kind":"macro"},"1575":{"crate_id":2,"path":["core","borrow","Borrow"],"kind":"trait"},"3337":{"crate_id":3,"path":["alloc","collections","binary_heap","IntoIter"],"kind":"struct"},"1021":{"crate_id":0,"path":["assertables","debug_assert_status_failure"],"kind":"macro"},"140":{"crate_id":0,"path":["assertables","assert_diff_le_x"],"kind":"macro"},"1902":{"crate_id":3,"path":["alloc","collections","btree","set","DifferenceInner"],"kind":"enum"},"2783":{"crate_id":2,"path":["core","core_arch","simd","i8x16"],"kind":"struct"},"3110":{"crate_id":1,"path":["std","usize"],"kind":"primitive"},"467":{"crate_id":0,"path":["assertables","assert_iter_eq"],"kind":"macro"},"1348":{"crate_id":16,"path":["gimli","read","loclists","DebugLoc"],"kind":"struct"},"2229":{"crate_id":4,"path":["compiler_builtins","float","cmp","Result"],"kind":"enum"},"1675":{"crate_id":2,"path":["core","ops","range","RangeToInclusive"],"kind":"struct"},"794":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_le"],"kind":"macro"},"2556":{"crate_id":17,"path":["object","read","archive","ArchiveMember"],"kind":"struct"},"3437":{"crate_id":9,"path":["miniz_oxide"],"kind":"module"},"1121":{"crate_id":0,"path":["assertables","debug_assert_poll_pending"],"kind":"macro"},"240":{"crate_id":0,"path":["assertables","debug_assert_email_address"],"kind":"macro"},"2002":{"crate_id":6,"path":["libc","unix","bsd","apple","vol_attributes_attr_t"],"kind":"struct"},"2883":{"crate_id":2,"path":["core","core_simd","simd","ptr","const_ptr","SimdConstPtr"],"kind":"trait"},"2329":{"crate_id":1,"path":["std","io","buffered","bufwriter","BufWriter"],"kind":"struct"},"567":{"crate_id":0,"path":["assertables","assert_fn_err_eq_as_result"],"kind":"macro"},"1448":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbolIterator"],"kind":"struct"},"3210":{"crate_id":17,"path":["object","read","archive","ArchiveSymbolIterator"],"kind":"struct"},"1775":{"crate_id":17,"path":["object","macho","LoadCommand"],"kind":"struct"},"13":{"crate_id":0,"path":["assertables","assert_le_as_result"],"kind":"macro"},"894":{"crate_id":0,"path":["assertables","assert_command_stdout_ne_x"],"kind":"macro"},"2656":{"crate_id":2,"path":["core","core_simd","swizzle","shift_elements_left","Shift"],"kind":"struct"},"1221":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStrExt"],"kind":"trait"},"340":{"crate_id":0,"path":["assertables","assert_starts_with"],"kind":"module"},"2102":{"crate_id":18,"path":["memchr","arch","all","twoway","TwoWay"],"kind":"struct"},"2983":{"crate_id":2,"path":["core","fmt","Display"],"kind":"trait"},"2429":{"crate_id":2,"path":["core","ops","bit","Not"],"kind":"trait"},"667":{"crate_id":0,"path":["assertables","assert_fs_read_to_string","assert_fs_read_to_string_eq"],"kind":"module"},"1548":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x4x2_t"],"kind":"struct"},"3310":{"crate_id":2,"path":["core","num","dec2flt","ParseFloatError"],"kind":"struct"},"1875":{"crate_id":1,"path":["std","sync","lazy_lock","LazyLock"],"kind":"struct"},"113":{"crate_id":0,"path":["assertables","assert_abs_diff_le"],"kind":"macro"},"994":{"crate_id":0,"path":["assertables","assert_program_args_stderr_lt_x_as_result"],"kind":"macro"},"2756":{"crate_id":17,"path":["object","read","macho","section","MachOSectionIterator"],"kind":"struct"},"3083":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x8_t"],"kind":"struct"},"440":{"crate_id":0,"path":["assertables","assert_ready","assert_ready_ne"],"kind":"module"},"1321":{"crate_id":16,"path":["gimli","read","endian_slice","DebugLen"],"kind":"struct"},"2202":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int8x16x2_t"],"kind":"struct"},"2529":{"crate_id":6,"path":["libc","unix","bsd","apple","attrreference_t"],"kind":"struct"},"767":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ne_x_as_result"],"kind":"macro"},"1648":{"crate_id":1,"path":["std","backtrace","BacktraceSymbol"],"kind":"struct"},"3410":{"crate_id":6,"path":["libc","unix","bsd","apple","sysdir_search_path_domain_mask_t"],"kind":"enum"},"1975":{"crate_id":17,"path":["object","read","xcoff","symbol","SymbolTable"],"kind":"struct"},"1094":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_ne"],"kind":"macro"},"213":{"crate_id":0,"path":["assertables","assert_count_eq_x"],"kind":"macro"},"2856":{"crate_id":2,"path":["core","char","ToUppercase"],"kind":"struct"},"3183":{"crate_id":2,"path":["core","convert","Into"],"kind":"trait"},"540":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_ne"],"kind":"module"},"1421":{"crate_id":6,"path":["libc","unix","linger"],"kind":"struct"},"2302":{"crate_id":2,"path":["core","marker","Sized"],"kind":"trait"},"2629":{"crate_id":17,"path":["object","read","pe","section","PeSection"],"kind":"struct"},"867":{"crate_id":0,"path":["assertables","assert_command_stderr_gt_x"],"kind":"macro"},"1748":{"crate_id":2,"path":["core","str","iter","CharIndices"],"kind":"struct"},"1194":{"crate_id":16,"path":["gimli","constants","DwAte"],"kind":"struct"},"313":{"crate_id":0,"path":["assertables","assert_len","assert_len_le_x"],"kind":"module"},"2075":{"crate_id":6,"path":["libc","unix","bsd","apple","sf_hdtr"],"kind":"struct"},"2956":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly64x1x2_t"],"kind":"struct"},"3283":{"crate_id":17,"path":["object","macho","DylibTableOfContents"],"kind":"struct"},"640":{"crate_id":0,"path":["assertables","assert_fn_ok_eq_x_as_result"],"kind":"macro"},"1521":{"crate_id":17,"path":["object","pe","ImageTlsDirectory64"],"kind":"struct"},"2402":{"crate_id":18,"path":["memchr","arch","aarch64","neon","memchr","One"],"kind":"struct"},"1848":{"crate_id":17,"path":["object","xcoff","FunAux32"],"kind":"struct"},"86":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_ge_x"],"kind":"macro"},"967":{"crate_id":0,"path":["assertables","assert_program_args_stderr_le_as_result"],"kind":"macro"},"2729":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"1294":{"crate_id":3,"path":["alloc","collections","btree","set","Intersection"],"kind":"struct"},"413":{"crate_id":0,"path":["assertables","assert_some","assert_some_eq_x"],"kind":"module"},"2175":{"crate_id":16,"path":["gimli","read","loclists","LocationLists"],"kind":"struct"},"3056":{"crate_id":18,"path":["memchr","arch","generic","memchr","Two"],"kind":"struct"},"3383":{"crate_id":1,"path":["std","process","Command"],"kind":"struct"},"740":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_lt"],"kind":"macro"},"1621":{"crate_id":18,"path":["memchr","memmem","searcher","PrefilterConfig"],"kind":"enum"},"2502":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x8x4_t"],"kind":"struct"},"1948":{"crate_id":18,"path":["memchr","arch","all","rabinkarp","FinderRev"],"kind":"struct"},"186":{"crate_id":0,"path":["assertables","debug_assert_not_contains"],"kind":"macro"},"1067":{"crate_id":0,"path":["assertables","assert_status_code_value_ne_x_as_result"],"kind":"macro"},"2829":{"crate_id":2,"path":["core","ffi","va_list","VaListImpl"],"kind":"struct"},"1394":{"crate_id":16,"path":["gimli","read","line","FileEntry"],"kind":"struct"},"513":{"crate_id":0,"path":["assertables","assert_set_superset_as_result"],"kind":"macro"},"2275":{"crate_id":1,"path":["std","os","unix","fs","FileExt"],"kind":"trait"},"3156":{"crate_id":17,"path":["object","macho","SubClientCommand"],"kind":"struct"},"2602":{"crate_id":2,"path":["core","sync","atomic","Ordering"],"kind":"enum"},"840":{"crate_id":0,"path":["assertables","assert_command_stderr_ge_as_result"],"kind":"macro"},"1721":{"crate_id":2,"path":["core","slice","iter","RSplitNMut"],"kind":"struct"},"2048":{"crate_id":17,"path":["object","macho","DyldCacheMappingInfo"],"kind":"struct"},"286":{"crate_id":0,"path":["assertables","assert_len_le"],"kind":"macro"},"1167":{"crate_id":0,"path":["assertables","debug_assert_status_code_value_ne_x"],"kind":"macro"},"2929":{"crate_id":17,"path":["object","macho","LinkerOptionCommand"],"kind":"struct"},"3256":{"crate_id":17,"path":["object","endian","U64Bytes"],"kind":"struct"},"1494":{"crate_id":17,"path":["object","pe","ImageSymbolExBytes"],"kind":"struct"},"613":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_ne_x"],"kind":"module"},"2375":{"crate_id":18,"path":["memchr","memmem","searcher","SearcherRev"],"kind":"struct"},"2702":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"59":{"crate_id":0,"path":["assertables","assert_f64_ge"],"kind":"macro"},"940":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ne_x"],"kind":"macro"},"1821":{"crate_id":1,"path":["std","sys","fs","unix","Dir"],"kind":"struct"},"2148":{"crate_id":2,"path":["core","iter","sources","from_fn","FromFn"],"kind":"struct"},"386":{"crate_id":0,"path":["assertables","assert_result","assert_result_ok_ne"],"kind":"module"},"1267":{"crate_id":2,"path":["core","mem","take"],"kind":"function"},"3029":{"crate_id":6,"path":["libc","unix","bsd","apple","vol_capabilities_attr_t"],"kind":"struct"},"3356":{"crate_id":2,"path":["core","num","niche_types","NonZeroUsizeInner"],"kind":"struct"},"713":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_contains_as_result"],"kind":"macro"},"1594":{"crate_id":3,"path":["alloc","sync","from_iter_exact","Guard"],"kind":"struct"},"2475":{"crate_id":2,"path":["core","core_arch","simd","u16x16"],"kind":"struct"},"2802":{"crate_id":2,"path":["core","cell","Cell"],"kind":"struct"},"159":{"crate_id":0,"path":["assertables","assert_in","assert_in_delta"],"kind":"module"},"1040":{"crate_id":0,"path":["assertables","assert_status_code_value_lt_as_result"],"kind":"macro"},"1921":{"crate_id":2,"path":["core","async_iter","async_iter","AsyncIterator"],"kind":"trait"},"1367":{"crate_id":3,"path":["alloc","collections","btree","map","drop","DropGuard"],"kind":"struct"},"486":{"crate_id":0,"path":["assertables","assert_iter","assert_iter_lt"],"kind":"module"},"2248":{"crate_id":1,"path":["std","sealed","Sealed"],"kind":"trait"},"3129":{"crate_id":1,"path":["std","sync","poison","Guard"],"kind":"struct"},"3456":{"crate_id":2,"path":["core","fmt","rt","Count"],"kind":"enum"},"813":{"crate_id":0,"path":["assertables","assert_command_stdout_gt_x_as_result"],"kind":"macro"},"1694":{"crate_id":3,"path":["alloc","collections","vec_deque","drain","drop","DropGuard"],"kind":"struct"},"2575":{"crate_id":2,"path":["core","marker","UnsizedConstParamTy"],"kind":"trait"},"2902":{"crate_id":17,"path":["object","pe","ImageHotPatchInfo"],"kind":"struct"},"259":{"crate_id":0,"path":["assertables","assert_is_empty","assert_is_empty"],"kind":"module"},"1140":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_ne_x"],"kind":"macro"},"2021":{"crate_id":2,"path":["core","ops","arith","AddAssign"],"kind":"trait"},"1467":{"crate_id":6,"path":["libc","unix","bsd","regex_t"],"kind":"struct"},"586":{"crate_id":0,"path":["assertables","assert_fn_err_ne"],"kind":"macro"},"2348":{"crate_id":9,"path":["miniz_oxide","StreamResult"],"kind":"struct"},"3229":{"crate_id":16,"path":["gimli","common","DebugTypesOffset"],"kind":"struct"},"913":{"crate_id":0,"path":["assertables","assert_program_args_stdout_lt_as_result"],"kind":"macro"},"32":{"crate_id":0,"path":["assertables","debug_assert_f32_eq"],"kind":"macro"},"1794":{"crate_id":2,"path":["core","ops","arith","Div"],"kind":"trait"},"2675":{"crate_id":16,"path":["gimli","read","index","DebugCuIndex"],"kind":"struct"},"2121":{"crate_id":6,"path":["libc","unix","bsd","apple","rt_msghdr"],"kind":"struct"},"359":{"crate_id":0,"path":["assertables","debug_assert_err_ne_x"],"kind":"macro"},"1240":{"crate_id":17,"path":["object","pe","ImageRomHeaders"],"kind":"struct"},"3002":{"crate_id":6,"path":["libc","unix","bsd","apple","in6_pktinfo"],"kind":"struct"},"1567":{"crate_id":17,"path":["object","elf","HashHeader"],"kind":"struct"},"686":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_ne"],"kind":"macro"},"2448":{"crate_id":2,"path":["core","iter","sources","repeat","Repeat"],"kind":"struct"},"3329":{"crate_id":1,"path":["std","thread","Builder"],"kind":"struct"},"2775":{"crate_id":2,"path":["core","num","dec2flt","decimal","Decimal"],"kind":"struct"},"132":{"crate_id":0,"path":["assertables","assert_diff_ge_x"],"kind":"macro"},"1013":{"crate_id":0,"path":["assertables","debug_assert_status_success"],"kind":"macro"},"1894":{"crate_id":17,"path":["object"],"kind":"module"},"2221":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x2_t"],"kind":"struct"},"459":{"crate_id":0,"path":["assertables","assert_bag_subbag_as_result"],"kind":"macro"},"1340":{"crate_id":16,"path":["gimli","read","cfi","UnwindTableRow"],"kind":"struct"},"3102":{"crate_id":2,"path":["core","str","pattern","SearchStep"],"kind":"enum"},"3429":{"crate_id":2,"path":["core","num","dec2flt","decimal_seq","DecimalSeq"],"kind":"struct"},"1667":{"crate_id":1,"path":["std","env","JoinPathsError"],"kind":"struct"},"786":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_ge"],"kind":"macro"},"2548":{"crate_id":3,"path":["alloc","string","Drain"],"kind":"struct"},"2875":{"crate_id":16,"path":["gimli","read","aranges","ArangeEntry"],"kind":"struct"},"232":{"crate_id":0,"path":["assertables","assert_count","assert_count_lt_x"],"kind":"module"},"1113":{"crate_id":0,"path":["assertables","assert_option_some_eq_as_result"],"kind":"macro"},"1994":{"crate_id":2,"path":["core","fmt","Formatter"],"kind":"struct"},"2321":{"crate_id":2,"path":["core","sync","atomic","AtomicI8"],"kind":"struct"},"559":{"crate_id":0,"path":["assertables","debug_assert_fn_lt_x"],"kind":"macro"},"1440":{"crate_id":18,"path":["memchr","cow","Imp"],"kind":"struct"},"3202":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"886":{"crate_id":0,"path":["assertables","assert_command_stderr_string_contains_as_result"],"kind":"macro"},"5":{"crate_id":0,"path":["assertables","assert_ge_as_result"],"kind":"macro"},"1767":{"crate_id":2,"path":["core","convert","num","FloatToInt"],"kind":"trait"},"2648":{"crate_id":16,"path":["gimli"],"kind":"module"},"2975":{"crate_id":2,"path":["core","cell","RefMut"],"kind":"struct"},"332":{"crate_id":0,"path":["assertables","assert_not_starts_with"],"kind":"macro"},"1213":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","__darwin_mcontext64"],"kind":"struct"},"2094":{"crate_id":2,"path":["core","core_arch","simd","u16x8"],"kind":"struct"},"1540":{"crate_id":1,"path":["std","sync","mpmc","select","Token"],"kind":"struct"},"659":{"crate_id":0,"path":["assertables","assert_fn_ok_ne_x"],"kind":"macro"},"2421":{"crate_id":3,"path":["alloc","collections","btree","set","Cursor"],"kind":"struct"},"3302":{"crate_id":17,"path":["object","pe","ImageResourceDirectory"],"kind":"struct"},"986":{"crate_id":0,"path":["assertables","assert_program_args_stderr_gt_x_as_result"],"kind":"macro"},"105":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_ge"],"kind":"module"},"1867":{"crate_id":6,"path":["libc","unix","bsd","option"],"kind":"struct"},"2748":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x16x4_t"],"kind":"struct"},"3075":{"crate_id":2,"path":["core","iter","sources","from_coroutine","FromCoroutine"],"kind":"struct"},"432":{"crate_id":0,"path":["assertables","assert_ready","assert_ready"],"kind":"module"},"1313":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int16x8x2_t"],"kind":"struct"},"2194":{"crate_id":17,"path":["object","read","any","SectionIteratorInternal"],"kind":"enum"},"1640":{"crate_id":2,"path":["core","core_arch","simd","f64x1"],"kind":"struct"},"759":{"crate_id":0,"path":["assertables","assert_io_read_to_string_le_x_as_result"],"kind":"macro"},"2521":{"crate_id":17,"path":["object","read","macho","section","MachOSection"],"kind":"struct"},"3402":{"crate_id":2,"path":["core","slice","iter","Iter"],"kind":"struct"},"1086":{"crate_id":0,"path":["assertables","debug_assert_abs_diff_ge"],"kind":"macro"},"205":{"crate_id":0,"path":["assertables","assert_count_lt"],"kind":"macro"},"1967":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"2848":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbolIterator"],"kind":"struct"},"2294":{"crate_id":1,"path":["std","collections","hash","map","OccupiedError"],"kind":"struct"},"532":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_le"],"kind":"module"},"1413":{"crate_id":17,"path":["object","macho","Nlist32"],"kind":"struct"},"3175":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation32"],"kind":"struct"},"1740":{"crate_id":6,"path":["libc","unix","bsd","apple","host_cpu_load_info"],"kind":"struct"},"859":{"crate_id":0,"path":["assertables","assert_command_stderr_eq_x"],"kind":"macro"},"2621":{"crate_id":17,"path":["object","pe","AnonObjectHeaderBigobj"],"kind":"struct"},"2948":{"crate_id":16,"path":["gimli","constants","DwTag"],"kind":"struct"},"1186":{"crate_id":17,"path":["object","elf","Verdaux"],"kind":"struct"},"305":{"crate_id":0,"path":["assertables","assert_len","assert_len_ge_x"],"kind":"module"},"2067":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x4_t"],"kind":"struct"},"2394":{"crate_id":2,"path":["core","error","Source"],"kind":"struct"},"632":{"crate_id":0,"path":["assertables","assert_fn_ok_lt_as_result"],"kind":"macro"},"1513":{"crate_id":1,"path":["std","path","Prefix"],"kind":"enum"},"3275":{"crate_id":3,"path":["alloc","slice","Concat"],"kind":"trait"},"1840":{"crate_id":3,"path":["alloc","collections","linked_list","Cursor"],"kind":"struct"},"78":{"crate_id":0,"path":["assertables","assert_f64","assert_f64_ne"],"kind":"module"},"959":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ge_as_result"],"kind":"macro"},"2721":{"crate_id":1,"path":["std","sys","backtrace","print","DisplayBacktrace"],"kind":"struct"},"3048":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint16x4_t"],"kind":"struct"},"405":{"crate_id":0,"path":["assertables","assert_some","assert_some_eq"],"kind":"module"},"1286":{"crate_id":2,"path":["core","hash","Hasher"],"kind":"trait"},"2167":{"crate_id":18,"path":["memchr","arch","all","twoway","Suffix"],"kind":"struct"},"2494":{"crate_id":2,"path":["core","convert","TryFrom"],"kind":"trait"},"732":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_gt"],"kind":"macro"},"1613":{"crate_id":2,"path":["core","str","pattern"],"kind":"module"},"3375":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_extended_info"],"kind":"struct"},"1059":{"crate_id":0,"path":["assertables","assert_status_code_value_le_x"],"kind":"macro"},"178":{"crate_id":0,"path":["assertables","debug_assert_infix"],"kind":"macro"},"1940":{"crate_id":1,"path":["std","sys","process","unix","common","ProgramKind"],"kind":"enum"},"2821":{"crate_id":6,"path":["libc","unix","bsd","apple","time_value_t"],"kind":"struct"},"3148":{"crate_id":2,"path":["core","future","pending","Pending"],"kind":"struct"},"505":{"crate_id":0,"path":["assertables","assert_set_joint_as_result"],"kind":"macro"},"1386":{"crate_id":17,"path":["object","pe","ImageSeparateDebugHeader"],"kind":"struct"},"2267":{"crate_id":1,"path":["std","sys","fs","unix","FilePermissions"],"kind":"struct"},"2594":{"crate_id":1,"path":["std","thread","scoped","ScopedJoinHandle"],"kind":"struct"},"832":{"crate_id":0,"path":["assertables","assert_command_stdout_string_is_match_as_result"],"kind":"macro"},"1713":{"crate_id":1,"path":["std","sys","net","connection","socket","unix","Socket"],"kind":"struct"},"1159":{"crate_id":0,"path":["assertables","debug_assert_program_args_stdout_is_match"],"kind":"macro"},"278":{"crate_id":0,"path":["assertables","assert_len_ge"],"kind":"macro"},"2040":{"crate_id":1,"path":["std","path","PathBuf"],"kind":"struct"},"2921":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdatIterator"],"kind":"struct"},"3248":{"crate_id":1,"path":["std","collections","hash","set","Intersection"],"kind":"struct"},"605":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_le_x"],"kind":"module"},"1486":{"crate_id":1,"path":["std","process","ChildStdout"],"kind":"struct"},"2367":{"crate_id":16,"path":["gimli","constants","DwSectV2"],"kind":"struct"},"1813":{"crate_id":1,"path":["std","sync","mpmc","Receiver"],"kind":"struct"},"51":{"crate_id":0,"path":["assertables","assert_f32_ne_as_result"],"kind":"macro"},"932":{"crate_id":0,"path":["assertables","assert_program_args_stdout_le_x"],"kind":"macro"},"2694":{"crate_id":2,"path":["core","ops","deref","Receiver"],"kind":"trait"},"1259":{"crate_id":6,"path":["libc","unix","bsd","apple","attribute_set_t"],"kind":"struct"},"378":{"crate_id":0,"path":["assertables","assert_ok_ne_x"],"kind":"macro"},"2140":{"crate_id":16,"path":["gimli","arch","RiscV"],"kind":"struct"},"3021":{"crate_id":17,"path":["object","elf","Syminfo32"],"kind":"struct"},"2467":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"705":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_lt_x_as_result"],"kind":"macro"},"1586":{"crate_id":17,"path":["object","pe","ImageAlphaRuntimeFunctionEntry"],"kind":"struct"},"3348":{"crate_id":2,"path":["core","ops","range","RangeBounds"],"kind":"trait"},"1913":{"crate_id":2,"path":["core","num","niche_types","NonZeroI8Inner"],"kind":"struct"},"151":{"crate_id":0,"path":["assertables","assert_diff","assert_diff_ne_x"],"kind":"module"},"1032":{"crate_id":0,"path":["assertables","assert_status_code_value_gt_as_result"],"kind":"macro"},"2794":{"crate_id":17,"path":["object","endian","U32Bytes"],"kind":"struct"},"3121":{"crate_id":2,"path":["core","clone","CloneToUninit"],"kind":"trait"},"1359":{"crate_id":2,"path":["core","core_arch","simd","i32x8"],"kind":"struct"},"478":{"crate_id":0,"path":["assertables","assert_iter","assert_iter_gt"],"kind":"module"},"2240":{"crate_id":2,"path":["core","slice","private_get_disjoint_mut_index","Sealed"],"kind":"trait"},"2567":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt2"],"kind":"trait"},"805":{"crate_id":0,"path":["assertables","assert_command_stdout_eq_x_as_result"],"kind":"macro"},"1686":{"crate_id":1,"path":["std","fs","exists"],"kind":"function"},"3448":{"crate_id":2,"path":["core","future","async_drop","Noop"],"kind":"struct"},"2013":{"crate_id":3,"path":["alloc","collections","btree","map","Cursor"],"kind":"struct"},"251":{"crate_id":0,"path":["assertables","assert_not_ends_with"],"kind":"macro"},"1132":{"crate_id":0,"path":["assertables","assert_set_impl_prep"],"kind":"macro"},"2894":{"crate_id":2,"path":["core","ops","range","RangeFrom"],"kind":"struct"},"3221":{"crate_id":3,"path":["alloc","collections","btree","node","marker","Owned"],"kind":"enum"},"578":{"crate_id":0,"path":["assertables","assert_fn_err_le"],"kind":"macro"},"1459":{"crate_id":1,"path":["std","io","stdio","StderrLock"],"kind":"struct"},"2340":{"crate_id":16,"path":["gimli","read","cfi","CieOrFde"],"kind":"enum"},"2667":{"crate_id":2,"path":["core","num","niche_types","Nanoseconds"],"kind":"struct"},"24":{"crate_id":0,"path":["assertables","debug_assert_eq_f32"],"kind":"macro"},"905":{"crate_id":0,"path":["assertables","assert_program_args_stdout_gt_as_result"],"kind":"macro"},"1786":{"crate_id":2,"path":["core","iter","range","Step"],"kind":"trait"},"1232":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","lru","Lru"],"kind":"struct"},"351":{"crate_id":0,"path":["assertables","debug_assert_err_ne"],"kind":"macro"},"2113":{"crate_id":11,"path":["hashbrown","table","IterMut"],"kind":"struct"},"2994":{"crate_id":2,"path":["core","num","bignum","tests","Big8x3"],"kind":"struct"},"3321":{"crate_id":17,"path":["object","endian","BigEndian"],"kind":"struct"},"678":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_le"],"kind":"macro"},"1559":{"crate_id":1,"path":["std","thread","ThreadId"],"kind":"struct"},"2440":{"crate_id":2,"path":["core","num","nonzero","ZeroablePrimitive"],"kind":"trait"},"2767":{"crate_id":17,"path":["object","pe","ImageNtHeaders32"],"kind":"struct"},"124":{"crate_id":0,"path":["assertables","assert_approx_ne_as_result"],"kind":"macro"},"1005":{"crate_id":0,"path":["assertables","debug_assert_program_args_stderr_string_contains"],"kind":"macro"},"1886":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","ucontext_t"],"kind":"struct"},"1332":{"crate_id":2,"path":["core","intrinsics","disjoint_bitor"],"kind":"function"},"451":{"crate_id":0,"path":["assertables","assert_bag_eq_as_result"],"kind":"macro"},"2213":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3094":{"crate_id":1,"path":["std","io","SeekFrom"],"kind":"enum"},"3421":{"crate_id":2,"path":["core","pat","RangePattern"],"kind":"trait"},"778":{"crate_id":0,"path":["assertables","assert_io_read_to_string","assert_io_read_to_string_matches"],"kind":"module"},"1659":{"crate_id":6,"path":["libc","unix","bsd","apple","processor_basic_info"],"kind":"struct"},"2540":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbolTable"],"kind":"struct"},"1986":{"crate_id":17,"path":["object","elf","NoteHeader64"],"kind":"struct"},"224":{"crate_id":0,"path":["assertables","assert_count","assert_count_gt_x"],"kind":"module"},"1105":{"crate_id":0,"path":["assertables","assert_result_ok_ne"],"kind":"macro"},"2867":{"crate_id":1,"path":["std","thread","PanicGuard"],"kind":"struct"},"1432":{"crate_id":11,"path":["hashbrown","raw","RawIntoIter"],"kind":"struct"},"551":{"crate_id":0,"path":["assertables","debug_assert_fn_gt_x"],"kind":"macro"},"2313":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3194":{"crate_id":3,"path":["alloc","sync","ArcInner"],"kind":"struct"},"2640":{"crate_id":1,"path":["std","sys","pal","unix","os","JoinPathsError"],"kind":"struct"},"878":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_lt_x"],"kind":"module"},"1759":{"crate_id":2,"path":["core","ops","range","OneSidedRangeBound"],"kind":"enum"},"2086":{"crate_id":17,"path":["object","read","coff","file","CoffCommon"],"kind":"struct"},"324":{"crate_id":0,"path":["assertables","assert_matches_as_result"],"kind":"macro"},"1205":{"crate_id":2,"path":["core","slice","sort","unstable","quicksort","GapGuard"],"kind":"struct"},"2967":{"crate_id":1,"path":["std","fs","symlink_metadata"],"kind":"function"},"1532":{"crate_id":4,"path":["compiler_builtins","int","big","u256"],"kind":"struct"},"651":{"crate_id":0,"path":["assertables","assert_fn_ok_le_x"],"kind":"macro"},"2413":{"crate_id":11,"path":["hashbrown","raw_entry","RawEntryBuilderMut"],"kind":"struct"},"3294":{"crate_id":17,"path":["object","read","util","Bytes"],"kind":"struct"},"2740":{"crate_id":17,"path":["object","read","archive","MemberHeader"],"kind":"enum"},"97":{"crate_id":0,"path":["assertables","assert_abs_diff_lt_x_as_result"],"kind":"macro"},"978":{"crate_id":0,"path":["assertables","assert_program_args_stderr_eq_x"],"kind":"macro"},"1859":{"crate_id":1,"path":["std","f16"],"kind":"primitive"},"2186":{"crate_id":2,"path":["core","num","niche_types","NonZeroU32Inner"],"kind":"struct"},"424":{"crate_id":0,"path":["assertables","assert_poll","assert_poll_pending"],"kind":"module"},"1305":{"crate_id":3,"path":["alloc","collections","btree","set","entry","Entry"],"kind":"enum"},"3067":{"crate_id":17,"path":["object","read","pe","section","PeSectionIterator"],"kind":"struct"},"3394":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"751":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ge_x_as_result"],"kind":"macro"},"1632":{"crate_id":1,"path":["std","process","Output"],"kind":"struct"},"2513":{"crate_id":16,"path":["gimli","common","DebugAddrBase"],"kind":"struct"},"2840":{"crate_id":1,"path":["std","sync","poison","condvar","WaitTimeoutResult"],"kind":"struct"},"1078":{"crate_id":0,"path":["assertables","assert_success","assert_success_false"],"kind":"module"},"197":{"crate_id":0,"path":["assertables","assert_count_gt"],"kind":"macro"},"1959":{"crate_id":2,"path":["core","iter","sources","once_with","OnceWith"],"kind":"struct"},"2286":{"crate_id":2,"path":["core","fmt","Pointer"],"kind":"trait"},"524":{"crate_id":0,"path":["assertables","assert_fn","assert_fn_ge"],"kind":"module"},"1405":{"crate_id":17,"path":["object","read","util","DebugLen"],"kind":"struct"},"3167":{"crate_id":6,"path":["libc","unix","bsd","apple","vm_statistics"],"kind":"struct"},"851":{"crate_id":0,"path":["assertables","assert_command_stderr_lt"],"kind":"macro"},"1732":{"crate_id":1,"path":["std","io","stdio","StderrRaw"],"kind":"struct"},"2613":{"crate_id":11,"path":["hashbrown","control","group","neon","Group"],"kind":"struct"},"2940":{"crate_id":2,"path":["core","num","wrapping","Wrapping"],"kind":"struct"},"297":{"crate_id":0,"path":["assertables","assert_len","assert_len_ne"],"kind":"module"},"1178":{"crate_id":2,"path":["core","str","iter","SplitInclusive"],"kind":"struct"},"2059":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"1505":{"crate_id":16,"path":["gimli","common","RawRangeListsOffset"],"kind":"struct"},"624":{"crate_id":0,"path":["assertables","assert_fn_ok_gt_as_result"],"kind":"macro"},"2386":{"crate_id":1,"path":["std","panicking","panic_count","MustAbort"],"kind":"enum"},"3267":{"crate_id":2,"path":["core","fmt","Arguments"],"kind":"struct"},"951":{"crate_id":0,"path":["assertables","assert_program_args_stdout_string_is_match_as_result"],"kind":"macro"},"70":{"crate_id":0,"path":["assertables","assert_f64","assert_f64_le"],"kind":"module"},"1832":{"crate_id":6,"path":["libc","unix","bsd","apple","sigevent"],"kind":"struct"},"2713":{"crate_id":17,"path":["object","read","any","SymbolIteratorInternal"],"kind":"enum"},"2159":{"crate_id":2,"path":["core","future","async_drop","AsyncDropOwning"],"kind":"struct"},"397":{"crate_id":0,"path":["assertables","assert_option"],"kind":"module"},"1278":{"crate_id":16,"path":["gimli","read","index","IndexSectionId"],"kind":"enum"},"3040":{"crate_id":2,"path":["core","hash","sip","State"],"kind":"struct"},"1605":{"crate_id":1,"path":["std","sync","poison","once","OnceState"],"kind":"struct"},"724":{"crate_id":0,"path":["assertables","debug_assert_io_read_to_string_eq"],"kind":"macro"},"2486":{"crate_id":16,"path":["gimli","constants","DwOrd"],"kind":"struct"},"3367":{"crate_id":2,"path":["core","core_arch","simd","i32x16"],"kind":"struct"},"2813":{"crate_id":1,"path":["std","sys_common","process","CommandEnv"],"kind":"struct"},"1051":{"crate_id":0,"path":["assertables","assert_status_code_value_ge_x"],"kind":"macro"},"170":{"crate_id":0,"path":["assertables","debug_assert_all"],"kind":"macro"},"1932":{"crate_id":6,"path":["libc","unix","bsd","apple","__c_anonymous_ifk_data"],"kind":"union"},"2259":{"crate_id":1,"path":["std","sync","reentrant_lock","ReentrantLock"],"kind":"struct"},"497":{"crate_id":0,"path":["assertables","assert_set_ne_as_result"],"kind":"macro"},"1378":{"crate_id":2,"path":["core","str","CharEscapeDefault"],"kind":"struct"},"3140":{"crate_id":6,"path":["libc","unix","bsd","apple","sockaddr_ndrv"],"kind":"struct"},"1705":{"crate_id":2,"path":["core","iter","adapters","map_while","MapWhile"],"kind":"struct"},"824":{"crate_id":0,"path":["assertables","assert_command","assert_command_stdout_ne_x"],"kind":"module"},"2586":{"crate_id":2,"path":["core","str","pattern","CharSearcher"],"kind":"struct"},"2913":{"crate_id":6,"path":["libc","unix","bsd","apple","ifs_iso_8802_3"],"kind":"struct"},"270":{"crate_id":0,"path":["assertables","assert_not_match_as_result"],"kind":"macro"},"1151":{"crate_id":0,"path":["assertables","assert_command_stderr_is_match"],"kind":"macro"},"2032":{"crate_id":3,"path":["alloc","collections","btree","dedup_sorted_iter","DedupSortedIter"],"kind":"struct"},"2359":{"crate_id":6,"path":["libc","unix","bsd","apple","timex"],"kind":"struct"},"597":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_ge_x"],"kind":"module"},"1478":{"crate_id":16,"path":["gimli","constants","DwId"],"kind":"struct"},"3240":{"crate_id":1,"path":["std","sys","process","unix","unix","do_exec","Reset"],"kind":"struct"},"924":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ge_x"],"kind":"macro"},"43":{"crate_id":0,"path":["assertables","assert_f32_le_as_result"],"kind":"macro"},"1805":{"crate_id":17,"path":["object","xcoff","AuxHeader64"],"kind":"struct"},"2686":{"crate_id":1,"path":["std"],"kind":"module"},"3013":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"370":{"crate_id":0,"path":["assertables","assert_ok_ne"],"kind":"macro"},"1251":{"crate_id":2,"path":["core","str","iter","Chars"],"kind":"struct"},"2132":{"crate_id":1,"path":["std","path","PrefixComponent"],"kind":"struct"},"2459":{"crate_id":2,"path":["core","core_arch","simd","f64x8"],"kind":"struct"},"697":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_gt_x_as_result"],"kind":"macro"},"1578":{"crate_id":16,"path":["gimli","read","cfi","EhFrame"],"kind":"struct"},"3340":{"crate_id":2,"path":["core","str","iter","Bytes"],"kind":"struct"},"1024":{"crate_id":0,"path":["assertables","assert_status_code_value_eq_as_result"],"kind":"macro"},"143":{"crate_id":0,"path":["assertables","assert_diff","assert_diff_le_x"],"kind":"module"},"1905":{"crate_id":17,"path":["object","read","pe","export","ExportTable"],"kind":"struct"},"2786":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int64x1x3_t"],"kind":"struct"},"3113":{"crate_id":2,"path":["core","ops","unsize","DispatchFromDyn"],"kind":"trait"},"470":{"crate_id":0,"path":["assertables","assert_iter","assert_iter_eq"],"kind":"module"},"1351":{"crate_id":2,"path":["core","task","wake","ExtData"],"kind":"enum"},"2232":{"crate_id":17,"path":["object","common","SubArchitecture"],"kind":"enum"},"1678":{"crate_id":15,"path":["addr2line","DebugFile"],"kind":"enum"},"797":{"crate_id":0,"path":["assertables","assert_command_stdout_lt_as_result"],"kind":"macro"},"2559":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint64x1x4_t"],"kind":"struct"},"3440":{"crate_id":6,"path":["libc","unix","bsd","apple","proc_threadinfo"],"kind":"struct"},"1124":{"crate_id":0,"path":["assertables","debug_assert_poll_ready"],"kind":"macro"},"243":{"crate_id":0,"path":["assertables","assert_not_email_address_as_result"],"kind":"macro"},"2005":{"crate_id":2,"path":["core","sync","atomic","AtomicU32"],"kind":"struct"},"2886":{"crate_id":17,"path":["object","elf","Sym32"],"kind":"struct"},"2332":{"crate_id":17,"path":["object","pe","ImageAuxSymbolCrc"],"kind":"struct"},"570":{"crate_id":0,"path":["assertables","assert_fn_err_ge"],"kind":"macro"},"1451":{"crate_id":14,"path":["rustc_demangle","DemangleStyle"],"kind":"enum"},"3213":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","int32x2x3_t"],"kind":"struct"},"1778":{"crate_id":3,"path":["alloc","collections","TryReserveError"],"kind":"struct"},"16":{"crate_id":0,"path":["assertables","assert_lt"],"kind":"macro"},"897":{"crate_id":0,"path":["assertables","assert_program_args_stdout_eq_as_result"],"kind":"macro"},"2659":{"crate_id":9,"path":["miniz_oxide","MZStatus"],"kind":"enum"},"1224":{"crate_id":17,"path":["object","read","pe","section","PeSegment"],"kind":"struct"},"343":{"crate_id":0,"path":["assertables","debug_assert_err"],"kind":"macro"},"2105":{"crate_id":1,"path":["std","fs","read_dir"],"kind":"function"},"2986":{"crate_id":3,"path":["alloc","collections","btree","set","CursorMut"],"kind":"struct"},"2432":{"crate_id":17,"path":["object","macho","SourceVersionCommand"],"kind":"struct"},"670":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_ge"],"kind":"macro"},"1551":{"crate_id":2,"path":["core","iter","traits","marker","TrustedLen"],"kind":"trait"},"3313":{"crate_id":17,"path":["object","elf","Rel64"],"kind":"struct"},"1878":{"crate_id":2,"path":["core","task","wake","RawWaker"],"kind":"struct"},"116":{"crate_id":0,"path":["assertables","assert_abs_diff"],"kind":"module"},"997":{"crate_id":0,"path":["assertables","assert_program_args_stderr_ne_x"],"kind":"macro"},"2759":{"crate_id":17,"path":["object","macho","FilesetEntryCommand"],"kind":"struct"},"3086":{"crate_id":11,"path":["hashbrown","map","IntoKeys"],"kind":"struct"},"443":{"crate_id":0,"path":["assertables","debug_assert_ready_eq_x"],"kind":"macro"},"1324":{"crate_id":2,"path":["core","pin","PinCoerceUnsized"],"kind":"trait"},"2205":{"crate_id":2,"path":["core","cell","BorrowRefMut"],"kind":"struct"},"2532":{"crate_id":17,"path":["object","read","FileKind"],"kind":"enum"},"770":{"crate_id":0,"path":["assertables","assert_io_read_to_string_contains"],"kind":"macro"},"1651":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"3413":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_background_policy"],"kind":"struct"},"1978":{"crate_id":6,"path":["libc","unix","servent"],"kind":"struct"},"216":{"crate_id":0,"path":["assertables","assert_count","assert_count_eq_x"],"kind":"module"},"1097":{"crate_id":0,"path":["assertables","debug_assert_result_err"],"kind":"macro"},"2859":{"crate_id":16,"path":["gimli","read","cfi","EhHdrTable"],"kind":"struct"},"3186":{"crate_id":2,"path":["core","core_arch","simd","u8x4"],"kind":"struct"},"543":{"crate_id":0,"path":["assertables","debug_assert_fn_eq_x"],"kind":"macro"},"1424":{"crate_id":2,"path":["core","convert","TryInto"],"kind":"trait"},"2305":{"crate_id":3,"path":["alloc","collections","binary_heap","Iter"],"kind":"struct"},"2632":{"crate_id":17,"path":["object","macho","RelocationInfo"],"kind":"struct"},"870":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_gt_x"],"kind":"module"},"1751":{"crate_id":17,"path":["object","read","coff","import","ImportFile"],"kind":"struct"},"1197":{"crate_id":2,"path":["core","intrinsics","fallback","DisjointBitOr"],"kind":"trait"},"316":{"crate_id":0,"path":["assertables","debug_assert_len_lt_x"],"kind":"macro"},"2078":{"crate_id":2,"path":["core","io","borrowed_buf","BorrowedBuf"],"kind":"struct"},"2959":{"crate_id":3,"path":["alloc","collections","btree","map","ValuesMut"],"kind":"struct"},"3286":{"crate_id":1,"path":["std","sys","pal","unix","time","Instant"],"kind":"struct"},"643":{"crate_id":0,"path":["assertables","assert_fn_ok_ge_x"],"kind":"macro"},"1524":{"crate_id":2,"path":["core","num","dec2flt","common","BiasedFp"],"kind":"struct"},"2405":{"crate_id":3,"path":["alloc","vec","drain","Drain"],"kind":"struct"},"1851":{"crate_id":1,"path":["std","collections","hash","set","HashSet"],"kind":"struct"},"89":{"crate_id":0,"path":["assertables","assert_abs_diff_gt_x_as_result"],"kind":"macro"},"970":{"crate_id":0,"path":["assertables","assert_program_args_stderr_lt"],"kind":"macro"},"2732":{"crate_id":17,"path":["object","macho","SubUmbrellaCommand"],"kind":"struct"},"1297":{"crate_id":1,"path":["std","backtrace","BytesOrWide"],"kind":"enum"},"416":{"crate_id":0,"path":["assertables","debug_assert_some_ne_x"],"kind":"macro"},"2178":{"crate_id":6,"path":["libc","unix","bsd","ifaddrs"],"kind":"struct"},"3059":{"crate_id":17,"path":["object","macho","DysymtabCommand"],"kind":"struct"},"2505":{"crate_id":1,"path":["std","collections","hash","set","Entry"],"kind":"enum"},"743":{"crate_id":0,"path":["assertables","assert_io_read_to_string_ne_as_result"],"kind":"macro"},"1624":{"crate_id":2,"path":["core","marker","PhantomData"],"kind":"struct"},"3386":{"crate_id":2,"path":["core","range","iter","IterRangeFrom"],"kind":"struct"},"1951":{"crate_id":16,"path":["gimli","read","dwarf","Unit"],"kind":"struct"},"1070":{"crate_id":0,"path":["assertables","assert_status"],"kind":"module"},"189":{"crate_id":0,"path":["assertables","assert_count_eq"],"kind":"macro"},"2832":{"crate_id":6,"path":["libc","unix","bsd","apple","b64","aarch64","malloc_zone_t"],"kind":"struct"},"1397":{"crate_id":2,"path":["core","core_simd","swizzle","shift_elements_right","Shift"],"kind":"struct"},"516":{"crate_id":0,"path":["assertables","assert_set"],"kind":"module"},"2278":{"crate_id":3,"path":["alloc","collections","binary_heap","RebuildOnDrop"],"kind":"struct"},"3159":{"crate_id":2,"path":["core","iter","adapters","step_by","StepBy"],"kind":"struct"},"2605":{"crate_id":17,"path":["object","read","elf","version","VernauxIterator"],"kind":"struct"},"843":{"crate_id":0,"path":["assertables","assert_command_stderr_gt"],"kind":"macro"},"1724":{"crate_id":1,"path":["std","sys","stdio","unix","Stdin"],"kind":"struct"},"2051":{"crate_id":18,"path":["memchr","arch","generic","memchr","One"],"kind":"struct"},"289":{"crate_id":0,"path":["assertables","assert_len","assert_len_le"],"kind":"module"},"1170":{"crate_id":16,"path":["gimli","read","rnglists","RangeLists"],"kind":"struct"},"2932":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x2x2_t"],"kind":"struct"},"3259":{"crate_id":17,"path":["object","macho","SegmentCommand64"],"kind":"struct"},"616":{"crate_id":0,"path":["assertables","assert_fn_ok_eq_as_result"],"kind":"macro"},"1497":{"crate_id":17,"path":["object","read","CodeView"],"kind":"struct"},"2378":{"crate_id":1,"path":["std","sys","process","unix","common","Argv"],"kind":"struct"},"2705":{"crate_id":16,"path":["gimli","read","cfi","SectionBaseAddresses"],"kind":"struct"},"62":{"crate_id":0,"path":["assertables","assert_f64","assert_f64_ge"],"kind":"module"},"943":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_ne_x"],"kind":"module"},"1824":{"crate_id":18,"path":["memchr","arch","all","twoway","SuffixKind"],"kind":"enum"},"2151":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint8x16_t"],"kind":"struct"},"389":{"crate_id":0,"path":["assertables","assert_none_as_result"],"kind":"macro"},"1270":{"crate_id":3,"path":["alloc","collections","vec_deque","iter","Iter"],"kind":"struct"},"3032":{"crate_id":9,"path":["miniz_oxide","MZFlush"],"kind":"enum"},"3359":{"crate_id":2,"path":["core","task","wake","Context"],"kind":"struct"},"716":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_is_match"],"kind":"macro"},"1597":{"crate_id":2,"path":["core","core_arch","simd","i64x4"],"kind":"struct"},"2478":{"crate_id":1,"path":["std","panicking","Hook"],"kind":"enum"},"2805":{"crate_id":1,"path":["std","pointer"],"kind":"primitive"},"162":{"crate_id":0,"path":["assertables","assert_in","assert_in_epsilon"],"kind":"module"},"1043":{"crate_id":0,"path":["assertables","assert_status_code_value_ne"],"kind":"macro"},"1924":{"crate_id":2,"path":["core","marker","PhantomPinned"],"kind":"struct"},"1370":{"crate_id":2,"path":["core","core_arch","simd","i8x4"],"kind":"struct"},"489":{"crate_id":0,"path":["assertables","debug_assert_iter_ne"],"kind":"macro"},"2251":{"crate_id":2,"path":["core","core_arch","simd","m8x32"],"kind":"struct"},"3132":{"crate_id":18,"path":["memchr","arch","aarch64","neon","packedpair","Finder"],"kind":"struct"},"3459":{"crate_id":3,"path":["alloc","boxed","thin","drop","DropGuard"],"kind":"struct"},"816":{"crate_id":0,"path":["assertables","assert_command_stdout_le_x"],"kind":"macro"},"1697":{"crate_id":2,"path":["core","slice","ascii","EscapeByte"],"kind":"struct"},"2578":{"crate_id":17,"path":["object","read","archive","ArchiveMemberIterator"],"kind":"struct"},"2024":{"crate_id":17,"path":["object","pe","ImportObjectHeader"],"kind":"struct"},"262":{"crate_id":0,"path":["assertables","debug_assert_not_empty"],"kind":"macro"},"1143":{"crate_id":0,"path":["assertables","debug_assert_command_stdout_contains"],"kind":"macro"},"2905":{"crate_id":2,"path":["core","iter","adapters","by_ref_sized","ByRefSized"],"kind":"struct"},"1470":{"crate_id":15,"path":["addr2line","line","LineLocationRangeIter"],"kind":"struct"},"589":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_ne"],"kind":"module"},"2351":{"crate_id":1,"path":["std","net","udp","UdpSocket"],"kind":"struct"},"3232":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","mmap","Mmap"],"kind":"struct"},"916":{"crate_id":0,"path":["assertables","assert_program_args_stdout_ne"],"kind":"macro"},"35":{"crate_id":0,"path":["assertables","assert_f32_ge_as_result"],"kind":"macro"},"1797":{"crate_id":18,"path":["memchr","arch","aarch64","neon","memchr","TwoIter"],"kind":"struct"},"2678":{"crate_id":2,"path":["core","ptr","metadata","DynMetadata"],"kind":"struct"},"2124":{"crate_id":3,"path":["alloc","collections","btree","map","entry","Entry"],"kind":"enum"},"362":{"crate_id":0,"path":["assertables","assert_ok"],"kind":"macro"},"1243":{"crate_id":17,"path":["object","pe","ImageImportDescriptor"],"kind":"struct"},"3005":{"crate_id":11,"path":["hashbrown","map","HashMap"],"kind":"struct"},"1570":{"crate_id":3,"path":["alloc","ffi","c_str","FromVecWithNulError"],"kind":"struct"},"689":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_eq_x_as_result"],"kind":"macro"},"2451":{"crate_id":2,"path":["core","core_simd","simd","num","sealed","Sealed"],"kind":"trait"},"3332":{"crate_id":1,"path":["std","fs","read_to_string"],"kind":"function"},"2778":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x2x2_t"],"kind":"struct"},"135":{"crate_id":0,"path":["assertables","assert_diff","assert_diff_ge_x"],"kind":"module"},"1016":{"crate_id":0,"path":["assertables","assert_status_success_false_as_result"],"kind":"macro"},"1897":{"crate_id":17,"path":["object","read","any","SegmentInternal"],"kind":"enum"},"2224":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","poly16x8x2_t"],"kind":"struct"},"462":{"crate_id":0,"path":["assertables","assert_bag_superbag"],"kind":"macro"},"1343":{"crate_id":18,"path":["memchr","memmem","searcher","PrefilterState"],"kind":"struct"},"3105":{"crate_id":2,"path":["core","ops","range","OneSidedRange"],"kind":"trait"},"3432":{"crate_id":17,"path":["object","read","elf","attributes","AttributesSubsectionIterator"],"kind":"struct"},"1670":{"crate_id":1,"path":["std","sys","personality","dwarf","eh","EHContext"],"kind":"struct"},"789":{"crate_id":0,"path":["assertables","assert_command_stdout_gt_as_result"],"kind":"macro"},"2551":{"crate_id":17,"path":["object","read","pe","import","Import"],"kind":"enum"},"2878":{"crate_id":2,"path":["core","marker","variance","PhantomContravariantLifetime"],"kind":"struct"},"235":{"crate_id":0,"path":["assertables","debug_assert_count_ne_x"],"kind":"macro"},"1116":{"crate_id":0,"path":["assertables","assert_option_some_ne_as_result"],"kind":"macro"},"1997":{"crate_id":17,"path":["object","pe","ImageDataDirectory"],"kind":"struct"},"2324":{"crate_id":18,"path":["memchr","memchr","Memchr2"],"kind":"struct"},"562":{"crate_id":0,"path":["assertables","assert_fn_ne_x_as_result"],"kind":"macro"},"1443":{"crate_id":16,"path":["gimli","read","dwarf","DwarfSections"],"kind":"struct"},"3205":{"crate_id":16,"path":["gimli","common","DebugLineOffset"],"kind":"struct"},"889":{"crate_id":0,"path":["assertables","assert_command_stderr_string_is_match"],"kind":"macro"},"8":{"crate_id":0,"path":["assertables","assert_gt"],"kind":"macro"},"1770":{"crate_id":6,"path":["libc","unix","bsd","sockaddr_un"],"kind":"struct"},"2651":{"crate_id":16,"path":["gimli","read","Error"],"kind":"enum"},"2978":{"crate_id":3,"path":["alloc","string","String"],"kind":"struct"},"335":{"crate_id":0,"path":["assertables","assert_starts_with","assert_not_starts_with"],"kind":"module"},"1216":{"crate_id":17,"path":["object","xcoff","FileAux64"],"kind":"struct"},"2097":{"crate_id":2,"path":["core","core_arch","simd","m8x16"],"kind":"struct"},"1543":{"crate_id":6,"path":["libc","unix","rlimit"],"kind":"struct"},"662":{"crate_id":0,"path":["assertables","assert_fn_ok","assert_fn_ok_ne_x"],"kind":"module"},"2424":{"crate_id":1,"path":["std","io","cursor","Cursor"],"kind":"struct"},"3305":{"crate_id":2,"path":["core","core_arch","aarch64","neon","float64x2_t"],"kind":"struct"},"989":{"crate_id":0,"path":["assertables","assert_program_args_stderr_le_x"],"kind":"macro"},"108":{"crate_id":0,"path":["assertables","assert_abs_diff","assert_abs_diff_lt"],"kind":"module"},"1870":{"crate_id":2,"path":["core","any","TypeId"],"kind":"struct"},"2751":{"crate_id":17,"path":["object","xcoff","BlockAux64"],"kind":"struct"},"3078":{"crate_id":1,"path":["std","sys","sync","once","queue","WaiterQueue"],"kind":"struct"},"435":{"crate_id":0,"path":["assertables","debug_assert_ready_eq"],"kind":"macro"},"1316":{"crate_id":17,"path":["object","macho","SubFrameworkCommand"],"kind":"struct"},"2197":{"crate_id":17,"path":["object","read","ObjectMapFile"],"kind":"struct"},"1643":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x4x3_t"],"kind":"struct"},"762":{"crate_id":0,"path":["assertables","assert_io_read_to_string_lt_x"],"kind":"macro"},"2524":{"crate_id":3,"path":["alloc","collections","vec_deque","VecDeque"],"kind":"struct"},"3405":{"crate_id":2,"path":["core","core_arch","simd","i16x16"],"kind":"struct"},"1089":{"crate_id":0,"path":["assertables","assert_abs_diff_le_as_result"],"kind":"macro"},"208":{"crate_id":0,"path":["assertables","assert_count","assert_count_lt"],"kind":"module"},"1970":{"crate_id":17,"path":["object","read","elf","attributes","AttributesSubsubsectionIterator"],"kind":"struct"},"2851":{"crate_id":1,"path":["std","sync","once_lock","OnceLock"],"kind":"struct"},"2297":{"crate_id":1,"path":["std","io","error","Result"],"kind":"type_alias"},"535":{"crate_id":0,"path":["assertables","debug_assert_fn_lt"],"kind":"macro"},"1416":{"crate_id":6,"path":["libc","unix","bsd","tm"],"kind":"struct"},"3178":{"crate_id":1,"path":["std","sys","process","unix","unix","ExitStatusError"],"kind":"struct"},"1743":{"crate_id":1,"path":["std","sys","net","connection","socket","TcpStream"],"kind":"struct"},"862":{"crate_id":0,"path":["assertables","assert_command","assert_command_stderr_eq_x"],"kind":"module"},"2624":{"crate_id":17,"path":["object","read","elf","version","VerdauxIterator"],"kind":"struct"},"2951":{"crate_id":1,"path":["std","net","tcp","TcpListener"],"kind":"struct"},"308":{"crate_id":0,"path":["assertables","debug_assert_len_gt_x"],"kind":"macro"},"1189":{"crate_id":6,"path":["libc","unix","bsd","apple","vinfo_stat"],"kind":"struct"},"2070":{"crate_id":2,"path":["core","marker","variance","sealed","Sealed"],"kind":"trait"},"2397":{"crate_id":1,"path":["std","fs","FileTimes"],"kind":"struct"},"635":{"crate_id":0,"path":["assertables","assert_fn_ok_ne"],"kind":"macro"},"1516":{"crate_id":6,"path":["libc","unix","winsize"],"kind":"struct"},"3278":{"crate_id":1,"path":["std","sys","thread_local","abort_on_dtor_unwind","DtorUnwindGuard"],"kind":"struct"},"1843":{"crate_id":17,"path":["object","macho","DyldSubCacheEntryV2"],"kind":"struct"},"81":{"crate_id":0,"path":["assertables","assert_abs_diff_eq_x_as_result"],"kind":"macro"},"962":{"crate_id":0,"path":["assertables","assert_program_args_stderr_gt"],"kind":"macro"},"2724":{"crate_id":6,"path":["libc","unix","bsd","apple","arphdr"],"kind":"struct"},"3051":{"crate_id":1,"path":["std","sys","net","connection","socket","UdpSocket"],"kind":"struct"},"408":{"crate_id":0,"path":["assertables","debug_assert_some_ne"],"kind":"macro"},"1289":{"crate_id":16,"path":["gimli","constants","DwEnd"],"kind":"struct"},"2170":{"crate_id":2,"path":["core","future","ready","Ready"],"kind":"struct"},"2497":{"crate_id":3,"path":["alloc","vec","into_iter","drop","DropGuard"],"kind":"struct"},"735":{"crate_id":0,"path":["assertables","assert_io_read_to_string_le_as_result"],"kind":"macro"},"1616":{"crate_id":2,"path":["core","core_simd","simd","cmp","eq","SimdPartialEq"],"kind":"trait"},"3378":{"crate_id":2,"path":["core","ops","deref","DerefMut"],"kind":"trait"},"1062":{"crate_id":0,"path":["assertables","assert_status","assert_status_code_value_le_x"],"kind":"module"},"181":{"crate_id":0,"path":["assertables","assert_contains_as_result"],"kind":"macro"},"1943":{"crate_id":17,"path":["object","pe","ImageResourceDirectoryString"],"kind":"struct"},"2824":{"crate_id":1,"path":["std","sync","mpmc","list","Position"],"kind":"struct"},"3151":{"crate_id":2,"path":["core","marker","StructuralPartialEq"],"kind":"trait"},"508":{"crate_id":0,"path":["assertables","assert_set_subset"],"kind":"macro"},"1389":{"crate_id":17,"path":["object","xcoff","FileAux32"],"kind":"struct"},"2270":{"crate_id":2,"path":["core","core_arch","simd","f64x4"],"kind":"struct"},"1716":{"crate_id":4,"path":["compiler_builtins","math","libm","support","hex_float","Hexf"],"kind":"struct"},"835":{"crate_id":0,"path":["assertables","assert_command_stderr_eq"],"kind":"macro"},"2597":{"crate_id":6,"path":["libc","unix","bsd","apple","thread_standard_policy"],"kind":"struct"},"1162":{"crate_id":0,"path":["assertables","assert_program_args_stderr_contains"],"kind":"macro"},"281":{"crate_id":0,"path":["assertables","assert_len","assert_len_ge"],"kind":"module"},"2043":{"crate_id":17,"path":["object","elf","Rela64"],"kind":"struct"},"2924":{"crate_id":2,"path":["core","io","borrowed_buf","BorrowedCursor"],"kind":"struct"},"3251":{"crate_id":6,"path":["libc","unix","bsd","apple","ifreq"],"kind":"struct"},"608":{"crate_id":0,"path":["assertables","debug_assert_fn_err_lt_x"],"kind":"macro"},"1489":{"crate_id":17,"path":["object","endian","I16Bytes"],"kind":"struct"},"2370":{"crate_id":2,"path":["core","slice","iter","RSplitMut"],"kind":"struct"},"1816":{"crate_id":2,"path":["core","core_arch","simd","f16x16"],"kind":"struct"},"54":{"crate_id":0,"path":["assertables","assert_f32"],"kind":"module"},"935":{"crate_id":0,"path":["assertables","assert_program_args","assert_program_args_stdout_le_x"],"kind":"module"},"2697":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"1262":{"crate_id":16,"path":["gimli","common","Format"],"kind":"enum"},"381":{"crate_id":0,"path":["assertables","assert_ok","assert_ok_ne_x"],"kind":"module"},"2143":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","splat","JustOne"],"kind":"struct"},"3024":{"crate_id":17,"path":["object","pe","ImageCoffSymbolsHeader"],"kind":"struct"},"2470":{"crate_id":11,"path":["hashbrown","raw_entry","RawEntryBuilder"],"kind":"struct"},"708":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_ne_x"],"kind":"macro"},"1589":{"crate_id":9,"path":["miniz_oxide","inflate","core","DecompressorOxide"],"kind":"struct"},"3351":{"crate_id":1,"path":["std","random","DefaultRandomSource"],"kind":"struct"},"1916":{"crate_id":17,"path":["object","read","elf","section","SectionTable"],"kind":"struct"},"154":{"crate_id":0,"path":["assertables","assert_in_as_result"],"kind":"macro"},"1035":{"crate_id":0,"path":["assertables","assert_status_code_value_le"],"kind":"macro"},"2797":{"crate_id":17,"path":["object","macho","LcStr"],"kind":"struct"},"3124":{"crate_id":3,"path":["alloc","collections","btree","navigate","LazyLeafHandle"],"kind":"enum"},"1362":{"crate_id":16,"path":["gimli","constants","DwAt"],"kind":"struct"},"481":{"crate_id":0,"path":["assertables","debug_assert_iter_le"],"kind":"macro"},"2243":{"crate_id":2,"path":["core","num","flt2dec","Sign"],"kind":"enum"},"2570":{"crate_id":3,"path":["alloc","ffi","c_str","IntoStringError"],"kind":"struct"},"808":{"crate_id":0,"path":["assertables","assert_command_stdout_ge_x"],"kind":"macro"},"1689":{"crate_id":4,"path":["compiler_builtins","math","libm","fma","Norm"],"kind":"struct"},"3451":{"crate_id":11,"path":["hashbrown","map","EntryRef"],"kind":"enum"},"2016":{"crate_id":2,"path":["core","core_arch","simd","splat","JustOne"],"kind":"struct"},"254":{"crate_id":0,"path":["assertables","assert_ends_with","assert_not_ends_with"],"kind":"module"},"1135":{"crate_id":0,"path":["assertables","debug_assert_fs_read_to_string_matches"],"kind":"macro"},"2897":{"crate_id":2,"path":["core","fmt","UpperHex"],"kind":"trait"},"3224":{"crate_id":3,"path":["alloc","collections","btree","set","IntersectionInner"],"kind":"enum"},"581":{"crate_id":0,"path":["assertables","assert_fn_err","assert_fn_err_le"],"kind":"module"},"1462":{"crate_id":3,"path":["alloc","collections","vec_deque","drain","Drain"],"kind":"struct"},"2343":{"crate_id":17,"path":["object","read","elf","segment","ElfSegment"],"kind":"struct"},"2670":{"crate_id":7,"path":["unwind"],"kind":"module"},"27":{"crate_id":0,"path":["assertables","assert_eq_f64_as_result"],"kind":"macro"},"908":{"crate_id":0,"path":["assertables","assert_program_args_stdout_le"],"kind":"macro"},"1789":{"crate_id":17,"path":["object","read","pe","import","ImportThunkList"],"kind":"struct"},"1235":{"crate_id":16,"path":["gimli","read","dwarf","DwarfPackageSections"],"kind":"struct"},"354":{"crate_id":0,"path":["assertables","assert_err_eq_x_as_result"],"kind":"macro"},"2116":{"crate_id":18,"path":["memchr","cow","CowBytes"],"kind":"struct"},"2997":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","uint32x2x4_t"],"kind":"struct"},"3324":{"crate_id":1,"path":["std","sys","process","unix","common","CommandArgs"],"kind":"struct"},"681":{"crate_id":0,"path":["assertables","assert_fs_read_to_string_lt_as_result"],"kind":"macro"},"1562":{"crate_id":2,"path":["core","str","pattern","MultiCharEqSearcher"],"kind":"struct"},"2443":{"crate_id":17,"path":["object","read","elf","note","NoteIterator"],"kind":"struct"},"2770":{"crate_id":16,"path":["gimli","read","line","LineRows"],"kind":"struct"},"127":{"crate_id":0,"path":["assertables","assert_approx"],"kind":"module"},"1008":{"crate_id":0,"path":["assertables","assert_program_args_stderr_string_is_match_as_result"],"kind":"macro"},"1889":{"crate_id":6,"path":["libc","unix","protoent"],"kind":"struct"},"1335":{"crate_id":2,"path":["core","core_arch","arm_shared","neon","float16x8x2_t"],"kind":"struct"},"454":{"crate_id":0,"path":["assertables","assert_bag_ne"],"kind":"macro"},"2216":{"crate_id":1,"path":["std","sys","sync","thread_parking","darwin","Parker"],"kind":"struct"},"3097":{"crate_id":2,"path":["core","future","future","Future"],"kind":"trait"},"3424":{"crate_id":16,"path":["gimli","constants","DwMacro"],"kind":"struct"},"781":{"crate_id":0,"path":["assertables","assert_command_stdout_eq_as_result"],"kind":"macro"},"1662":{"crate_id":3,"path":["alloc","collections","binary_heap","Hole"],"kind":"struct"},"2543":{"crate_id":2,"path":["core","slice","sort","unstable","quicksort","GapGuardRaw"],"kind":"struct"},"1989":{"crate_id":2,"path":["core","core_simd","cast","sealed","Sealed"],"kind":"trait"},"227":{"crate_id":0,"path":["assertables","debug_assert_count_le_x"],"kind":"macro"},"1108":{"crate_id":0,"path":["assertables","assert_option_none"],"kind":"macro"},"2870":{"crate_id":11,"path":["hashbrown","set","Drain"],"kind":"struct"},"1435":{"crate_id":2,"path":["core","char","decode","DecodeUtf16"],"kind":"struct"},"554":{"crate_id":0,"path":["assertables","assert_fn_le_x_as_result"],"kind":"macro"},"2316":{"crate_id":6,"path":["libc","unix","bsd","apple","xucred"],"kind":"struct"},"3197":{"crate_id":17,"path":["object","read","coff","section","CoffSection"],"kind":"struct"},"2643":{"crate_id":11,"path":["hashbrown","table","IterHashMut"],"kind":"struct"},"881":{"crate_id":0,"path":["assertables","debug_assert_command_stderr_ne_x"],"kind":"macro"}},"external_crates":{"11":{"name":"hashbrown","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"3":{"name":"alloc","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"14":{"name":"rustc_demangle","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"6":{"name":"libc","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"17":{"name":"object","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"9":{"name":"miniz_oxide","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"1":{"name":"std","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"12":{"name":"rustc_std_workspace_alloc","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"4":{"name":"compiler_builtins","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"15":{"name":"addr2line","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"7":{"name":"unwind","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"18":{"name":"memchr","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"10":{"name":"adler2","html_root_url":"https://docs.rs/adler2/2.0.0/"},"2":{"name":"core","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"13":{"name":"std_detect","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"5":{"name":"rustc_std_workspace_core","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"16":{"name":"gimli","html_root_url":"https://doc.rust-lang.org/1.87.0/"},"8":{"name":"cfg_if","html_root_url":"https://docs.rs/cfg-if/"},"19":{"name":"panic_unwind","html_root_url":"https://doc.rust-lang.org/1.87.0/"}},"format_version":43}