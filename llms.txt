# Crate Documentation

**Version:** 9.8.0

**Format Version:** 43

# Module `assertables`

# Assertables: assert macros for better testing

Assertables is a Rust crate that provides many assert macros
to improve your compile-time tests and run-time reliability.

**[documentation](https://docs.rs/assertables/)**
•
**[source](https://github.com/sixarm/assertables-rust-crate/)**
•
**[llms.txt](https://raw.githubusercontent.com/sixarm/assertables-rust-crate/refs/heads/main/llms.txt)**
•
**[crate](https://crates.io/crates/assertables)**
•
**[email](mailto:joel@joelparkerhenderson.com)**

## Introduction

The Assertables Rust crate provides many assert macros
that can help you develop, test, and debug.

* Test values with
  [assert_lt](module@crate::assert_lt),
  [assert_gt](module@crate::assert_gt),
  [assert_in](module@crate::assert_in),
  […](https://docs.rs/assertables)
* Test groups with
  [assert_all](module@crate::assert_all),
  [assert_any](module@crate::assert_any),
  [assert_iter](module@crate::assert_iter),
  […](https://docs.rs/assertables)
* Test wrappers with
  [assert_ok](module@crate::assert_ok),
  [assert_some](module@crate::assert_some),
  [assert_ready](module@crate::assert_ready),
  […](https://docs.rs/assertables)
* Test matching with
  [assert_matches](module@crate::assert_matches),
  [assert_is_match](module@crate::assert_is_match),
  […](https://docs.rs/assertables)
* Test nearness with
  [assert_approx](module@crate::assert_approx),
  [assert_abs_diff](module@crate::assert_abs_diff),
  […](https://docs.rs/assertables/)
* Test programs with
  [assert_command](module@crate::assert_command),
  [assert_status](module@crate::assert_status),
  […](https://docs.rs/assertables)
* Many more below.

To use this crate, add it to your file `Cargo.toml`:

```toml
assertables = "9.8.0"
```

Benefits:

* You will write better tests to improve reliability and maintainability.
* You will handle more corner cases without needing to write custom code.
* You will troubleshoot faster because error messages show more detail.

Learning:
[FAQ](https://github.com/SixArm/assertables-rust-crate/tree/main/help/faq),
[docs](https://docs.rs/assertables/),
[examples](https://github.com/SixArm/assertables-rust-crate/blob/main/tests/examples/),
[changes](https://github.com/SixArm/assertables-rust-crate/tree/main/CHANGES.md),
[upgrades](https://github.com/SixArm/assertables-rust-crate/tree/main/help/upgrades/upgrade-from-version-8-to-9),
[developing](https://github.com/SixArm/assertables-rust-crate/tree/main/help/developing/).

Comparisons:
[more_asserts](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/more_asserts),
[cool_asserts](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/cool_asserts),
[assert2](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/assert2),
[claims](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons/claims),
[etc.](https://github.com/SixArm/assertables-rust-crate/tree/main/help/comparisons)

## Examples

Examples with numbers:

```rust
# use assertables::*;
let i = 1;
assert_lt!(i, 5);
assert_diff_eq_x!(i, 5, 4);
assert_in_range!(i, 1..5);
```

Examples with strings:

```rust
# use assertables::*;
# use regex::Regex;
let s = "hello";
assert_starts_with!(s, "h");
assert_contains!(s, "e");
assert_is_match!(Regex::new(r"h.*o").unwrap(), s);
```

Examples with arrays:

```rust
# use assertables::*;
let a = [1, 2, 3];
assert_not_empty!(a);
assert_len_eq_x!(a, 3);
assert_all!(a.into_iter(), |i: i32| i < 4);
```

## Highlights

Values:

* [`assert_eq!(a, b)`](module@crate::assert_eq)
* [`assert_ne!(a, b)`](module@crate::assert_ne)
* [`assert_ge!(a, b)`](module@crate::assert_ge)
* [`assert_gt!(a, b)`](module@crate::assert_gt)
* [`assert_le!(a, b)`](module@crate::assert_le)
* [`assert_lt!(a, b)`](module@crate::assert_lt)

Floats:
 
* [`assert_f32_eq!(a, b)`](module@crate::assert_f32::assert_f32_eq)
* [`assert_f64_eq!(a, b)`](module@crate::assert_f64::assert_f64_eq)

Nearness:

* [`assert_approx_eq!(a, b)`](module@crate::assert_approx::assert_approx_eq)
* [`assert_in_delta!(a, b, delta)`](module@crate::assert_in::assert_in_delta)
* [`assert_in_epsilon!(a, b, epsilon)`](module@crate::assert_in::assert_in_epsilon)
* [`assert_in_range!(a, range)`](module@crate::assert_in::assert_in_range)
* [`assert_diff_eq_x!(a, b, x)`](module@crate::assert_diff::assert_diff_eq_x)
* [`assert_abs_diff_eq_x!(a, b, x)`](module@crate::assert_abs_diff::assert_abs_diff_eq_x)

Groups:

* [`assert_all!(group, predicate)`](module@crate::assert_all)
* [`assert_any!(group, predicate)`](module@crate::assert_any)
* [`assert_is_empty!(group)`](module@crate::assert_is_empty::assert_is_empty)
* [`assert_len_eq!(a, b)`](module@crate::assert_len::assert_len_eq)
* [`assert_count_eq!(a, b)`](module@crate::assert_count::assert_count_eq)

Matching:

* [`assert_starts_with!(sequence, x)`](module@crate::assert_starts_with)
* [`assert_ends_with!(sequence, x)`](module@crate::assert_ends_with)
* [`assert_contains!(container, x)`](module@crate::assert_contains)
* [`assert_is_match!(matcher, x)`](module@crate::assert_is_match)
* [`assert_matches!(expr, pattern)`](module@crate::assert_matches)
* [`assert_email_address!(string)`](module@crate::assert_email_address)

Results:

* [`assert_ok!(result)`](module@crate::assert_ok)
* [`assert_ok_eq_x!(result, x)`](module@crate::assert_ok::assert_ok_eq_x)
* [`assert_ok_ne_x!(result, x)`](module@crate::assert_ok::assert_ok_ne_x)
* [`assert_err!(result)`](module@crate::assert_err)

Options:

* [`assert_some!(option)`](module@crate::assert_some)
* [`assert_some_eq_x!(option, x)`](module@crate::assert_some::assert_some_eq_x)
* [`assert_some_ne_x!(option, x)`](module@crate::assert_some::assert_some_ne_x)
* [`assert_none!(option)`](module@crate::assert_none)

Polls:

* [`assert_ready!(poll)`](module@crate::assert_ready)
* [`assert_ready_eq_x!(poll, x)`](module@crate::assert_ready::assert_ready_eq_x)
* [`assert_ready_ne_x!(poll, x)`](module@crate::assert_ready::assert_ready_ne_x)
* [`assert_pending!(poll)`](module@crate::assert_pending)

Iterators:

* [`assert_iter_eq!(a, b)`](module@crate::assert_iter::assert_iter_eq)
* [`assert_iter_ne!(a, b)`](module@crate::assert_iter::assert_iter_ne)
* [`assert_iter_ge!(a, b)`](module@crate::assert_iter::assert_iter_ge)
* [`assert_iter_gt!(a, b)`](module@crate::assert_iter::assert_iter_gt)
* [`assert_iter_le!(a, b)`](module@crate::assert_iter::assert_iter_le)
* [`assert_iter_lt!(a, b)`](module@crate::assert_iter::assert_iter_lt)
 
Sets:

* [`assert_set_eq!(a, b)`](module@crate::assert_set::assert_set_eq)
* [`assert_set_ne!(a, b)`](module@crate::assert_set::assert_set_ne)
* [`assert_set_subset!(a, b)`](module@crate::assert_set::assert_set_subset)
* [`assert_set_superset!(a, b)`](module@crate::assert_set::assert_set_superset)

Bags:

* [`assert_bag_eq!(a, b)`](module@crate::assert_bag::assert_bag_eq)
* [`assert_bag_ne!(a, b)`](module@crate::assert_bag::assert_bag_ne)
* [`assert_bag_subbag!(a, b)`](module@crate::assert_bag::assert_bag_subbag)
* [`assert_bag_superbag!(a, b)`](module@crate::assert_bag::assert_bag_superbag)
 
Readers:

* [`assert_fs_read_to_string_eq_x!(path, x)`](module@crate::assert_fs_read_to_string)
* [`assert_io_read_to_string_eq_x!(reader, x)`](module@crate::assert_io_read_to_string)

Commands:

* [`assert_command_stdout_eq_x!(command, x)`](module@crate::assert_command) `// command ⇒ stdout == x`
* [`assert_program_args_stdout_eq_x!(program, args, x)`](module@crate::assert_program_args) `// program.args ⇒ stdout == x`

Status:

* [`assert_status_success!(a)`](module@crate::assert_status::assert_status_success)
* [`assert_status_code_value_eq_x!(a, x)`](module@crate::assert_status::assert_status_code_value_eq_x)
* [`assert_status_code_value_ne_x!(a, x)`](module@crate::assert_status::assert_status_code_value_ne_x)
* [`assert_status_failure!(a)`](module@crate::assert_status::assert_status_failure)

Infix values:
 
* [`assert_infix!(a == b)`](module@crate::assert_infix)
* [`assert_infix!(a != b)`](module@crate::assert_infix)
* [`assert_infix!(a < b)`](module@crate::assert_infix)
* [`assert_infix!(a <= b)`](module@crate::assert_infix)
* [`assert_infix!(a > b)`](module@crate::assert_infix)
* [`assert_infix!(a >= b)`](module@crate::assert_infix)
 
Infix logic:
 
* [`assert_infix!(a & b)`](module@crate::assert_infix)
* [`assert_infix!(a | b)`](module@crate::assert_infix)
* [`assert_infix!(a ^ b)`](module@crate::assert_infix)
* [`assert_infix!(a && b)`](module@crate::assert_infix)
* [`assert_infix!(a || b)`](module@crate::assert_infix)

For a complete list of modules and macros, see the
[docs](https://docs.rs/assertables/).

## Forms

The Assertables macros have a variety of forms to help you write the tests that matter most to you.

All the macros have forms for an optional message:

* [`assert_gt!(a, b)`](module@crate::assert_gt) `// default message`
* [`assert_gt!(a, b, "your text")`](module@crate::assert_gt) `// custom message`

All the macros have forms for different outcomes:

* [`assert_gt!(1, 2)`](macro@crate::assert_gt) `// panic`
* [`assert_gt_as_result!(1, 2)`](macro@crate::assert_gt_as_result) `// return Result`
* [`debug_assert_gt!(1, 2)`](macro@crate::debug_assert_gt) `// panic in debug mode`

Many of the macros have a form "compare left item to right item" that compares
items of the same kind, and a form "compare left item to right expression" that
compares one item to any arbitrary expression:

* [`assert_len_eq!(a, b)`](module@crate::assert_ok::assert_ok_eq) `// a.len() = b.len()`
* [`assert_len_eq_x!(a, x)`](module@crate::assert_ok::assert_ok_eq_x)) `// a.len() = x`

Many of the macros has a "success return", which means the macro returns data that you can optionally use for more testing.

* [`let inner = assert_ok!(result)`](module@crate::assert_ok::assert_ok)
* [`let string = assert_fs_read_to_string_ne!("alfa.txt", "")`](module@crate::assert_fs_read_to_string::assert_fs_read_to_string_ne)
* [`let stdout = assert_command_stdout_gt!("ls", vec![b' '])`](module@crate::assert_command::assert_command_stdout_gt)

## Tracking

* Package: assertables-rust-crate
* Version: 9.8.0
* Created: 2021-03-30T15:47:49Z
* Updated: 2025-06-21T22:20:00Z
* License: MIT or Apache-2.0 or GPL-2.0 or GPL-3.0 or contact us for more
* Contact: Joel Parker Henderson (joel@joelparkerhenderson.com)

## Modules

## Module `assert`

Assert a condition is true.

Pseudocode:<br>
condition

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert`](macro@assert),
except this macro returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_as_result`](macro.assert_as_result.html)

```rust
pub mod assert { /* ... */ }
```

## Module `assert_eq`

Assert an expression is equal to another.

Pseudocode:<br>
a = b

# Module macro

* [`assert_eq_as_result`](macro@crate::assert_eq_as_result)

# Rust standard macros

* [`assert_eq`](https://doc.rust-lang.org/std/macro.assert_eq.html)
* [`debug_assert_eq`](https://doc.rust-lang.org/std/macro.debug_assert_eq.html)

```rust
pub mod assert_eq { /* ... */ }
```

## Module `assert_ge`

Assert an expression is greater than or equal to another.

Pseudocode:<br>
a ≥ b

# Example

```rust
use assertables::*;

let a = 2;
let b = 1;
assert_ge!(a, b);
```

# Module macros

* [`assert_ge`](macro@crate::assert_ge)
* [`assert_ge_as_result`](macro@crate::assert_ge_as_result)
* [`debug_assert_ge`](macro@crate::debug_assert_ge)

```rust
pub mod assert_ge { /* ... */ }
```

## Module `assert_gt`

Assert an expression is greater than another.

Pseudocode:<br>
a > b

# Example

```rust
use assertables::*;

let a = 2;
let b = 1;
assert_gt!(a, b);
```

# Module macros

* [`assert_gt`](macro@crate::assert_gt)
* [`assert_gt_as_result`](macro@crate::assert_gt_as_result)
* [`debug_assert_gt`](macro@crate::debug_assert_gt)

```rust
pub mod assert_gt { /* ... */ }
```

## Module `assert_le`

Assert an expression is less than or equal to another.

Pseudocode:<br>
a ≤ b

# Example

```rust
use assertables::*;

let a = 1;
let b = 2;
assert_le!(a, b);
```

# Module macros

* [`assert_le`](macro@crate::assert_le)
* [`assert_le_as_result`](macro@crate::assert_le_as_result)
* [`debug_assert_le`](macro@crate::debug_assert_le)

```rust
pub mod assert_le { /* ... */ }
```

## Module `assert_lt`

Assert an expression is less than another.

Pseudocode:<br>
a < b

# Example

```rust
use assertables::*;

let a = 1;
let b = 2;
assert_lt!(a, b);
```

# Module macros

* [`assert_lt`](macro@crate::assert_lt)
* [`assert_lt_as_result`](macro@crate::assert_lt_as_result)
* [`debug_assert_lt`](macro@crate::debug_assert_lt)

```rust
pub mod assert_lt { /* ... */ }
```

## Module `assert_ne`

Assert an expression is not equal to another.

Pseudocode:<br>
a ≠ b

# Module macro

* [`assert_ne_as_result`](macro@crate::assert_ne_as_result)

# Rust standard macros

* [`assert_ne`](https://doc.rust-lang.org/std/macro.assert_ne.html)
* [`debug_assert_ne`](https://doc.rust-lang.org/std/macro.debug_assert_ne.html)

```rust
pub mod assert_ne { /* ... */ }
```

## Module `assert_eq_f32`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a = b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333333;
assert_eq_f32!(a, b);
```

# Module macros

* [`assert_eq_f32`](macro@crate::assert_eq_f32)
* [`assert_eq_f32_as_result`](macro@crate::assert_eq_f32_as_result)
* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)
Assert a floating point 32-bit number is equal to another within f32::EPSILON.

```rust
pub mod assert_eq_f32 { /* ... */ }
```

## Module `assert_eq_f64`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a = b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333334;
assert_eq_f64!(a, b);
```

# Module macros

* [`assert_eq_f64`](macro@crate::assert_eq_f64)
* [`assert_eq_f64_as_result`](macro@crate::assert_eq_f64_as_result)
* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)

```rust
pub mod assert_eq_f64 { /* ... */ }
```

## Module `assert_f32`

Assert for comparing floating-point 32-bit numbers within 2.0 * EPSILON.

These macros are available:

* [`assert_f32_eq!(a, b)`](macro@crate::assert_f32_eq) ≈ a = b (within 2ε)
* [`assert_f32_ne!(a, b)`](macro@crate::assert_f32_ne) ≈ a ≠ b (within 2ε)

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333333;
assert_f32_eq!(a, b);

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_ne!(a, b);
```

```rust
pub mod assert_f32 { /* ... */ }
```

### Modules

## Module `assert_f32_eq`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a = b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333333;
assert_f32_eq!(a, b);
```

# Module macros

* [`assert_f32_eq`](macro@crate::assert_f32_eq)
* [`assert_f32_eq_as_result`](macro@crate::assert_f32_eq_as_result)
* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)
Assert a floating point 32-bit number is equal to another within f32::EPSILON.

```rust
pub mod assert_f32_eq { /* ... */ }
```

## Module `assert_f32_ge`

Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.

Pseudocode:<br>
a ≥ b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333331;
assert_f32_ge!(a, b);
```

# Module macros

* [`assert_f32_ge`](macro@crate::assert_f32_ge)
* [`assert_f32_ge_as_result`](macro@crate::assert_f32_ge_as_result)
* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)
Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.

```rust
pub mod assert_f32_ge { /* ... */ }
```

## Module `assert_f32_gt`

Assert a floating point 32-bit number is greater than another within f32::EPSILON.

Pseudocode:<br>
a > b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333331;
assert_f32_gt!(a, b);
```

# Module macros

* [`assert_f32_gt`](macro@crate::assert_f32_gt)
* [`assert_f32_gt_as_result`](macro@crate::assert_f32_gt_as_result)
* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)
Assert a floating point 32-bit number is greater than another within f32::EPSILON.

```rust
pub mod assert_f32_gt { /* ... */ }
```

## Module `assert_f32_le`

Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.

Pseudocode:<br>
a ≤ b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_le!(a, b);
```

# Module macros

* [`assert_f32_le`](macro@crate::assert_f32_le)
* [`assert_f32_le_as_result`](macro@crate::assert_f32_le_as_result)
* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)
Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.

```rust
pub mod assert_f32_le { /* ... */ }
```

## Module `assert_f32_lt`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a < b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_lt!(a, b);
```

# Module macros

* [`assert_f32_lt`](macro@crate::assert_f32_lt)
* [`assert_f32_lt_as_result`](macro@crate::assert_f32_lt_as_result)
* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)
Assert a floating point 32-bit number is equal to another within f32::EPSILON.

```rust
pub mod assert_f32_lt { /* ... */ }
```

## Module `assert_f32_ne`

Assert a floating point 32-bit number is not equal to another within f32::EPSILON.

Pseudocode:<br>
a ≠ b

# Example

```rust
use assertables::*;

let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_ne!(a, b);
```

# Module macros

* [`assert_f32_ne`](macro@crate::assert_f32_ne)
* [`assert_f32_ne_as_result`](macro@crate::assert_f32_ne_as_result)
* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)
Assert a floating point 32-bit number is not equal to another within f32::EPSILON.

```rust
pub mod assert_f32_ne { /* ... */ }
```

## Module `assert_f64`

Assert for comparing floating-point 32-bit numbers within 2.0 * EPSILON.

These macros are available:

* [`assert_f64_eq!(a, b)`](macro@crate::assert_f64_eq) ≈ a = b (within 2ε)
* [`assert_f64_ne!(a, b)`](macro@crate::assert_f64_ne) ≈ a ≠ b (within 2ε)

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333335;
assert_f64_eq!(a, b);

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_ne!(a, b);
```

```rust
pub mod assert_f64 { /* ... */ }
```

### Modules

## Module `assert_f64_eq`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a = b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333334;
assert_f64_eq!(a, b);
```

# Module macros

* [`assert_f64_eq`](macro@crate::assert_f64_eq)
* [`assert_f64_eq_as_result`](macro@crate::assert_f64_eq_as_result)
* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)

```rust
pub mod assert_f64_eq { /* ... */ }
```

## Module `assert_f64_ge`

Assert a floating point 64-bit number is greater than or equal to another within f64::EPSILON.

Pseudocode:<br>
a ≥ b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333329;
assert_f64_ge!(a, b);
```

# Module macros

* [`assert_f64_ge`](macro@crate::assert_f64_ge)
* [`assert_f64_ge_as_result`](macro@crate::assert_f64_ge_as_result)
* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)

```rust
pub mod assert_f64_ge { /* ... */ }
```

## Module `assert_f64_gt`

Assert a floating point 64-bit number is greater than another within f64::EPSILON.

Pseudocode:<br>
a > b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333329;
assert_f64_gt!(a, b);
```

# Module macros

* [`assert_f64_gt`](macro@crate::assert_f64_gt)
* [`assert_f64_gt_as_result`](macro@crate::assert_f64_gt_as_result)
* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)

```rust
pub mod assert_f64_gt { /* ... */ }
```

## Module `assert_f64_le`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a ≤ b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_le!(a, b);
```

# Module macros

* [`assert_f64_le`](macro@crate::assert_f64_le)
* [`assert_f64_le_as_result`](macro@crate::assert_f64_le_as_result)
* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)

```rust
pub mod assert_f64_le { /* ... */ }
```

## Module `assert_f64_lt`

Assert a floating point 64-bit number is less than another within f64::EPSILON.

Pseudocode:<br>
a < b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_lt!(a, b);
```

# Module macros

* [`assert_f64_lt`](macro@crate::assert_f64_lt)
* [`assert_f64_lt_as_result`](macro@crate::assert_f64_lt_as_result)
* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)

```rust
pub mod assert_f64_lt { /* ... */ }
```

## Module `assert_f64_ne`

Assert a floating point 64-bit number is not equal to another within f64::EPSILON.

Pseudocode:<br>
a ≠ b

# Example

```rust
use assertables::*;

let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_ne!(a, b);
```

# Module macros

* [`assert_f64_ne`](macro@crate::assert_f64_ne)
* [`assert_f64_ne_as_result`](macro@crate::assert_f64_ne_as_result)
* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)

```rust
pub mod assert_f64_ne { /* ... */ }
```

## Module `assert_abs_diff`

Assert for comparing absolute differences.

These macros help with collection lengths, such as for strings, arrays,
vectors, iterators, and anything that has a typical `.len()` method.

Compare an absolute difference with an expression:

* [`assert_abs_diff_eq_x!(a, b, x)`](macro@crate::assert_abs_diff_eq) ≈ | a - b | = x

* [`assert_abs_diff_ne_x!(a, b, x)`](macro@crate::assert_abs_diff_ne) ≈ | a - b | ≠ x

* [`assert_abs_diff_lt_x!(a, b, x)`](macro@crate::assert_abs_diff_lt) ≈ | a - b | < x

* [`assert_abs_diff_le_x!(a, b, x)`](macro@crate::assert_abs_diff_le) ≈ | a - b | ≤ x

* [`assert_abs_diff_gt_x!(a, b, x)`](macro@crate::assert_abs_diff_gt) ≈ | a - b | > x

* [`assert_abs_diff_ge_x!(a, b, x)`](macro@crate::assert_abs_diff_ge) ≈ | a - b | ≥ x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 3;
assert_abs_diff_eq_x!(a, b, x);
```

```rust
pub mod assert_abs_diff { /* ... */ }
```

### Modules

## Module `assert_abs_diff_eq_x`

Assert an absolute difference is equal to an expression.

Pseudocode:<br>
|Δ| = x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 3;
assert_abs_diff_eq_x!(a, b, x);
```

# Module macros

* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)
* [`assert_abs_diff_eq_x_as_result`](macro@crate::assert_abs_diff_eq_x_as_result)
* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)

```rust
pub mod assert_abs_diff_eq_x { /* ... */ }
```

## Module `assert_abs_diff_ge_x`

Assert an absolute difference is greater than or equal to an expression.

Pseudocode:<br>
|Δ| ≥ x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_ge_x!(a, b, x);
```

# Module macros

* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)
* [`assert_abs_diff_ge_x_as_result`](macro@crate::assert_abs_diff_ge_x_as_result)
* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)

```rust
pub mod assert_abs_diff_ge_x { /* ... */ }
```

## Module `assert_abs_diff_gt_x`

Assert an absolute difference is greater than an expression.

Pseudocode:<br>
|Δ| > x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_gt_x!(a, b, x);
```

# Module macros

* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)
* [`assert_abs_diff_gt_x_as_result`](macro@crate::assert_abs_diff_gt_x_as_result)
* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)

```rust
pub mod assert_abs_diff_gt_x { /* ... */ }
```

## Module `assert_abs_diff_le_x`

Assert an absolute difference is less than or equal to an expression.

Pseudocode:<br>
|Δ| ≤ x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 4;
assert_abs_diff_le_x!(a, b, x);
```

# Module macros

* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)
* [`assert_abs_diff_le_x_as_result`](macro@crate::assert_abs_diff_le_x_as_result)
* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)

```rust
pub mod assert_abs_diff_le_x { /* ... */ }
```

## Module `assert_abs_diff_lt_x`

Assert an absolute difference is less than an expression.

Pseudocode:<br>
|Δ| < x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 4;
assert_abs_diff_lt_x!(a, b, x);
```

# Module macros

* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)
* [`assert_abs_diff_lt_x_as_result`](macro@crate::assert_abs_diff_lt_x_as_result)
* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)

```rust
pub mod assert_abs_diff_lt_x { /* ... */ }
```

## Module `assert_abs_diff_ne_x`

Assert an absolute difference is not equal to an expression.

Pseudocode:<br>
|Δ| ≠ x

# Example

```rust
use assertables::*;

let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_ne_x!(a, b, x);
```

# Module macros

* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)
* [`assert_abs_diff_ne_x_as_result`](macro@crate::assert_abs_diff_ne_x_as_result)
* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)

```rust
pub mod assert_abs_diff_ne_x { /* ... */ }
```

## Module `assert_abs_diff_eq`

Assert an absolute difference is equal to an expression.

Deprecated. Please rename from `assert_abs_diff_eq_as_resul` into `assert_abs_diff_eq_x`.

```rust
pub mod assert_abs_diff_eq { /* ... */ }
```

## Module `assert_abs_diff_ge`

Assert an absolute difference is greater than or equal to an expression.

Deprecated. Please rename from `assert_abs_diff_ge` into `assert_abs_diff_ge_x`.

```rust
pub mod assert_abs_diff_ge { /* ... */ }
```

## Module `assert_abs_diff_gt`

Assert an absolute difference is greater than an expression.

Deprecated. Please rename from `assert_abs_diff_gt` into `assert_abs_diff_gt_x`.

```rust
pub mod assert_abs_diff_gt { /* ... */ }
```

## Module `assert_abs_diff_le`

Assert an absolute difference is less than or equal to an expression.

Deprecated. Please rename from `assert_abs_diff_le` into `assert_abs_diff_le_x`.

```rust
pub mod assert_abs_diff_le { /* ... */ }
```

## Module `assert_abs_diff_lt`

Assert an absolute difference is less than an expression.

Deprecated. Please rename from `assert_abs_diff_lt` into `assert_abs_diff_lt_x`.

```rust
pub mod assert_abs_diff_lt { /* ... */ }
```

## Module `assert_abs_diff_ne`

Assert an absolute difference is not equal to an expression.

Deprecated. Please rename from `assert_abs_diff_ne` into `assert_abs_diff_ne_x`.

```rust
pub mod assert_abs_diff_ne { /* ... */ }
```

## Module `assert_approx`

Assert for approximations.

These macros compare numbers, such as two floating point numbers,
where one number may be very close to another number but not quite equal.

* [`assert_approx_eq!(a, b)`](macro@crate::assert_approx_eq) ≈ a is approximately equal to b

* [`assert_approx_ne!(a, b)`](macro@crate::assert_approx_ne) ≈ a is approximately not equal to b

# Example

```rust
use assertables::*;

let a: f32 = 1.0000001;
let b: f32 = 1.0000011;
assert_approx_eq!(a, b);
```

```rust
pub mod assert_approx { /* ... */ }
```

### Modules

## Module `assert_approx_eq`

Assert a number is approximately equal to another.

Pseudocode:<br>
| a - b | ≤ 1e-6

# Example

```rust
use assertables::*;

let a: f32 = 1.0000001;
let b: f32 = 1.0000011;
assert_approx_eq!(a, b);
```

## Comparisons

This crate provides macro groups that test approximations and nearness:

* [`assert_approx_eq`](macro@crate::assert_approx_eq) and
  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate
  equality within 1e-6. The macro name and the approximate value are chosen
  to be similar to the longtime popular rust crate `assert_approx_eq`.

* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error
  (i.e. delta). This is the magnitude of the difference between the exact
  value and the approximation.

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative
  error (i.e. epsilon). This is the absolute error divided by the magnitude
  of the exact value. This can be used to compare approximations of numbers
  of wildly differing size.

Examples:

* Approximating the number 100 and 103 has an absolute error (approx) of 3
  and a relative error (epsilon) of 0.03.

* Approximating the number 1,000,000 and 1,000,003 has an absolute error
  (approx) of 3, and a relative error (epsilon) of 0.000003.

* For many kinds of applications, the relative error is more important than
  the absolute error.

## Thanks

* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for
  creating and maintaining the `assert_approx_eq` crate.

* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for
  creating and maintaining `assert_in_approx` and `assert_in_epsilon` code.

# Module macros

* [`assert_approx_eq`](macro@crate::assert_approx_eq)
* [`assert_approx_eq_as_result`](macro@crate::assert_approx_eq_as_result)
* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)

```rust
pub mod assert_approx_eq { /* ... */ }
```

## Module `assert_approx_ne`

Assert a number is approximately not equal to another.

Pseudocode:<br>
| a - b | > 1e-6

# Example

```rust
use assertables::*;

let a: f32 = 1.0000001;
let b: f32 = 1.0000012;
assert_approx_ne!(a, b);
```

## Comparisons

This crate provides macro groups that test approximations and nearness:

* [`assert_approx_eq`](macro@crate::assert_approx_eq) and
  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate
  equality within 1e-6. The macro name and the approximate value are chosen
  to be similar to the longtime popular rust crate `assert_approx_eq`.

* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error
  (i.e. delta). This is the magnitude of the difference between the exact
  value and the approximation.

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative
  error (i.e. epsilon). This is the absolute error divided by the magnitude
  of the exact value. This can be used to compare approximations of numbers
  of wildly differing size.

Examples:

* Approximating the number 100 and 103 has an absolute error (approx) of 3
  and a relative error (epsilon) of 0.03.

* Approximating the number 1,000,000 and 1,000,003 has an absolute error
  (approx) of 3, and a relative error (epsilon) of 0.000003.

* For many kinds of applications, the relative error is more important than
  the absolute error.

## Thanks

* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for
  creating and maintaining the `assert_approx_eq` crate.

* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for
  creating and maintaining `assert_in_approx` and `assert_in_epsilon` code.

# Module macros

* [`assert_approx_ne`](macro@crate::assert_approx_ne)
* [`assert_approx_ne_as_result`](macro@crate::assert_approx_ne_as_result)
* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)

```rust
pub mod assert_approx_ne { /* ... */ }
```

## Module `assert_diff`

Assert for comparing delta differences.

Compare a delta with an expression:

* [`assert_diff_eq_x!(a, b, expr)`](macro@crate::assert_diff_eq_x) ≈ b - a = expr
* [`assert_diff_ne_x!(a, b, expr)`](macro@crate::assert_diff_ne_x) ≈ b - a ≠ expr
* [`assert_diff_lt_x!(a, b, expr)`](macro@crate::assert_diff_lt_x) ≈ b - a < expr
* [`assert_diff_le_x!(a, b, expr)`](macro@crate::assert_diff_le_x) ≈ b - a ≤ expr
* [`assert_diff_gt_x!(a, b, expr)`](macro@crate::assert_diff_gt_x) ≈ b - a > expr
* [`assert_diff_ge_x!(a, b, expr)`](macro@crate::assert_diff_ge_x) ≈ b - a ≥ expr

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 12;
let x: i8 = 2;
assert_diff_eq_x!(a, b, x);
```

```rust
pub mod assert_diff { /* ... */ }
```

### Modules

## Module `assert_diff_eq_x`

Assert a difference is equal to an expression.

Pseudocode:<br>
Δ = x

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 3;
assert_diff_eq_x!(a, b, x);
```

# Module macros

* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)
* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)
* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)

```rust
pub mod assert_diff_eq_x { /* ... */ }
```

## Module `assert_diff_ge_x`

Assert a difference is greater than or equal to an expression.

Pseudocode:<br>
Δ ≥ x

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 2;
assert_diff_ge_x!(a, b, x);
```

# Module macros

* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)
* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)
* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)

```rust
pub mod assert_diff_ge_x { /* ... */ }
```

## Module `assert_diff_gt_x`

Assert a difference is greater than an expression.

Pseudocode:<br>
Δ > x

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 2;
assert_diff_gt_x!(a, b, x);
```

# Module macros

* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)
* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)
* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)

```rust
pub mod assert_diff_gt_x { /* ... */ }
```

## Module `assert_diff_le_x`

Assert a difference is less than or equal to an expression.

Pseudocode:<br>
Δ ≤ x

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 3;
assert_diff_le_x!(a, b, x);
```

# Module macros

* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)
* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)
* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)

```rust
pub mod assert_diff_le_x { /* ... */ }
```

## Module `assert_diff_lt_x`

Assert a difference is less than an expression.

Pseudocode:<br>
Δ < x

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 4;
assert_diff_lt_x!(a, b, x);
```

# Module macros

* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)
* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)
* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)

```rust
pub mod assert_diff_lt_x { /* ... */ }
```

## Module `assert_diff_ne_x`

Assert a difference is not equal to an expression.

Pseudocode:<br>
Δ ≠ x

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 4;
assert_diff_ne_x!(a, b, x);
```

# Module macros

* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)
* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)
* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)

```rust
pub mod assert_diff_ne_x { /* ... */ }
```

## Module `assert_in`

Assert in nearness.

These macros compare numbers, such as two numbers
where one number may be close to another number.

* [`assert_in!(a, container)`](macro@crate::assert_in) ≈ a is in container
* [`assert_in_range!(a, range)`](macro@crate::assert_in_range) ≈ a is in range
* [`assert_in_delta!(a, b, delta)`](macro@crate::assert_in_delta) ≈ | a - b | ≤ Δ
* [`assert_in_epsilon!(a, b, epsilon)`](macro@crate::assert_in_epsilon) ≈ | a - b | ≤ ε * min(a, b)

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 11;
let delta: i8 = 1;
assert_in_delta!(a, b, delta);
```

```rust
pub mod assert_in { /* ... */ }
```

### Modules

## Module `assert_in`

Assert an item is in a container.

Pseudocode:<br>
a is in container

# Example

```rust
use assertables::*;

let a = 1;
let b = 0..2;
assert_in!(a, b);
```

# Module macros

* [`assert_in`](macro@crate::assert_in)
* [`assert_in_as_result`](macro@crate::assert_in_as_result)
* [`debug_assert_in`](macro@crate::debug_assert_in)

```rust
pub mod assert_in { /* ... */ }
```

## Module `assert_in_delta`

Assert a number is within delta of another.

Pseudocode:<br>
| a - b | ≤ Δ

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 11;
let delta: i8 = 1;
assert_in_delta!(a, b, delta);
```

## Comparisons

This crate provides macro groups that test approximations and nearness:

* [`assert_approx_eq`](macro@crate::assert_approx_eq) and
  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate
  equality within 1e-6. The macro name and the approximate value are chosen
  to be similar to the longtime popular rust crate `assert_approx_eq`.

* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error
  (i.e. delta). This is the magnitude of the difference between the exact
  value and the approximation.

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative
  error (i.e. epsilon). This is the absolute error divided by the magnitude
  of the exact value. This can be used to compare approximations of numbers
  of wildly differing size.

Examples:

* Approximating the number 100 and 103 has an absolute error (delta) of 3
  and a relative error (epsilon) of 0.03.

* Approximating the number 1,000,000 and 1,000,003 has an absolute error
  (delta) of 3, and a relative error (epsilon) of 0.000003.

* For many kinds of applications, the relative error is more important than
  the absolute error.

## Thanks

* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for
  creating and maintaining the `assert_approx_eq` crate.

* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for
  creating and maintaining `assert_in_delta` and `assert_in_epsilon` code.

# Module macros

* [`assert_in_delta`](macro@crate::assert_in_delta)
* [`assert_in_delta_as_result`](macro@crate::assert_in_delta_as_result)
* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)

```rust
pub mod assert_in_delta { /* ... */ }
```

## Module `assert_in_epsilon`

Assert a number is within epsilon of another.

Pseudocode:<br>
| a - b | ≤ ε * min(a, b)

# Example

```rust
use assertables::*;

let a: i8 = 10;
let b: i8 = 20;
let epsilon: i8 = 1;
assert_in_epsilon!(a, b, epsilon);
```

## Comparisons

This crate provides macro groups that test approximations and nearness:

* [`assert_approx_eq`](macro@crate::assert_approx_eq) and
  [`assert_approx_ne`](macro@crate::assert_approx_ne) test the approximate
  equality within 1e-6. The macro name and the approximate value are chosen
  to be similar to the longtime popular rust crate `assert_approx_eq`.

* [`assert_in_delta`](macro@crate::assert_in_delta) tests the absolute error
  (i.e. delta). This is the magnitude of the difference between the exact
  value and the approximation.

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon) tests the relative
  error (i.e. epsilon). This is the absolute error divided by the magnitude
  of the exact value. This can be used to compare approximations of numbers
  of wildly differing size.

Examples:

* Approximating the number 100 and 103 has an absolute error (delta) of 3
  and a relative error (epsilon) of 0.03.

* Approximating the number 1,000,000 and 1,000,003 has an absolute error
  (delta) of 3, and a relative error (epsilon) of 0.000003.

* For many kinds of applications, the relative error is more important than
  the absolute error.

## Thanks

* Thanks to [Ashley Williams](https://github.com/ashleygwilliams) for
  creating and maintaining the `assert_approx_eq` crate.

* Thanks to [Ryan Davis](https://github.com/zenspider) and Ruby minitest for
  creating and maintaining `assert_in_delta` and `assert_in_epsilon` code.

# Module macros

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)
* [`assert_in_epsilon_as_result`](macro@crate::assert_in_epsilon_as_result)
* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)

```rust
pub mod assert_in_epsilon { /* ... */ }
```

## Module `assert_in_range`

Assert an item is in a range.

Pseudocode:<br>
a is in range

# Example

```rust
use assertables::*;

let a = 1;
let b = 0..2;
assert_in_range!(a, b);
```

# Module macros

* [`assert_in_range`](macro@crate::assert_in_range)
* [`assert_in_range_as_result`](macro@crate::assert_in_range_as_result)
* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)

```rust
pub mod assert_in_range { /* ... */ }
```

## Module `assert_all`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

# Example

```rust
use assertables::*;

let a = [1, 2, 3];
assert_all!(a.into_iter(), |x: i8| x > 0);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_all`](macro@crate::assert_all)
* [`assert_all_as_result`](macro@crate::assert_all_as_result)
* [`debug_assert_all`](macro@crate::debug_assert_all)

```rust
pub mod assert_all { /* ... */ }
```

## Module `assert_any`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

# Example

```rust
use assertables::*;

let a = [1, 2, 3];
assert_any!(a.into_iter(), |x: i8| x > 0);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_any`](macro@crate::assert_any)
* [`assert_any_as_result`](macro@crate::assert_any_as_result)
* [`debug_assert_any`](macro@crate::debug_assert_any)

```rust
pub mod assert_any { /* ... */ }
```

## Module `assert_infix`

Assert a infix operator, such as assert_infix!(a == b).

Pseudocode:<br>
a infix b

Compare values via infix value operator:

* `assert_infix!(a == b)` ≈ a == b

* `assert_infix!(a != b)` ≈ a ≠ b

* `assert_infix!(a < b)` ≈ a < b

* `assert_infix!(a <= b)` ≈ a ≤ b

* `assert_infix!(a > b)` ≈ a > b

* `assert_infix!(a >= b)` ≈ a ≥ b

Relate values via infix logical operator:

* `assert_infix!(a & b)` ≈ a ∧ b ≈ a AND b

* `assert_infix!(a | b)` ≈ a ∨ b ≈ a OR b

* `assert_infix!(a ^ b)` ≈ a ⊻ b ≈ a XOR b

* `assert_infix!(a && b)` ≈ a …∧ b ≈ a lazy AND b

* `assert_infix!(a || b)` ≈ a …∨ b ≈ a lazy OR b

# Example

```rust
use assertables::*;

let a = 1;
let b = 1;
assert_infix!(a == b);
```

# Infix operators

For values:

* `==`  equal
* `!=`  not equal
* `<`	less than
* `<=`	less than or equal to
* `>`	greater than
* `>=`	greater than or equal to

For booleans:

* `^`	logical XOR
* `!`	logical NOT
* `&`	logical AND
* `|`	logical OR
* `&&`	logical lazy AND
* `||`	logical lazy OR

# Module macros

* [`assert_infix`](macro@crate::assert_infix)
* [`assert_infix_as_result`](macro@crate::assert_infix_as_result)
* [`debug_assert_infix`](macro@crate::debug_assert_infix)

```rust
pub mod assert_infix { /* ... */ }
```

## Module `assert_contains`

Assert for a container and a containee.

These macros help with comparison of a container (such as a string, array, range)
and a containee (such as a string substring, an array element, a range value).

* [`assert_contains(container, containee)`](macro@crate::assert_contains) ≈ container.contains(containee)

* [`assert_not_contains!(container, containee)`](macro@crate::assert_not_contains) ≈ !container.contains(containee)

These macros work with many kinds of Rust types, such as String, Vec, Range, HashSet.
The specifics depend on each type's implementation of a method `contains`, and some types
require the second argument to be borrowable, so be sure to check the Rust documentation.

# Example

```rust
use assertables::*;

// String contains substring
let a: &str = "alfa";
let b: &str = "lf";
assert_contains!(a, b);

// Range contains value
let a = 1..3;
let b = 2;
assert_contains!(a, &b); // Borrow

// Vector contains &element
let a = vec![1, 2, 3];
let b = 2;
assert_contains!(a, &b); // Borrow
```

```rust
pub mod assert_contains { /* ... */ }
```

### Modules

## Module `assert_contains`

Assert a container is a match for an expression.

Pseudocode:<br>
a.contains(b)

These macros work with many kinds of Rust types, such as String, Vec, Range, HashSet.
The specifics depend on each type's implementation of a method `contains`, and some types
require the second argument to be borrowable, so be sure to check the Rust documentation.

# Example

```rust
use assertables::*;
use std::collections::HashSet;

// String contains substring
let a = "alfa";
let b = "lf";
assert_contains!(a, b);

// Range contains value.
// Notice the &b because the macro calls Range.contains(&self, &value).
let a = 1..3;
let b = 2;
assert_contains!(a, &b);

// Vector contains element.
// Notice the &b because the macro calls Vec.contains(&self, &value).
let a = vec![1, 2, 3];
let b = 2;
assert_contains!(a, &b);

// HashSet contains element.
// Notice the &b because the macro calls HashSet.contains(&self, &value).
let a: HashSet<String> = [String::from("1")].into();
let b: String = String::from("1");
assert_contains!(a, &b);

// HashSet contains element with automatic borrow optimization.
// Notice the b because the value type &str is already a reference,
// which HashSet.contains knows how to borrow to compare to String.
let a: HashSet<String> = [String::from("1")].into();
let b = "1";
assert_contains!(a, b);
```

# Module macros

* [`assert_contains`](macro@crate::assert_contains)
* [`assert_contains_as_result`](macro@crate::assert_contains_as_result)
* [`debug_assert_contains`](macro@crate::debug_assert_contains)

```rust
pub mod assert_contains { /* ... */ }
```

## Module `assert_not_contains`

Assert an expression (such as a string) does not contain an expression (such as a substring).

Pseudocode:<br>
¬ a.contains(b)

These macros work with many kinds of Rust types, such as String, Vec, Range, HashSet.
The specifics depend on each type's implementation of a method `contains`, and some types
require the second argument to be borrowable, so be sure to check the Rust documentation.

# Example

```rust
use assertables::*;
use std::collections::HashSet;

// String does not contain substring.
let a = "alfa";
let b = "xx";
assert_not_contains!(a, b);

// Range does not contain value.
// Notice the &b because the macro calls Range.contains(&self, &value).
let a = 1..3;
let b = 4;
assert_not_contains!(a, &b);

// Vector does not contain element.
// Notice the &b because the macro calls Vec.contains(&self, &value).
let a = vec![1, 2, 3];
let b = 4;
assert_not_contains!(a, &b);

// HashSet does not contain element.
// Notice the &b because the macro calls HashSet.contains(&self, &value).
let a: HashSet<String> = [String::from("1")].into();
let b: String = String::from("2");
assert_not_contains!(a, &b);

// HashSet does not contain element with automatic borrow optimization.
// Notice the b because the value type &str is already a reference,
// which HashSet.contains knows how to borrow to compare to String.
let a: HashSet<String> = [String::from("1")].into();
let b = "2";
assert_not_contains!(a, b);
```

# Module macros

* [`assert_not_contains`](macro@crate::assert_not_contains)
* [`assert_not_contains_as_result`](macro@crate::assert_not_contains_as_result)
* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)

```rust
pub mod assert_not_contains { /* ... */ }
```

## Module `assert_count`

Assert for comparing counts.

These macros help with collection counts, such as for strings, arrays,
vectors, iterators, and anything that has a typical `.count()` method.

Compare a count with another count:

* [`assert_count_eq!(a, b)`](macro@crate::assert_count_eq) ≈ a.count() = b.count()
* [`assert_count_ne!(a, b)`](macro@crate::assert_count_ne) ≈ a.count() ≠ b.count()
* [`assert_count_lt!(a, b)`](macro@crate::assert_count_lt) ≈ a.count() < b.count()
* [`assert_count_le!(a, b)`](macro@crate::assert_count_le) ≈ a.count() ≤ b.count()
* [`assert_count_gt!(a, b)`](macro@crate::assert_count_gt) ≈ a.count() > b.count()
* [`assert_count_ge!(a, b)`](macro@crate::assert_count_ge) ≈ a.count() ≥ b.count()

Compare a count with an expression:

* [`assert_count_eq_x!(a, expr)`](macro@crate::assert_count_eq_x) ≈ a.count() = expr
* [`assert_count_ne_x!(a, expr)`](macro@crate::assert_count_ne_x) ≈ a.count() ≠ expr
* [`assert_count_lt_x!(a, expr)`](macro@crate::assert_count_lt_x) ≈ a.count() < expr
* [`assert_count_le_x!(a, expr)`](macro@crate::assert_count_le_x) ≈ a.count() ≤ expr
* [`assert_count_gt_x!(a, expr)`](macro@crate::assert_count_gt_x) ≈ a.count() > expr
* [`assert_count_ge_x!(a, expr)`](macro@crate::assert_count_ge_x) ≈ a.count() ≥ expr

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = "x".chars();
assert_count_eq!(a, b);
```

```rust
pub mod assert_count { /* ... */ }
```

### Modules

## Module `assert_count_eq`

Assert a count is equal to another.

Pseudocode:<br>
a.count() = b.count()

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = "x".chars();
assert_count_eq!(a, b);
```

# Module macros

* [`assert_count_eq`](macro@crate::assert_count_eq)
* [`assert_count_eq_as_result`](macro@crate::assert_count_eq_as_result)
* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)

```rust
pub mod assert_count_eq { /* ... */ }
```

## Module `assert_count_ge`

Assert a count is greater than or equal to another.

Pseudocode:<br>
a.count() ≥ b.count()

# Example

```rust
use assertables::*;

let a = "xx".chars();
let b = "x".chars();
assert_count_ge!(a, b);
```

# Module macros

* [`assert_count_ge`](macro@crate::assert_count_ge)
* [`assert_count_ge_as_result`](macro@crate::assert_count_ge_as_result)
* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)

```rust
pub mod assert_count_ge { /* ... */ }
```

## Module `assert_count_gt`

Assert a count is greater than another.

Pseudocode:<br>
a.count() > b.count()

# Example

```rust
use assertables::*;

let a = "xx".chars();
let b = "x".chars();
assert_count_gt!(a, b);
```

# Module macros

* [`assert_count_gt`](macro@crate::assert_count_gt)
* [`assert_count_gt_as_result`](macro@crate::assert_count_gt_as_result)
* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)

```rust
pub mod assert_count_gt { /* ... */ }
```

## Module `assert_count_le`

Assert a count is less than or equal to another.

Pseudocode:<br>
a.count() ≤ b.count()

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = "xx".chars();
assert_count_le!(a, b);
```

# Module macros

* [`assert_count_le`](macro@crate::assert_count_le)
* [`assert_count_le_as_result`](macro@crate::assert_count_le_as_result)
* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)

```rust
pub mod assert_count_le { /* ... */ }
```

## Module `assert_count_lt`

Assert a count is less than another.

Pseudocode:<br>
a.count() < b.count()

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = "xx".chars();
assert_count_lt!(a, b);
```

# Module macros

* [`assert_count_lt`](macro@crate::assert_count_lt)
* [`assert_count_lt_as_result`](macro@crate::assert_count_lt_as_result)
* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)

```rust
pub mod assert_count_lt { /* ... */ }
```

## Module `assert_count_ne`

Assert a count is not equal to another.

Pseudocode:<br>
a.count() ≠ b.count()

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = "xx".chars();
assert_count_ne!(a, b);
```

# Module macros

* [`assert_count_ne`](macro@crate::assert_count_ne)
* [`assert_count_ne_as_result`](macro@crate::assert_count_ne_as_result)
* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)

```rust
pub mod assert_count_ne { /* ... */ }
```

## Module `assert_count_eq_x`

Assert a count is equal to an expression.

Pseudocode:<br>
a.count() = b

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = 1;
assert_count_eq_x!(a, b);
```

# Module macros

* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)
* [`assert_count_eq_x_as_result`](macro@crate::assert_count_eq_x_as_result)
* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)

```rust
pub mod assert_count_eq_x { /* ... */ }
```

## Module `assert_count_ge_x`

Assert a count is greater than or equal to an expression.

Pseudocode:<br>
a.count() ≥ b

# Example

```rust
use assertables::*;

let a = "xx".chars();
let b = 1;
assert_count_ge_x!(a, b);
```

# Module macros

* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)
* [`assert_count_ge_x_as_result`](macro@crate::assert_count_ge_x_as_result)
* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)

```rust
pub mod assert_count_ge_x { /* ... */ }
```

## Module `assert_count_gt_x`

Assert a count is greater than an expression.

Pseudocode:<br>
a.count() > b

# Example

```rust
use assertables::*;

let a = "xx".chars();
let b = 1;
assert_count_gt_x!(a, b);
```

# Module macros

* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)
* [`assert_count_gt_x_as_result`](macro@crate::assert_count_gt_x_as_result)
* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)

```rust
pub mod assert_count_gt_x { /* ... */ }
```

## Module `assert_count_le_x`

Assert a count is less than or equal to an expression.

Pseudocode:<br>
a.count() ≤ b

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = 2;
assert_count_le_x!(a, b);
```

# Module macros

* [`assert_count_le_x`](macro@crate::assert_count_le_x)
* [`assert_count_le_x_as_result`](macro@crate::assert_count_le_x_as_result)
* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)

```rust
pub mod assert_count_le_x { /* ... */ }
```

## Module `assert_count_lt_x`

Assert a count is less than an expression.

Pseudocode:<br>
a.count() < b

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = 2;
assert_count_lt_x!(a, b);
```

# Module macros

* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)
* [`assert_count_lt_x_as_result`](macro@crate::assert_count_lt_x_as_result)
* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)

```rust
pub mod assert_count_lt_x { /* ... */ }
```

## Module `assert_count_ne_x`

Assert a count is not equal to an expression.

Pseudocode:<br>
a.count() ≠ b

# Example

```rust
use assertables::*;

let a = "x".chars();
let b = 2;
assert_count_ne_x!(a, b);
```

# Module macros

* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)
* [`assert_count_ne_x_as_result`](macro@crate::assert_count_ne_x_as_result)
* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)

```rust
pub mod assert_count_ne_x { /* ... */ }
```

## Module `assert_email_address`

Assert expression is possibly an email address or not.

* [`assert_email_address!(a)`](macro@crate::assert_email_address) ≈ email_address(a)

* [`assert_not_email_address!(a)`](macro@crate::assert_email_address) ≈ not_email_address(a)

# Example

```rust
use assertables::*;

let a = "hello@example.com";
assert_email_address!(a);
```

```rust
pub mod assert_email_address { /* ... */ }
```

### Modules

## Module `assert_email_address`

Assert expression is possibly an email address.

# Example

```rust
use assertables::*;

let a = "hello@example.com";
assert_email_address!(a);
```

Note: this implementation is relatively basic.

* If you want more capabilities, then use an email address parser.

* If you want to know for sure, then send an email to the address.

# Module macros

* [`assert_email_address`](macro@crate::assert_email_address)
* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)
* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)

```rust
pub mod assert_email_address { /* ... */ }
```

## Module `assert_not_email_address`

Assert expression is possibly not an email address.

# Example

```rust
use assertables::*;

let a = "hello*example.com";
assert_not_email_address!(a);
```

Note: this implementation is relatively basic.

* If you want more capabilities, then use an email address parser.

* If you want to know for sure, then send an email to the address.

# Module macros

* [`assert_not_email_address`](macro@crate::assert_not_email_address)
* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)
* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)

```rust
pub mod assert_not_email_address { /* ... */ }
```

## Module `assert_ends_with`

Assert for a sequence that may end with a part.

These macros help with comparison of a sequence (such as a string, array, range)
and a part (such as a string substring, an array element, a range value).

* [`assert_ends_with(sequence, subsequence)`](macro@crate::assert_ends_with) ≈ container.contains(containee)

* [`assert_not_ends_with!(sequence, subsequence)`](macro@crate::assert_not_ends_with) ≈ !container.contains(containee)

# Example

```rust
use assertables::*;

// String ends with substring?
let sequence: &str = "alfa";
let subsequence: &str = "fa";
assert_ends_with!(sequence, subsequence);

// Vector ends with element?
let sequence = vec![1, 2, 3];
let subsequence = [3];
assert_ends_with!(sequence, subsequence);
```

```rust
pub mod assert_ends_with { /* ... */ }
```

### Modules

## Module `assert_ends_with`

Assert an expression (such as a string) ends with an expression (such as a string).

Pseudocode:<br>
a.ends_with(b)

# Example

```rust
use assertables::*;

// String ends with substring?
let sequence: &str = "alfa";
let subsequence: &str = "fa";
assert_ends_with!(sequence, subsequence);

// Vector ends with element?
let sequence = vec![1, 2, 3];
let subsequence = [3];
assert_ends_with!(sequence, subsequence);
```

# Module macros

* [`assert_ends_with`](macro@crate::assert_ends_with)
* [`assert_ends_with_as_result`](macro@crate::assert_ends_with_as_result)
* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)

```rust
pub mod assert_ends_with { /* ... */ }
```

## Module `assert_not_ends_with`

Assert an expression (such as a string) does not end with an expression (such as a string).

Pseudocode:<br>
¬ a.ends_with(b)

# Example

```rust
use assertables::*;

// String ends with substring?
let sequence: &str = "alfa";
let subsequence: &str = "al";
assert_not_ends_with!(sequence, subsequence);

// Vector ends with element?
let sequence = vec![1, 2, 3];
let subsequence = [1];
assert_not_ends_with!(sequence, subsequence);
```

# Module macros

* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)
* [`assert_not_ends_with_as_result`](macro@crate::assert_not_ends_with_as_result)
* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)

```rust
pub mod assert_not_ends_with { /* ... */ }
```

## Module `assert_is_empty`

Assert for method is_empty().

These macros help with any item that implements self.is_empty().

* [`assert_is_empty!(collection)`](macro@crate::assert_is_empty) ≈ collection.is_empty()

* [`assert_not_empty!(collection)`](macro@crate::assert_not_empty) ≈ !collection.is_empty()

# Example

```rust
use assertables::*;

let a = "";
assert_is_empty!(a);
```

```rust
pub mod assert_is_empty { /* ... */ }
```

### Modules

## Module `assert_is_empty`

Assert an expression (such as a string or array) is empty.

Pseudocode:<br>
a.is_empty()

# Example

```rust
use assertables::*;

let a = "";
assert_is_empty!(a);
```

# Module macros

* [`assert_is_empty`](macro@crate::assert_is_empty)
* [`assert_is_empty_as_result`](macro@crate::assert_is_empty_as_result)
* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)

```rust
pub mod assert_is_empty { /* ... */ }
```

## Module `assert_not_empty`

Assert an expression (such as a string or array) is not empty.

Pseudocode:<br>
¬ a.is_empty()

# Example

```rust
use assertables::*;

let a = "alfa";
assert_not_empty!(a);
```

# Module macros

* [`assert_not_empty`](macro@crate::assert_not_empty)
* [`assert_not_empty_as_result`](macro@crate::assert_not_empty_as_result)
* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)

```rust
pub mod assert_not_empty { /* ... */ }
```

## Module `assert_is_match`

Assert for method is_match(…).

These macros help with any item that implements self.is_match(…).

* [`assert_is_match!(matcher, matchee)`](macro@crate::assert_is_match) ≈ matcher.is_match(matchee)

* [`assert_not_match!(matcher, matchee)`](macro@crate::assert_not_match) ≈ !matcher.is_match(matchee)

# Example

```rust
use assertables::*;
use regex::Regex;

let a = Regex::new(r"lf").expect("regex");
let b = "alfa";
assert_is_match!(a, b);
```

```rust
pub mod assert_is_match { /* ... */ }
```

### Modules

## Module `assert_is_match`

Assert a matcher is a match for an expression.

Pseudocode:<br>
a.is_match(b)

# Example

```rust
use assertables::*;
use regex::Regex;

let a = Regex::new(r"lf").expect("regex");
let b = "alfa";
assert_is_match!(a, b);
```

# Module macros

* [`assert_is_match`](macro@crate::assert_is_match)
* [`assert_is_match_as_result`](macro@crate::assert_is_match_as_result)
* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)

```rust
pub mod assert_is_match { /* ... */ }
```

## Module `assert_not_match`

Assert an expression (such as a regex) is not a match for an expression (such as a string).

Pseudocode:<br>
¬ a.is_match(b)

# Example

```rust
use assertables::*;
use regex::Regex;

let a = Regex::new(r"xx").expect("regex");
let b = "alfa";
assert_not_match!(a, b);
```

# Module macros

* [`assert_not_match`](macro@crate::assert_not_match)
* [`assert_not_match_as_result`](macro@crate::assert_not_match_as_result)
* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)

```rust
pub mod assert_not_match { /* ... */ }
```

## Module `assert_len`

Assert for comparing lengths.

These macros help with collection lengths, such as for strings, arrays,
vectors, iterators, and anything that has a typical `.len()` method.

Compare a length with another length:

* [`assert_len_eq!(a, b)`](macro@crate::assert_len_eq) ≈ a.len() = b.len()
* [`assert_len_ne!(a, b)`](macro@crate::assert_len_ne) ≈ a.len() ≠ b.len()
* [`assert_len_lt!(a, b)`](macro@crate::assert_len_lt) ≈ a.len() < b.len()
* [`assert_len_le!(a, b)`](macro@crate::assert_len_le) ≈ a.len() ≤ b.len()
* [`assert_len_gt!(a, b)`](macro@crate::assert_len_gt) ≈ a.len() > b.len()
* [`assert_len_ge!(a, b)`](macro@crate::assert_len_ge) ≈ a.len() ≥ b.len()

Compare a length with an expression:

* [`assert_len_eq_x!(a, expr)`](macro@crate::assert_len_eq_x) ≈ a.len() = expr
* [`assert_len_ne_x!(a, expr)`](macro@crate::assert_len_ne_x) ≈ a.len() ≠ expr
* [`assert_len_lt_x!(a, expr)`](macro@crate::assert_len_lt_x) ≈ a.len() < expr
* [`assert_len_le_x!(a, expr)`](macro@crate::assert_len_le_x) ≈ a.len() ≤ expr
* [`assert_len_gt_x!(a, expr)`](macro@crate::assert_len_gt_x) ≈ a.len() > expr
* [`assert_len_ge_x!(a, expr)`](macro@crate::assert_len_ge_x) ≈ a.len() ≥ expr

# Example

```rust
use assertables::*;

let a = "x";
let b = "x";
assert_len_eq!(a, b);
```

```rust
pub mod assert_len { /* ... */ }
```

### Modules

## Module `assert_len_eq`

Assert a length is equal to another.

Pseudocode:<br>
a.len() = b.len()

# Example

```rust
use assertables::*;

let a = "x";
let b = "x";
assert_len_eq!(a, b);
```

# Module macros

* [`assert_len_eq`](macro@crate::assert_len_eq)
* [`assert_len_eq_as_result`](macro@crate::assert_len_eq_as_result)
* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)

```rust
pub mod assert_len_eq { /* ... */ }
```

## Module `assert_len_ge`

Assert a length is greater than or equal to another.

Pseudocode:<br>
a.len() ≥ b.len()

# Example

```rust
use assertables::*;

let a = "xx";
let b = "x";
assert_len_ge!(a, b);
```

# Module macros

* [`assert_len_ge`](macro@crate::assert_len_ge)
* [`assert_len_ge_as_result`](macro@crate::assert_len_ge_as_result)
* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)

```rust
pub mod assert_len_ge { /* ... */ }
```

## Module `assert_len_gt`

Assert a length is greater than another.

Pseudocode:<br>
a.len() > b.len()

# Example

```rust
use assertables::*;

let a = "xx";
let b = "x";
assert_len_gt!(a, b);
```

# Module macros

* [`assert_len_gt`](macro@crate::assert_len_gt)
* [`assert_len_gt_as_result`](macro@crate::assert_len_gt_as_result)
* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)

```rust
pub mod assert_len_gt { /* ... */ }
```

## Module `assert_len_le`

Assert a length is less than or equal to another.

Pseudocode:<br>
a.len() ≤ b.len()

# Example

```rust
use assertables::*;

let a = "x";
let b = "xx";
assert_len_le!(a, b);
```

# Module macros

* [`assert_len_le`](macro@crate::assert_len_le)
* [`assert_len_le_as_result`](macro@crate::assert_len_le_as_result)
* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)

```rust
pub mod assert_len_le { /* ... */ }
```

## Module `assert_len_lt`

Assert a length is less than another.

Pseudocode:<br>
a.len() < b.len()

# Example

```rust
use assertables::*;

let a = "x";
let b = "xx";
assert_len_lt!(a, b);
```

# Module macros

* [`assert_len_lt`](macro@crate::assert_len_lt)
* [`assert_len_lt_as_result`](macro@crate::assert_len_lt_as_result)
* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)

```rust
pub mod assert_len_lt { /* ... */ }
```

## Module `assert_len_ne`

Assert a length is not equal to another.

Pseudocode:<br>
a.len() ≠ b.len()

# Example

```rust
use assertables::*;

let a = "x";
let b = "xx";
assert_len_ne!(a, b);
```

# Module macros

* [`assert_len_ne`](macro@crate::assert_len_ne)
* [`assert_len_ne_as_result`](macro@crate::assert_len_ne_as_result)
* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)

```rust
pub mod assert_len_ne { /* ... */ }
```

## Module `assert_len_eq_x`

Assert a length is equal to an expression.

Pseudocode:<br>
a.len() = b

# Example

```rust
use assertables::*;

let a = "x";
let b = 1;
assert_len_eq_x!(a, b);
```

# Module macros

* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)
* [`assert_len_eq_x_as_result`](macro@crate::assert_len_eq_x_as_result)
* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)

```rust
pub mod assert_len_eq_x { /* ... */ }
```

## Module `assert_len_ge_x`

Assert a length is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

# Example

```rust
use assertables::*;

let a = "xx";
let b = 1;
assert_len_ge_x!(a, b);
```

# Module macros

* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)
* [`assert_len_ge_x_as_result`](macro@crate::assert_len_ge_x_as_result)
* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)

```rust
pub mod assert_len_ge_x { /* ... */ }
```

## Module `assert_len_gt_x`

Assert a length is greater than an expression.

Pseudocode:<br>
a.len() > b

# Example

```rust
use assertables::*;

let a = "xx";
let b = 1;
assert_len_gt_x!(a, b);
```

# Module macros

* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)
* [`assert_len_gt_x_as_result`](macro@crate::assert_len_gt_x_as_result)
* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)

```rust
pub mod assert_len_gt_x { /* ... */ }
```

## Module `assert_len_le_x`

Assert a length is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

# Example

```rust
use assertables::*;

let a = "x";
let b = 2;
assert_len_le_x!(a, b);
```

# Module macros

* [`assert_len_le_x`](macro@crate::assert_len_le_x)
* [`assert_len_le_x_as_result`](macro@crate::assert_len_le_x_as_result)
* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)

```rust
pub mod assert_len_le_x { /* ... */ }
```

## Module `assert_len_lt_x`

Assert a length is less than an expression.

Pseudocode:<br>
a.len() < b

# Example

```rust
use assertables::*;

let a = "x";
let b = 2;
assert_len_lt_x!(a, b);
```

# Module macros

* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)
* [`assert_len_lt_x_as_result`](macro@crate::assert_len_lt_x_as_result)
* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)

```rust
pub mod assert_len_lt_x { /* ... */ }
```

## Module `assert_len_ne_x`

Assert a length is not equal to an expression.

Pseudocode:<br>
a.len() ≠ b

# Example

```rust
use assertables::*;

let a = "x";
let b = 2;
assert_len_ne_x!(a, b);
```

# Module macros

* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)
* [`assert_len_ne_x_as_result`](macro@crate::assert_len_ne_x_as_result)
* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)

```rust
pub mod assert_len_ne_x { /* ... */ }
```

## Module `assert_matches`

Assert matches for verifying an item matches a case.

* [`assert_matches!(a, b)`](macro@crate::assert_matches) ≈ match(a) { b }

* [`assert_not_matches!(a, b)`](macro@crate::assert_matches) ≈ match(a) { b }

# Example

```rust
use assertables::*;

let a = 'a';
assert_matches!(a, 'a'..='z');
```

```rust
pub mod assert_matches { /* ... */ }
```

### Modules

## Module `assert_matches`

Assert expression matches a case.

# Example

```rust
use assertables::*;

let a = 'a';
assert_matches!(a, 'a'..='z');
```

Note: this implementation of `assert_matches` is relatively basic.

* If you want more capabilities, consider the crate `assert_matches`.

* If you're using Rust nightly, use the std lib macro `assert_matches`.

# Module macros

* [`assert_matches`](macro@crate::assert_matches)
* [`assert_matches_as_result`](macro@crate::assert_matches_as_result)
* [`debug_assert_matches`](macro@crate::debug_assert_matches)

```rust
pub mod assert_matches { /* ... */ }
```

## Module `assert_not_matches`

Assert expression matches a case.

# Example

```rust
use assertables::*;

let a = 'a';
assert_not_matches!(a, 'b'..='z');
```

Note: this implementation of `assert_not_matches` is relatively basic.

* If you want more capabilities, consider the crate `assert_not_matches`.

* If you're using Rust nightly, use the std lib macro `assert_not_matches`.

# Module macros

* [`assert_not_matches`](macro@crate::assert_not_matches)
* [`assert_not_matches_as_result`](macro@crate::assert_not_matches_as_result)
* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)

```rust
pub mod assert_not_matches { /* ... */ }
```

## Module `assert_starts_with`

Assert for a sequence that may start with a part.

These macros help with comparison of a sequence (such as a string, vector, range)
and a part (such as a string substring, an array element, a range value).

* [`assert_starts_with(sequence, subsequence)`](macro@crate::assert_starts_with) ≈ container.contains(containee)

* [`assert_not_starts_with!(sequence, subsequence)`](macro@crate::assert_not_starts_with) ≈ !container.contains(containee)

# Example

```rust
use assertables::*;

// String starts with substring?
let sequence: &str = "alfa";
let subsequence: &str = "al";
assert_starts_with!(sequence, subsequence);

// Vector starts with element?
let sequence = vec![1, 2, 3];
let subsequence = [1];
assert_starts_with!(sequence, subsequence);
```

```rust
pub mod assert_starts_with { /* ... */ }
```

### Modules

## Module `assert_not_starts_with`

Assert an expression (such as a string) does not start with an expression (such as a string).

Pseudocode:<br>
¬ a.starts_with(b)

# Example

```rust
use assertables::*;

// String starts with substring?
let sequence: &str = "alfa";
let subsequence: &str = "z";
assert_not_starts_with!(sequence, subsequence);

// Vector starts with element?
let sequence = vec![1, 2, 3];
let subsequence = [3];
assert_not_starts_with!(sequence, subsequence);
```

# Module macros

* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)
* [`assert_not_starts_with_as_result`](macro@crate::assert_not_starts_with_as_result)
* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)

```rust
pub mod assert_not_starts_with { /* ... */ }
```

## Module `assert_starts_with`

Assert an expression (such as a string) starts with an expression (such as a string).

Pseudocode:<br>
a.starts_with(b)

# Example

```rust
use assertables::*;

// String starts with substring?
let sequence: &str = "alfa";
let subsequence: &str = "al";
assert_starts_with!(sequence, subsequence);

// Vector starts with element?
let sequence = vec![1, 2, 3];
let subsequence = [1];
assert_starts_with!(sequence, subsequence);
```

# Module macros

* [`assert_starts_with`](macro@crate::assert_starts_with)
* [`assert_starts_with_as_result`](macro@crate::assert_starts_with_as_result)
* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)

```rust
pub mod assert_starts_with { /* ... */ }
```

## Module `assert_err`

Assert for Err(…) items.

These macros help compare Err(…) items, such as `::std::Result::Err` or similar.

Assert expression is Err:

* [`assert_err!(a)`](macro@crate::assert_err) ≈ a is Err(_)

Compare Err(…) to another Err(…):

* [`assert_err_eq!(a, b)`](macro@crate::assert_err_eq) ≈ (a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)
* [`assert_err_ne!(a, b)`](macro@crate::assert_err_ne) ≈ (a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)

Compare Err(…) to an expression:

* [`assert_err_eq_x!(a, expr)`](macro@crate::assert_err_eq_x) ≈ (a ⇒ Err(a1) ⇒ a1) = expr
* [`assert_err_ne_x!(a, expr)`](macro@crate::assert_err_ne_x) ≈ (a ⇒ Err(a1) ⇒ a1) ≠ expr

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Err(1);
assert_err!(a);
```

```rust
pub mod assert_err { /* ... */ }
```

### Modules

## Module `assert_err`

Assert expression is Err.

Pseudocode:<br>
a is Err(_)

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Err(1);
assert_err!(a);
```

# Module macros

* [`assert_err`](macro@crate::assert_err)
* [`assert_err_as_result`](macro@crate::assert_err_as_result)
* [`debug_assert_err`](macro@crate::debug_assert_err)

```rust
pub mod assert_err { /* ... */ }
```

## Module `assert_err_eq`

Assert two expressions are Err and their values are equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Err(1);
let b: Result<i8, i8> = Err(1);
assert_err_eq!(a, b);
```

# Module macros

* [`assert_err_eq`](macro@crate::assert_err_eq)
* [`assert_err_eq_as_result`](macro@crate::assert_err_eq_as_result)
* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)

```rust
pub mod assert_err_eq { /* ... */ }
```

## Module `assert_err_ne`

Assert two expressions are Err and their values are not equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Err(1);
let b: Result<i8, i8> = Err(2);
assert_err_ne!(a, b);
```

# Module macros

* [`assert_err_ne`](macro@crate::assert_err_ne)
* [`assert_err_ne_as_result`](macro@crate::assert_err_ne_as_result)
* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)

```rust
pub mod assert_err_ne { /* ... */ }
```

## Module `assert_err_eq_x`

Assert an expression is Err and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = b

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Err(1);
let b: i8 = 1;
assert_err_eq_x!(a, b);
```

# Module macros

* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)
* [`assert_err_eq_x_as_result`](macro@crate::assert_err_eq_x_as_result)
* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)

```rust
pub mod assert_err_eq_x { /* ... */ }
```

## Module `assert_err_ne_x`

Assert an expression is Err and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) ≠ b

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Err(1);
let b: i8 = 2;
assert_err_ne_x!(a, b);
```

# Module macros

* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)
* [`assert_err_ne_x_as_result`](macro@crate::assert_err_ne_x_as_result)
* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)

```rust
pub mod assert_err_ne_x { /* ... */ }
```

## Module `assert_ok`

Assert for Ok(…) items.

These macros help compare Ok(…) items, such as `::std::Result::Ok` or similar.

Assert expression is Ok:

* [`assert_ok!(a)`](macro@crate::assert_ok)
  ≈ a is Ok.

Compare Ok(…) to another Ok(…):

* [`assert_ok_eq!(a, b)`](macro@crate::assert_ok_eq) ≈ (a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)
* [`assert_ok_ne!(a, b)`](macro@crate::assert_ok_ne) ≈ (a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)

Compare Ok(…) to an expression:

* [`assert_ok_eq_x!(a, expr)`](macro@crate::assert_ok_eq_x) ≈ (a ⇒ Ok(a1) ⇒ a1) = expr
* [`assert_ok_ne_x!(a, expr)`](macro@crate::assert_ok_ne_x) ≈ (a ⇒ Ok(a1) ⇒ a1) ≠ expr

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Ok(1);
assert_ok!(a);
```

```rust
pub mod assert_ok { /* ... */ }
```

### Modules

## Module `assert_ok`

Assert expression is Ok.

Pseudocode:<br>
a is Ok.

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Ok(1);
assert_ok!(a);
```

# Module macros

* [`assert_ok`](macro@crate::assert_ok)
* [`assert_ok_as_result`](macro@crate::assert_ok_as_result)
* [`debug_assert_ok`](macro@crate::debug_assert_ok)

```rust
pub mod assert_ok { /* ... */ }
```

## Module `assert_ok_eq`

Assert two expressions are Ok and their values are equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Ok(1);
let b: Result<i8, i8> = Ok(1);
assert_ok_eq!(a, b);
```

# Module macros

* [`assert_ok_eq`](macro@crate::assert_ok_eq)
* [`assert_ok_eq_as_result`](macro@crate::assert_ok_eq_as_result)
* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)

```rust
pub mod assert_ok_eq { /* ... */ }
```

## Module `assert_ok_ne`

Assert two expressions are Ok and their values are not equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Ok(1);
let b: Result<i8, i8> = Ok(2);
assert_ok_ne!(a, b);
```

# Module macros

* [`assert_ok_ne`](macro@crate::assert_ok_ne)
* [`assert_ok_ne_as_result`](macro@crate::assert_ok_ne_as_result)
* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)

```rust
pub mod assert_ok_ne { /* ... */ }
```

## Module `assert_ok_eq_x`

Assert an expression is Ok and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = b

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Ok(1);
let b: i8 = 1;
assert_ok_eq_x!(a, b);
```

# Module macros

* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)
* [`assert_ok_eq_x_as_result`](macro@crate::assert_ok_eq_x_as_result)
* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)

```rust
pub mod assert_ok_eq_x { /* ... */ }
```

## Module `assert_ok_ne_x`

Assert an expression is Ok and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) ≠ b

# Example

```rust
use assertables::*;

let a: Result<i8, i8> = Ok(1);
let b: i8 = 2;
assert_ok_ne_x!(a, b);
```

# Module macros

* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)
* [`assert_ok_ne_x_as_result`](macro@crate::assert_ok_ne_x_as_result)
* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)

```rust
pub mod assert_ok_ne_x { /* ... */ }
```

## Module `assert_result`

Assert for `Result` {`Ok`, `Err`}

Deprecated.

Please rename from `assert_result_ok*` into `assert_ok*`.

Please rename from `assert_result_err` into `assert_err`.

```rust
pub mod assert_result { /* ... */ }
```

### Modules

## Module `assert_result_err`

Assert expression is Err.

Deprecated. Please rename from `assert_result_err` into `assert_err` because more developers prefer the shorter name.

```rust
pub mod assert_result_err { /* ... */ }
```

## Module `assert_result_ok`

Assert expression is Ok.

Deprecated. Please rename from `assert_result_ok` into `assert_ok` because more developers prefer the shorter name.

```rust
pub mod assert_result_ok { /* ... */ }
```

## Module `assert_result_ok_eq`

Assert two expressions are Ok and their values are equal.

Deprecated. Please rename from `assert_result_ok_eq` into `assert_ok_eq` because more developers prefer the shorter name.

```rust
pub mod assert_result_ok_eq { /* ... */ }
```

## Module `assert_result_ok_ne`

Assert two expressions are Ok and their values are not equal.

Deprecated. Please rename from `assert_result_ok_ne` into `assert_ok_ne` because more developers prefer the shorter name.

```rust
pub mod assert_result_ok_ne { /* ... */ }
```

## Module `assert_none`

Assert for None items.

These macros help compare None items, such as `::std::Option::None` or similar.

Assert expression is None:

* [`assert_none!(a)`](macro@crate::assert_none)
  ≈ a is None

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::None;
assert_none!(a);
```

```rust
pub mod assert_none { /* ... */ }
```

### Modules

## Module `assert_none`

Assert expression is None.

Pseudocode:<br>
a is None

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::None;
assert_none!(a);
```

# Module macros

* [`assert_none`](macro@crate::assert_none)
* [`assert_none_as_result`](macro@crate::assert_none_as_result)
* [`debug_assert_none`](macro@crate::debug_assert_none)

```rust
pub mod assert_none { /* ... */ }
```

## Module `assert_option`

Assert for `Option` {`Some`, `None`}

Deprecated.

Please rename from `assert_option_some*` into `assert_some*`.

Please rename from `assert_option_none` into `assert_none`.

```rust
pub mod assert_option { /* ... */ }
```

### Modules

## Module `assert_option_none`

Assert expression is None.

Deprecated. Please rename from `assert_option_none` into `assert_none` because more developers prefer the shorter name.

```rust
pub mod assert_option_none { /* ... */ }
```

## Module `assert_option_some`

Assert expression is Some.

Deprecated. Please rename from `assert_option_some` into `assert_some` because more developers prefer the shorter name.

```rust
pub mod assert_option_some { /* ... */ }
```

## Module `assert_option_some_eq`

Assert two expressions are Some and their values are equal.

Deprecated. Please rename from `assert_option_some_eq` into `assert_some_eq` because more developers prefer the shorter name.

```rust
pub mod assert_option_some_eq { /* ... */ }
```

## Module `assert_option_some_ne`

Assert two expressions are Some and their values are not equal.

Deprecated. Please rename from `assert_option_some_ne` into `assert_some_ne` because more developers prefer the shorter name.

```rust
pub mod assert_option_some_ne { /* ... */ }
```

## Module `assert_some`

Assert for Some(_) items.

These macros help compare Some(…) items, such as `::std::Option::Some` or similar.

Assert expression is Some:

* [`assert_some!(a)`](macro@crate::assert_some)
  ≈ a is Some

Compare Some(…) to another Some(…):

* [`assert_some_eq!(a, b)`](macro@crate::assert_some_eq) ≈ (a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)
* [`assert_some_ne!(a, b)`](macro@crate::assert_some_ne) ≈ (a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)

Compare Some(…) to an expression:

* [`assert_some_eq_x!(a, expr)`](macro@crate::assert_some_eq_x) ≈ (a ⇒ Some(a1) ⇒ a1) = expr
* [`assert_some_ne_x!(a, expr)`](macro@crate::assert_some_ne_x) ≈ (a ⇒ Some(a1) ⇒ a1) ≠ expr

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::Some(1);
assert_some!(a);
```

```rust
pub mod assert_some { /* ... */ }
```

### Modules

## Module `assert_some`

Assert expression is Some.

 Pseudocode:<br>
 a is Some

 # Example

 ```rust
 use assertables::*;

 let a: Option<i8> = Option::Some(1);
 assert_some!(a);
 ```

 # Module macros

 * [`assert_some`](macro@crate::assert_some)
 * [`assert_some_as_result`](macro@crate::assert_some_as_result)
 * [`debug_assert_some`](macro@crate::debug_assert_some)

```rust
pub mod assert_some { /* ... */ }
```

## Module `assert_some_eq`

Assert two expressions are Some and their values are equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::Some(1);
let b: Option<i8> = Option::Some(1);
assert_some_eq!(a, b);
```

# Module macros

* [`assert_some_eq`](macro@crate::assert_some_eq)
* [`assert_some_eq_as_result`](macro@crate::assert_some_eq_as_result)
* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)
Assert two expressions are Some and their values are equal.

```rust
pub mod assert_some_eq { /* ... */ }
```

## Module `assert_some_ne`

Assert two expressions are Some and their values are not equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::Some(1);
let b: Option<i8> = Option::Some(2);
assert_some_ne!(a, b);
```

# Module macros

* [`assert_some_ne`](macro@crate::assert_some_ne)
* [`assert_some_ne_as_result`](macro@crate::assert_some_ne_as_result)
* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)

```rust
pub mod assert_some_ne { /* ... */ }
```

## Module `assert_some_eq_x`

Assert an expression is Some and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = b

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::Some(1);
let b: i8 = 1;
assert_some_eq_x!(a, b);
```

# Module macros

* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)
* [`assert_some_eq_x_as_result`](macro@crate::assert_some_eq_x_as_result)
* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)

```rust
pub mod assert_some_eq_x { /* ... */ }
```

## Module `assert_some_ne_x`

Assert an expression is Some and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ b

# Example

```rust
use assertables::*;

let a: Option<i8> = Option::Some(1);
let b: i8 = 2;
assert_some_ne_x!(a, b);
```

# Module macros

* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)
* [`assert_some_ne_x_as_result`](macro@crate::assert_some_ne_x_as_result)
* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)

```rust
pub mod assert_some_ne_x { /* ... */ }
```

## Module `assert_pending`

Assert for Pending items.

These macros help compare Pending items, such as `::std::Poll::Pending` or similar.

Assert expression is Pending:

* [`assert_pending!(a)`](macro@crate::assert_pending)
  ≈ a is Pending

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;

let a: Poll<i8> = Pending;
assert_pending!(a);
```

```rust
pub mod assert_pending { /* ... */ }
```

### Modules

## Module `assert_pending`

Assert an expression is Pending.

Pseudocode:<br>
a is Pending

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;

let a: Poll<i8> = Pending;
assert_pending!(a);
```

# Module macros

* [`assert_pending`](macro@crate::assert_pending)
* [`assert_pending_as_result`](macro@crate::assert_pending_as_result)
* [`debug_assert_pending`](macro@crate::debug_assert_pending)

```rust
pub mod assert_pending { /* ... */ }
```

## Module `assert_poll`

Assert for `Poll` {`Ready`, `Pending`}

Deprecated.

Please rename from `assert_poll_ready*` into `assert_ready*`.

Please rename from `assert_poll_pending` into `assert_pending`.

```rust
pub mod assert_poll { /* ... */ }
```

### Modules

## Module `assert_poll_pending`

Assert an expression is Pending.

Deprecated. Please rename from `assert_poll_pending` into `assert_pending_as_result` because more developers prefer the shorter name.

```rust
pub mod assert_poll_pending { /* ... */ }
```

## Module `assert_poll_ready`

Assert an expression is Ready.

Deprecated. Please rename from `assert_poll_ready` into `assert_ready` because more developers prefer the shorter name.

```rust
pub mod assert_poll_ready { /* ... */ }
```

## Module `assert_poll_ready_eq`

Assert two expressions are Ready(_) and their values are equal.

Deprecated. Please rename from `assert_poll_ready_eq` into `assert_ready_eq` because more developers prefer the shorter name.

```rust
pub mod assert_poll_ready_eq { /* ... */ }
```

## Module `assert_poll_ready_ne`

Assert two expressions are Ready(_) and their values are not equal.

Deprecated. Please rename from `assert_poll_ready_ne` into `assert_ready_ne` because more developers prefer the shorter name.

```rust
pub mod assert_poll_ready_ne { /* ... */ }
```

## Module `assert_ready`

Assert for Ready(_) items.

These macros help compare Ready(…) items, such as `::std::Ready::Ready` or similar.

Assert expression is Ready:

* [`assert_ready!(a)`](macro@crate::assert_ready)
  ≈ a is Ready

Compare Ready(…) to another Ready(…):

* [`assert_ready_eq!(a, b)`](macro@crate::assert_ready_eq) ≈ (a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)
* [`assert_ready_ne!(a, b)`](macro@crate::assert_ready_ne) ≈ (a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)

Compare Ready(…) to an expression:

* [`assert_ready_eq_x!(a, expr)`](macro@crate::assert_ready_eq_x) ≈ (a ⇒ Ready(a1) ⇒ a1) = expr
* [`assert_ready_ne_x!(a, expr)`](macro@crate::assert_ready_ne_x) ≈ (a ⇒ Ready(a1) ⇒ a1) ≠ expr

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;

let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(1);
assert_ready_eq!(a, b);
```

```rust
pub mod assert_ready { /* ... */ }
```

### Modules

## Module `assert_ready`

Assert an expression is Ready.

Pseudocode:<br>
a is Ready

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;

let a: Poll<i8> = Ready(1);
assert_ready!(a);
```

# Module macros

* [`assert_ready`](macro@crate::assert_ready)
* [`assert_ready_as_result`](macro@crate::assert_ready_as_result)
* [`debug_assert_ready`](macro@crate::debug_assert_ready)

```rust
pub mod assert_ready { /* ... */ }
```

## Module `assert_ready_eq`

Assert two expressions are Ready and their values are equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;
let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(1);
assert_ready_eq!(a, b);
```

# Module macros

* [`assert_ready_eq`](macro@crate::assert_ready_eq)
* [`assert_ready_eq_as_result`](macro@crate::assert_ready_eq_as_result)
* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)

```rust
pub mod assert_ready_eq { /* ... */ }
```

## Module `assert_ready_ne`

Assert two expressions are Ready and their values are not equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;
let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(2);
assert_ready_ne!(a, b);
```

# Module macros

* [`assert_ready_ne`](macro@crate::assert_ready_ne)
* [`assert_ready_ne_as_result`](macro@crate::assert_ready_ne_as_result)
* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)

```rust
pub mod assert_ready_ne { /* ... */ }
```

## Module `assert_ready_eq_x`

Assert an expression is Ready and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = b

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;
let a: Poll<i8> = Ready(1);
let b: i8 = 1;
assert_ready_eq_x!(a, b);
```

# Module macros

* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)
* [`assert_ready_eq_x_as_result`](macro@crate::assert_ready_eq_x_as_result)
* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)

```rust
pub mod assert_ready_eq_x { /* ... */ }
```

## Module `assert_ready_ne_x`

Assert an expression is Ready and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ b

# Example

```rust
use assertables::*;
use std::task::Poll;
use std::task::Poll::*;
let a: Poll<i8> = Ready(1);
let b: i8 = 2;
assert_ready_ne_x!(a, b);
```

# Module macros

* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)
* [`assert_ready_ne_x_as_result`](macro@crate::assert_ready_ne_x_as_result)
* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)

```rust
pub mod assert_ready_ne_x { /* ... */ }
```

## Module `assert_bag`

Assert for comparing bag collections.

These macros help with comparison of bag parameters, such as comparison of
two arrays or two vectors, where the item order does not matter, and the
item count does matter. These macros convert their inputs into HashMap
iterators. See tutorial below.

For eq & ne:

* [`assert_bag_eq!(collection1, collection2)`](macro@crate::assert_bag_eq) ≈ bag a = bag b

* [`assert_bag_ne!(collection1, collection2)`](macro@crate::assert_bag_ne) ≈ bag a ≠ bag b

For subbag & superbag:

* [`assert_bag_subbag(collection1, collection2)`](macro@crate::assert_bag_subbag) ≈ bag a ⊆ bag b

* [`assert_bag_superbag!(collection1, collection2)`](macro@crate::assert_bag_superbag) ≈ bag a ⊇ bag b

# Example

```rust
use assertables::*;

let a = [1, 1];
let b = [1, 1];
assert_bag_eq!(&a, &b);
```

## Tutorial

A **bag** means a collection of elements, without any ordering, and tracking duplicate elements.

A bag is sometimes written by using mathematical notation, which looks like this:

```text
bag = {1, 1, 1, 2, 3}
```

Bags are equal when they contain all the same elements and corresponding counts in any order:

```text
{1, 1, 1, 2, 3} = {1, 1, 1, 2, 3} (same order)
{1, 1, 1, 2, 3} = {1, 3, 1, 2, 1} (different order)
```

Bags are not equal when they contain any different elements or any different corresponding counts:

```text
{1, 1, 1, 2, 3} ≠ {1, 1, 2, 3}
{1, 1, 1, 2, 3} ≠ {1, 1, 1, 2, 3, 4}
```

To create a bag using Rust, one way is to create an array or vector, then convert it into an iterator by using the method `into_iter`, then convert the elements into a map by using `std::collections::BTreeMap` and tracking each element's count:

```rust
# use ::std::collections::BTreeMap;
let array = [1, 1, 1, 2, 3];
let mut bag: BTreeMap<_, usize> = BTreeMap::new();
for x in array.into_iter() {
    let n = bag.entry(x).or_insert(0);
    *n += 1;
}
```

To compare two arrays as bags, one way is to convert each array to a bag, then use `assert_eq!` to compare the bags:

```rust
# use ::std::collections::BTreeMap;
let array1 = [1, 1, 1, 2, 3];
let array2 = [1, 3, 1, 2, 1];
let mut bag1: BTreeMap<_, usize> = BTreeMap::new();
for x in array1.into_iter() {
    let n = bag1.entry(x).or_insert(0);
    *n += 1;
}
let mut bag2: BTreeMap<_, usize> = BTreeMap::new();
for x in array2.into_iter() {
    let n = bag2.entry(x).or_insert(0);
    *n += 1;
}
assert_eq!(bag1, bag2);
```

The `assertables` crate provides macros that do the conversion for you:

```rust
# use ::std::collections::BTreeMap;
# use assertables::*;
let array1 = [1, 2, 3];
let array2 = [3, 2, 1];
assert_bag_eq!(array1, array2);
```

```rust
pub mod assert_bag { /* ... */ }
```

### Modules

## Module `assert_bag_eq`

Assert a bag is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)

# Example

```rust
use assertables::*;

let a = [1, 1];
let b = [1, 1];
assert_bag_eq!(a, b);
```

# Module macros

* [`assert_bag_eq`](macro@crate::assert_bag_eq)
* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)
* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)

```rust
pub mod assert_bag_eq { /* ... */ }
```

## Module `assert_bag_ne`

Assert a bag is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)

# Example

```rust
use assertables::*;

let a = [1, 1];
let b = [1, 1, 1];
assert_bag_ne!(a, b);
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_ne`](macro@crate::assert_bag_ne)
* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)
* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)

```rust
pub mod assert_bag_ne { /* ... */ }
```

## Module `assert_bag_subbag`

Assert a bag is a subbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)

# Example

```rust
use assertables::*;

let a = [1, 1];
let b = [1, 1, 1];
assert_bag_subbag!(a, b);
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)
* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)
* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)

```rust
pub mod assert_bag_subbag { /* ... */ }
```

## Module `assert_bag_superbag`

Assert a bag is a superbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)

# Example

```rust
use assertables::*;

let a = [1, 1, 1];
let b = [1, 1];
assert_bag_superbag!(a, b);
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)
* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)
* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)

```rust
pub mod assert_bag_superbag { /* ... */ }
```

## Module `assert_iter`

Assert for comparing iter collections.

These macros help with comparison of iter parameters, such as two arrays or
two vectors. These macros convert each input using the std::iter::Iterator trait.

* [`assert_iter_eq!(collection1, collection2)`](macro@crate::assert_iter_eq) ≈ iter a = iter b
* [`assert_iter_ne!(collection1, collection2)`](macro@crate::assert_iter_ne) ≈ iter a ≠ iter b
* [`assert_iter_lt!(collection1, collection2)`](macro@crate::assert_iter_gt) ≈ iter a < iter b
* [`assert_iter_le!(collection1, collection2)`](macro@crate::assert_iter_gt) ≈ iter a ≤ iter b
* [`assert_iter_gt!(collection1, collection2)`](macro@crate::assert_iter_gt) ≈ iter a > iter b
* [`assert_iter_ge!(collection1, collection2)`](macro@crate::assert_iter_ge) ≈ iter a ≥ iter b

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [1, 2];
assert_iter_eq!(&a, &b);
```

```rust
pub mod assert_iter { /* ... */ }
```

### Modules

## Module `assert_iter_eq`

Assert an iter is equal to another.

Pseudocode:<br>
(collection1 into iter) = (collection2 into iter)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [1, 2];
assert_iter_eq!(&a, &b);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_eq`](macro@crate::assert_iter_eq)
* [`assert_iter_eq_as_result`](macro@crate::assert_iter_eq_as_result)
* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)

```rust
pub mod assert_iter_eq { /* ... */ }
```

## Module `assert_iter_ge`

Assert an iter is greater than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≥ (collection2 into iter)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [1, 2];
assert_iter_ge!(&a, &b);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_ge`](macro@crate::assert_iter_ge)
* [`assert_iter_ge_as_result`](macro@crate::assert_iter_ge_as_result)
* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)

```rust
pub mod assert_iter_ge { /* ... */ }
```

## Module `assert_iter_gt`

Assert an iter is greater than another.

Pseudocode:<br>
(collection1 into iter) > (collection2 into iter)

# Example

```rust
use assertables::*;

let a = [3, 4];
let b = [1, 2];
assert_iter_gt!(&a, &b);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_gt`](macro@crate::assert_iter_gt)
* [`assert_iter_gt_as_result`](macro@crate::assert_iter_gt_as_result)
* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)

```rust
pub mod assert_iter_gt { /* ... */ }
```

## Module `assert_iter_le`

Assert an iter is less than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≤ (collection2 into iter)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [1, 2];
assert_iter_le!(&a, &b);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_le`](macro@crate::assert_iter_le)
* [`assert_iter_le_as_result`](macro@crate::assert_iter_le_as_result)
* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)

```rust
pub mod assert_iter_le { /* ... */ }
```

## Module `assert_iter_lt`

Assert an iter is less than another.

Pseudocode:<br>
(collection1 into iter) < (collection2 into iter)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [3, 4];
assert_iter_lt!(&a, &b);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_lt`](macro@crate::assert_iter_lt)
* [`assert_iter_lt_as_result`](macro@crate::assert_iter_lt_as_result)
* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)

```rust
pub mod assert_iter_lt { /* ... */ }
```

## Module `assert_iter_ne`

Assert an iter is not equal to another.

Pseudocode:<br>
(collection1 into iter) ≠ (collection2 into iter)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [3, 4];
assert_iter_ne!(&a, &b);
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_ne`](macro@crate::assert_iter_ne)
* [`assert_iter_ne_as_result`](macro@crate::assert_iter_ne_as_result)
* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)

```rust
pub mod assert_iter_ne { /* ... */ }
```

## Module `assert_set`

Assert for comparing set collections.

These macros help with comparison of set parameters, such as two arrays or
two vectors. where the item order does not matter, and the item count does
not matter. These macros convert their inputs into HashSet iterators.
See tutorial below.

For eq & ne:

* [`assert_set_eq!(collection1, collection2)`](macro@crate::assert_set_eq) ≈ set a = set b

* [`assert_set_ne!(collection1, collection2)`](macro@crate::assert_set_ne) ≈ set a ≠ set b

For subset & superset:

* [`assert_set_subset!(collection1, collection2)`](macro@crate::assert_set_subset) ≈ set a ⊆ set b

* [`assert_set_superset!(collection1, collection2)`](macro@crate::assert_set_superset) ≈ set a ⊇ set b

For joint & disjoint:

* [`assert_set_joint!(collection1, collection2)`](macro@crate::assert_set_joint) ≈ set a ∩ set b ≠ ∅

* [`assert_set_disjoint!(collection1, collection2)`](macro@crate::assert_set_disjoint) ≈ set a ∩ set b = ∅

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [2, 1];
assert_set_eq!(&a, &b);
```

## Tutorial

A **set** means a collection of elements, without any ordering, without duplicate elements.

A set is sometimes written by using mathematical notation, which looks like this:

```text
set = {1, 2, 3}
```

The definition of a set includes never having duplicate elements:

```text
set = {1, 2, 3, 2} // error because the element 2 is a duplicate
```

Sets are equal when they contain all the same elements in any order:

```text
{1, 2, 3} = {1, 2, 3} (same order)
{1, 2, 3} = {3, 2, 1} (different order)
```

Sets are not equal when they contain any different elements:

```text
{1, 2, 3} ≠ {1, 2}
{1, 2, 3} ≠ {1, 2, 3, 4}
```

To create a set using Rust, one way is to create an array or vector, then convert it into an iterator by using the method `into_iter`, then convert the elements into a set by using `std::collections::BTreeSet`:

```rust
# use ::std::collections::BTreeSet;
let array = [1, 2, 3];
let set: BTreeSet<_> = array.into_iter().collect();
```

To compare two arrays as sets, one way is to convert each array to a set, then use `assert_eq!` to compare the sets:

```rust
# use ::std::collections::BTreeSet;
let array1 = [1, 2, 3];
let array2 = [3, 2, 1];
let set1: BTreeSet<_> = array1.into_iter().collect();
let set2: BTreeSet<_> = array2.into_iter().collect();
assert_eq!(set1, set2);
```

The `assertables` crate provides macros that do the conversion for you:

```rust
# use ::std::collections::BTreeSet;
# use assertables::*;
let array1 = [1, 2, 3];
let array2 = [3, 2, 1];
assert_set_eq!(array1, array2);
```

```rust
pub mod assert_set { /* ... */ }
```

### Modules

## Module `assert_set_eq`

Assert a set is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) = (b_collection ⇒ b_set)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [2, 1];
assert_set_eq!(a, b);
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_eq`](macro@crate::assert_set_eq)
* [`assert_set_eq_as_result`](macro@crate::assert_set_eq_as_result)
* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)

```rust
pub mod assert_set_eq { /* ... */ }
```

## Module `assert_set_ne`

Assert a set is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [3, 4];
assert_set_ne!(a, b);
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_ne`](macro@crate::assert_set_ne)
* [`assert_set_ne_as_result`](macro@crate::assert_set_ne_as_result)
* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)

```rust
pub mod assert_set_ne { /* ... */ }
```

## Module `assert_set_disjoint`

Assert a set is disjoint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [3, 4];
assert_set_disjoint!(a, b);
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)
* [`assert_set_disjoint_as_result`](macro@crate::assert_set_disjoint_as_result)
* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)

```rust
pub mod assert_set_disjoint { /* ... */ }
```

## Module `assert_set_joint`

Assert a set is joint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [2, 3];
assert_set_joint!(a, b);
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_joint`](macro@crate::assert_set_joint)
* [`assert_set_joint_as_result`](macro@crate::assert_set_joint_as_result)
* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)

```rust
pub mod assert_set_joint { /* ... */ }
```

## Module `assert_set_subset`

Assert a set is a subset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)

# Example

```rust
use assertables::*;

let a = [1, 2];
let b = [1, 2, 3];
assert_set_subset!(a, b);
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_subset`](macro@crate::assert_set_subset)
* [`assert_set_subset_as_result`](macro@crate::assert_set_subset_as_result)
* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)

```rust
pub mod assert_set_subset { /* ... */ }
```

## Module `assert_set_superset`

Assert a set is a superset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)

# Example

```rust
use assertables::*;

let a = [1, 2, 3];
let b = [1, 2];
assert_set_superset!(a, b);
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_superset`](macro@crate::assert_set_superset)
* [`assert_set_superset_as_result`](macro@crate::assert_set_superset_as_result)
* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)

```rust
pub mod assert_set_superset { /* ... */ }
```

## Module `assert_fn`

Assert for comparing functions.

These macros help compare functions that return anything.
The macros call the functions, then compare the return values.

Compare a function with another function:

* [`assert_fn_eq!(a_function, b_function)`](macro@crate::assert_fn_eq) ≈ a_function() = b_function()
* [`assert_fn_ne!(a_function, b_function)`](macro@crate::assert_fn_ne) ≈ a_function() ≠ b_function()
* [`assert_fn_ge!(a_function, b_function)`](macro@crate::assert_fn_ge) ≈ a_function() ≥ b_function()
* [`assert_fn_gt!(a_function, b_function)`](macro@crate::assert_fn_gt) ≈ a_function() > b_function()
* [`assert_fn_le!(a_function, b_function)`](macro@crate::assert_fn_le) ≈ a_function() ≤ b_function()
* [`assert_fn_lt!(a_function, b_function)`](macro@crate::assert_fn_lt) ≈ a_function() < b_function()

Compare a function with an expression:

* [`assert_fn_eq_x!(function, expr)`](macro@crate::assert_fn_eq_x) ≈ function() = expr
* [`assert_fn_ne_x!(function, expr)`](macro@crate::assert_fn_ne_x) ≈ function() ≠ expr
* [`assert_fn_ge_x!(function, expr)`](macro@crate::assert_fn_ge_x) ≈ function() ≥ expr
* [`assert_fn_gt_x!(function, expr)`](macro@crate::assert_fn_gt_x) ≈ function() > expr
* [`assert_fn_le_x!(function, expr)`](macro@crate::assert_fn_le_x) ≈ function() ≤ expr
* [`assert_fn_lt_x!(function, expr)`](macro@crate::assert_fn_lt_x) ≈ function() < expr

# Example

```rust
use assertables::*;

let a: i8 = -1;
let b: i8 = 1;
assert_fn_eq!(i8::abs, a, i8::abs, b);
```

```rust
pub mod assert_fn { /* ... */ }
```

### Modules

## Module `assert_fn_eq`

Assert a function output is equal to another.

Pseudocode:<br>
a_function(a) == b_function(b)

# Example

```rust
use assertables::*;

let a: i8 = -1;
let b: i8 = 1;
assert_fn_eq!(i8::abs, a, i8::abs, b);
```

# Module macros

* [`assert_fn_eq`](macro@crate::assert_fn_eq)
* [`assert_fn_eq_as_result`](macro@crate::assert_fn_eq_as_result)
* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)

```rust
pub mod assert_fn_eq { /* ... */ }
```

## Module `assert_fn_ge`

Assert a function output is greater than or equal to another.

Pseudocode:<br>
a_function(a) > b_function(b)

# Example

```rust
use assertables::*;

let a: i8 = -2;
let b: i8 = 1;
assert_fn_ge!(i8::abs, a, i8::abs, b);
```

# Module macros

* [`assert_fn_ge`](macro@crate::assert_fn_ge)
* [`assert_fn_ge_as_result`](macro@crate::assert_fn_ge_as_result)
* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)

```rust
pub mod assert_fn_ge { /* ... */ }
```

## Module `assert_fn_gt`

Assert a function output is greater than another.

Pseudocode:<br>
a_function(a) > b_function(b)

# Example

```rust
use assertables::*;

let a: i8 = -2;
let b: i8 = 1;
assert_fn_gt!(i8::abs, a, i8::abs, b);
```

# Module macros

* [`assert_fn_gt`](macro@crate::assert_fn_gt)
* [`assert_fn_gt_as_result`](macro@crate::assert_fn_gt_as_result)
* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)

```rust
pub mod assert_fn_gt { /* ... */ }
```

## Module `assert_fn_le`

Assert a function output is less than or equal to another.

Pseudocode:<br>
a_function(a) ≤ b_function(b)

# Example

```rust
use assertables::*;

let a: i8 = 1;
let b: i8 = -2;
assert_fn_le!(i8::abs, a, i8::abs, b);
```

# Module macros

* [`assert_fn_le`](macro@crate::assert_fn_le)
* [`assert_fn_le_as_result`](macro@crate::assert_fn_le_as_result)
* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)

```rust
pub mod assert_fn_le { /* ... */ }
```

## Module `assert_fn_lt`

Assert a function output is less than another.

Pseudocode:<br>
a_function(a) < b_function(b)

# Example

```rust
use assertables::*;

let a: i8 = 1;
let b: i8 = -2;
assert_fn_lt!(i8::abs, a, i8::abs, b);
```

# Module macros

* [`assert_fn_lt`](macro@crate::assert_fn_lt)
* [`assert_fn_lt_as_result`](macro@crate::assert_fn_lt_as_result)
* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)

```rust
pub mod assert_fn_lt { /* ... */ }
```

## Module `assert_fn_ne`

Assert a function output is not equal to another.

Pseudocode:<br>
a_function(a) ≠ b_function(b)

# Example

```rust
use assertables::*;

let a: i8 = -1;
let b: i8 = 2;
assert_fn_ne!(i8::abs, a, i8::abs, b);
```

# Module macros

* [`assert_fn_ne`](macro@crate::assert_fn_ne)
* [`assert_fn_ne_as_result`](macro@crate::assert_fn_ne_as_result)
* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)

```rust
pub mod assert_fn_ne { /* ... */ }
```

## Module `assert_fn_eq_x`

Assert a function output is equal to an expression.

Pseudocode:<br>
function(a) = b

# Example

```rust
use assertables::*;

let a: i8 = -1;
let b: i8 = 1;
assert_fn_eq_x!(i8::abs, a, b);
```

# Module macros

* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)
* [`assert_fn_eq_x_as_result`](macro@crate::assert_fn_eq_x_as_result)
* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)

```rust
pub mod assert_fn_eq_x { /* ... */ }
```

## Module `assert_fn_ge_x`

Assert a function output is greater than or equal to an expression.

Pseudocode:<br>
function(a) ≥ expr

# Example

```rust
use assertables::*;

let a: i8 = -2;
let b: i8 = 1;
assert_fn_ge_x!(i8::abs, a, b);
```

# Module macros

* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)
* [`assert_fn_ge_x_as_result`](macro@crate::assert_fn_ge_x_as_result)
* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)

```rust
pub mod assert_fn_ge_x { /* ... */ }
```

## Module `assert_fn_gt_x`

Assert a function output is greater than an expression.

Pseudocode:<br>
function(a) > b

# Example

```rust
use assertables::*;

let a: i8 = -2;
let b: i8 = 1;
assert_fn_gt_x!(i8::abs, a, b);
```

# Module macros

* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)
* [`assert_fn_gt_x_as_result`](macro@crate::assert_fn_gt_x_as_result)
* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)

```rust
pub mod assert_fn_gt_x { /* ... */ }
```

## Module `assert_fn_le_x`

Assert a function output is less than or equal to an expression.

Pseudocode:<br>
function(a) ≤ b

# Example

```rust
use assertables::*;

let a: i8 = -1;
let b: i8 = 2;
assert_fn_le_x!(i8::abs, a, b);
```

# Module macros

* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)
* [`assert_fn_le_x_as_result`](macro@crate::assert_fn_le_x_as_result)
* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)

```rust
pub mod assert_fn_le_x { /* ... */ }
```

## Module `assert_fn_lt_x`

Assert a function output is less than an expression.

Pseudocode:<br>
a_function(a) < b

# Example

```rust
use assertables::*;

let a: i8 = -1;
let b: i8 = 2;
assert_fn_lt_x!(i8::abs, a, b);
```

# Module macros

* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)
* [`assert_fn_lt_x_as_result`](macro@crate::assert_fn_lt_x_as_result)
* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)

```rust
pub mod assert_fn_lt_x { /* ... */ }
```

## Module `assert_fn_ne_x`

Assert a function output is not equal to an expression.

Pseudocode:<br>
function(a) ≠ b

# Example

```rust
use assertables::*;

let a: i8 = 1;
let b: i8 = -2;
assert_fn_ne_x!(i8::abs, a, b);
```

# Module macros

* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)
* [`assert_fn_ne_x_as_result`](macro@crate::assert_fn_ne_x_as_result)
* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)

```rust
pub mod assert_fn_ne_x { /* ... */ }
```

## Module `assert_fn_err`

Assert for comparing functions that return errors.

These macros help compare functions that return results that are errors,
such as `::std::Result::Err` or similar.

The macros use these capabilities:

* implements `.is_err() -> bool`

* implements `.unwrap_err() -> comparable`

Compare a function Err() with another function Err():

* [`assert_fn_err_eq!(a_function, b_function)`](macro@crate::assert_fn_err_eq) ≈ a_function().unwrap_err() = b_function().unwrap_err()
* [`assert_fn_err_ne!(a_function, b_function)`](macro@crate::assert_fn_err_ne) ≈ a_function().unwrap_err() ≠ b_function().unwrap_err()
* [`assert_fn_err_ge!(a_function, b_function)`](macro@crate::assert_fn_err_ge) ≈ a_function().unwrap_err() ≥ b_function().unwrap_err()
* [`assert_fn_err_gt!(a_function, b_function)`](macro@crate::assert_fn_err_gt) ≈ a_function().unwrap_err() > b_function().unwrap_err()
* [`assert_fn_err_le!(a_function, b_function)`](macro@crate::assert_fn_err_le) ≈ a_function().unwrap_err() ≤ b_function().unwrap_err()
* [`assert_fn_err_lt!(a_function, b_function)`](macro@crate::assert_fn_err_lt) ≈ a_function().unwrap_err() < b_function().unwrap_err()

Compare a function Err() with an expression:

* [`assert_fn_err_eq_x!(function, expr)`](macro@crate::assert_fn_err_eq_x) ≈ function().unwrap_err() = expr
* [`assert_fn_err_ne_x!(function, expr)`](macro@crate::assert_fn_err_ne_x) ≈ function().unwrap_err() ≠ expr
* [`assert_fn_err_ge_x!(function, expr)`](macro@crate::assert_fn_err_ge_x) ≈ function().unwrap_err() ≥ expr
* [`assert_fn_err_gt_x!(function, expr)`](macro@crate::assert_fn_err_gt_x) ≈ function().unwrap_err() > expr
* [`assert_fn_err_le_x!(function, expr)`](macro@crate::assert_fn_err_le_x) ≈ function().unwrap_err() ≤ expr
* [`assert_fn_err_lt_x!(function, expr)`](macro@crate::assert_fn_err_lt_x) ≈ function().unwrap_err() < expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b: i8 = 10;
assert_fn_err_eq!(f, a, f, b);
```

```rust
pub mod assert_fn_err { /* ... */ }
```

### Modules

## Module `assert_fn_err_eq`

Assert a function Err(…) is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b: i8 = 10;
assert_fn_err_eq!(f, a, f, b);
```

# Module macros

* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)
* [`assert_fn_err_eq_as_result`](macro@crate::assert_fn_err_eq_as_result)
* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)

```rust
pub mod assert_fn_err_eq { /* ... */ }
```

## Module `assert_fn_err_ge`

Assert a function Err(…) is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 20;
let b: i8 = 10;
assert_fn_err_ge!(f, a, f, b);
```

# Module macros

* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)
* [`assert_fn_err_ge_as_result`](macro@crate::assert_fn_err_ge_as_result)
* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)

```rust
pub mod assert_fn_err_ge { /* ... */ }
```

## Module `assert_fn_err_gt`

Assert a function Err(…) is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 20;
let b: i8 = 10;
assert_fn_err_gt!(f, a, f, b);
```

# Module macros

* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)
* [`assert_fn_err_gt_as_result`](macro@crate::assert_fn_err_gt_as_result)
* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)

```rust
pub mod assert_fn_err_gt { /* ... */ }
```

## Module `assert_fn_err_le`

Assert a function Err(…) is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_le!(f, a, f, b);
```

# Module macros

* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)
* [`assert_fn_err_le_as_result`](macro@crate::assert_fn_err_le_as_result)
* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)

```rust
pub mod assert_fn_err_le { /* ... */ }
```

## Module `assert_fn_err_lt`

Assert a function Err(…) is less than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) < (b_function(b_param) ⇒ Err(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_lt!(f, a, f, b);
```

# Module macros

* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)
* [`assert_fn_err_lt_as_result`](macro@crate::assert_fn_err_lt_as_result)
* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)

```rust
pub mod assert_fn_err_lt { /* ... */ }
```

## Module `assert_fn_err_ne`

Assert a function Err(…) is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_ne!(f, a, f, b);
```

# Module macros

* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)
* [`assert_fn_err_ne_as_result`](macro@crate::assert_fn_err_ne_as_result)
* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)

```rust
pub mod assert_fn_err_ne { /* ... */ }
```

## Module `assert_fn_err_eq_x`

Assert a function Err(…) is equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) = expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}
```

# Module macros

* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)
* [`assert_fn_err_eq_x_as_result`](macro@crate::assert_fn_err_eq_x_as_result)
* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)

```rust
pub mod assert_fn_err_eq_x { /* ... */ }
```

## Module `assert_fn_err_ge_x`

Assert a function Err(…) is greater than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≥ expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 20;
let b = String::from("10 is out of range");
assert_fn_err_ge_x!(f, a, b);
```

# Module macros

* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)
* [`assert_fn_err_ge_x_as_result`](macro@crate::assert_fn_err_ge_x_as_result)
* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)

```rust
pub mod assert_fn_err_ge_x { /* ... */ }
```

## Module `assert_fn_err_gt_x`

Assert a function Err(…) is greater than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) > expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 20;
let b = String::from("10 is out of range");
assert_fn_err_gt_x!(f, a, b);
```

# Module macros

* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)
* [`assert_fn_err_gt_x_as_result`](macro@crate::assert_fn_err_gt_x_as_result)
* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)

```rust
pub mod assert_fn_err_gt_x { /* ... */ }
```

## Module `assert_fn_err_le_x`

Assert a function Err(…) is less than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≤ expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_le_x!(f, a, b);
```

# Module macros

* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)
* [`assert_fn_err_le_x_as_result`](macro@crate::assert_fn_err_le_x_as_result)
* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)

```rust
pub mod assert_fn_err_le_x { /* ... */ }
```

## Module `assert_fn_err_lt_x`

Assert a function Err(…) is less than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) < expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_lt_x!(f, a, b);
```

# Module macros

* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)
* [`assert_fn_err_lt_x_as_result`](macro@crate::assert_fn_err_lt_x_as_result)
* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)

```rust
pub mod assert_fn_err_lt_x { /* ... */ }
```

## Module `assert_fn_err_ne_x`

Assert a function Err(…) is not equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≠ expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_ne_x!(f, a, b);
```

# Module macros

* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)
* [`assert_fn_err_ne_x_as_result`](macro@crate::assert_fn_err_ne_x_as_result)
* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)

```rust
pub mod assert_fn_err_ne_x { /* ... */ }
```

## Module `assert_fn_ok`

Assert for comparing functions that return Result::Ok.

These macros help compare functions that return results that are ok, such as
`::std::Result::Ok` or similar.

The macros use these capabilities:

* implements `.is_ok() -> bool`

* implements `.unwrap_ok() -> comparable`

Compare a function Ok() with another function Ok():

* [`assert_fn_ok_eq!(a_function, b_function)`](macro@crate::assert_fn_ok_eq) ≈ a_function().unwrap_err() = b_function().unwrap_err()
* [`assert_fn_ok_ne!(a_function, b_function)`](macro@crate::assert_fn_ok_ne) ≈ a_function().unwrap_err() ≠ b_function().unwrap_err()
* [`assert_fn_ok_ge!(a_function, b_function)`](macro@crate::assert_fn_ok_ge) ≈ a_function().unwrap_err() ≥ b_function().unwrap_err()
* [`assert_fn_ok_gt!(a_function, b_function)`](macro@crate::assert_fn_ok_gt) ≈ a_function().unwrap_err() > b_function().unwrap_err()
* [`assert_fn_ok_le!(a_function, b_function)`](macro@crate::assert_fn_ok_le) ≈ a_function().unwrap_err() ≤ b_function().unwrap_err()
* [`assert_fn_ok_lt!(a_function, b_function)`](macro@crate::assert_fn_ok_lt) ≈ a_function().unwrap_err() < b_function().unwrap_err()

Compare a function Ok() with an expression:

* [`assert_fn_ok_eq_x!(function, expr)`](macro@crate::assert_fn_ok_eq_x) ≈ function().unwrap_err() = expr
* [`assert_fn_ok_ne_x!(function, expr)`](macro@crate::assert_fn_ok_ne_x) ≈ function().unwrap_err() ≠ expr
* [`assert_fn_ok_ge_x!(function, expr)`](macro@crate::assert_fn_ok_ge_x) ≈ function().unwrap_err() ≥ expr
* [`assert_fn_ok_gt_x!(function, expr)`](macro@crate::assert_fn_ok_gt_x) ≈ function().unwrap_err() > expr
* [`assert_fn_ok_le_x!(function, expr)`](macro@crate::assert_fn_ok_le_x) ≈ function().unwrap_err() ≤ expr
* [`assert_fn_ok_lt_x!(function, expr)`](macro@crate::assert_fn_ok_lt_x) ≈ function().unwrap_err() < expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b: i8 = 1;
assert_fn_ok_eq!(f, a, f, b);
```

```rust
pub mod assert_fn_ok { /* ... */ }
```

### Modules

## Module `assert_fn_ok_eq`

Assert a function Ok(…) is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b: i8 = 1;
assert_fn_ok_eq!(f, a, f, b);
```

# Module macros

* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)
* [`assert_fn_ok_eq_as_result`](macro@crate::assert_fn_ok_eq_as_result)
* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)

```rust
pub mod assert_fn_ok_eq { /* ... */ }
```

## Module `assert_fn_ok_ge`

Assert a function Ok(…) is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 2;
let b: i8 = 1;
assert_fn_ok_ge!(f, a, f, b);
```

# Module macros

* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)
* [`assert_fn_ok_ge_as_result`](macro@crate::assert_fn_ok_ge_as_result)
* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)

```rust
pub mod assert_fn_ok_ge { /* ... */ }
```

## Module `assert_fn_ok_gt`

Assert a function Ok(…) is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 2;
let b: i8 = 1;
assert_fn_ok_gt!(f, a, f, b);
```

# Module macros

* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)
* [`assert_fn_ok_gt_as_result`](macro@crate::assert_fn_ok_gt_as_result)
* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)

```rust
pub mod assert_fn_ok_gt { /* ... */ }
```

## Module `assert_fn_ok_le`

Assert a function Ok(…) is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_le!(f, a, f, b);
```

# Module macros

* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)
* [`assert_fn_ok_le_as_result`](macro@crate::assert_fn_ok_le_as_result)
* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)

```rust
pub mod assert_fn_ok_le { /* ... */ }
```

## Module `assert_fn_ok_lt`

Assert a function Ok(…) is less than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_lt!(f, a, f, b);
```

# Module macros

* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)
* [`assert_fn_ok_lt_as_result`](macro@crate::assert_fn_ok_lt_as_result)
* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)

```rust
pub mod assert_fn_ok_lt { /* ... */ }
```

## Module `assert_fn_ok_ne`

Assert a function Ok(…) is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_ne!(f, a, f, b);
```

# Module macros

* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)
* [`assert_fn_ok_ne_as_result`](macro@crate::assert_fn_ok_ne_as_result)
* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)

```rust
pub mod assert_fn_ok_ne { /* ... */ }
```

## Module `assert_fn_ok_eq_x`

Assert a function Ok(…) is equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b = String::from("1");
assert_fn_ok_eq_x!(f, a, b);
```

# Module macros

* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)
* [`assert_fn_ok_eq_x_as_result`](macro@crate::assert_fn_ok_eq_x_as_result)
* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)

```rust
pub mod assert_fn_ok_eq_x { /* ... */ }
```

## Module `assert_fn_ok_ge_x`

Assert a function Ok(…) is greater than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 2;
let b = String::from("1");
assert_fn_ok_ge_x!(f, a, b);
```

# Module macros

* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)
* [`assert_fn_ok_ge_x_as_result`](macro@crate::assert_fn_ok_ge_x_as_result)
* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)

```rust
pub mod assert_fn_ok_ge_x { /* ... */ }
```

## Module `assert_fn_ok_gt_x`

Assert a function Ok(…) is greater than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 2;
let b = String::from("1");
assert_fn_ok_gt_x!(f, a, b);
```

# Module macros

* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)
* [`assert_fn_ok_gt_x_as_result`](macro@crate::assert_fn_ok_gt_x_as_result)
* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)

```rust
pub mod assert_fn_ok_gt_x { /* ... */ }
```

## Module `assert_fn_ok_le_x`

Assert a function Ok(…) is less than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_le_x!(f, a, b);
```

# Module macros

* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)
* [`assert_fn_ok_le_x_as_result`](macro@crate::assert_fn_ok_le_x_as_result)
* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)

```rust
pub mod assert_fn_ok_le_x { /* ... */ }
```

## Module `assert_fn_ok_lt_x`

Assert a function Ok(…) is less than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_lt_x!(f, a, b);
```

# Module macros

* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)
* [`assert_fn_ok_lt_x_as_result`](macro@crate::assert_fn_ok_lt_x_as_result)
* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)

```rust
pub mod assert_fn_ok_lt_x { /* ... */ }
```

## Module `assert_fn_ok_ne_x`

Assert a function Ok(…) is not equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr

# Example

```rust
use assertables::*;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_ne_x!(f, a, b);
```

# Module macros

* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)
* [`assert_fn_ok_ne_x_as_result`](macro@crate::assert_fn_ok_ne_x_as_result)
* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)

```rust
pub mod assert_fn_ok_ne_x { /* ... */ }
```

## Module `assert_fs_read_to_string`

Assert for comparing file system path contents.

These macros help with file system paths, such as disk files, `Path`,
`PathBuf`, the trait `AsRef<Path>`, and anything that is readable via
`::std::fs::read_to_string(…)`. See tutorial below.

Compare a path with another path:

* [`assert_fs_read_to_string_eq!(path1, path2)`](macro@crate::assert_fs_read_to_string_eq) ≈ std::fs::read_to_string(path1) = std::fs::read_to_string(path2)
* [`assert_fs_read_to_string_ne!(path1, path2)`](macro@crate::assert_fs_read_to_string_ne) ≈ std::fs::read_to_string(path1) ≠ std::fs::read_to_string(path2)
* [`assert_fs_read_to_string_lt!(path1, path2)`](macro@crate::assert_fs_read_to_string_lt) ≈ std::fs::read_to_string(path1) < std::fs::read_to_string(path2)
* [`assert_fs_read_to_string_le!(path1, path2)`](macro@crate::assert_fs_read_to_string_le) ≈ std::fs::read_to_string(path1) ≤ std::fs::read_to_string(path2)
* [`assert_fs_read_to_string_gt!(path1, path2)`](macro@crate::assert_fs_read_to_string_gt) ≈ std::fs::read_to_string(path1) > std::fs::read_to_string(path2)
* [`assert_fs_read_to_string_ge!(path1, path2)`](macro@crate::assert_fs_read_to_string_ge) ≈ std::fs::read_to_string(path1) ≥ std::fs::read_to_string(path2)

Compare a path with an expression:

* [`assert_fs_read_to_string_eq_x!(path, expr)`](macro@crate::assert_fs_read_to_string_eq_x) ≈ std::fs::read_to_string(path) = expr
* [`assert_fs_read_to_string_ne_x!(path, expr)`](macro@crate::assert_fs_read_to_string_ne_x) ≈ std::fs::read_to_string(path) ≠ expr
* [`assert_fs_read_to_string_lt_x!(path, expr)`](macro@crate::assert_fs_read_to_string_lt_x) ≈ std::fs::read_to_string(path) < expr
* [`assert_fs_read_to_string_le_x!(path, expr)`](macro@crate::assert_fs_read_to_string_le_x) ≈ std::fs::read_to_string(path) ≤ expr
* [`assert_fs_read_to_string_gt_x!(path, expr)`](macro@crate::assert_fs_read_to_string_gt_x) ≈ std::fs::read_to_string(path) > expr
* [`assert_fs_read_to_string_ge_x!(path, expr)`](macro@crate::assert_fs_read_to_string_ge_x) ≈ std::fs::read_to_string(path) ≥ expr

Compare a path with its contents:

* [`assert_fs_read_to_string_contains!(path, containee)`](macro@crate::assert_fs_read_to_string_contains) ≈ std::fs::read_to_string(path).contains(containee)
* [`assert_fs_read_to_string_is_match!(path, matcher)`](macro@crate::assert_fs_read_to_string_is_match) ≈ matcher.is_match(::std::fs::read_to_string(path))

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa.txt";
let b = "alfa.txt";
assert_fs_read_to_string_eq!(a, b);
```

## Tutorial

Rust has a concept of a "file system" and a function "read to string"
that makes it easy to read a file to a string:

```rust
let path = "alfa.txt";
let string = ::std::fs::read_to_string(path);
```

Rust can compare a file's string to another file's string:

```rust
let path1 = "alfa.txt";
let path2 = "bravo.txt";
let a_string = ::std::fs::read_to_string(path1).unwrap();
let b_string = ::std::fs::read_to_string(path2).unwrap();
assert_ne!(a_string, b_string);
```

The `assertables` crate provides macros that do the reading for you:

```rust
# use assertables::*;
let path1 = "alfa.txt";
let path2 = "bravo.txt";
assert_fs_read_to_string_ne!(path1, path2);
```

```rust
pub mod assert_fs_read_to_string { /* ... */ }
```

### Modules

## Module `assert_fs_read_to_string_eq`

Assert a ::std::fs::read_to_string(path) value is equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)

# Example

```rust
use assertables::*;

let a = "alfa.txt";
let b = "alfa.txt";
assert_fs_read_to_string_eq!(a, b);
```

# Module macros

* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)
* [`assert_fs_read_to_string_eq_as_result`](macro@crate::assert_fs_read_to_string_eq_as_result)
* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)

```rust
pub mod assert_fs_read_to_string_eq { /* ... */ }
```

## Module `assert_fs_read_to_string_ge`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)

# Example

```rust
use assertables::*;

let a = "alfa.txt";
let b ="bravo.txt";
assert_fs_read_to_string_ge!(&b, &a);
```

# Module macros

* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)
* [`assert_fs_read_to_string_ge_as_result`](macro@crate::assert_fs_read_to_string_ge_as_result)
* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)

```rust
pub mod assert_fs_read_to_string_ge { /* ... */ }
```

## Module `assert_fs_read_to_string_gt`

Assert a ::std::fs::read_to_string(path) value is greater than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)

# Example

```rust
use assertables::*;

let a = "alfa.txt";
let b ="bravo.txt";
assert_fs_read_to_string_gt!(&b, &a);
```

# Module macros

* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)
* [`assert_fs_read_to_string_gt_as_result`](macro@crate::assert_fs_read_to_string_gt_as_result)
* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)

```rust
pub mod assert_fs_read_to_string_gt { /* ... */ }
```

## Module `assert_fs_read_to_string_le`

Assert a ::std::fs::read_to_string(path) value is less than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)

# Example

```rust
use assertables::*;

let a = "alfa.txt";
let b ="bravo.txt";
assert_fs_read_to_string_le!(a, b);
```

# Module macros

* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)
* [`assert_fs_read_to_string_le_as_result`](macro@crate::assert_fs_read_to_string_le_as_result)
* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)

```rust
pub mod assert_fs_read_to_string_le { /* ... */ }
```

## Module `assert_fs_read_to_string_lt`

Assert a ::std::fs::read_to_string(path) value is less than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)

# Example

```rust
use assertables::*;

let a = "alfa.txt";
let b ="bravo.txt";
assert_fs_read_to_string_lt!(a, b);
```

# Module macros

* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)
* [`assert_fs_read_to_string_lt_as_result`](macro@crate::assert_fs_read_to_string_lt_as_result)
* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)

```rust
pub mod assert_fs_read_to_string_lt { /* ... */ }
```

## Module `assert_fs_read_to_string_ne`

Assert a ::std::fs::read_to_string(path) is not equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)

# Example

```rust
use assertables::*;

let a = "alfa.txt";
let b ="bravo.txt";
assert_fs_read_to_string_ne!(a, b);
```

# Module macros

* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)
* [`assert_fs_read_to_string_ne_as_result`](macro@crate::assert_fs_read_to_string_ne_as_result)
* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)

```rust
pub mod assert_fs_read_to_string_ne { /* ... */ }
```

## Module `assert_fs_read_to_string_eq_x`

Assert a ::std::fs::read_to_string(path) value is equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) = expr

# Example

```rust
use assertables::*;

let path = "alfa.txt";
let x = "alfa\n";
assert_fs_read_to_string_eq_x!(path, x);
```

# Module macros

* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)
* [`assert_fs_read_to_string_eq_x_as_result`](macro@crate::assert_fs_read_to_string_eq_x_as_result)
* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)

```rust
pub mod assert_fs_read_to_string_eq_x { /* ... */ }
```

## Module `assert_fs_read_to_string_ge_x`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≥ expr

# Example

```rust
use assertables::*;

let path = "bravo.txt";
let x = "alfa\n";
assert_fs_read_to_string_ge_x!(path, x);
```

# Module macros

* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)
* [`assert_fs_read_to_string_ge_x_as_result`](macro@crate::assert_fs_read_to_string_ge_x_as_result)
* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)

```rust
pub mod assert_fs_read_to_string_ge_x { /* ... */ }
```

## Module `assert_fs_read_to_string_gt_x`

Assert a ::std::fs::read_to_string(path) value is greater than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) > expr

# Example

```rust
use assertables::*;

let path = "bravo.txt";
let x = "alfa\n";
assert_fs_read_to_string_gt_x!(path, x);
```

# Module macros

* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)
* [`assert_fs_read_to_string_gt_x_as_result`](macro@crate::assert_fs_read_to_string_gt_x_as_result)
* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)

```rust
pub mod assert_fs_read_to_string_gt_x { /* ... */ }
```

## Module `assert_fs_read_to_string_le_x`

Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≤ expr

# Example

```rust
use assertables::*;

let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_le_x!(path, x);
```

# Module macros

* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)
* [`assert_fs_read_to_string_le_x_as_result`](macro@crate::assert_fs_read_to_string_le_x_as_result)
* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)

```rust
pub mod assert_fs_read_to_string_le_x { /* ... */ }
```

## Module `assert_fs_read_to_string_lt_x`

Assert a ::std::fs::read_to_string(path) value is less than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) < expr

# Example

```rust
use assertables::*;

let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_lt_x!(path, x);
```

# Module macros

* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)
* [`assert_fs_read_to_string_lt_x_as_result`](macro@crate::assert_fs_read_to_string_lt_x_as_result)
* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)

```rust
pub mod assert_fs_read_to_string_lt_x { /* ... */ }
```

## Module `assert_fs_read_to_string_ne_x`

Assert a ::std::fs::read_to_string(path) is not equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≠ expr

# Example

```rust
use assertables::*;

let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_ne_x!(path, x);
```

# Module macros

* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)
* [`assert_fs_read_to_string_ne_x_as_result`](macro@crate::assert_fs_read_to_string_ne_x_as_result)
* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)

```rust
pub mod assert_fs_read_to_string_ne_x { /* ... */ }
```

## Module `assert_fs_read_to_string_contains`

Assert a ::std::fs::read_to_string(path) contains a pattern.

Pseudocode:<br>
std::fs::read_to_string(path) contains expr

# Example

```rust
use assertables::*;

let path = "alfa.txt";
let containee = "alfa";
assert_fs_read_to_string_contains!(path, containee);
```

# Module macros

* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)
* [`assert_fs_read_to_string_contains_as_result`](macro@crate::assert_fs_read_to_string_contains_as_result)
* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)

```rust
pub mod assert_fs_read_to_string_contains { /* ... */ }
```

## Module `assert_fs_read_to_string_is_match`

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Pseudocode:<br>
std::fs::read_to_string(path) matches expr

# Example

```rust
use assertables::*;
use regex::Regex;

let path = "alfa.txt";
let matcher = Regex::new(r"lf").expect("regex");
assert_fs_read_to_string_is_match!(path, matcher);
```

# Module macros

* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)
* [`assert_fs_read_to_string_is_match_as_result`](macro@crate::assert_fs_read_to_string_is_match_as_result)
* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)

```rust
pub mod assert_fs_read_to_string_is_match { /* ... */ }
```

## Module `assert_fs_read_to_string_matches`

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `assert_fs_read_to_string_matches` into `assert_fs_read_to_string_is_match`.

```rust
pub mod assert_fs_read_to_string_matches { /* ... */ }
```

## Module `assert_io_read_to_string`

Assert for comparing input/output reader streams.

These macros help with input/output readers, such as file handles, byte arrays,
input streams, the trait `::std::io::Read`, and anything that implements a
method `read_to_string() -> String`. See tutorial below.

## Macros

Compare a reader with another reader:

* [`assert_io_read_to_string_eq!(reader1, reader2)`](macro@crate::assert_io_read_to_string_eq) ≈ reader1.read_to_string() = reader2.read_to_string()
* [`assert_io_read_to_string_ne!(reader1, reader2)`](macro@crate::assert_io_read_to_string_ne) ≈ reader1.read_to_string() ≠ reader2.read_to_string()
* [`assert_io_read_to_string_lt!(reader1, reader2)`](macro@crate::assert_io_read_to_string_lt) ≈ reader1.read_to_string() < reader2.read_to_string()
* [`assert_io_read_to_string_le!(reader1, reader2)`](macro@crate::assert_io_read_to_string_le) ≈ reader1.read_to_string() ≤ reader2.read_to_string()
* [`assert_io_read_to_string_gt!(reader1, reader2)`](macro@crate::assert_io_read_to_string_gt) ≈ reader1.read_to_string() > reader2.read_to_string()
* [`assert_io_read_to_string_ge!(reader1, reader2)`](macro@crate::assert_io_read_to_string_ge) ≈ reader1.read_to_string() ≥ reader2.read_to_string()

Compare a reader with an expression:

* [`assert_io_read_to_string_eq_x!(reader, expr)`](macro@crate::assert_io_read_to_string_eq_x) ≈ reader.read_to_string() = expr
* [`assert_io_read_to_string_ne_x!(reader, expr)`](macro@crate::assert_io_read_to_string_ne_x) ≈ reader.read_to_string() ≠ expr
* [`assert_io_read_to_string_lt_x!(reader, expr)`](macro@crate::assert_io_read_to_string_lt_x) ≈ reader.read_to_string() < expr
* [`assert_io_read_to_string_le_x!(reader, expr)`](macro@crate::assert_io_read_to_string_le_x) ≈ reader.read_to_string() ≤ expr
* [`assert_io_read_to_string_gt_x!(reader, expr)`](macro@crate::assert_io_read_to_string_gt_x) ≈ reader.read_to_string() > expr
* [`assert_io_read_to_string_ge_x!(reader, expr)`](macro@crate::assert_io_read_to_string_ge_x) ≈ reader.read_to_string() ≥ expr

Compare a reader with its contents:

* [`assert_io_read_to_string_contains!(reader, &containee)`](macro@crate::assert_io_read_to_string_contains) ≈ reader.read_to_string().contains(containee)
* [`assert_io_read_to_string_is_match!(reader, matcher)`](macro@crate::assert_io_read_to_string_is_match) ≈ matcher.is_match(reader.read_to_string())

# Example

```rust
use assertables::*;
use std::io::Read;

let mut a = "alfa".as_bytes();
let mut b = "alfa".as_bytes();
assert_io_read_to_string_eq!(a, b);
```

## Tutorial

Rust has a concept of a "reader", such as using `::std::io::Read` to read bytes,
or to use the method `read_to_string` to read bytes into a string buffer.

```rust
use std::io::Read;
let mut reader = "hello".as_bytes();
let mut string = String::new();
let result = reader.read_to_string(&mut string);
```

Rust can compare a reader's string to another reader's string:

```rust
use std::io::Read;
let mut reader1 = "hello".as_bytes();
let mut reader2 = "world".as_bytes();
let mut a_string = String::new();
let mut b_string = String::new();
let result1 = reader1.read_to_string(&mut a_string);
let result2 = reader2.read_to_string(&mut b_string);
assert_ne!(a_string, b_string);
```

The `assertables` crate provides macros that do the reading and string buffering for you:

```rust
# use std::io::Read;
# use assertables::*;
let mut reader1 = "hello".as_bytes();
let mut reader2 = "world".as_bytes();
assert_io_read_to_string_ne!(reader1, reader2);
```

```rust
pub mod assert_io_read_to_string { /* ... */ }
```

### Modules

## Module `assert_io_read_to_string_eq`

Assert a ::std::io::Read read_to_string() value is equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa".as_bytes();
let b = "alfa".as_bytes();
assert_io_read_to_string_eq!(a, b);
```

# Module macros

* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)
* [`assert_io_read_to_string_eq_as_result`](macro@crate::assert_io_read_to_string_eq_as_result)
* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)

```rust
pub mod assert_io_read_to_string_eq { /* ... */ }
```

## Module `assert_io_read_to_string_ge`

Assert a ::std::io::Read read_to_string() value is greater than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa".as_bytes();
let b = "aa".as_bytes();
assert_io_read_to_string_ge!(a, b);
```

# Module macros

* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)
* [`assert_io_read_to_string_ge_as_result`](macro@crate::assert_io_read_to_string_ge_as_result)
* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)

```rust
pub mod assert_io_read_to_string_ge { /* ... */ }
```

## Module `assert_io_read_to_string_gt`

Assert a ::std::io::Read read_to_string() value is greater than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa".as_bytes();
let b = "aa".as_bytes();
assert_io_read_to_string_gt!(a, b);
```

# Module macros

* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)
* [`assert_io_read_to_string_gt_as_result`](macro@crate::assert_io_read_to_string_gt_as_result)
* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)

```rust
pub mod assert_io_read_to_string_gt { /* ... */ }
```

## Module `assert_io_read_to_string_le`

Assert a ::std::io::Read read_to_string() value is less than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_le!(a, b);
```

# Module macros

* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)
* [`assert_io_read_to_string_le_as_result`](macro@crate::assert_io_read_to_string_le_as_result)
* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)

```rust
pub mod assert_io_read_to_string_le { /* ... */ }
```

## Module `assert_io_read_to_string_lt`

Assert a ::std::io::Read read_to_string() value is less than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_lt!(a, b);
```

# Module macros

* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)
* [`assert_io_read_to_string_lt_as_result`](macro@crate::assert_io_read_to_string_lt_as_result)
* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)

```rust
pub mod assert_io_read_to_string_lt { /* ... */ }
```

## Module `assert_io_read_to_string_ne`

Assert a ::std::io::Read read_to_string() is not equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_ne!(a, b);
```

# Module macros

* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)
* [`assert_io_read_to_string_ne_as_result`](macro@crate::assert_io_read_to_string_ne_as_result)
* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)

```rust
pub mod assert_io_read_to_string_ne { /* ... */ }
```

## Module `assert_io_read_to_string_eq_x`

Assert a ::std::io::Read read_to_string() value is equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) = expr

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "alfa".as_bytes();
let x = String::from("alfa");
assert_io_read_to_string_eq_x!(reader, x);
```

# Module macros

* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)
* [`assert_io_read_to_string_eq_x_as_result`](macro@crate::assert_io_read_to_string_eq_x_as_result)
* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)

```rust
pub mod assert_io_read_to_string_eq_x { /* ... */ }
```

## Module `assert_io_read_to_string_ge_x`

Assert a ::std::io::Read read_to_string() value is greater than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "alfa".as_bytes();
let x = String::from("aa");
assert_io_read_to_string_ge_x!(reader, x);
```

# Module macros

* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)
* [`assert_io_read_to_string_ge_x_as_result`](macro@crate::assert_io_read_to_string_ge_x_as_result)
* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)

```rust
pub mod assert_io_read_to_string_ge_x { /* ... */ }
```

## Module `assert_io_read_to_string_gt_x`

Assert a ::std::io::Read read_to_string() value is greater than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "alfa".as_bytes();
let x = String::from("aa");
assert_io_read_to_string_gt_x!(reader, x);
```

# Module macros

* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)
* [`assert_io_read_to_string_gt_x_as_result`](macro@crate::assert_io_read_to_string_gt_x_as_result)
* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)

```rust
pub mod assert_io_read_to_string_gt_x { /* ... */ }
```

## Module `assert_io_read_to_string_le_x`

Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_le_x!(reader, x);
```

# Module macros

* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)
* [`assert_io_read_to_string_le_x_as_result`](macro@crate::assert_io_read_to_string_le_x_as_result)
* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)

```rust
pub mod assert_io_read_to_string_le_x { /* ... */ }
```

## Module `assert_io_read_to_string_lt_x`

Assert a ::std::io::Read read_to_string() value is less than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_lt_x!(reader, x);
```

# Module macros

* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)
* [`assert_io_read_to_string_lt_x_as_result`](macro@crate::assert_io_read_to_string_lt_x_as_result)
* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)

```rust
pub mod assert_io_read_to_string_lt_x { /* ... */ }
```

## Module `assert_io_read_to_string_ne_x`

Assert a ::std::io::Read read_to_string() is not equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_ne_x!(reader, x);
```

# Module macros

* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)
* [`assert_io_read_to_string_ne_x_as_result`](macro@crate::assert_io_read_to_string_ne_x_as_result)
* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)

```rust
pub mod assert_io_read_to_string_ne_x { /* ... */ }
```

## Module `assert_io_read_to_string_contains`

Assert a ::std::io::Read read_to_string() contains a pattern.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) contains (expr ⇒ b_string)

# Example

```rust
use assertables::*;
use std::io::Read;

let reader = "hello".as_bytes();
let containee = "ell";
assert_io_read_to_string_contains!(reader, containee);
```

# Module macros

* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)
* [`assert_io_read_to_string_contains_as_result`](macro@crate::assert_io_read_to_string_contains_as_result)
* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)

```rust
pub mod assert_io_read_to_string_contains { /* ... */ }
```

## Module `assert_io_read_to_string_is_match`

Assert a ::std::io::Read read_to_string() is a match to a regex.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) matches matcher

# Example

```rust
use assertables::*;
use regex::Regex;

let reader = "hello".as_bytes();
let matcher = Regex::new(r"ell").expect("regex");
assert_io_read_to_string_is_match!(reader, matcher);
```

# Module macros

* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)
* [`assert_io_read_to_string_is_match_as_result`](macro@crate::assert_io_read_to_string_is_match_as_result)
* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)

```rust
pub mod assert_io_read_to_string_is_match { /* ... */ }
```

## Module `assert_io_read_to_string_matches`

Assert a ::std::io::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `assert_io_read_to_string_matches` into `assert_io_read_to_string_is_match`.

```rust
pub mod assert_io_read_to_string_matches { /* ... */ }
```

## Module `assert_command`

Assert for comparing commands and their stdout & stderr.

These macros help with calling external commands, then capturing the
standard output stream and standard error stream.
See tutorial below.

These macros have corresponding the macros in the module [`assert_program_args`](module@crate::assert_program_args).

## Macros for command standard output

Compare command standard output to another command standard output:

* [`assert_command_stdout_eq!(a_command, b_command)`](macro@crate::assert_command_stdout_eq) ≈ a_command stdout = b_command stdout
* [`assert_command_stdout_ne!(a_command, b_command)`](macro@crate::assert_command_stdout_ne) ≈ a_command stdout ≠ b_command stdout
* [`assert_command_stdout_lt!(a_command, b_command)`](macro@crate::assert_command_stdout_lt) ≈ a_command stdout < b_command stdout
* [`assert_command_stdout_le!(a_command, b_command)`](macro@crate::assert_command_stdout_le) ≈ a_command stdout ≤ b_command stdout
* [`assert_command_stdout_gt!(a_command, b_command)`](macro@crate::assert_command_stdout_gt) ≈ a_command stdout > b_command stdout
* [`assert_command_stdout_ge!(a_command, b_command)`](macro@crate::assert_command_stdout_ge) ≈ a_command stdout ≥ b_command stdout

Compare command standard output to an expression:

* [`assert_command_stdout_eq_x!(command, expr)`](macro@crate::assert_command_stdout_eq_x) ≈ command stdout = expr
* [`assert_command_stdout_ne_x!(command, expr)`](macro@crate::assert_command_stdout_ne_x) ≈ command stdout ≠ expr
* [`assert_command_stdout_lt_x!(command, expr)`](macro@crate::assert_command_stdout_lt_x) ≈ command stdout < expr
* [`assert_command_stdout_le_x!(command, expr)`](macro@crate::assert_command_stdout_le_x) ≈ command stdout ≤ expr
* [`assert_command_stdout_gt_x!(command, expr)`](macro@crate::assert_command_stdout_gt_x) ≈ command stdout > expr
* [`assert_command_stdout_ge_x!(command, expr)`](macro@crate::assert_command_stdout_ge_x) ≈ command stdout ≥ expr

Assert command standard output as a string:

* [`assert_command_stdout_string_contains!(command, containee)`](macro@crate::assert_command_stdout_string_contains) ≈ command stdout string contains containee
* [`assert_command_stdout_string_is_match!(command, matcher)`](macro@crate::assert_command_stdout_string_is_match) ≈ command stdout string is a matcher match

## Macros for command standard error

Compare command standard error to another command standard error:

* [`assert_command_stderr_eq!(a_command, b_command)`](macro@crate::assert_command_stderr_eq) ≈ a_command stderr = b_command stderr
* [`assert_command_stderr_ne!(a_command, b_command)`](macro@crate::assert_command_stderr_ne) ≈ a_command stderr ≠ b_command stderr
* [`assert_command_stderr_lt!(a_command, b_command)`](macro@crate::assert_command_stderr_lt) ≈ a_command stderr < b_command stderr
* [`assert_command_stderr_le!(a_command, b_command)`](macro@crate::assert_command_stderr_le) ≈ a_command stderr ≤ b_command stderr
* [`assert_command_stderr_gt!(a_command, b_command)`](macro@crate::assert_command_stderr_gt) ≈ a_command stderr > b_command stderr
* [`assert_command_stderr_ge!(a_command, b_command)`](macro@crate::assert_command_stderr_ge) ≈ a_command stderr ≥ b_command stderr

Compare command standard error to an expression:

* [`assert_command_stderr_eq_x!(command, expr)`](macro@crate::assert_command_stderr_eq_x) ≈ command stderr = expr
* [`assert_command_stderr_ne_x!(command, expr)`](macro@crate::assert_command_stderr_ne_x) ≈ command stderr ≠ expr
* [`assert_command_stderr_lt_x!(command, expr)`](macro@crate::assert_command_stderr_lt_x) ≈ command stderr < expr
* [`assert_command_stderr_le_x!(command, expr)`](macro@crate::assert_command_stderr_le_x) ≈ command stderr ≤ expr
* [`assert_command_stderr_gt_x!(command, expr)`](macro@crate::assert_command_stderr_gt_x) ≈ command stderr > expr
* [`assert_command_stderr_ge_x!(command, expr)`](macro@crate::assert_command_stderr_ge_x) ≈ command stderr ≥ expr

Assert standard error as a string:

* [`assert_command_stderr_string_contains!(command, containee)`](macro@crate::assert_command_stderr_string_contains) ≈ command stderr string contains containee
* [`assert_command_stderr_string_is_match!(command, matcher)`](macro@crate::assert_command_stderr_string_is_match) ≈ command stderr string is a matcher match

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s%s%s%s", "a", "l", "f", "a"]);
assert_command_stdout_eq!(a, b);
```

## Tutorial

Rust programs can call system commands.

For example this system command will print the word hello:

```sh
printf %s hello
```

Rust can create a system command then capture its standard output, by using:

```rust
# use std::process::Command;
let mut command = Command::new("printf"); command.args(["%s", "hello"]);
let stdout = command.output().unwrap().stdout;
```

Rust can compare a command's standard output to another command's standard output, by using:

```rust
# use std::process::Command;
let mut a_command = Command::new("printf"); a_command.args(["%s", "hello"]);
let mut b_command = Command::new("printf"); a_command.args(["%s", "world"]);
let a_stdout = a_command.output().unwrap().stdout;
let b_stdout = b_command.output().unwrap().stdout;
assert_ne!(a_stdout, b_stdout);
```

The `assertables` crate provides macros that do the same kind of processing, by automatically converting each command into standard output:

```rust
# use std::process::Command;
# use assertables::*;
let mut a_command = Command::new("printf"); a_command.args(["%s", "hello"]);
let mut b_command = Command::new("printf"); a_command.args(["%s", "world"]);
assert_command_stdout_ne!(a_command, b_command);
```

```rust
pub mod assert_command { /* ... */ }
```

### Modules

## Module `assert_command_stdout_eq`

Assert a command stdout string is equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "alfa"]);
assert_command_stdout_eq!(a, b);
```

# Module macros

* [`assert_command_stdout_eq`](macro@crate::assert_command_stdout_eq)
* [`assert_command_stdout_eq_as_result`](macro@crate::assert_command_stdout_eq_as_result)
* [`debug_assert_command_stdout_eq`](macro@crate::debug_assert_command_stdout_eq)

```rust
pub mod assert_command_stdout_eq { /* ... */ }
```

## Module `assert_command_stdout_ge`

Assert a command stdout string is greater than or equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "aa"]);
assert_command_stdout_ge!(a, b);
```

# Module macros

* [`assert_command_stdout_ge`](macro@crate::assert_command_stdout_ge)
* [`assert_command_stdout_ge_as_result`](macro@crate::assert_command_stdout_ge_as_result)
* [`debug_assert_command_stdout_ge`](macro@crate::debug_assert_command_stdout_ge)

```rust
pub mod assert_command_stdout_ge { /* ... */ }
```

## Module `assert_command_stdout_gt`

Assert a command stdout string is greater than another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "aa"]);
assert_command_stdout_gt!(a, b);
```

# Module macros

* [`assert_command_stdout_gt`](macro@crate::assert_command_stdout_gt)
* [`assert_command_stdout_gt_as_result`](macro@crate::assert_command_stdout_gt_as_result)
* [`debug_assert_command_stdout_gt`](macro@crate::debug_assert_command_stdout_gt)

```rust
pub mod assert_command_stdout_gt { /* ... */ }
```

## Module `assert_command_stdout_le`

Assert a command stdout string is less than or equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_le!(a, b);
```

# Module macros

* [`assert_command_stdout_le`](macro@crate::assert_command_stdout_le)
* [`assert_command_stdout_le_as_result`](macro@crate::assert_command_stdout_le_as_result)
* [`debug_assert_command_stdout_le`](macro@crate::debug_assert_command_stdout_le)

```rust
pub mod assert_command_stdout_le { /* ... */ }
```

## Module `assert_command_stdout_lt`

Assert a command stdout string is less than another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_lt!(a, b);
```

# Module macros

* [`assert_command_stdout_lt`](macro@crate::assert_command_stdout_lt)
* [`assert_command_stdout_lt_as_result`](macro@crate::assert_command_stdout_lt_as_result)
* [`debug_assert_command_stdout_lt`](macro@crate::debug_assert_command_stdout_lt)

```rust
pub mod assert_command_stdout_lt { /* ... */ }
```

## Module `assert_command_stdout_ne`

Assert a command stdout string is not equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_ne!(a, b);
```

# Module macros

* [`assert_command_stdout_ne`](macro@crate::assert_command_stdout_ne)
* [`assert_command_stdout_ne_as_result`](macro@crate::assert_command_stdout_ne_as_result)
* [`debug_assert_command_stdout_ne`](macro@crate::debug_assert_command_stdout_ne)

```rust
pub mod assert_command_stdout_ne { /* ... */ }
```

## Module `assert_command_stdout_eq_x`

Assert a command stdout string is equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_command_stdout_eq_x!(command, bytes);
```

# Module macros

* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)
* [`assert_command_stdout_eq_x_as_result`](macro@crate::assert_command_stdout_eq_x_as_result)
* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)

```rust
pub mod assert_command_stdout_eq_x { /* ... */ }
```

## Module `assert_command_stdout_ge_x`

Assert a command stdout string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stdout_ge_x!(command, bytes);
```

# Module macros

* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)
* [`assert_command_stdout_ge_x_as_result`](macro@crate::assert_command_stdout_ge_x_as_result)
* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)

```rust
pub mod assert_command_stdout_ge_x { /* ... */ }
```

## Module `assert_command_stdout_gt_x`

Assert a command stdout string is greater than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stdout_gt_x!(command, bytes);
```

# Module macros

* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)
* [`assert_command_stdout_gt_x_as_result`](macro@crate::assert_command_stdout_gt_x_as_result)
* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)

```rust
pub mod assert_command_stdout_gt_x { /* ... */ }
```

## Module `assert_command_stdout_le_x`

Assert a command stdout string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_le_x!(command, bytes);
```

# Module macros

* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)
* [`assert_command_stdout_le_x_as_result`](macro@crate::assert_command_stdout_le_x_as_result)
* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)

```rust
pub mod assert_command_stdout_le_x { /* ... */ }
```

## Module `assert_command_stdout_lt_x`

Assert a command stdout string is less than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_lt_x!(command, bytes);
```

# Module macros

* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)
* [`assert_command_stdout_lt_x_as_result`](macro@crate::assert_command_stdout_lt_x_as_result)
* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)

```rust
pub mod assert_command_stdout_lt_x { /* ... */ }
```

## Module `assert_command_stdout_ne_x`

Assert a command stdout string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_ne_x!(command, bytes);
```

```rust
pub mod assert_command_stdout_ne_x { /* ... */ }
```

## Module `assert_command_stdout_contains`

Assert a command stdout string contains a given containee.

Deprecated. Please rename from `assert_command_stdout_contains` into `assert_command_stdout_string_contains`.

```rust
pub mod assert_command_stdout_contains { /* ... */ }
```

## Module `assert_command_stdout_is_match`

Assert a command stdout string is a match to a regex.

Deprecated. Please rename from `assert_command_stdout_is_match` into `assert_command_stdout_string_is_match`.

```rust
pub mod assert_command_stdout_is_match { /* ... */ }
```

## Module `assert_command_stdout_string_contains`

Assert a command stdout string contains a given containee.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) contains (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let containee = "lf";
assert_command_stdout_string_contains!(command, containee);
```

# Module macros

* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)
* [`assert_command_stdout_string_contains_as_result`](macro@crate::assert_command_stdout_string_contains_as_result)
* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)

```rust
pub mod assert_command_stdout_string_contains { /* ... */ }
```

## Module `assert_command_stdout_string_is_match`

Assert a command stdout string is a match to a regex.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) is match (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;
use regex::Regex;

let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let matcher = Regex::new(r"lf").expect("regex");
assert_command_stdout_string_is_match!(command, matcher);
```

# Module macros

* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)
* [`assert_command_stdout_string_is_match_as_result`](macro@crate::assert_command_stdout_string_is_match_as_result)
* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)

```rust
pub mod assert_command_stdout_string_is_match { /* ... */ }
```

## Module `assert_command_stderr_eq`

Assert a command stderr string is equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

# Example

```
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "alfa"]);
assert_command_stderr_eq!(a, b);
```

# Module macros

* [`assert_command_stderr_eq`](macro@crate::assert_command_stderr_eq)
* [`assert_command_stderr_eq_as_result`](macro@crate::assert_command_stderr_eq_as_result)
* [`debug_assert_command_stderr_eq`](macro@crate::debug_assert_command_stderr_eq)

```rust
pub mod assert_command_stderr_eq { /* ... */ }
```

## Module `assert_command_stderr_ge`

Assert a command stderr string is greater than or equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "aa"]);
assert_command_stderr_ge!(a, b);
```

# Module macros

* [`assert_command_stderr_ge`](macro@crate::assert_command_stderr_ge)
* [`assert_command_stderr_ge_as_result`](macro@crate::assert_command_stderr_ge_as_result)
* [`debug_assert_command_stderr_ge`](macro@crate::debug_assert_command_stderr_ge)

```rust
pub mod assert_command_stderr_ge { /* ... */ }
```

## Module `assert_command_stderr_gt`

Assert a command stderr string is greater than another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "aa"]);
assert_command_stderr_gt!(a, b);
```

# Module macros

* [`assert_command_stderr_gt`](macro@crate::assert_command_stderr_gt)
* [`assert_command_stderr_gt_as_result`](macro@crate::assert_command_stderr_gt_as_result)
* [`debug_assert_command_stderr_gt`](macro@crate::debug_assert_command_stderr_gt)

```rust
pub mod assert_command_stderr_gt { /* ... */ }
```

## Module `assert_command_stderr_le`

Assert a command stderr string is less than or equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_le!(a, b);
```

# Module macros

* [`assert_command_stderr_le`](macro@crate::assert_command_stderr_le)
* [`assert_command_stderr_le_as_result`](macro@crate::assert_command_stderr_le_as_result)
* [`debug_assert_command_stderr_le`](macro@crate::debug_assert_command_stderr_le)

```rust
pub mod assert_command_stderr_le { /* ... */ }
```

## Module `assert_command_stderr_lt`

Assert a command stderr string is less than another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_lt!(a, b);
```

# Module macros

* [`assert_command_stderr_lt`](macro@crate::assert_command_stderr_lt)
* [`assert_command_stderr_lt_as_result`](macro@crate::assert_command_stderr_lt_as_result)
* [`debug_assert_command_stderr_lt`](macro@crate::debug_assert_command_stderr_lt)

```rust
pub mod assert_command_stderr_lt { /* ... */ }
```

## Module `assert_command_stderr_ne`

Assert a command stderr string is not equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_ne!(a, b);
```

# Module macros

* [`assert_command_stderr_ne`](macro@crate::assert_command_stderr_ne)
* [`assert_command_stderr_ne_as_result`](macro@crate::assert_command_stderr_ne_as_result)
* [`debug_assert_command_stderr_ne`](macro@crate::debug_assert_command_stderr_ne)

```rust
pub mod assert_command_stderr_ne { /* ... */ }
```

## Module `assert_command_stderr_eq_x`

Assert a command stderr string is equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_command_stderr_eq_x!(command, bytes);
```

# Module macros

* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)
* [`assert_command_stderr_eq_x_as_result`](macro@crate::assert_command_stderr_eq_x_as_result)
* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)

```rust
pub mod assert_command_stderr_eq_x { /* ... */ }
```

## Module `assert_command_stderr_ge_x`

Assert a command stderr string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stderr_ge_x!(command, bytes);
```

# Module macros

* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)
* [`assert_command_stderr_ge_x_as_result`](macro@crate::assert_command_stderr_ge_x_as_result)
* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)

```rust
pub mod assert_command_stderr_ge_x { /* ... */ }
```

## Module `assert_command_stderr_gt_x`

Assert a command stderr string is greater than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stderr_gt_x!(command, bytes);
```

# Module macros

* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)
* [`assert_command_stderr_gt_x_as_result`](macro@crate::assert_command_stderr_gt_x_as_result)
* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)

```rust
pub mod assert_command_stderr_gt_x { /* ... */ }
```

## Module `assert_command_stderr_le_x`

Assert a command stderr string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_le_x!(command, bytes);
```

# Module macros

* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)
* [`assert_command_stderr_le_x_as_result`](macro@crate::assert_command_stderr_le_x_as_result)
* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)

```rust
pub mod assert_command_stderr_le_x { /* ... */ }
```

## Module `assert_command_stderr_lt_x`

Assert a command stderr string is less than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_lt_x!(command, bytes);
```

# Module macros

* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)
* [`assert_command_stderr_lt_x_as_result`](macro@crate::assert_command_stderr_lt_x_as_result)
* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)

```rust
pub mod assert_command_stderr_lt_x { /* ... */ }
```

## Module `assert_command_stderr_ne_x`

Assert a command stderr string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_ne_x!(command, bytes);
```

# Module macros

* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)
* [`assert_command_stderr_ne_x_as_result`](macro@crate::assert_command_stderr_ne_x_as_result)
* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)

```rust
pub mod assert_command_stderr_ne_x { /* ... */ }
```

## Module `assert_command_stderr_contains`

Assert a command stderr string contains a given containee.

Deprecated. Please rename from `assert_command_stderr_contains`

```rust
pub mod assert_command_stderr_contains { /* ... */ }
```

## Module `assert_command_stderr_is_match`

Assert a command stderr string is a match to a regex.

Deprecated. Please rename from `assert_command_stderr_is_match` into `assert_command_stderr_string_is_match`.

```rust
pub mod assert_command_stderr_is_match { /* ... */ }
```

## Module `assert_command_stderr_string_contains`

Assert a command stderr string contains a given containee.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) contains (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let containee = "lf";
assert_command_stderr_string_contains!(command, containee);
```

# Module macros

* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)
* [`assert_command_stderr_string_contains_as_result`](macro@crate::assert_command_stderr_string_contains_as_result)
* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)

```rust
pub mod assert_command_stderr_string_contains { /* ... */ }
```

## Module `assert_command_stderr_string_is_match`

Assert a command stderr string is a match to a regex.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) is match (expr into string)

# Example

```rust
use assertables::*;
use std::process::Command;
use regex::Regex;

let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let matcher = Regex::new(r"lf").expect("regex");
assert_command_stderr_string_is_match!(command, matcher);
```

# Module macros

* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)
* [`assert_command_stderr_string_is_match_as_result`](macro@crate::assert_command_stderr_string_is_match_as_result)
* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)

```rust
pub mod assert_command_stderr_string_is_match { /* ... */ }
```

## Module `assert_program_args`

Assert for comparing programs with arguments.

These macros help with calling external programs with arguments, then
capturing the standard output stream and standard error stream.
See tutorial below.

These macros have corresponding macros in the module [`assert_command`](module@crate::assert_command).

## Program args stdout

Compare program and arguments standard output to another program and arguments standard output:

* [`assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_eq) ≈ command using a_program and a_args to stdout = b_command with b_program and b_args to stdout
* [`assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_ne) ≈ command using a_program and a_args to stdout ≠ b_command with b_program and b_args to stdout
* [`assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_lt) ≈ command using a_program and a_args to stdout < b_command with b_program and b_args to stdout
* [`assert_program_args_stdout_le!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_le) ≈ command using a_program and a_args to stdout ≤ b_command with b_program and b_args to stdout
* [`assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_gt) ≈ command using a_program and a_args to stdout > b_command with b_program and b_args to stdout
* [`assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stdout_ge) ≈ command using a_program and a_args to stdout ≥ b_command with b_program and b_args to stdout

Compare program and arguments standard output to an expression:

* [`assert_program_args_stdout_eq_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_eq_x) ≈ command using program and args to stdout = expr
* [`assert_program_args_stdout_ne_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_ne_x) ≈ command using program and args to stdout ≠ expr
* [`assert_program_args_stdout_lt_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_lt_x) ≈ command using program and args to stdout < expr
* [`assert_program_args_stdout_le_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_le_x) ≈ command using program and args to stdout ≤ expr
* [`assert_program_args_stdout_gt_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_gt_x) ≈ command using program and args to stdout > expr
* [`assert_program_args_stdout_ge_x!(program, args, expr)`](macro@crate::assert_program_args_stdout_ge_x) ≈ command using program and args to stdout ≥ expr

Assert program and arguments standard output as a string:

* [`assert_program_args_stdout_string_contains!(program, args, containee)`](macro@crate::assert_program_args_stdout_string_contains) ≈ command using program and args to stdout string contains containee
* [`assert_program_args_stdout_string_is_match!(program, args, matcher)`](macro@crate::assert_program_args_stdout_string_is_match) ≈ matcher is match with command using program and args

## Program args stderr

Compare program and arguments standard error to another program and arguments standard error:

* [`assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_eq) ≈ command using a_program and a_args to stderr = b_command with b_program and b_args to stderr
* [`assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_ne) ≈ command using a_program and a_args to stderr ≠ b_command with b_program and b_args to stderr
* [`assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_lt) ≈ command using a_program and a_args to stderr < b_command with b_program and b_args to stderr
* [`assert_program_args_stderr_le!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_le) ≈ command using a_program and a_args to stderr ≤ b_command with b_program and b_args to stderr
* [`assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_gt) ≈ command using a_program and a_args to stderr > b_command with b_program and b_args to stderr
* [`assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args)`](macro@crate::assert_program_args_stderr_ge) ≈ command using a_program and a_args to stderr ≥ b_command with b_program and b_args to stderr

Compare program and arguments standard error to an expression:

* [`assert_program_args_stderr_eq_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_eq_x) ≈ command using program and args to stderr = expr
* [`assert_program_args_stderr_ne_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_ne_x) ≈ command using program and args to stderr ≠ expr
* [`assert_program_args_stderr_lt_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_lt_x) ≈ command using program and args to stderr < expr
* [`assert_program_args_stderr_le_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_le_x) ≈ command using program and args to stderr ≤ expr
* [`assert_program_args_stderr_gt_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_gt_x) ≈ command using program and args to stderr > expr
* [`assert_program_args_stderr_ge_x!(program, args, expr)`](macro@crate::assert_program_args_stderr_ge_x) ≈ command using program and args to stderr ≥ expr

Assert program and arguments standard error as a string:

* [`assert_program_args_stderr_string_contains!(program, args, containee)`](macro@crate::assert_program_args_stderr_string_contains) ≈ command using program and args to stderr string contains containee
* [`assert_program_args_stderr_string_is_match!(program, args, matcher)`](macro@crate::assert_program_args_stderr_string_is_match) ≈ matcher is match with command using program and args

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s%s%s", "a", "l", "f", "a"];
assert_program_args_stdout_eq!(&a_program, &a_args, &b_program, &b_args);
```

## Tutorial

Rust programs can call system commands.

For example this system command will print the word hello:

```sh
printf %s hello
```

Rust can create a system command then capture its standard output, by using:

```rust
# use std::process::Command;
let program = "printf";
let args = ["%s", "hello"];
let mut command = Command::new(program);
command.args(args);
let stdout = command.output().unwrap().stdout;
```

Rust can compare a command's standard output to another command's standard output, by using:

```rust
# use std::process::Command;
let a_program = "printf";
let a_args = ["%s", "hello"];
let b_program = "printf";
let b_args = ["%s", "world"];
let mut a_command = Command::new(a_program); a_command.args(a_args);
let mut b_command = Command::new(b_program); b_command.args(b_args);
let a_stdout = a_command.output().unwrap().stdout;
let b_stdout = b_command.output().unwrap().stdout;
assert_ne!(a_stdout, b_stdout);
```

The `assertables` crate provides macros that do the same kind of processing, by automatically converting programs and args into commands, then to standard outputs:

```rust
# use std::process::Command;
# use assertables::*;
let a_program = "printf";
let a_args = ["%s", "hello"];
let b_program = "printf";
let b_args = ["%s", "world"];
assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);
```

```rust
pub mod assert_program_args { /* ... */ }
```

### Modules

## Module `assert_program_args_stdout_eq`

Assert a command (built with program and args) stdout is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s%s%s", "a", "l", "f", "a"];
assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args);
```

# Module macros

* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)
* [`assert_program_args_stdout_eq_as_result`](macro@crate::assert_program_args_stdout_eq_as_result)
* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)

```rust
pub mod assert_program_args_stdout_eq { /* ... */ }
```

## Module `assert_program_args_stdout_ge`

Assert a command (built with program and args) stdout is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "a", "a"];
assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args);
```

# Module macros

* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)
* [`assert_program_args_stdout_ge_as_result`](macro@crate::assert_program_args_stdout_ge_as_result)
* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)

```rust
pub mod assert_program_args_stdout_ge { /* ... */ }
```

## Module `assert_program_args_stdout_gt`

Assert a command (built with program and args) stdout is greater than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "a", "a"];
assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args);
```

# Module macros

* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)
* [`assert_program_args_stdout_gt_as_result`](macro@crate::assert_program_args_stdout_gt_as_result)
* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)

```rust
pub mod assert_program_args_stdout_gt { /* ... */ }
```

## Module `assert_program_args_stdout_le`

Assert a command (built with program and args) stdout is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z"];
assert_program_args_stdout_le!(a_program, a_args, b_program, b_args);
```

# Module macros

* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)
* [`assert_program_args_stdout_le_as_result`](macro@crate::assert_program_args_stdout_le_as_result)
* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)

```rust
pub mod assert_program_args_stdout_le { /* ... */ }
```

## Module `assert_program_args_stdout_lt`

Assert a command (built with program and args) stdout is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z"];
assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args);
```

# Module macros

* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)
* [`assert_program_args_stdout_lt_as_result`](macro@crate::assert_program_args_stdout_lt_as_result)
* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)

```rust
pub mod assert_program_args_stdout_lt { /* ... */ }
```

## Module `assert_program_args_stdout_ne`

Assert a command (built with program and args) stdout is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (b_program + b_args ⇒ command ⇒ stdout)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z" ];
assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);
```

# Module macros

* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)
* [`assert_program_args_stdout_ne_as_result`](macro@crate::assert_program_args_stdout_ne_as_result)
* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)

```rust
pub mod assert_program_args_stdout_ne { /* ... */ }
```

## Module `assert_program_args_stdout_eq_x`

Assert a command (built with program and args) stdout is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stdout_eq_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)
* [`assert_program_args_stdout_eq_x_as_result`](macro@crate::assert_program_args_stdout_eq_x_as_result)
* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)

```rust
pub mod assert_program_args_stdout_eq_x { /* ... */ }
```

## Module `assert_program_args_stdout_ge_x`

Assert a command (built with program and args) stdout is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stdout_ge_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)
* [`assert_program_args_stdout_ge_x_as_result`](macro@crate::assert_program_args_stdout_ge_x_as_result)
* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)

```rust
pub mod assert_program_args_stdout_ge_x { /* ... */ }
```

## Module `assert_program_args_stdout_gt_x`

Assert a command (built with program and args) stdout is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stdout_gt_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)
* [`assert_program_args_stdout_gt_x_as_result`](macro@crate::assert_program_args_stdout_gt_x_as_result)
* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)

```rust
pub mod assert_program_args_stdout_gt_x { /* ... */ }
```

## Module `assert_program_args_stdout_le_x`

Assert a command (built with program and args) stdout is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_le_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)
* [`assert_program_args_stdout_le_x_as_result`](macro@crate::assert_program_args_stdout_le_x_as_result)
* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)

```rust
pub mod assert_program_args_stdout_le_x { /* ... */ }
```

## Module `assert_program_args_stdout_lt_x`

Assert a command (built with program and args) stdout is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_lt_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)
* [`assert_program_args_stdout_lt_x_as_result`](macro@crate::assert_program_args_stdout_lt_x_as_result)
* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)

```rust
pub mod assert_program_args_stdout_lt_x { /* ... */ }
```

## Module `assert_program_args_stdout_ne_x`

Assert a command (built with program and args) stdout is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'x', b'x'];
assert_program_args_stdout_ne_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)
* [`assert_program_args_stdout_ne_x_as_result`](macro@crate::assert_program_args_stdout_ne_x_as_result)
* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)

```rust
pub mod assert_program_args_stdout_ne_x { /* ... */ }
```

## Module `assert_program_args_stdout_contains`

Assert a command (built with program and args) stdout into a string contains a given containee.

Deprecated. Please rename from `assert_program_args_stdout_contains` to `assert_program_args_stdout_string_contains`.

```rust
pub mod assert_program_args_stdout_contains { /* ... */ }
```

## Module `assert_program_args_stdout_is_match`

Assert a command (built with program and args) stdout into a string is a match to a regex.

Deprecated. Please rename from `assert_program_args_stdout_is_match` to `assert_program_args_stdout_string_is_match`.

```rust
pub mod assert_program_args_stdout_is_match { /* ... */ }
```

## Module `assert_program_args_stdout_string_contains`

Assert a command (built with program and args) stdout into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) contains (expr into string)

This uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.

* The containee can be a &str, char, a slice of chars, or a function or
closure that determines if a character contains.

# Example

```rust
use assertables::*;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let containee = "lf";
assert_program_args_stdout_string_contains!(program, args, containee);
```

# Module macros

* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)
* [`assert_program_args_stdout_string_contains_as_result`](macro@crate::assert_program_args_stdout_string_contains_as_result)
* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)

```rust
pub mod assert_program_args_stdout_string_contains { /* ... */ }
```

## Module `assert_program_args_stdout_string_is_match`

Assert a command (built with program and args) stdout into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)

# Example

```rust
use assertables::*;
use regex::Regex;

let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let matcher = Regex::new(r"lf").expect("regex");
assert_program_args_stdout_string_is_match!(program, args, matcher);
```

# Module macros

* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)
* [`assert_program_args_stdout_string_is_match_as_result`](macro@crate::assert_program_args_stdout_string_is_match_as_result)
* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)

```rust
pub mod assert_program_args_stdout_string_is_match { /* ... */ }
```

## Module `assert_program_args_stderr_eq`

Assert a command (built with program and args) stderr is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "alfa"];
assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args);
```

/// # Module macros

* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)
* [`assert_program_args_stderr_eq_as_result`](macro@crate::assert_program_args_stderr_eq_as_result)
* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)

```rust
pub mod assert_program_args_stderr_eq { /* ... */ }
```

## Module `assert_program_args_stderr_ge`

Assert a command (built with program and args) stderr is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "aa"];
assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args);
```

/// # Module macros

* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)
* [`assert_program_args_stderr_ge_as_result`](macro@crate::assert_program_args_stderr_ge_as_result)
* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)

```rust
pub mod assert_program_args_stderr_ge { /* ... */ }
```

## Module `assert_program_args_stderr_gt`

Assert a command (built with program and args) stderr is greater than to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "aa"];
assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args);
```

/// # Module macros

* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)
* [`assert_program_args_stderr_gt_as_result`](macro@crate::assert_program_args_stderr_gt_as_result)
* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)

```rust
pub mod assert_program_args_stderr_gt { /* ... */ }
```

## Module `assert_program_args_stderr_le`

Assert a command (built with program and args) stderr is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_le!(a_program, a_args, b_program, b_args);
```

/// # Module macros

* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)
* [`assert_program_args_stderr_le_as_result`](macro@crate::assert_program_args_stderr_le_as_result)
* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)

```rust
pub mod assert_program_args_stderr_le { /* ... */ }
```

## Module `assert_program_args_stderr_lt`

Assert a command (built with program and args) stderr is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args);
```

/// # Module macros

* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)
* [`assert_program_args_stderr_lt_as_result`](macro@crate::assert_program_args_stderr_lt_as_result)
* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)

```rust
pub mod assert_program_args_stderr_lt { /* ... */ }
```

## Module `assert_program_args_stderr_ne`

Assert a command (built with program and args) stderr is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)

# Example

```rust
use assertables::*;

let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args);
```

/// # Module macros

* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)
* [`assert_program_args_stderr_ne_as_result`](macro@crate::assert_program_args_stderr_ne_as_result)
* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)

```rust
pub mod assert_program_args_stderr_ne { /* ... */ }
```

## Module `assert_program_args_stderr_eq_x`

Assert a command (built with program and args) stderr is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stderr_eq_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)
* [`assert_program_args_stderr_eq_x_as_result`](macro@crate::assert_program_args_stderr_eq_x_as_result)
* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)

```rust
pub mod assert_program_args_stderr_eq_x { /* ... */ }
```

## Module `assert_program_args_stderr_ge_x`

Assert a command (built with program and args) stderr is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)

# Examples

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stderr_ge_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)
* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)
* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)

```rust
pub mod assert_program_args_stderr_ge_x { /* ... */ }
```

## Module `assert_program_args_stderr_gt_x`

Assert a command (built with program and args) stderr is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stderr_gt_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)
* [`assert_program_args_stderr_gt_x_as_result`](macro@crate::assert_program_args_stderr_gt_x_as_result)
* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)

```rust
pub mod assert_program_args_stderr_gt_x { /* ... */ }
```

## Module `assert_program_args_stderr_le_x`

Assert a command (built with program and args) stderr is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_le_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)
* [`assert_program_args_stderr_le_x_as_result`](macro@crate::assert_program_args_stderr_le_x_as_result)
* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)

```rust
pub mod assert_program_args_stderr_le_x { /* ... */ }
```

## Module `assert_program_args_stderr_lt_x`

Assert a command (built with program and args) stderr is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_lt_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)
* [`assert_program_args_stderr_lt_x_as_result`](macro@crate::assert_program_args_stderr_lt_x_as_result)
* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)

```rust
pub mod assert_program_args_stderr_lt_x { /* ... */ }
```

## Module `assert_program_args_stderr_ne_x`

Assert a command (built with program and args) stderr is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)

# Example

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'x', b'x'];
assert_program_args_stderr_ne_x!(program, args, bytes);
```

# Module macros

* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)
* [`assert_program_args_stderr_ne_x_as_result`](macro@crate::assert_program_args_stderr_ne_x_as_result)
* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)

```rust
pub mod assert_program_args_stderr_ne_x { /* ... */ }
```

## Module `assert_program_args_stderr_contains`

Assert a command (built with program and args) stderr into a string contains a given containee.

Deprecated. Please rename from `assert_program_args_stderr_contains` to `assert_program_args_stderr_string_contains`.

```rust
pub mod assert_program_args_stderr_contains { /* ... */ }
```

## Module `assert_program_args_stderr_is_match`

Assert a command (built with program and args) stderr into a string is a match to a regex.

Deprecated. Please rename from `assert_program_args_stderr_is_match` to `assert_program_args_stderr_string_is_match`.

```rust
pub mod assert_program_args_stderr_is_match { /* ... */ }
```

## Module `assert_program_args_stderr_string_contains`

Assert a command (built with program and args) stderr into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)

This uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.

* The containee can be a &str, char, a slice of chars, or a function or
closure that determines if a character contains.

# Example

```rust
use assertables::*;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let containee = "lf";
assert_program_args_stderr_string_contains!(program, args, containee);
```

# Module macros

* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)
* [`assert_program_args_stderr_string_contains_as_result`](macro@crate::assert_program_args_stderr_string_contains_as_result)
* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)

```rust
pub mod assert_program_args_stderr_string_contains { /* ... */ }
```

## Module `assert_program_args_stderr_string_is_match`

Assert a command (built with program and args) stderr into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)

# Example

```rust
use assertables::*;
use regex::Regex;

let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let matcher = Regex::new(r"lf").expect("regex");
assert_program_args_stderr_string_is_match!(program, args, matcher);
```

# Module macros

* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)
* [`assert_program_args_stderr_string_is_match_as_result`](macro@crate::assert_program_args_stderr_string_is_match_as_result)
* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)

```rust
pub mod assert_program_args_stderr_string_is_match { /* ... */ }
```

## Module `assert_status`

Assert for comparing status concepts.

These macros help with commands, program, processes, and anything else that
provides a method `status()`, and optionally status methods such as:

* `success() => bool`
* `code() => Result(T, E)`

Try success/failure:

* [`assert_status_success!(a)`](macro@crate::assert_status_success) ≈ a.status().success() = true``
* [`assert_status_success_false!(a)`](macro@crate::assert_status_success_false) ≈ a.status().success() = false``
* [`assert_status_failure!(a)`](macro@crate::assert_status_failure) ≈ a.status().success() = false``

Compare a status code with another status code:

* [`assert_status_code_value_eq!(a, b)`](macro@crate::assert_status_code_value_eq) ≈ a.len() = b.len()
* [`assert_status_code_value_ne!(a, b)`](macro@crate::assert_status_code_value_ne) ≈ a.len() ≠ b.len()
* [`assert_status_code_value_lt!(a, b)`](macro@crate::assert_status_code_value_lt) ≈ a.len() < b.len()
* [`assert_status_code_value_le!(a, b)`](macro@crate::assert_status_code_value_le) ≈ a.len() ≤ b.len()
* [`assert_status_code_value_gt!(a, b)`](macro@crate::assert_status_code_value_gt) ≈ a.len() > b.len()
* [`assert_status_code_value_ge!(a, b)`](macro@crate::assert_status_code_value_ge) ≈ a.len() ≥ b.len()

Compare a status code with an expression:

* [`assert_status_code_value_eq_x!(a, expr)`](macro@crate::assert_status_code_value_eq_x) ≈ a.len() = expr
* [`assert_status_code_value_ne_x!(a, expr)`](macro@crate::assert_status_code_value_ne_x) ≈ a.len() ≠ expr
* [`assert_status_code_value_lt_x!(a, expr)`](macro@crate::assert_status_code_value_lt_x) ≈ a.len() < expr
* [`assert_status_code_value_le_x!(a, expr)`](macro@crate::assert_status_code_value_le_x) ≈ a.len() ≤ expr
* [`assert_status_code_value_gt_x!(a, expr)`](macro@crate::assert_status_code_value_gt_x) ≈ a.len() > expr
* [`assert_status_code_value_ge_x!(a, expr)`](macro@crate::assert_status_code_value_ge_x) ≈ a.len() ≥ expr

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_eq!(a, b);
```

```rust
pub mod assert_status { /* ... */ }
```

### Modules

## Module `assert_status_success`

Assert a status is a success.

Pseudocode:<br>
a ⇒ status ⇒ success = true

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("0");
assert_status_success!(a);
```

# Module macros

* [`assert_status_success`](macro@crate::assert_status_success)
* [`assert_status_success_as_result`](macro@crate::assert_status_success_as_result)
* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)

```rust
pub mod assert_status_success { /* ... */ }
```

## Module `assert_status_success_false`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
assert_status_success_false!(a);
```

# Module macros

* [`assert_status_success_false`](macro@crate::assert_status_success_false)
* [`assert_status_success_false_as_result`](macro@crate::assert_status_success_false_as_result)
* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)

```rust
pub mod assert_status_success_false { /* ... */ }
```

## Module `assert_status_failure`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
assert_status_failure!(a);
```

# Module macros

* [`assert_status_failure`](macro@crate::assert_status_failure)
* [`assert_status_failure_as_result`](macro@crate::assert_status_failure_as_result)
* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)

```rust
pub mod assert_status_failure { /* ... */ }
```

## Module `assert_status_code_value_eq`

Assert a status code value is equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_eq!(a, b);
```

# Module macros

* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)
* [`assert_status_code_value_eq_as_result`](macro@crate::assert_status_code_value_eq_as_result)
* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)

```rust
pub mod assert_status_code_value_eq { /* ... */ }
```

## Module `assert_status_code_value_ge`

Assert a status code value is greater than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_ge!(a, b);
```

# Module macros

* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)
* [`assert_status_code_value_ge_as_result`](macro@crate::assert_status_code_value_ge_as_result)
* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)

```rust
pub mod assert_status_code_value_ge { /* ... */ }
```

## Module `assert_status_code_value_gt`

Assert a status code value is greater than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_gt!(a, b);
```

# Module macros

* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)
* [`assert_status_code_value_gt_as_result`](macro@crate::assert_status_code_value_gt_as_result)
* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)

```rust
pub mod assert_status_code_value_gt { /* ... */ }
```

## Module `assert_status_code_value_le`

Assert a status code value is less than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_le!(a, b);
```

# Module macros

* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)
* [`assert_status_code_value_le_as_result`](macro@crate::assert_status_code_value_le_as_result)
* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)

```rust
pub mod assert_status_code_value_le { /* ... */ }
```

## Module `assert_status_code_value_lt`

Assert a status code value is less than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_lt!(a, b);
```

# Module macros

* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)
* [`assert_status_code_value_lt_as_result`](macro@crate::assert_status_code_value_lt_as_result)
* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)

```rust
pub mod assert_status_code_value_lt { /* ... */ }
```

## Module `assert_status_code_value_ne`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_ne!(a, b);
```

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne_as_result`](macro@crate::assert_status_code_value_ne_as_result)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)

```rust
pub mod assert_status_code_value_ne { /* ... */ }
```

## Module `assert_status_code_value_eq_x`

Assert a status code value is equal to an expression.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 1;
assert_status_code_value_eq_x!(a, b);
```

# Module macros

* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)
* [`assert_status_code_value_eq_x_as_result`](macro@crate::assert_status_code_value_eq_x_as_result)
* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)

```rust
pub mod assert_status_code_value_eq_x { /* ... */ }
```

## Module `assert_status_code_value_ge_x`

Assert a status code value is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let b = 1;
assert_status_code_value_ge_x!(a, b);
```

# Module macros

* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)
* [`assert_status_code_value_ge_x_as_result`](macro@crate::assert_status_code_value_ge_x_as_result)
* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)

```rust
pub mod assert_status_code_value_ge_x { /* ... */ }
```

## Module `assert_status_code_value_gt_x`

Assert a status code value is greater than an expression.

Pseudocode:<br>
a.len() > b

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let b = 1;
assert_status_code_value_gt_x!(a, b);
```

# Module macros

* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)
* [`assert_status_code_value_gt_x_as_result`](macro@crate::assert_status_code_value_gt_x_as_result)
* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)

```rust
pub mod assert_status_code_value_gt_x { /* ... */ }
```

## Module `assert_status_code_value_le_x`

Assert a status code value is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_le_x!(a, b);
```

# Module macros

* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)
* [`assert_status_code_value_le_x_as_result`](macro@crate::assert_status_code_value_le_x_as_result)
* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)

```rust
pub mod assert_status_code_value_le_x { /* ... */ }
```

## Module `assert_status_code_value_lt_x`

Assert a status code value is less than an expression.

Pseudocode:<br>
a.len() < b

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_lt_x!(a, b);
```

# Module macros

* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)
* [`assert_status_code_value_lt_x_as_result`](macro@crate::assert_status_code_value_lt_x_as_result)
* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)

```rust
pub mod assert_status_code_value_lt_x { /* ... */ }
```

## Module `assert_status_code_value_ne_x`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

# Example

```rust
use assertables::*;
use std::process::Command;

let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_ne_x!(a, b);
```

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne_x_as_result`](macro@crate::assert_status_code_value_ne_x_as_result)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)

```rust
pub mod assert_status_code_value_ne_x { /* ... */ }
```

## Module `assert_success`

Assert a success method is true.

These macros help compare None items, such as `::std::Option::None` or similar.

Assert expression is None:

* [`assert_success!(a)`](macro@crate::assert_success)
  ≈ a.success() is true

# Example

```rust
use assertables::*;

#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { true }}
let a = A{};
assert_success!(a);
```

```rust
pub mod assert_success { /* ... */ }
```

### Modules

## Module `assert_success`

Assert success.

Pseudocode:<br>
a.success() = true

# Example

```rust
use assertables::*;

#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { true }}
let a = A{};
assert_success!(a);
```

# Module macros

* [`assert_success`](macro@crate::assert_success)
* [`assert_success_as_result`](macro@crate::assert_success_as_result)
* [`debug_assert_success`](macro@crate::debug_assert_success)

```rust
pub mod assert_success { /* ... */ }
```

## Module `assert_success_false`

Assert failure.

Pseudocode:<br>
a.success() = false

# Example

```rust
use assertables::*;

#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { false }}
let a = A{};
assert_success_false!(a);
```

# Module macros

* [`assert_success_false`](macro@crate::assert_success_false)
* [`assert_success_false_as_result`](macro@crate::assert_success_false_as_result)
* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)

```rust
pub mod assert_success_false { /* ... */ }
```

## Macros

### Macro `assert_as_result`

**Attributes:**

- `#[macro_export]`

Assert a condition is true.

Pseudocode:<br>
condition

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_as_result`](macro.assert_as_result.html)


```rust
pub macro_rules! assert_as_result {
    /* macro_rules! assert_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is equal to another.

Pseudocode:<br>
a = b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_eq_as_result`](macro@crate::assert_eq_as_result)

# Rust standard macros

* [`assert_eq`](https://doc.rust-lang.org/std/macro.assert_eq.html)
* [`debug_assert_eq`](https://doc.rust-lang.org/std/macro.debug_assert_eq.html)


```rust
pub macro_rules! assert_eq_as_result {
    /* macro_rules! assert_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is greater than or equal to another.

Pseudocode:<br>
a ≥ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ge`](macro@crate::assert_ge)
* [`assert_ge_as_result`](macro@crate::assert_ge_as_result)
* [`debug_assert_ge`](macro@crate::debug_assert_ge)


```rust
pub macro_rules! assert_ge_as_result {
    /* macro_rules! assert_ge_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ge`

**Attributes:**

- `#[macro_export]`

Assert an expression is greater than or equal to another.

Pseudocode:<br>
a ≥ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 2;
let b = 1;
assert_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 1;
let b = 2;
assert_ge!(a, b);
# });
// assertion failed: `assert_ge!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ge.html
//  a label: `a`,
//  a debug: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ge!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ge`](macro@crate::assert_ge)
* [`assert_ge_as_result`](macro@crate::assert_ge_as_result)
* [`debug_assert_ge`](macro@crate::debug_assert_ge)


```rust
pub macro_rules! assert_ge {
    /* macro_rules! assert_ge {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ge`

**Attributes:**

- `#[macro_export]`

Assert an expression is greater than or equal to another.

Pseudocode:<br>
a ≥ b

This macro provides the same statements as [`assert_ge`](macro.assert_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ge`](macro@crate::assert_ge)
* [`assert_ge`](macro@crate::assert_ge)
* [`debug_assert_ge`](macro@crate::debug_assert_ge)


```rust
pub macro_rules! debug_assert_ge {
    /* macro_rules! debug_assert_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is greater than another.

Pseudocode:<br>
a > b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_gt`](macro@crate::assert_gt)
* [`assert_gt_as_result`](macro@crate::assert_gt_as_result)
* [`debug_assert_gt`](macro@crate::debug_assert_gt)


```rust
pub macro_rules! assert_gt_as_result {
    /* macro_rules! assert_gt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_gt`

**Attributes:**

- `#[macro_export]`

Assert an expression is greater than another.

Pseudocode:<br>
a > b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 2;
let b = 1;
assert_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 1;
let b = 2;
assert_gt!(a, b);
# });
// assertion failed: `assert_gt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_gt.html
//  a label: `a`,
//  a debug: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_gt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_gt`](macro@crate::assert_gt)
* [`assert_gt_as_result`](macro@crate::assert_gt_as_result)
* [`debug_assert_gt`](macro@crate::debug_assert_gt)


```rust
pub macro_rules! assert_gt {
    /* macro_rules! assert_gt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_gt`

**Attributes:**

- `#[macro_export]`

Assert an expression is greater than another.

Pseudocode:<br>
a > b

This macro provides the same statements as [`assert_gt`](macro.assert_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_gt`](macro@crate::assert_gt)
* [`assert_gt`](macro@crate::assert_gt)
* [`debug_assert_gt`](macro@crate::debug_assert_gt)


```rust
pub macro_rules! debug_assert_gt {
    /* macro_rules! debug_assert_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is less than or equal to another.

Pseudocode:<br>
a ≤ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_le`](macro@crate::assert_le)
* [`assert_le_as_result`](macro@crate::assert_le_as_result)
* [`debug_assert_le`](macro@crate::debug_assert_le)


```rust
pub macro_rules! assert_le_as_result {
    /* macro_rules! assert_le_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_le`

**Attributes:**

- `#[macro_export]`

Assert an expression is less than or equal to another.

Pseudocode:<br>
a ≤ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 1;
let b = 2;
assert_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 2;
let b = 1;
assert_le!(a, b);
# });
// assertion failed: `assert_le!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_le.html
//  a label: `a`,
//  a debug: `2`,
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_le!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_le`](macro@crate::assert_le)
* [`assert_le_as_result`](macro@crate::assert_le_as_result)
* [`debug_assert_le`](macro@crate::debug_assert_le)


```rust
pub macro_rules! assert_le {
    /* macro_rules! assert_le {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_le`

**Attributes:**

- `#[macro_export]`

Assert an expression is less than or equal to another.

Pseudocode:<br>
a ≤ b

This macro provides the same statements as [`assert_le`](macro.assert_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_le`](macro@crate::assert_le)
* [`assert_le`](macro@crate::assert_le)
* [`debug_assert_le`](macro@crate::debug_assert_le)


```rust
pub macro_rules! debug_assert_le {
    /* macro_rules! debug_assert_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is less than another.

Pseudocode:<br>
a < b

* If true, return `Ok(())`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_lt`](macro@crate::assert_lt)
* [`assert_lt_as_result`](macro@crate::assert_lt_as_result)
* [`debug_assert_lt`](macro@crate::debug_assert_lt)


```rust
pub macro_rules! assert_lt_as_result {
    /* macro_rules! assert_lt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_lt`

**Attributes:**

- `#[macro_export]`

Assert an expression is less than another.

Pseudocode:<br>
a < b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 1;
let b = 2;
assert_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 2;
let b = 1;
assert_lt!(a, b);
# });
// assertion failed: `assert_lt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_lt.html
//  a label: `a`,
//  a debug: `2`,
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_lt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_lt`](macro@crate::assert_lt)
* [`assert_lt_as_result`](macro@crate::assert_lt_as_result)
* [`debug_assert_lt`](macro@crate::debug_assert_lt)


```rust
pub macro_rules! assert_lt {
    /* macro_rules! assert_lt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_lt`

**Attributes:**

- `#[macro_export]`

Assert an expression is less than another.

Pseudocode:<br>
a < b

This macro provides the same statements as [`assert_lt`](macro.assert_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_lt`](macro@crate::assert_lt)
* [`assert_lt`](macro@crate::assert_lt)
* [`debug_assert_lt`](macro@crate::debug_assert_lt)


```rust
pub macro_rules! debug_assert_lt {
    /* macro_rules! debug_assert_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is not equal to another.

Pseudocode:<br>
a ≠ b

* If true, return Result `Ok(())`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macro

* [`assert_ne_as_result`](macro@crate::assert_ne_as_result)

# Rust standard macros

* [`assert_ne`](https://doc.rust-lang.org/std/macro.assert_ne.html)
* [`debug_assert_ne`](https://doc.rust-lang.org/std/macro.debug_assert_ne.html)


```rust
pub macro_rules! assert_ne_as_result {
    /* macro_rules! assert_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_eq_f32_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a = b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_eq_f32`](macro@crate::assert_eq_f32)
* [`assert_eq_f32_as_result`](macro@crate::assert_eq_f32_as_result)
* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)


```rust
pub macro_rules! assert_eq_f32_as_result {
    /* macro_rules! assert_eq_f32_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_eq_f32`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a = b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333333;
assert_eq_f32!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_eq_f32!(a, b);
# });
// assertion failed: `assert_eq_f32!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_eq_f32.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.3333336`,`
//     diff: `-0.0000002682209`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_eq_f32!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_eq_f32.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333336`,\n",
#     "    diff: `-0.0000002682209`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_eq_f32`](macro@crate::assert_eq_f32)
* [`assert_eq_f32_as_result`](macro@crate::assert_eq_f32_as_result)
* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)


```rust
pub macro_rules! assert_eq_f32 {
    /* macro_rules! assert_eq_f32 {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_eq_f32`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a = b


This macro provides the same statements as [`assert_eq_f32`](macro.assert_eq_f32.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_eq_f32`](macro@crate::assert_eq_f32)
* [`assert_eq_f32`](macro@crate::assert_eq_f32)
* [`debug_assert_eq_f32`](macro@crate::debug_assert_eq_f32)


```rust
pub macro_rules! debug_assert_eq_f32 {
    /* macro_rules! debug_assert_eq_f32 {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_eq_f64_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a = b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_eq_f64`](macro@crate::assert_eq_f64)
* [`assert_eq_f64_as_result`](macro@crate::assert_eq_f64_as_result)
* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)


```rust
pub macro_rules! assert_eq_f64_as_result {
    /* macro_rules! assert_eq_f64_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_eq_f64`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a = b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333335;
assert_eq_f64!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_eq_f64!(a, b);
# });
// assertion failed: `assert_eq_f64!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_eq_f64.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333339`,`
//     diff: `-0.0000000000000006106226635438361`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_eq_f64!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_eq_f64.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333339`,\n",
#     "    diff: `-0.0000000000000006106226635438361`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_eq_f64`](macro@crate::assert_eq_f64)
* [`assert_eq_f64_as_result`](macro@crate::assert_eq_f64_as_result)
* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)


```rust
pub macro_rules! assert_eq_f64 {
    /* macro_rules! assert_eq_f64 {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_eq_f64`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a = b

This macro provides the same statements as [`assert_eq_f64`](macro.assert_eq_f64.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_eq_f64`](macro@crate::assert_eq_f64)
* [`assert_eq_f64`](macro@crate::assert_eq_f64)
* [`debug_assert_eq_f64`](macro@crate::debug_assert_eq_f64)


```rust
pub macro_rules! debug_assert_eq_f64 {
    /* macro_rules! debug_assert_eq_f64 {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f32_eq_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a = b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f32_eq`](macro@crate::assert_f32_eq)
* [`assert_f32_eq_as_result`](macro@crate::assert_f32_eq_as_result)
* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)


```rust
pub macro_rules! assert_f32_eq_as_result {
    /* macro_rules! assert_f32_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f32_eq`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a = b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333333;
assert_f32_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_eq!(a, b);
# });
// assertion failed: `assert_f32_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f32_eq.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.3333336`,`
//     diff: `-0.0000002682209`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f32_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f32_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333336`,\n",
#     "    diff: `-0.0000002682209`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f32_eq`](macro@crate::assert_f32_eq)
* [`assert_f32_eq_as_result`](macro@crate::assert_f32_eq_as_result)
* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)


```rust
pub macro_rules! assert_f32_eq {
    /* macro_rules! assert_f32_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f32_eq`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a = b


This macro provides the same statements as [`assert_f32_eq`](macro.assert_f32_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f32_eq`](macro@crate::assert_f32_eq)
* [`assert_f32_eq`](macro@crate::assert_f32_eq)
* [`debug_assert_f32_eq`](macro@crate::debug_assert_f32_eq)


```rust
pub macro_rules! debug_assert_f32_eq {
    /* macro_rules! debug_assert_f32_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f32_ge_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a ≥ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f32_ge`](macro@crate::assert_f32_ge)
* [`assert_f32_ge_as_result`](macro@crate::assert_f32_ge_as_result)
* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)


```rust
pub macro_rules! assert_f32_ge_as_result {
    /* macro_rules! assert_f32_ge_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f32_ge`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.

Pseudocode:<br>
a ≥ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333331;
assert_f32_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_ge!(a, b);
# });
// assertion failed: `assert_f32_ge!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f32_ge.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.3333336`,`
//     diff: `-0.00000029802322`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f32_ge!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f32_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333336`,\n",
#     "    diff: `-0.0000002682209`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f32_ge`](macro@crate::assert_f32_ge)
* [`assert_f32_ge_as_result`](macro@crate::assert_f32_ge_as_result)
* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)


```rust
pub macro_rules! assert_f32_ge {
    /* macro_rules! assert_f32_ge {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f32_ge`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is greater than or equal to another within f32::EPSILON.

Pseudocode:<br>
a ≥ b


This macro provides the same statements as [`assert_f32_ge`](macro.assert_f32_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f32_ge`](macro@crate::assert_f32_ge)
* [`assert_f32_ge`](macro@crate::assert_f32_ge)
* [`debug_assert_f32_ge`](macro@crate::debug_assert_f32_ge)


```rust
pub macro_rules! debug_assert_f32_ge {
    /* macro_rules! debug_assert_f32_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f32_gt_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a > b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f32_gt`](macro@crate::assert_f32_gt)
* [`assert_f32_gt_as_result`](macro@crate::assert_f32_gt_as_result)
* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)


```rust
pub macro_rules! assert_f32_gt_as_result {
    /* macro_rules! assert_f32_gt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f32_gt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is greater than another within f32::EPSILON.

Pseudocode:<br>
a > b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333331;
assert_f32_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_gt!(a, b);
# });
// assertion failed: `assert_f32_gt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f32_gt.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.3333336`,`
//     diff: `-0.00000029802322`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f32_gt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f32_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333336`,\n",
#     "    diff: `-0.0000002682209`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f32_gt`](macro@crate::assert_f32_gt)
* [`assert_f32_gt_as_result`](macro@crate::assert_f32_gt_as_result)
* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)


```rust
pub macro_rules! assert_f32_gt {
    /* macro_rules! assert_f32_gt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f32_gt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is greater than another within f32::EPSILON.

Pseudocode:<br>
a > b


This macro provides the same statements as [`assert_f32_gt`](macro.assert_f32_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f32_gt`](macro@crate::assert_f32_gt)
* [`assert_f32_gt`](macro@crate::assert_f32_gt)
* [`debug_assert_f32_gt`](macro@crate::debug_assert_f32_gt)


```rust
pub macro_rules! debug_assert_f32_gt {
    /* macro_rules! debug_assert_f32_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f32_le_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a ≤ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f32_le`](macro@crate::assert_f32_le)
* [`assert_f32_le_as_result`](macro@crate::assert_f32_le_as_result)
* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)


```rust
pub macro_rules! assert_f32_le_as_result {
    /* macro_rules! assert_f32_le_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f32_le`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.

Pseudocode:<br>
a ≤ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333331;
assert_f32_le!(a, b);
# });
// assertion failed: `assert_f32_le!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f32_le.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.3333331`,`
//     diff: `0.00000023841858`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f32_le!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f32_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333331`,\n",
#     "    diff: `0.00000023841858`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f32_le`](macro@crate::assert_f32_le)
* [`assert_f32_le_as_result`](macro@crate::assert_f32_le_as_result)
* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)


```rust
pub macro_rules! assert_f32_le {
    /* macro_rules! assert_f32_le {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f32_le`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is less than or equal to another within f32::EPSILON.

Pseudocode:<br>
a ≤ b


This macro provides the same statements as [`assert_f32_le`](macro.assert_f32_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f32_le`](macro@crate::assert_f32_le)
* [`assert_f32_le`](macro@crate::assert_f32_le)
* [`debug_assert_f32_le`](macro@crate::debug_assert_f32_le)


```rust
pub macro_rules! debug_assert_f32_le {
    /* macro_rules! debug_assert_f32_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f32_lt_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a < b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f32_lt`](macro@crate::assert_f32_lt)
* [`assert_f32_lt_as_result`](macro@crate::assert_f32_lt_as_result)
* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)


```rust
pub macro_rules! assert_f32_lt_as_result {
    /* macro_rules! assert_f32_lt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f32_lt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a < b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333331;
assert_f32_lt!(a, b);
# });
// assertion failed: `assert_f32_lt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f32_lt.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.3333331`,`
//     diff: `0.00000029802322`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f32_lt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f32_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333331`,\n",
#     "    diff: `0.00000023841858`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f32_lt`](macro@crate::assert_f32_lt)
* [`assert_f32_lt_as_result`](macro@crate::assert_f32_lt_as_result)
* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)


```rust
pub macro_rules! assert_f32_lt {
    /* macro_rules! assert_f32_lt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f32_lt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is equal to another within f32::EPSILON.

Pseudocode:<br>
a < b


This macro provides the same statements as [`assert_f32_lt`](macro.assert_f32_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f32_lt`](macro@crate::assert_f32_lt)
* [`assert_f32_lt`](macro@crate::assert_f32_lt)
* [`debug_assert_f32_lt`](macro@crate::debug_assert_f32_lt)


```rust
pub macro_rules! debug_assert_f32_lt {
    /* macro_rules! debug_assert_f32_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f32_ne_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
a ≠ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f32_ne`](macro@crate::assert_f32_ne)
* [`assert_f32_ne_as_result`](macro@crate::assert_f32_ne_as_result)
* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)


```rust
pub macro_rules! assert_f32_ne_as_result {
    /* macro_rules! assert_f32_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f32_ne`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is not equal to another within f32::EPSILON.

Pseudocode:<br>
a ≠ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0 / 3.0;
let b: f32 = 0.3333336;
assert_f32_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0 / 3.0;
let b: f32 = 1.0 / 3.0;
assert_f32_ne!(a, b);
# });
// assertion failed: `assert_f32_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f32_ne.html
//  a label: `a`,
//  a debug: `0.33333334`,
//  b label: `b`,
//  b debug: `0.33333334`,`
//     diff: `0`,
//        ε: `0.00000011920929`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f32_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f32_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.33333334`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.33333334`,\n",
#     "    diff: `0`,\n",
#     "       ε: `0.00000011920929`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f32_ne`](macro@crate::assert_f32_ne)
* [`assert_f32_ne_as_result`](macro@crate::assert_f32_ne_as_result)
* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)


```rust
pub macro_rules! assert_f32_ne {
    /* macro_rules! assert_f32_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f32_ne`

**Attributes:**

- `#[macro_export]`

Assert a floating point 32-bit number is not equal to another within f32::EPSILON.

Pseudocode:<br>
a ≠ b


This macro provides the same statements as [`assert_f32_ne`](macro.assert_f32_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f32_ne`](macro@crate::assert_f32_ne)
* [`assert_f32_ne`](macro@crate::assert_f32_ne)
* [`debug_assert_f32_ne`](macro@crate::debug_assert_f32_ne)


```rust
pub macro_rules! debug_assert_f32_ne {
    /* macro_rules! debug_assert_f32_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f64_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a = b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f64_eq`](macro@crate::assert_f64_eq)
* [`assert_f64_eq_as_result`](macro@crate::assert_f64_eq_as_result)
* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)


```rust
pub macro_rules! assert_f64_eq_as_result {
    /* macro_rules! assert_f64_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f64_eq`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a = b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333335;
assert_f64_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_eq!(a, b);
# });
// assertion failed: `assert_f64_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f64_eq.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333339`,`
//     diff: `-0.0000000000000006106226635438361`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f64_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f64_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333339`,\n",
#     "    diff: `-0.0000000000000006106226635438361`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f64_eq`](macro@crate::assert_f64_eq)
* [`assert_f64_eq_as_result`](macro@crate::assert_f64_eq_as_result)
* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)


```rust
pub macro_rules! assert_f64_eq {
    /* macro_rules! assert_f64_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f64_eq`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a = b

This macro provides the same statements as [`assert_f64_eq`](macro.assert_f64_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f64_eq`](macro@crate::assert_f64_eq)
* [`assert_f64_eq`](macro@crate::assert_f64_eq)
* [`debug_assert_f64_eq`](macro@crate::debug_assert_f64_eq)


```rust
pub macro_rules! debug_assert_f64_eq {
    /* macro_rules! debug_assert_f64_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f64_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a ≥ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f64_ge`](macro@crate::assert_f64_ge)
* [`assert_f64_ge_as_result`](macro@crate::assert_f64_ge_as_result)
* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)


```rust
pub macro_rules! assert_f64_ge_as_result {
    /* macro_rules! assert_f64_ge_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f64_ge`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is greater than or equal to another within f64::EPSILON.

Pseudocode:<br>
a ≥ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333335;
assert_f64_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_ge!(a, b);
# });
// assertion failed: `assert_f64_ge!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f64_ge.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333339`,`
//     diff: `-0.0000000000000006106226635438361`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f64_ge!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f64_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333339`,\n",
#     "    diff: `-0.0000000000000006106226635438361`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f64_ge`](macro@crate::assert_f64_ge)
* [`assert_f64_ge_as_result`](macro@crate::assert_f64_ge_as_result)
* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)


```rust
pub macro_rules! assert_f64_ge {
    /* macro_rules! assert_f64_ge {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f64_ge`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is greater than or equal to another within f64::EPSILON.

Pseudocode:<br>
a ≥ b

This macro provides the same statements as [`assert_f64_ge`](macro.assert_f64_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f64_ge`](macro@crate::assert_f64_ge)
* [`assert_f64_ge`](macro@crate::assert_f64_ge)
* [`debug_assert_f64_ge`](macro@crate::debug_assert_f64_ge)


```rust
pub macro_rules! debug_assert_f64_ge {
    /* macro_rules! debug_assert_f64_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f64_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a > b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f64_gt`](macro@crate::assert_f64_gt)
* [`assert_f64_gt_as_result`](macro@crate::assert_f64_gt_as_result)
* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)


```rust
pub macro_rules! assert_f64_gt_as_result {
    /* macro_rules! assert_f64_gt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f64_gt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is greater than another within f64::EPSILON.

Pseudocode:<br>
a > b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333329;
assert_f64_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_gt!(a, b);
# });
// assertion failed: `assert_f64_gt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f64_gt.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333339`,`
//     diff: `-0.0000000000000006106226635438361`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f64_gt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f64_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333339`,\n",
#     "    diff: `-0.0000000000000006106226635438361`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f64_gt`](macro@crate::assert_f64_gt)
* [`assert_f64_gt_as_result`](macro@crate::assert_f64_gt_as_result)
* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)


```rust
pub macro_rules! assert_f64_gt {
    /* macro_rules! assert_f64_gt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f64_gt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is greater than another within f64::EPSILON.

Pseudocode:<br>
a > b

This macro provides the same statements as [`assert_f64_gt`](macro.assert_f64_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f64_gt`](macro@crate::assert_f64_gt)
* [`assert_f64_gt`](macro@crate::assert_f64_gt)
* [`debug_assert_f64_gt`](macro@crate::debug_assert_f64_gt)


```rust
pub macro_rules! debug_assert_f64_gt {
    /* macro_rules! debug_assert_f64_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f64_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a ≤ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f64_le`](macro@crate::assert_f64_le)
* [`assert_f64_le_as_result`](macro@crate::assert_f64_le_as_result)
* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)


```rust
pub macro_rules! assert_f64_le_as_result {
    /* macro_rules! assert_f64_le_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f64_le`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a ≤ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333335;
assert_f64_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333329;
assert_f64_le!(a, b);
# });
// assertion failed: `assert_f64_le!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f64_le.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333329`,`
//     diff: `0.0000000000000004996003610813204`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f64_le!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f64_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333329`,\n",
#     "    diff: `0.0000000000000003885780586188048`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f64_le`](macro@crate::assert_f64_le)
* [`assert_f64_le_as_result`](macro@crate::assert_f64_le_as_result)
* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)


```rust
pub macro_rules! assert_f64_le {
    /* macro_rules! assert_f64_le {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f64_le`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is equal to another within f64::EPSILON.

Pseudocode:<br>
a ≤ b

This macro provides the same statements as [`assert_f64_le`](macro.assert_f64_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f64_le`](macro@crate::assert_f64_le)
* [`assert_f64_le`](macro@crate::assert_f64_le)
* [`debug_assert_f64_le`](macro@crate::debug_assert_f64_le)


```rust
pub macro_rules! debug_assert_f64_le {
    /* macro_rules! debug_assert_f64_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f64_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a < b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f64_lt`](macro@crate::assert_f64_lt)
* [`assert_f64_lt_as_result`](macro@crate::assert_f64_lt_as_result)
* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)


```rust
pub macro_rules! assert_f64_lt_as_result {
    /* macro_rules! assert_f64_lt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f64_lt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is less than another within f64::EPSILON.

Pseudocode:<br>
a < b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333339;
assert_f64_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333329;
assert_f64_lt!(a, b);
# });
// assertion failed: `assert_f64_lt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f64_lt.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333329`,`
//     diff: `0.0000000000000003885780586188048`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f64_lt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f64_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333329`,\n",
#     "    diff: `0.0000000000000003885780586188048`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f64_lt`](macro@crate::assert_f64_lt)
* [`assert_f64_lt_as_result`](macro@crate::assert_f64_lt_as_result)
* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)


```rust
pub macro_rules! assert_f64_lt {
    /* macro_rules! assert_f64_lt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f64_lt`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is less than another within f64::EPSILON.

Pseudocode:<br>
a < b

This macro provides the same statements as [`assert_f64_lt`](macro.assert_f64_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f64_lt`](macro@crate::assert_f64_lt)
* [`assert_f64_lt`](macro@crate::assert_f64_lt)
* [`debug_assert_f64_lt`](macro@crate::debug_assert_f64_lt)


```rust
pub macro_rules! debug_assert_f64_lt {
    /* macro_rules! debug_assert_f64_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_f64_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert two floating point numbers are equal within f64::EPSILON.

Pseudocode:<br>
a ≠ b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_f64_ne`](macro@crate::assert_f64_ne)
* [`assert_f64_ne_as_result`](macro@crate::assert_f64_ne_as_result)
* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)


```rust
pub macro_rules! assert_f64_ne_as_result {
    /* macro_rules! assert_f64_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_f64_ne`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is not equal to another within f64::EPSILON.

Pseudocode:<br>
a ≠ b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333338;
assert_f64_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f64 = 1.0 / 3.0;
let b: f64 = 0.3333333333333333;
assert_f64_ne!(a, b);
# });
// assertion failed: `assert_f64_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_f64_ne.html
//  a label: `a`,
//  a debug: `0.3333333333333333`,
//  b label: `b`,
//  b debug: `0.3333333333333333`,`
//     diff: `0`,
//        ε: `0.0000000000000002220446049250313`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_f64_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_f64_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `0.3333333333333333`,\n",
#     " b label: `b`,\n",
#     " b debug: `0.3333333333333333`,\n",
#     "    diff: `0`,\n",
#     "       ε: `0.0000000000000002220446049250313`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_f64_ne`](macro@crate::assert_f64_ne)
* [`assert_f64_ne_as_result`](macro@crate::assert_f64_ne_as_result)
* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)


```rust
pub macro_rules! assert_f64_ne {
    /* macro_rules! assert_f64_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_f64_ne`

**Attributes:**

- `#[macro_export]`

Assert a floating point 64-bit number is not equal to another within f64::EPSILON.

Pseudocode:<br>
a ≠ b

This macro provides the same statements as [`assert_f64_ne`](macro.assert_f64_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_f64_ne`](macro@crate::assert_f64_ne)
* [`assert_f64_ne`](macro@crate::assert_f64_ne)
* [`debug_assert_f64_ne`](macro@crate::debug_assert_f64_ne)


```rust
pub macro_rules! debug_assert_f64_ne {
    /* macro_rules! debug_assert_f64_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is equal to an expression.

Pseudocode:<br>
|Δ| = x

* If true, return `Ok((lhs, rhs))`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)
* [`assert_abs_diff_eq_x_as_result`](macro@crate::assert_abs_diff_eq_x_as_result)
* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)


```rust
pub macro_rules! assert_abs_diff_eq_x_as_result {
    /* macro_rules! assert_abs_diff_eq_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_abs_diff_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is equal to an expression.

Pseudocode:<br>
|Δ| = x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 10;
let b = 13;
let x = 3;
assert_abs_diff_eq_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_eq_x!(a, b, x);
# });
// assertion failed: `assert_abs_diff_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_abs_diff_eq_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `2`,
//      |Δ|: `3`,
//  |Δ| = x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_abs_diff_eq_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_abs_diff_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `2`,\n",
#     "     |Δ|: `3`,\n",
#     " |Δ| = x: false"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)
* [`assert_abs_diff_eq_x_as_result`](macro@crate::assert_abs_diff_eq_x_as_result)
* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)


```rust
pub macro_rules! assert_abs_diff_eq_x {
    /* macro_rules! assert_abs_diff_eq_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is equal to an expression.

Pseudocode:<br>
|Δ| = c

This macro provides the same statements as [`assert_abs_diff_eq_x`](macro.assert_abs_diff_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-x debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)
* [`assert_abs_diff_eq_x`](macro@crate::assert_abs_diff_eq_x)
* [`debug_assert_abs_diff_eq_x`](macro@crate::debug_assert_abs_diff_eq_x)


```rust
pub macro_rules! debug_assert_abs_diff_eq_x {
    /* macro_rules! debug_assert_abs_diff_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is greater than or equal to an expression.

Pseudocode:<br>
|Δ| ≥ x

* If true, return `Ok((lhs, rhs))`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)
* [`assert_abs_diff_ge_x_as_result`](macro@crate::assert_abs_diff_ge_x_as_result)
* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)


```rust
pub macro_rules! assert_abs_diff_ge_x_as_result {
    /* macro_rules! assert_abs_diff_ge_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_abs_diff_ge_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is greater than or equal to an expression.

Pseudocode:<br>
|Δ| ≥ x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_ge_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 10;
let b = 13;
let x = 4;
assert_abs_diff_ge_x!(a, b, x);
# });
// assertion failed: `assert_abs_diff_ge_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_abs_diff_ge_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `4`,
//      |Δ|: `3`,
//  |Δ| ≥ x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_abs_diff_ge_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_abs_diff_ge_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `4`,\n",
#     "     |Δ|: `3`,\n",
#     " |Δ| ≥ x: false"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)
* [`assert_abs_diff_ge_x_as_result`](macro@crate::assert_abs_diff_ge_x_as_result)
* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)


```rust
pub macro_rules! assert_abs_diff_ge_x {
    /* macro_rules! assert_abs_diff_ge_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_ge_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is greater than or equal to an expression.

Pseudocode:<br>
|Δ| ≥ c

This macro provides the same statements as [`assert_abs_diff_ge_x`](macro.assert_abs_diff_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-x debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)
* [`assert_abs_diff_ge_x`](macro@crate::assert_abs_diff_ge_x)
* [`debug_assert_abs_diff_ge_x`](macro@crate::debug_assert_abs_diff_ge_x)


```rust
pub macro_rules! debug_assert_abs_diff_ge_x {
    /* macro_rules! debug_assert_abs_diff_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is greater than an expression.

Pseudocode:<br>
|Δ| > x

* If true, return `Ok((lhs, rhs))`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)
* [`assert_abs_diff_gt_x_as_result`](macro@crate::assert_abs_diff_gt_x_as_result)
* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)


```rust
pub macro_rules! assert_abs_diff_gt_x_as_result {
    /* macro_rules! assert_abs_diff_gt_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_abs_diff_gt_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is greater than an expression.

Pseudocode:<br>
|Δ| > x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_gt_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 10;
let b = 13;
let x = 4;
assert_abs_diff_gt_x!(a, b, x);
# });
// assertion failed: `assert_abs_diff_gt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_abs_diff_gt_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `4`,
//      |Δ|: `3`,
//  |Δ| > x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_abs_diff_gt_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_abs_diff_gt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `4`,\n",
#     "     |Δ|: `3`,\n",
#     " |Δ| > x: false"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)
* [`assert_abs_diff_gt_x_as_result`](macro@crate::assert_abs_diff_gt_x_as_result)
* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)


```rust
pub macro_rules! assert_abs_diff_gt_x {
    /* macro_rules! assert_abs_diff_gt_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_gt_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is greater than an expression.

Pseudocode:<br>
|Δ| > c

This macro provides the same statements as [`assert_abs_diff_gt_x`](macro.assert_abs_diff_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-x debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)
* [`assert_abs_diff_gt_x`](macro@crate::assert_abs_diff_gt_x)
* [`debug_assert_abs_diff_gt_x`](macro@crate::debug_assert_abs_diff_gt_x)


```rust
pub macro_rules! debug_assert_abs_diff_gt_x {
    /* macro_rules! debug_assert_abs_diff_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is less than or equal to an expression.

Pseudocode:<br>
|Δ| ≤ x

* If true, return `Ok((lhs, rhs))`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)
* [`assert_abs_diff_le_x_as_result`](macro@crate::assert_abs_diff_le_x_as_result)
* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)


```rust
pub macro_rules! assert_abs_diff_le_x_as_result {
    /* macro_rules! assert_abs_diff_le_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_abs_diff_le_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is less than or equal to an expression.

Pseudocode:<br>
|Δ| ≤ x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 10;
let b = 13;
let x = 4;
assert_abs_diff_le_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_le_x!(a, b, x);
# });
// assertion failed: `assert_abs_diff_le_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_abs_diff_le_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `2`,
//      |Δ|: `3`,
//  |Δ| ≤ x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_abs_diff_le_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_abs_diff_le_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `2`,\n",
#     "     |Δ|: `3`,\n",
#     " |Δ| ≤ x: false"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)
* [`assert_abs_diff_le_x_as_result`](macro@crate::assert_abs_diff_le_x_as_result)
* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)


```rust
pub macro_rules! assert_abs_diff_le_x {
    /* macro_rules! assert_abs_diff_le_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_le_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is less than or equal to an expression.

Pseudocode:<br>
|Δ| ≤ c

This macro provides the same statements as [`assert_abs_diff_le_x`](macro.assert_abs_diff_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-x debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)
* [`assert_abs_diff_le_x`](macro@crate::assert_abs_diff_le_x)
* [`debug_assert_abs_diff_le_x`](macro@crate::debug_assert_abs_diff_le_x)


```rust
pub macro_rules! debug_assert_abs_diff_le_x {
    /* macro_rules! debug_assert_abs_diff_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is less than an expression.

Pseudocode:<br>
|Δ| < x

* If true, return `Ok((lhs, rhs))`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)
* [`assert_abs_diff_lt_x_as_result`](macro@crate::assert_abs_diff_lt_x_as_result)
* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)


```rust
pub macro_rules! assert_abs_diff_lt_x_as_result {
    /* macro_rules! assert_abs_diff_lt_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_abs_diff_lt_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is less than an expression.

Pseudocode:<br>
|Δ| < x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 10;
let b = 13;
let x = 4;
assert_abs_diff_lt_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_lt_x!(a, b, x);
# });
// assertion failed: `assert_abs_diff_lt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_abs_diff_lt_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `2`,
//      |Δ|: `3`,
//  |Δ| < x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_abs_diff_lt_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_abs_diff_lt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `2`,\n",
#     "     |Δ|: `3`,\n",
#     " |Δ| < x: false"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)
* [`assert_abs_diff_lt_x_as_result`](macro@crate::assert_abs_diff_lt_x_as_result)
* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)


```rust
pub macro_rules! assert_abs_diff_lt_x {
    /* macro_rules! assert_abs_diff_lt_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_lt_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is less than an expression.

Pseudocode:<br>
|Δ| < c

This macro provides the same statements as [`assert_abs_diff_lt_x`](macro.assert_abs_diff_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-x debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)
* [`assert_abs_diff_lt_x`](macro@crate::assert_abs_diff_lt_x)
* [`debug_assert_abs_diff_lt_x`](macro@crate::debug_assert_abs_diff_lt_x)


```rust
pub macro_rules! debug_assert_abs_diff_lt_x {
    /* macro_rules! debug_assert_abs_diff_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is not equal to an expression.

Pseudocode:<br>
|Δ| ≠ x

* If true, return `Ok((lhs, rhs))`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)
* [`assert_abs_diff_ne_x_as_result`](macro@crate::assert_abs_diff_ne_x_as_result)
* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)


```rust
pub macro_rules! assert_abs_diff_ne_x_as_result {
    /* macro_rules! assert_abs_diff_ne_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_abs_diff_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is not equal to an expression.

Pseudocode:<br>
|Δ| ≠ x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 10;
let b = 13;
let x = 2;
assert_abs_diff_ne_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 10;
let b = 13;
let x = 3;
assert_abs_diff_ne_x!(a, b, x);
# });
// assertion failed: `assert_abs_diff_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_abs_diff_ne_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `2`,
//      |Δ|: `3`,
//  |Δ| ≠ x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_abs_diff_ne_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_abs_diff_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `3`,\n",
#     "     |Δ|: `3`,\n",
#     " |Δ| ≠ x: false"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)
* [`assert_abs_diff_ne_x_as_result`](macro@crate::assert_abs_diff_ne_x_as_result)
* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)


```rust
pub macro_rules! assert_abs_diff_ne_x {
    /* macro_rules! assert_abs_diff_ne_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an absolute difference is not equal to an expression.

Pseudocode:<br>
|Δ| ≠ c

This macro provides the same statements as [`assert_abs_diff_ne_x`](macro.assert_abs_diff_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-x debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)
* [`assert_abs_diff_ne_x`](macro@crate::assert_abs_diff_ne_x)
* [`debug_assert_abs_diff_ne_x`](macro@crate::debug_assert_abs_diff_ne_x)


```rust
pub macro_rules! debug_assert_abs_diff_ne_x {
    /* macro_rules! debug_assert_abs_diff_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_eq_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_eq_as_result` into `assert_abs_diff_eq_x_as_result`.

Assert an absolute difference is equal to an expression.

Deprecated. Please rename from `assert_abs_diff_eq_as_result` into `assert_abs_diff_eq_x_as_result`.


```rust
pub macro_rules! assert_abs_diff_eq_as_result {
    /* macro_rules! assert_abs_diff_eq_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_eq` into `assert_abs_diff_eq_x`.

Assert an absolute difference is equal to an expression.

Deprecated. Please rename from `assert_abs_diff_eq` into `assert_abs_diff_eq_x`.


```rust
pub macro_rules! assert_abs_diff_eq {
    /* macro_rules! assert_abs_diff_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_abs_diff_eq` into `debug_assert_abs_diff_eq_x`.

Assert an absolute difference is equal to an expression.

Deprecated. Please rename from `debug_assert_abs_diff_eq` into `debug_assert_abs_diff_eq_x`.


```rust
pub macro_rules! debug_assert_abs_diff_eq {
    /* macro_rules! debug_assert_abs_diff_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_ge_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_ge_as_result` into `assert_abs_diff_ge_x_as_result`.

Assert an absolute difference is greater than or equal to an expression.

Deprecated. Please rename from `assert_abs_diff_ge_as_result` into `assert_abs_diff_ge_x_as_result`.


```rust
pub macro_rules! assert_abs_diff_ge_as_result {
    /* macro_rules! assert_abs_diff_ge_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_ge`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_ge` into `assert_abs_diff_ge_x`.

Assert an absolute difference is greater than or equal to an expression.

Deprecated. Please rename from `assert_abs_diff_ge` into `assert_abs_diff_ge_x`.


```rust
pub macro_rules! assert_abs_diff_ge {
    /* macro_rules! assert_abs_diff_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_ge`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_abs_diff_ge` into `debug_assert_abs_diff_ge_x`.

Assert an absolute difference is greater than or equal to an expression.

Deprecated. Please rename from `debug_assert_abs_diff_ge` into `debug_assert_abs_diff_ge_x`.


```rust
pub macro_rules! debug_assert_abs_diff_ge {
    /* macro_rules! debug_assert_abs_diff_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_gt_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_gt_as_result` into `assert_abs_diff_gt_x_as_result`.

Assert an absolute difference is greater than an expression.

Deprecated. Please rename from `assert_abs_diff_gt_as_result` into `assert_abs_diff_gt_x_as_result`.


```rust
pub macro_rules! assert_abs_diff_gt_as_result {
    /* macro_rules! assert_abs_diff_gt_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_gt`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_gt` into `assert_abs_diff_gt_x`.

Assert an absolute difference is greater than an expression.

Deprecated. Please rename from `assert_abs_diff_gt` into `assert_abs_diff_gt_x`.


```rust
pub macro_rules! assert_abs_diff_gt {
    /* macro_rules! assert_abs_diff_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_gt`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_abs_diff_gt` into `debug_assert_abs_diff_gt_x`.

Assert an absolute difference is greater than an expression.

Deprecated. Please rename from `debug_assert_abs_diff_gt` into `debug_assert_abs_diff_gt_x`.


```rust
pub macro_rules! debug_assert_abs_diff_gt {
    /* macro_rules! debug_assert_abs_diff_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_le_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_le_as_result` into `assert_abs_diff_le_x_as_result`.

Assert an absolute difference is less than or equal to an expression.

Deprecated. Please rename from `assert_abs_diff_le_as_result` into `assert_abs_diff_le_x_as_result`.


```rust
pub macro_rules! assert_abs_diff_le_as_result {
    /* macro_rules! assert_abs_diff_le_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_le`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_le` into `assert_abs_diff_le_x`.

Assert an absolute difference is less than or equal to an expression.

Deprecated. Please rename from `assert_abs_diff_le` into `assert_abs_diff_le_x`.


```rust
pub macro_rules! assert_abs_diff_le {
    /* macro_rules! assert_abs_diff_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_le`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_abs_diff_le` into `debug_assert_abs_diff_le_x`.

Assert an absolute difference is less than or equal to an expression.

Deprecated. Please rename from `debug_assert_abs_diff_le` into `debug_assert_abs_diff_le_x`.


```rust
pub macro_rules! debug_assert_abs_diff_le {
    /* macro_rules! debug_assert_abs_diff_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_lt_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_lt_as_result` into `assert_abs_diff_lt_x_as_result`.

Assert an absolute difference is less than an expression.

Deprecated. Please rename from `assert_abs_diff_lt_as_result` into `assert_abs_diff_lt_x_as_result`.


```rust
pub macro_rules! assert_abs_diff_lt_as_result {
    /* macro_rules! assert_abs_diff_lt_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_lt`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_lt` into `assert_abs_diff_lt_x`.

Assert an absolute difference is less than an expression.

Deprecated. Please rename from `assert_abs_diff_lt` into `assert_abs_diff_lt_x`.


```rust
pub macro_rules! assert_abs_diff_lt {
    /* macro_rules! assert_abs_diff_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_lt`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_abs_diff_lt` into `debug_assert_abs_diff_lt_x`.

Assert an absolute difference is less than an expression.

Deprecated. Please rename from `debug_assert_abs_diff_lt` into `debug_assert_abs_diff_lt_x`.


```rust
pub macro_rules! debug_assert_abs_diff_lt {
    /* macro_rules! debug_assert_abs_diff_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_ne_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_ne_as_result` into `assert_abs_diff_ne_x_as_result`.

Assert an absolute difference is not equal to an expression.

Deprecated. Please rename from `assert_abs_diff_ne_as_result` into `assert_abs_diff_ne_x_as_result`.


```rust
pub macro_rules! assert_abs_diff_ne_as_result {
    /* macro_rules! assert_abs_diff_ne_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_abs_diff_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_abs_diff_ne` into `assert_abs_diff_ne_x`.

Assert an absolute difference is not equal to an expression.

Deprecated. Please rename from `assert_abs_diff_ne` into `assert_abs_diff_ne_x`.


```rust
pub macro_rules! assert_abs_diff_ne {
    /* macro_rules! assert_abs_diff_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_abs_diff_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_abs_diff_ne` into `debug_assert_abs_diff_ne_x`.

Assert an absolute difference is not equal to an expression.

Deprecated. Please rename from `debug_assert_abs_diff_ne` into `debug_assert_abs_diff_ne_x`.


```rust
pub macro_rules! debug_assert_abs_diff_ne {
    /* macro_rules! debug_assert_abs_diff_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_approx_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a number is approximately equal to another.

Pseudocode:<br>
| a - b | ≤ 1e-6

* If true, return Result `Ok(abs_diff, approx)`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_approx_eq`](macro@crate::assert_approx_eq)
* [`assert_approx_eq_as_result`](macro@crate::assert_approx_eq_as_result)
* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)


```rust
pub macro_rules! assert_approx_eq_as_result {
    /* macro_rules! assert_approx_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_approx_eq`

**Attributes:**

- `#[macro_export]`

Assert a number is approximately equal to another.

Pseudocode:<br>
| a - b | ≤ 1e-6

* If true, return `(diff, approx)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0000001;
let b: f32 = 1.0000011;
assert_approx_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0000001;
let b: f32 = 1.0000012;
assert_approx_eq!(a, b);
# });
// assertion failed: `assert_approx_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_approx_eq.html
//             a label: `a`,
//             a debug: `1.0000001`,
//             b label: `b`,
//             b debug: `1.0000012`,
//           | a - b |: `1.0728836e-6`,
//              approx: `1e-6`,
//  | a - b | ≤ approx: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_approx_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_approx_eq.html\n",
#     "            a label: `a`,\n",
#     "            a debug: `1.0000001`,\n",
#     "            b label: `b`,\n",
#     "            b debug: `1.0000012`,\n",
#     "          | a - b |: `1.0728836e-6`,\n",
#     "             approx: `1e-6`,\n",
#     " | a - b | ≤ approx: false",
# );
# assert_eq!(actual, message);
# }
```

The macros `assert_approx_eq` and `assert_in_epsilon` can test
approximations:

* For an approximation, the absolute error (i.e. approx) is the magnitude of
  the difference between the exact value and the approximation. For this,
 use the macro

* For an approximation, the relative error (i.e. epsilon) is the absolute
  error divided by the magnitude of the exact value. This can be used to
  compare approximations of numbers of wildly differing size.

* For example, approximating the number 1,000 with an absolute error of 3
  is, in most applications, much worse than approximating the number
  1,000,000 with an absolute error of 3; in the first case the relative
  error is 0.003 and in the second it is only 0.000003.

* Thanks to Ruby minitest for the example and documentation.

# Module macros

* [`assert_approx_eq`](macro@crate::assert_approx_eq)
* [`assert_approx_eq_as_result`](macro@crate::assert_approx_eq_as_result)
* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)


```rust
pub macro_rules! assert_approx_eq {
    /* macro_rules! assert_approx_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_approx_eq`

**Attributes:**

- `#[macro_export]`

Assert a number is approximately equal to another.

Pseudocode:<br>
| a - b | ≤ 1e-6

This macro provides the same statements as [`assert_approx_eq`](macro.assert_approx_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_approx_eq`](macro@crate::assert_approx_eq)
* [`assert_approx_eq`](macro@crate::assert_approx_eq)
* [`debug_assert_approx_eq`](macro@crate::debug_assert_approx_eq)


```rust
pub macro_rules! debug_assert_approx_eq {
    /* macro_rules! debug_assert_approx_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_approx_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a number is approximately not equal to another.

Pseudocode:<br>
| a - b | > 1e-6

* If true, return Result `Ok(abs_diff, approx)`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_approx_ne`](macro@crate::assert_approx_ne)
* [`assert_approx_ne_as_result`](macro@crate::assert_approx_ne_as_result)
* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)


```rust
pub macro_rules! assert_approx_ne_as_result {
    /* macro_rules! assert_approx_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_approx_ne`

**Attributes:**

- `#[macro_export]`

Assert a number is approximately not equal to another.

Pseudocode:<br>
| a - b | > 1e-6

* If true, return `(diff, approx)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: f32 = 1.0000001;
let b: f32 = 1.0000012;
assert_approx_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: f32 = 1.0000001;
let b: f32 = 1.0000011;
assert_approx_ne!(a, b);
# });
// assertion failed: `assert_approx_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_approx_ne.html
//             a label: `a`,
//             a debug: `1.0000001`,
//             b label: `b`,
//             b debug: `1.0000011`,
//           | a - b |: `9.536743e-7`,
//              approx: `1e-6`,
//  | a - b | > approx: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_approx_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_approx_ne.html\n",
#     "            a label: `a`,\n",
#     "            a debug: `1.0000001`,\n",
#     "            b label: `b`,\n",
#     "            b debug: `1.0000011`,\n",
#     "          | a - b |: `9.536743e-7`,\n",
#     "             approx: `1e-6`,\n",
#     " | a - b | > approx: false",
# );
# assert_eq!(actual, message);
# }
```

The macros `assert_approx_ne` and `assert_in_epsilon` can test
approximations:

* For an approximation, the absolute error (i.e. approx) is the magnitude of
  the difference between the exact value and the approximation. For this,
 use the macro

* For an approximation, the relative error (i.e. epsilon) is the absolute
  error divided by the magnitude of the exact value. This can be used to
  compare approximations of numbers of wildly differing size.

* For example, approximating the number 1,000 with an absolute error of 3
  is, in most applications, much worse than approximating the number
  1,000,000 with an absolute error of 3; in the first case the relative
  error is 0.003 and in the second it is only 0.000003.

* Thanks to Ruby minitest for the example and documentation.

# Module macros

* [`assert_approx_ne`](macro@crate::assert_approx_ne)
* [`assert_approx_ne_as_result`](macro@crate::assert_approx_ne_as_result)
* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)


```rust
pub macro_rules! assert_approx_ne {
    /* macro_rules! assert_approx_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_approx_ne`

**Attributes:**

- `#[macro_export]`

Assert a number is approximately not equal to another.

Pseudocode:<br>
| a - b | > 1e-6

This macro provides the same statements as [`assert_approx_ne`](macro.assert_approx_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_approx_ne`](macro@crate::assert_approx_ne)
* [`assert_approx_ne`](macro@crate::assert_approx_ne)
* [`debug_assert_approx_ne`](macro@crate::debug_assert_approx_ne)


```rust
pub macro_rules! debug_assert_approx_ne {
    /* macro_rules! debug_assert_approx_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_diff_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a difference is equal to an expression.

Pseudocode:<br>
Δ = x

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)
* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)
* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)


```rust
pub macro_rules! assert_diff_eq_x_as_result {
    /* macro_rules! assert_diff_eq_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_diff_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is equal to an expression.

Pseudocode:<br>
Δ = x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 3;
assert_diff_eq_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 2;
assert_diff_eq_x!(a, b, x);
# });
// assertion failed: `assert_diff_eq_x!(a, b, x)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_diff_eq_x.html
//  a label: `a`,
//  a debug: `10`,
//  b label: `b`,
//  b debug: `13`,
//  x label: `x`,
//  x debug: `2`,
//        Δ: `3`,
//    Δ = x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_diff_eq_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_diff_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `2`,\n",
#     "       Δ: `3`,\n",
#     "   Δ = x: false",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)
* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)
* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)


```rust
pub macro_rules! assert_diff_eq_x {
    /* macro_rules! assert_diff_eq_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_diff_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is equal to an expression.

Pseudocode:<br>
Δ = x

This macro provides the same statements as [`assert_diff_eq_x`](macro.assert_diff_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_diff_eq_x`](macro@crate::assert_diff_eq_x)
* [`assert_diff_eq_x_as_result`](macro@crate::assert_diff_eq_x_as_result)
* [`debug_assert_diff_eq_x`](macro@crate::debug_assert_diff_eq_x)


```rust
pub macro_rules! debug_assert_diff_eq_x {
    /* macro_rules! debug_assert_diff_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_diff_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a difference is greater than or equal to an expression.

Pseudocode:<br>
Δ ≥ x

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)
* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)
* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)


```rust
pub macro_rules! assert_diff_ge_x_as_result {
    /* macro_rules! assert_diff_ge_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_diff_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is greater than or equal to an expression.

Pseudocode:<br>
Δ ≥ x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 2;
assert_diff_ge_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 4;
assert_diff_ge_x!(a, b, x);
# });
// assertion failed: `assert_diff_ge_x!(a, b, x)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_diff_ge_x.html
//        a label: `a`,
//        a debug: `10`,
//        b label: `b`,
//        b debug: `13`,
//        x label: `x`,
//        x debug: `4`,
//              Δ: `3`,
//          Δ ≥ x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_diff_ge_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_diff_ge_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `4`,\n",
#     "       Δ: `3`,\n",
#     "   Δ ≥ x: false",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)
* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)
* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)


```rust
pub macro_rules! assert_diff_ge_x {
    /* macro_rules! assert_diff_ge_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_diff_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is greater than or equal to an expression.

Pseudocode:<br>
Δ ≥ x

This macro provides the same statements as [`assert_diff_ge_x`](macro.assert_diff_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_diff_ge_x`](macro@crate::assert_diff_ge_x)
* [`assert_diff_ge_x_as_result`](macro@crate::assert_diff_ge_x_as_result)
* [`debug_assert_diff_ge_x`](macro@crate::debug_assert_diff_ge_x)


```rust
pub macro_rules! debug_assert_diff_ge_x {
    /* macro_rules! debug_assert_diff_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_diff_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a difference is greater than an expression.

Pseudocode:<br>
Δ > x

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)
* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)
* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)


```rust
pub macro_rules! assert_diff_gt_x_as_result {
    /* macro_rules! assert_diff_gt_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_diff_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is greater than an expression.

Pseudocode:<br>
Δ > x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 2;
assert_diff_gt_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 4;
assert_diff_gt_x!(a, b, x);
# });
// assertion failed: `assert_diff_gt_x!(a, b, x)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_diff_gt_x.html
//        a label: `a`,
//        a debug: `10`,
//        b label: `b`,
//        b debug: `13`,
//        x label: `x`,
//        x debug: `4`,
//              Δ: `3`,
//          Δ > x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_diff_gt_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_diff_gt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `4`,\n",
#     "       Δ: `3`,\n",
#     "   Δ > x: false",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)
* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)
* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)


```rust
pub macro_rules! assert_diff_gt_x {
    /* macro_rules! assert_diff_gt_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_diff_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is greater than an expression.

Pseudocode:<br>
Δ > x

This macro provides the same statements as [`assert_diff_gt_x`](macro.assert_diff_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_diff_gt_x`](macro@crate::assert_diff_gt_x)
* [`assert_diff_gt_x_as_result`](macro@crate::assert_diff_gt_x_as_result)
* [`debug_assert_diff_gt_x`](macro@crate::debug_assert_diff_gt_x)


```rust
pub macro_rules! debug_assert_diff_gt_x {
    /* macro_rules! debug_assert_diff_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_diff_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a difference is less than or equal to an expression.

Pseudocode:<br>
Δ ≤ x

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)
* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)
* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)


```rust
pub macro_rules! assert_diff_le_x_as_result {
    /* macro_rules! assert_diff_le_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_diff_le_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is less than or equal to an expression.

Pseudocode:<br>
Δ ≤ x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 3;
assert_diff_le_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 1;
assert_diff_le_x!(a, b, x);
# });
// assertion failed: `assert_diff_le_x!(a, b, x)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_diff_le_x.html
//        a label: `a`,
//        a debug: `10`,
//        b label: `b`,
//        b debug: `13`,
//        x label: `x`,
//        x debug: `1`,
//              Δ: `3`,
//          Δ ≤ x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_diff_le_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_diff_le_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `1`,\n",
#     "       Δ: `3`,\n",
#     "   Δ ≤ x: false",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)
* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)
* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)


```rust
pub macro_rules! assert_diff_le_x {
    /* macro_rules! assert_diff_le_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_diff_le_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is less than or equal to an expression.

Pseudocode:<br>
Δ ≤ x

This macro provides the same statements as [`assert_diff_le_x`](macro.assert_diff_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_diff_le_x`](macro@crate::assert_diff_le_x)
* [`assert_diff_le_x_as_result`](macro@crate::assert_diff_le_x_as_result)
* [`debug_assert_diff_le_x`](macro@crate::debug_assert_diff_le_x)


```rust
pub macro_rules! debug_assert_diff_le_x {
    /* macro_rules! debug_assert_diff_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_diff_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a difference is less than an expression.

Pseudocode:<br>
Δ < x

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)
* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)
* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)


```rust
pub macro_rules! assert_diff_lt_x_as_result {
    /* macro_rules! assert_diff_lt_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_diff_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is less than an expression.

Pseudocode:<br>
Δ < x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 4;
assert_diff_lt_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 2;
assert_diff_lt_x!(a, b, x);
# });
// assertion failed: `assert_diff_lt_x!(a, b, x)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_diff_lt_x.html
//        a label: `a`,
//        a debug: `10`,
//        b label: `b`,
//        b debug: `13`,
//        x label: `x`,
//        x debug: `2`,
//              Δ: `3`,
//          Δ < x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_diff_lt_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_diff_lt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `2`,\n",
#     "       Δ: `3`,\n",
#     "   Δ < x: false",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)
* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)
* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)


```rust
pub macro_rules! assert_diff_lt_x {
    /* macro_rules! assert_diff_lt_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_diff_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is less than an expression.

Pseudocode:<br>
Δ < x

This macro provides the same statements as [`assert_diff_lt_x`](macro.assert_diff_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_diff_lt_x`](macro@crate::assert_diff_lt_x)
* [`assert_diff_lt_x_as_result`](macro@crate::assert_diff_lt_x_as_result)
* [`debug_assert_diff_lt_x`](macro@crate::debug_assert_diff_lt_x)


```rust
pub macro_rules! debug_assert_diff_lt_x {
    /* macro_rules! debug_assert_diff_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_diff_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a difference is not equal to an expression.

Pseudocode:<br>
Δ ≠ x

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)
* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)
* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)


```rust
pub macro_rules! assert_diff_ne_x_as_result {
    /* macro_rules! assert_diff_ne_x_as_result {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_diff_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is not equal to an expression.

Pseudocode:<br>
Δ ≠ x

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 4;
assert_diff_ne_x!(a, b, x);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 13;
let x: i8 = 3;
assert_diff_ne_x!(a, b, x);
# });
// assertion failed: `assert_diff_ne_x!(a, b, x)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_diff_ne_x.html
//        a label: `a`,
//        a debug: `10`,
//        b label: `b`,
//        b debug: `13`,
//        x label: `x`,
//        x debug: `3`,
//              Δ: `3`,
//          Δ ≠ x: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_diff_ne_x!(a, b, x)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_diff_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `10`,\n",
#     " b label: `b`,\n",
#     " b debug: `13`,\n",
#     " x label: `x`,\n",
#     " x debug: `3`,\n",
#     "       Δ: `3`,\n",
#     "   Δ ≠ x: false",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)
* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)
* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)


```rust
pub macro_rules! assert_diff_ne_x {
    /* macro_rules! assert_diff_ne_x {
    ($a:expr, $b:expr, $x:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $x:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_diff_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a difference is not equal to an expression.

Pseudocode:<br>
Δ = x

This macro provides the same statements as [`assert_diff_ne_x`](macro.assert_diff_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_diff_ne_x`](macro@crate::assert_diff_ne_x)
* [`assert_diff_ne_x_as_result`](macro@crate::assert_diff_ne_x_as_result)
* [`debug_assert_diff_ne_x`](macro@crate::debug_assert_diff_ne_x)


```rust
pub macro_rules! debug_assert_diff_ne_x {
    /* macro_rules! debug_assert_diff_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_in_as_result`

**Attributes:**

- `#[macro_export]`

Assert an item is in a container.

Pseudocode:<br>
a is in container

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_in`](macro@crate::assert_in)
* [`assert_in_as_result`](macro@crate::assert_in_as_result)
* [`debug_assert_in`](macro@crate::debug_assert_in)


```rust
pub macro_rules! assert_in_as_result {
    /* macro_rules! assert_in_as_result {
    ($a:expr, $container:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_in`

**Attributes:**

- `#[macro_export]`

Assert an item is in a container.

Pseudocode:<br>
a is in container

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 1;
let b = 0..2;
assert_in!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 1;
let b = 2..4;
assert_in!(a, b);
# });
// assertion failed: `assert_in!(a, container)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_in.html
//  a label: `a`,
//  a debug: `1`,
//  container label: `b`,
//  container debug: `2..4`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_in!(a, container)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_in.html\n",
#     "         a label: `a`,\n",
#     "         a debug: `1`,\n",
#     " container label: `b`,\n",
#     " container debug: `2..4`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_in`](macro@crate::assert_in)
* [`assert_in_as_result`](macro@crate::assert_in_as_result)
* [`debug_assert_in`](macro@crate::debug_assert_in)


```rust
pub macro_rules! assert_in {
    /* macro_rules! assert_in {
    ($a:expr, $container:expr $(,)?) => { ... };
    ($a:expr, $container:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_in`

**Attributes:**

- `#[macro_export]`

Assert an item is in a container.

Pseudocode:<br>
a is in container

This macro provides the same statements as [`assert_in`](macro.assert_in.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_in`](macro@crate::assert_in)
* [`assert_in`](macro@crate::assert_in)
* [`debug_assert_in`](macro@crate::debug_assert_in)


```rust
pub macro_rules! debug_assert_in {
    /* macro_rules! debug_assert_in {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_in_delta_as_result`

**Attributes:**

- `#[macro_export]`

Assert a number is within delta of another.

Pseudocode:<br>
| a - b | ≤ Δ

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro provides the same statements as [`assert_`](macro.assert_.html), except this macro
returns a Result, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters, or
sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_in_delta`](macro@crate::assert_in_delta)
* [`assert_in_delta_as_result`](macro@crate::assert_in_delta_as_result)
* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)


```rust
pub macro_rules! assert_in_delta_as_result {
    /* macro_rules! assert_in_delta_as_result {
    ($a:expr, $b:expr, $delta:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_in_delta`

**Attributes:**

- `#[macro_export]`

Assert a number is within delta of another.

Pseudocode:<br>
| a - b | ≤ Δ

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 11;
let delta: i8 = 1;
assert_in_delta!(a, b, delta);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 12;
let delta: i8 = 1;
assert_in_delta!(a, b, delta);
# });
// assertion failed: `assert_in_delta!(a, b, Δ)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_in_delta.html
//        a label: `a`,
//        a debug: `10`,
//        b label: `b`,
//        b debug: `12`,
//        Δ label: `delta`,
//        Δ debug: `1`,
//      | a - b |: `2`,
//  | a - b | ≤ Δ: false
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_in_delta!(a, b, Δ)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_in_delta.html\n",
#     "       a label: `a`,\n",
#     "       a debug: `10`,\n",
#     "       b label: `b`,\n",
#     "       b debug: `12`,\n",
#     "       Δ label: `delta`,\n",
#     "       Δ debug: `1`,\n",
#     "     | a - b |: `2`,\n",
#     " | a - b | ≤ Δ: false",
# );
# assert_eq!(actual, message);
# }
```

The macros `assert_in_delta` and `assert_in_epsilon` can test
approximations:

* For an approximation, the absolute error (i.e. delta) is the magnitude of
  the difference between the exact value and the approximation. For this,
 use the macro

* For an approximation, the relative error (i.e. epsilon) is the absolute
  error divided by the magnitude of the exact value. This can be used to
  compare approximations of numbers of wildly differing size.

* For example, approximating the number 1,000 with an absolute error of 3
  is, in most applications, much worse than approximating the number
  1,000,000 with an absolute error of 3; in the first case the relative
  error is 0.003 and in the second it is only 0.000003.

* Thanks to Ruby minitest for the example and documentation.

# Module macros

* [`assert_in_delta`](macro@crate::assert_in_delta)
* [`assert_in_delta_as_result`](macro@crate::assert_in_delta_as_result)
* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)


```rust
pub macro_rules! assert_in_delta {
    /* macro_rules! assert_in_delta {
    ($a:expr, $b:expr, $delta:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $delta:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_in_delta`

**Attributes:**

- `#[macro_export]`

Assert a number is within delta of another.

Pseudocode:<br>
| a - b | ≤ Δ

This macro provides the same statements as [`assert_in_delta`](macro.assert_in_delta.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_in_delta`](macro@crate::assert_in_delta)
* [`assert_in_delta`](macro@crate::assert_in_delta)
* [`debug_assert_in_delta`](macro@crate::debug_assert_in_delta)


```rust
pub macro_rules! debug_assert_in_delta {
    /* macro_rules! debug_assert_in_delta {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_in_epsilon_as_result`

**Attributes:**

- `#[macro_export]`

Assert a number is within epsilon of another.

Pseudocode:<br>
| a - b | ≤ ε * min(a, b)

* If true, return Result `Ok((lhs, rhs))`.

* When false, return [`Err`] with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)
* [`assert_in_epsilon_as_result`](macro@crate::assert_in_epsilon_as_result)
* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)


```rust
pub macro_rules! assert_in_epsilon_as_result {
    /* macro_rules! assert_in_epsilon_as_result {
    ($a:expr, $b:expr, $epsilon:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_in_epsilon`

**Attributes:**

- `#[macro_export]`

Assert a number is within epsilon of another.

Pseudocode:<br>
| a - b | ≤ ε * min(a, b)

* If true, return `(lhs, rhs)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 10;
let b: i8 = 20;
let epsilon: i8 = 1;
assert_in_epsilon!(a, b, epsilon);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 30;
let epsilon: i8 = 1;
assert_in_epsilon!(a, b, epsilon);
# });
// assertion failed: `assert_in_epsilon!(a, b, epsilon)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_in_epsilon.html
//                    a label: `a`,
//                    a debug: `10`,
//                    b label: `b`,
//                    b debug: `30`,
//                    ε label: `epsilon`,
//                    ε debug: `1`,
//                  | a - b |: `20`,
//              ε * min(a, b): `10`,\n",
//  | a - b | ≤ ε * min(a, b): false"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_in_epsilon!(a, b, ε)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_in_epsilon.html\n",
#     "                   a label: `a`,\n",
#     "                   a debug: `10`,\n",
#     "                   b label: `b`,\n",
#     "                   b debug: `30`,\n",
#     "                   ε label: `epsilon`,\n",
#     "                   ε debug: `1`,\n",
#     "                 | a - b |: `20`,\n",
#     "             ε * min(a, b): `10`,\n",
#     " | a - b | ≤ ε * min(a, b): false"
# );
# assert_eq!(actual, message);
# }
```

The macros `assert_in_delta` and `assert_in_epsilon` can test
approximations:

* For an approximation, the absolute error (i.e. delta) is the magnitude of
  the difference between the exact value and the approximation. For this,
 use the macro

* For an approximation, the relative error (i.e. epsilon) is the absolute
  error divided by the magnitude of the exact value. This can be used to
  compare approximations of numbers of wildly differing size.

* For example, approximating the number 1,000 with an absolute error of 3
  is, in most applications, much worse than approximating the number
  1,000,000 with an absolute error of 3; in the first case the relative
  error is 0.003 and in the second it is only 0.000003.

* Thanks to Ruby minitest for the example and documentation.

# Module macros

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)
* [`assert_in_epsilon_as_result`](macro@crate::assert_in_epsilon_as_result)
* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)


```rust
pub macro_rules! assert_in_epsilon {
    /* macro_rules! assert_in_epsilon {
    ($a:expr, $b:expr, $epsilon:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $epsilon:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_in_epsilon`

**Attributes:**

- `#[macro_export]`

Assert a number is within epsilon of another.

Pseudocode:<br>
| a - b | ≤ ε * min(a, b)

This macro provides the same statements as [`assert_in_epsilon`](macro.assert_in_epsilon.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)
* [`assert_in_epsilon`](macro@crate::assert_in_epsilon)
* [`debug_assert_in_epsilon`](macro@crate::debug_assert_in_epsilon)


```rust
pub macro_rules! debug_assert_in_epsilon {
    /* macro_rules! debug_assert_in_epsilon {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_in_range_as_result`

**Attributes:**

- `#[macro_export]`

Assert an item is in a range.

Pseudocode:<br>
a is in range

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_in_range`](macro@crate::assert_in_range)
* [`assert_in_range_as_result`](macro@crate::assert_in_range_as_result)
* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)


```rust
pub macro_rules! assert_in_range_as_result {
    /* macro_rules! assert_in_range_as_result {
    ($a:expr, $range:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_in_range`

**Attributes:**

- `#[macro_export]`

Assert an item is in a range.

Pseudocode:<br>
a is in range

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 1;
let b = 0..2;
assert_in_range!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 1;
let b = 2..4;
assert_in_range!(a, b);
# });
// assertion failed: `assert_in_range!(a, range)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_in_range.html
//  a label: `a`,
//  a debug: `1`,
//  range label: `b`,
//  range debug: `2..4`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_in_range!(a, range)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_in_range.html\n",
#     "     a label: `a`,\n",
#     "     a debug: `1`,\n",
#     " range label: `b`,\n",
#     " range debug: `2..4`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_in_range`](macro@crate::assert_in_range)
* [`assert_in_range_as_result`](macro@crate::assert_in_range_as_result)
* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)


```rust
pub macro_rules! assert_in_range {
    /* macro_rules! assert_in_range {
    ($a:expr, $range:expr $(,)?) => { ... };
    ($a:expr, $range:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_in_range`

**Attributes:**

- `#[macro_export]`

Assert an item is in a range.

Pseudocode:<br>
a is in range

This macro provides the same statements as [`assert_in_range`](macro.assert_in_range.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_in_range`](macro@crate::assert_in_range)
* [`assert_in_range`](macro@crate::assert_in_range)
* [`debug_assert_in_range`](macro@crate::debug_assert_in_range)


```rust
pub macro_rules! debug_assert_in_range {
    /* macro_rules! debug_assert_in_range {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_all_as_result`

**Attributes:**

- `#[macro_export]`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_all`](macro@crate::assert_all)
* [`assert_all_as_result`](macro@crate::assert_all_as_result)
* [`debug_assert_all`](macro@crate::debug_assert_all)


```rust
pub macro_rules! assert_all_as_result {
    /* macro_rules! assert_all_as_result {
    ($collection:expr, $predicate:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_all`

**Attributes:**

- `#[macro_export]`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2, 3];
assert_all!(a.into_iter(), |x: i8| x > 0);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, -2, 3];
assert_all!(a.into_iter(), |x: i8| x > 0);
# });
// assertion failed: `assert_all!(collection, predicate)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_all.html
//  collection label: `a.into_iter()`,
//  collection debug: `IntoIter([1, -2, 3])`,
//         predicate: `|x: i8| x > 0`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_all!(collection, predicate)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_all.html\n",
#     " collection label: `a.into_iter()`,\n",
#     " collection debug: `IntoIter([1, -2, 3])`,\n",
#     "        predicate: `|x: i8| x > 0`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_all`](macro@crate::assert_all)
* [`assert_all_as_result`](macro@crate::assert_all_as_result)
* [`debug_assert_all`](macro@crate::debug_assert_all)


```rust
pub macro_rules! assert_all {
    /* macro_rules! assert_all {
    ($collection:expr, $predicate:expr $(,)?) => { ... };
    ($collection:expr, $predicate:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_all`

**Attributes:**

- `#[macro_export]`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

This macro provides the same statements as [`assert_all`](macro.assert_all.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_all`](macro@crate::assert_all)
* [`assert_all`](macro@crate::assert_all)
* [`debug_assert_all`](macro@crate::debug_assert_all)


```rust
pub macro_rules! debug_assert_all {
    /* macro_rules! debug_assert_all {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_any_as_result`

**Attributes:**

- `#[macro_export]`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_any`](macro@crate::assert_any)
* [`assert_any_as_result`](macro@crate::assert_any_as_result)
* [`debug_assert_any`](macro@crate::debug_assert_any)


```rust
pub macro_rules! assert_any_as_result {
    /* macro_rules! assert_any_as_result {
    ($collection:expr, $predicate:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_any`

**Attributes:**

- `#[macro_export]`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2, 3];
assert_any!(a.into_iter(), |x: i8| x > 0);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2, 3];
assert_any!(a.into_iter(), |x: i8| x > 3);
# });
// assertion failed: `assert_any!(collection, predicate)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_any.html
//  collection label: `a.into_iter()`,
//  collection debug: `IntoIter([1, 2, 3])`,
//         predicate: `|x: i8| x > 3`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_any!(collection, predicate)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_any.html\n",
#     " collection label: `a.into_iter()`,\n",
#     " collection debug: `IntoIter([1, 2, 3])`,\n",
#     "        predicate: `|x: i8| x > 3`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_any`](macro@crate::assert_any)
* [`assert_any_as_result`](macro@crate::assert_any_as_result)
* [`debug_assert_any`](macro@crate::debug_assert_any)


```rust
pub macro_rules! assert_any {
    /* macro_rules! assert_any {
    ($collection:expr, $predicate:expr $(,)?) => { ... };
    ($collection:expr, $predicate:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_any`

**Attributes:**

- `#[macro_export]`

Assert every element of the iterator matches a predicate.

Pseudocode:<br>
collection into iter ∀ predicate

This macro provides the same statements as [`assert_any`](macro.assert_any.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_any`](macro@crate::assert_any)
* [`assert_any`](macro@crate::assert_any)
* [`debug_assert_any`](macro@crate::debug_assert_any)


```rust
pub macro_rules! debug_assert_any {
    /* macro_rules! debug_assert_any {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_infix_as_result`

**Attributes:**

- `#[macro_export]`

Assert a infix operator, such as assert_infix!(a == b).

Pseudocode:<br>
a infix b

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_infix`](macro@crate::assert_infix)
* [`assert_infix_as_result`](macro@crate::assert_infix_as_result)
* [`debug_assert_infix`](macro@crate::debug_assert_infix)


```rust
pub macro_rules! assert_infix_as_result {
    /* macro_rules! assert_infix_as_result {
    ($a:tt $infix:tt $b:tt) => { ... };
} */
}
```

### Macro `assert_infix`

**Attributes:**

- `#[macro_export]`

Assert a infix operator, such as assert_infix!(a == b).

Pseudocode:<br>
a infix b

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 1;
let b = 1;
assert_infix!(a == b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = 1;
let b = 2;
assert_infix!(a == b);
# });
// assertion failed: `assert_infix!(a == b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_infix.html
//  a label: `a`,
//  a debug: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_infix!(a == b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_infix.html\n",
#     " a label: `a`,\n",
#     " a debug: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Infix operators

For values:

* `==`  equal
* `!=`  not equal
* `<`	less than
* `<=`	less than or equal to
* `>`	greater than
* `>=`	greater than or equal to

For booleans:

* `^`	logical XOR
* `!`	logical NOT
* `&`	logical AND
* `|`	logical OR
* `&&`	logical lazy AND
* `||`	logical lazy OR

# Module macros

* [`assert_infix`](macro@crate::assert_infix)
* [`assert_infix_as_result`](macro@crate::assert_infix_as_result)
* [`debug_assert_infix`](macro@crate::debug_assert_infix)


```rust
pub macro_rules! assert_infix {
    /* macro_rules! assert_infix {
    ($a:tt $infix:tt $b:tt) => { ... };
    ($a:tt $infix:tt $b:tt, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_infix`

**Attributes:**

- `#[macro_export]`

Assert a infix operator, such as assert_infix!(a == b).

Pseudocode:<br>
a infix b

This macro provides the same statements as [`assert_infix`](macro.assert_infix.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_infix`](macro@crate::assert_infix)
* [`assert_infix`](macro@crate::assert_infix)
* [`debug_assert_infix`](macro@crate::debug_assert_infix)


```rust
pub macro_rules! debug_assert_infix {
    /* macro_rules! debug_assert_infix {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) contains an expression (such as a substring).

Pseudocode:<br>
a.contains(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_contains`](macro@crate::assert_contains)
* [`assert_contains_as_result`](macro@crate::assert_contains_as_result)
* [`debug_assert_contains`](macro@crate::debug_assert_contains)


```rust
pub macro_rules! assert_contains_as_result {
    /* macro_rules! assert_contains_as_result {
    ($container:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_contains`

**Attributes:**

- `#[macro_export]`

Assert a container is a match for an expression.

Pseudocode:<br>
a.contains(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::collections::HashSet;
# use std::panic;

# fn main() {
// String contains a substring
let a = "alfa";
let b = "lf";
assert_contains!(a, b);

// Range contains a value
let a = 1..3;
let b = 2;
assert_contains!(a, &b);

// Vector contains element
let a = vec![1, 2, 3];
let b = 2;
assert_contains!(a, &b);

// HashSet contains element.
// Notice the &b because the macro calls HashSet.contains(&self, &value).
let a: HashSet<String> = [String::from("1")].into();
let b: String = String::from("1");
assert_contains!(a, &b);

// HashSet contains element with automatic borrow optimization.
// Notice the b because the value type &str is already a reference,
// which HashSet.contains knows how to borrow to compare to String.
let a: HashSet<String> = [String::from("1")].into();
let b = "1";
assert_contains!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa";
let b = "xx";
assert_contains!(a, b);
# });
// assertion failed: `assert_contains!(container, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_contains.html
//  container label: `a`,
//  container debug: `\"alfa\"`,
//  containee label: `b`,
//  containee debug: `\"xx\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_contains!(container, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_contains.html\n",
#     " container label: `a`,\n",
#     " container debug: `\"alfa\"`,\n",
#     " containee label: `b`,\n",
#     " containee debug: `\"xx\"`"
# );
# assert_eq!(actual, message);
# }
```

* [`assert_contains`](macro@crate::assert_contains)
* [`assert_contains_as_result`](macro@crate::assert_contains_as_result)
* [`debug_assert_contains`](macro@crate::debug_assert_contains)


```rust
pub macro_rules! assert_contains {
    /* macro_rules! assert_contains {
    ($container:expr, $containee:expr $(,)?) => { ... };
    ($container:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_contains`

**Attributes:**

- `#[macro_export]`

Assert a container is a match for an expression.

Pseudocode:<br>
a.contains(b)

This macro provides the same statements as [`assert_contains`](macro.assert_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_contains`](macro@crate::assert_contains)
* [`assert_contains`](macro@crate::assert_contains)
* [`debug_assert_contains`](macro@crate::debug_assert_contains)


```rust
pub macro_rules! debug_assert_contains {
    /* macro_rules! debug_assert_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not contain an expression (such as a substring).

Pseudocode:<br>
¬ a.contains(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_contains`](macro@crate::assert_not_contains)
* [`assert_not_contains_as_result`](macro@crate::assert_not_contains_as_result)
* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)


```rust
pub macro_rules! assert_not_contains_as_result {
    /* macro_rules! assert_not_contains_as_result {
    ($container:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_not_contains`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not contain an expression (such as a substring).

Pseudocode:<br>
¬ a.contains(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::collections::HashSet;
# use std::panic;

# fn main() {
// String contains substring
let a = "alfa";
let b = "zz";
assert_not_contains!(a, b);

// Range contains value
let a = 1..3;
let b = 4;
assert_not_contains!(a, &b);

// Vector contains element
let a = vec![1, 2, 3];
let b = 4;
assert_not_contains!(a, &b);

// HashSet does not contain element.
// Notice the &b because the macro calls HashSet.contains(&self, &value).
let a: HashSet<String> = [String::from("1")].into();
let b: String = String::from("2");
assert_not_contains!(a, &b);

// HashSet does not contain element with automatic borrow optimization.
// Notice the b because the value type &str is already a reference,
// which HashSet.contains knows how to borrow to compare to String.
let a: HashSet<String> = [String::from("1")].into();
let b = "2";
assert_not_contains!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa";
let b = "lf";
assert_not_contains!(a, b);
# });
// assertion failed: `assert_not_contains!(container, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_contains.html
//  container label: `a`,
//  container debug: `\"alfa\"`,
//  containee label: `b`,
//  containee debug: `\"lf\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_contains!(container, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_contains.html\n",
#     " container label: `a`,\n",
#     " container debug: `\"alfa\"`,\n",
#     " containee label: `b`,\n",
#     " containee debug: `\"lf\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_contains`](macro@crate::assert_not_contains)
* [`assert_not_contains_as_result`](macro@crate::assert_not_contains_as_result)
* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)


```rust
pub macro_rules! assert_not_contains {
    /* macro_rules! assert_not_contains {
    ($container:expr, $containee:expr $(,)?) => { ... };
    ($container:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_contains`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not contain an expression (such as a substring).

Pseudocode:<br>
¬ a.contains(b)

This macro provides the same statements as [`assert_not_contains`](macro.assert_not_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_contains`](macro@crate::assert_not_contains)
* [`assert_not_contains`](macro@crate::assert_not_contains)
* [`debug_assert_not_contains`](macro@crate::debug_assert_not_contains)


```rust
pub macro_rules! debug_assert_not_contains {
    /* macro_rules! debug_assert_not_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is equal to another.

Pseudocode:<br>
a.count() = b.count()

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_eq`](macro@crate::assert_count_eq)
* [`assert_count_eq_as_result`](macro@crate::assert_count_eq_as_result)
* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)


```rust
pub macro_rules! assert_count_eq_as_result {
    /* macro_rules! assert_count_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_eq`

**Attributes:**

- `#[macro_export]`

Assert a count is equal to another.

Pseudocode:<br>
a.count() = b.count()

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = "x".chars();
assert_count_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = "xx".chars();
assert_count_eq!(a, b);
# });
// assertion failed: `assert_count_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_eq.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `Chars(['x', 'x'])`,
//  b.count(): `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Chars(['x', 'x'])`\n",
#     " b.count(): `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_eq`](macro@crate::assert_count_eq)
* [`assert_count_eq_as_result`](macro@crate::assert_count_eq_as_result)
* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)


```rust
pub macro_rules! assert_count_eq {
    /* macro_rules! assert_count_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_eq`

**Attributes:**

- `#[macro_export]`

Assert a count is equal to another.

Pseudocode:<br>
a.count() = b.count()

This macro provides the same statements as [`assert_count_eq`](macro.assert_count_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_eq`](macro@crate::assert_count_eq)
* [`assert_count_eq`](macro@crate::assert_count_eq)
* [`debug_assert_count_eq`](macro@crate::debug_assert_count_eq)


```rust
pub macro_rules! debug_assert_count_eq {
    /* macro_rules! debug_assert_count_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than or equal to another.

Pseudocode:<br>
a.count() ≥ b.count()

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_ge`](macro@crate::assert_count_ge)
* [`assert_count_ge_as_result`](macro@crate::assert_count_ge_as_result)
* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)


```rust
pub macro_rules! assert_count_ge_as_result {
    /* macro_rules! assert_count_ge_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_ge`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than or equal to another.

Pseudocode:<br>
a.count() ≥ b.count()

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx".chars();
let b = "x".chars();
assert_count_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = "xx".chars();
assert_count_ge!(a, b);
# });
// assertion failed: `assert_count_ge!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_ge.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `Chars(['x', 'x'])`,
//  b.count(): `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_ge!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Chars(['x', 'x'])`\n",
#     " b.count(): `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_ge`](macro@crate::assert_count_ge)
* [`assert_count_ge_as_result`](macro@crate::assert_count_ge_as_result)
* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)


```rust
pub macro_rules! assert_count_ge {
    /* macro_rules! assert_count_ge {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_ge`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than or equal to another.

Pseudocode:<br>
a.count() ≥ b.count()

This macro provides the same statements as [`assert_count_ge`](macro.assert_count_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_ge`](macro@crate::assert_count_ge)
* [`assert_count_ge`](macro@crate::assert_count_ge)
* [`debug_assert_count_ge`](macro@crate::debug_assert_count_ge)


```rust
pub macro_rules! debug_assert_count_ge {
    /* macro_rules! debug_assert_count_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than another.

Pseudocode:<br>
a.count() > b.count()

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_gt`](macro@crate::assert_count_gt)
* [`assert_count_gt_as_result`](macro@crate::assert_count_gt_as_result)
* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)


```rust
pub macro_rules! assert_count_gt_as_result {
    /* macro_rules! assert_count_gt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_gt`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than another.

Pseudocode:<br>
a.count() > b.count()

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx".chars();
let b = "x".chars();
assert_count_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = "xx".chars();
assert_count_gt!(a, b);
# });
// assertion failed: `assert_count_gt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_gt.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `Chars(['x', 'x'])`,
//  b.count(): `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_gt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Chars(['x', 'x'])`\n",
#     " b.count(): `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_gt`](macro@crate::assert_count_gt)
* [`assert_count_gt_as_result`](macro@crate::assert_count_gt_as_result)
* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)


```rust
pub macro_rules! assert_count_gt {
    /* macro_rules! assert_count_gt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_gt`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than another.

Pseudocode:<br>
a.count() > b.count()

This macro provides the same statements as [`assert_count_gt`](macro.assert_count_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_gt`](macro@crate::assert_count_gt)
* [`assert_count_gt`](macro@crate::assert_count_gt)
* [`debug_assert_count_gt`](macro@crate::debug_assert_count_gt)


```rust
pub macro_rules! debug_assert_count_gt {
    /* macro_rules! debug_assert_count_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is less than or equal to another.

Pseudocode:<br>
a.count() ≤ b.count()

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_le`](macro@crate::assert_count_le)
* [`assert_count_le_as_result`](macro@crate::assert_count_le_as_result)
* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)


```rust
pub macro_rules! assert_count_le_as_result {
    /* macro_rules! assert_count_le_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_le`

**Attributes:**

- `#[macro_export]`

Assert a count is less than or equal to another.

Pseudocode:<br>
a.count() ≤ b.count()

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = "xx".chars();
assert_count_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx".chars();
let b = "x".chars();
assert_count_le!(a, b);
# });
// assertion failed: `assert_count_le!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_le.html
//  a label: `a`,
//  a debug: `Chars(['x', 'x'])`,
//  a.count(): `2`",
//  b label: `b`,
//  b debug: `Chars(['x'])`,
//  b.count(): `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_le!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x', 'x'])`,\n",
#     " a.count(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `Chars(['x'])`\n",
#     " b.count(): `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_le`](macro@crate::assert_count_le)
* [`assert_count_le_as_result`](macro@crate::assert_count_le_as_result)
* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)


```rust
pub macro_rules! assert_count_le {
    /* macro_rules! assert_count_le {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_le`

**Attributes:**

- `#[macro_export]`

Assert a count is less than or equal to another.

Pseudocode:<br>
a.count() ≤ b.count()

This macro provides the same statements as [`assert_count_le`](macro.assert_count_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_le`](macro@crate::assert_count_le)
* [`assert_count_le`](macro@crate::assert_count_le)
* [`debug_assert_count_le`](macro@crate::debug_assert_count_le)


```rust
pub macro_rules! debug_assert_count_le {
    /* macro_rules! debug_assert_count_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is less than another.

Pseudocode:<br>
a.count() < b.count()

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_lt`](macro@crate::assert_count_lt)
* [`assert_count_lt_as_result`](macro@crate::assert_count_lt_as_result)
* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)


```rust
pub macro_rules! assert_count_lt_as_result {
    /* macro_rules! assert_count_lt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_lt`

**Attributes:**

- `#[macro_export]`

Assert a count is less than another.

Pseudocode:<br>
a.count() < b.count()

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = "xx".chars();
assert_count_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx".chars();
let b = "x".chars();
assert_count_lt!(a, b);
# });
// assertion failed: `assert_count_lt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_lt.html
//  a label: `a`,
//  a debug: `Chars(['x', 'x'])`,
//  a.count(): `2`",
//  b label: `b`,
//  b debug: `Chars(['x'])`,
//  b.count(): `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_lt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x', 'x'])`,\n",
#     " a.count(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `Chars(['x'])`\n",
#     " b.count(): `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_lt`](macro@crate::assert_count_lt)
* [`assert_count_lt_as_result`](macro@crate::assert_count_lt_as_result)
* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)


```rust
pub macro_rules! assert_count_lt {
    /* macro_rules! assert_count_lt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_lt`

**Attributes:**

- `#[macro_export]`

Assert a count is less than another.

Pseudocode:<br>
a.count() < b.count()

This macro provides the same statements as [`assert_count_lt`](macro.assert_count_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_lt`](macro@crate::assert_count_lt)
* [`assert_count_lt`](macro@crate::assert_count_lt)
* [`debug_assert_count_lt`](macro@crate::debug_assert_count_lt)


```rust
pub macro_rules! debug_assert_count_lt {
    /* macro_rules! debug_assert_count_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is not equal to another.

Pseudocode:<br>
a.count() ≠ b.count()

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_ne`](macro@crate::assert_count_ne)
* [`assert_count_ne_as_result`](macro@crate::assert_count_ne_as_result)
* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)


```rust
pub macro_rules! assert_count_ne_as_result {
    /* macro_rules! assert_count_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_ne`

**Attributes:**

- `#[macro_export]`

Assert a count is not equal to another.

Pseudocode:<br>
a.count() ≠ b.count()

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = "xx".chars();
assert_count_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = "x".chars();
assert_count_ne!(a, b);
# });
// assertion failed: `assert_count_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_ne.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `Chars(['x'])`,
//  b.count(): `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Chars(['x'])`\n",
#     " b.count(): `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_ne`](macro@crate::assert_count_ne)
* [`assert_count_ne_as_result`](macro@crate::assert_count_ne_as_result)
* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)


```rust
pub macro_rules! assert_count_ne {
    /* macro_rules! assert_count_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_ne`

**Attributes:**

- `#[macro_export]`

Assert a count is not equal to another.

Pseudocode:<br>
a.count() ≠ b.count()

This macro provides the same statements as [`assert_count_ne`](macro.assert_count_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_ne`](macro@crate::assert_count_ne)
* [`assert_count_ne`](macro@crate::assert_count_ne)
* [`debug_assert_count_ne`](macro@crate::debug_assert_count_ne)


```rust
pub macro_rules! debug_assert_count_ne {
    /* macro_rules! debug_assert_count_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is equal to an expression.

Pseudocode:<br>
a.count() = b

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)
* [`assert_count_eq_x_as_result`](macro@crate::assert_count_eq_x_as_result)
* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)


```rust
pub macro_rules! assert_count_eq_x_as_result {
    /* macro_rules! assert_count_eq_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a count is equal to an expression.

Pseudocode:<br>
a.count() = b

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = 1;
assert_count_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = 2;
assert_count_eq_x!(a, b);
# });
// assertion failed: `assert_count_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_eq_x.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)
* [`assert_count_eq_x_as_result`](macro@crate::assert_count_eq_x_as_result)
* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)


```rust
pub macro_rules! assert_count_eq_x {
    /* macro_rules! assert_count_eq_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a count is equal to an expression.

Pseudocode:<br>
a.count() = b

This macro provides the same statements as [`assert_count_eq_x`](macro.assert_count_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)
* [`assert_count_eq_x`](macro@crate::assert_count_eq_x)
* [`debug_assert_count_eq_x`](macro@crate::debug_assert_count_eq_x)


```rust
pub macro_rules! debug_assert_count_eq_x {
    /* macro_rules! debug_assert_count_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than or equal to an expression.

Pseudocode:<br>
a.count() ≥ b

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)
* [`assert_count_ge_x_as_result`](macro@crate::assert_count_ge_x_as_result)
* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)


```rust
pub macro_rules! assert_count_ge_x_as_result {
    /* macro_rules! assert_count_ge_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than or equal to an expression.

Pseudocode:<br>
a.count() ≥ b

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx".chars();
let b = 1;
assert_count_ge_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = 2;
assert_count_ge_x!(a, b);
# });
// assertion failed: `assert_count_ge_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_ge_x.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_ge_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_ge_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)
* [`assert_count_ge_x_as_result`](macro@crate::assert_count_ge_x_as_result)
* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)


```rust
pub macro_rules! assert_count_ge_x {
    /* macro_rules! assert_count_ge_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than or equal to an expression.

Pseudocode:<br>
a.count() ≥ b

This macro provides the same statements as [`assert_count_ge_x`](macro.assert_count_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)
* [`assert_count_ge_x`](macro@crate::assert_count_ge_x)
* [`debug_assert_count_ge_x`](macro@crate::debug_assert_count_ge_x)


```rust
pub macro_rules! debug_assert_count_ge_x {
    /* macro_rules! debug_assert_count_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than an expression.

Pseudocode:<br>
a.count() > b

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)
* [`assert_count_gt_x_as_result`](macro@crate::assert_count_gt_x_as_result)
* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)


```rust
pub macro_rules! assert_count_gt_x_as_result {
    /* macro_rules! assert_count_gt_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than an expression.

Pseudocode:<br>
a.count() > b

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx".chars();
let b = 1;
assert_count_gt_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = 2;
assert_count_gt_x!(a, b);
# });
// assertion failed: `assert_count_gt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_gt_x.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_gt_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_gt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)
* [`assert_count_gt_x_as_result`](macro@crate::assert_count_gt_x_as_result)
* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)


```rust
pub macro_rules! assert_count_gt_x {
    /* macro_rules! assert_count_gt_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a count is greater than an expression.

Pseudocode:<br>
a.count() > b

This macro provides the same statements as [`assert_count_gt_x`](macro.assert_count_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)
* [`assert_count_gt_x`](macro@crate::assert_count_gt_x)
* [`debug_assert_count_gt_x`](macro@crate::debug_assert_count_gt_x)


```rust
pub macro_rules! debug_assert_count_gt_x {
    /* macro_rules! debug_assert_count_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is less than or equal to an expression.

Pseudocode:<br>
a.count() ≤ b

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_le_x`](macro@crate::assert_count_le_x)
* [`assert_count_le_x_as_result`](macro@crate::assert_count_le_x_as_result)
* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)


```rust
pub macro_rules! assert_count_le_x_as_result {
    /* macro_rules! assert_count_le_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_le_x`

**Attributes:**

- `#[macro_export]`

Assert a count is less than or equal to an expression.

Pseudocode:<br>
a.count() ≤ b

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = 2;
assert_count_le_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx".chars();
let b = 1;
assert_count_le_x!(a, b);
# });
// assertion failed: `assert_count_le_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_le_x.html
//  a label: `a`,
//  a debug: `Chars(['x', 'x'])`,
//  a.count(): `2`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_le_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_le_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x', 'x'])`,\n",
#     " a.count(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_le_x`](macro@crate::assert_count_le_x)
* [`assert_count_le_x_as_result`](macro@crate::assert_count_le_x_as_result)
* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)


```rust
pub macro_rules! assert_count_le_x {
    /* macro_rules! assert_count_le_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_le_x`

**Attributes:**

- `#[macro_export]`

Assert a count is less than or equal to an expression.

Pseudocode:<br>
a.count() ≤ b

This macro provides the same statements as [`assert_count_le_x`](macro.assert_count_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_le_x`](macro@crate::assert_count_le_x)
* [`assert_count_le_x`](macro@crate::assert_count_le_x)
* [`debug_assert_count_le_x`](macro@crate::debug_assert_count_le_x)


```rust
pub macro_rules! debug_assert_count_le_x {
    /* macro_rules! debug_assert_count_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is less than an expression.

Pseudocode:<br>
a.count() < b

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)
* [`assert_count_lt_x_as_result`](macro@crate::assert_count_lt_x_as_result)
* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)


```rust
pub macro_rules! assert_count_lt_x_as_result {
    /* macro_rules! assert_count_lt_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a count is less than an expression.

Pseudocode:<br>
a.count() < b

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = 2;
assert_count_lt_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx".chars();
let b = 1;
assert_count_lt_x!(a, b);
# });
// assertion failed: `assert_count_lt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_lt_x.html
//  a label: `a`,
//  a debug: `Chars(['x', 'x'])`,
//  a.count(): `2`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_lt_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_lt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x', 'x'])`,\n",
#     " a.count(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)
* [`assert_count_lt_x_as_result`](macro@crate::assert_count_lt_x_as_result)
* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)


```rust
pub macro_rules! assert_count_lt_x {
    /* macro_rules! assert_count_lt_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a count is less than an expression.

Pseudocode:<br>
a.count() < b

This macro provides the same statements as [`assert_count_lt_x`](macro.assert_count_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)
* [`assert_count_lt_x`](macro@crate::assert_count_lt_x)
* [`debug_assert_count_lt_x`](macro@crate::debug_assert_count_lt_x)


```rust
pub macro_rules! debug_assert_count_lt_x {
    /* macro_rules! debug_assert_count_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_count_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a count is not equal to an expression.

Pseudocode:<br>
a.count() ≠ b

* If true, return Result `Ok((a.count(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)
* [`assert_count_ne_x_as_result`](macro@crate::assert_count_ne_x_as_result)
* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)


```rust
pub macro_rules! assert_count_ne_x_as_result {
    /* macro_rules! assert_count_ne_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_count_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a count is not equal to an expression.

Pseudocode:<br>
a.count() ≠ b

* If true, return `(a.count(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x".chars();
let b = 2;
assert_count_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x".chars();
let b = 1;
assert_count_ne_x!(a, b);
# });
// assertion failed: `assert_count_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_count_ne_x.html
//  a label: `a`,
//  a debug: `Chars(['x'])`,
//  a.count(): `1`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_count_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_count_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Chars(['x'])`,\n",
#     " a.count(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)
* [`assert_count_ne_x_as_result`](macro@crate::assert_count_ne_x_as_result)
* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)


```rust
pub macro_rules! assert_count_ne_x {
    /* macro_rules! assert_count_ne_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_count_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a count is not equal to an expression.

Pseudocode:<br>
a.count() ≠ b

This macro provides the same statements as [`assert_count_ne_x`](macro.assert_count_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)
* [`assert_count_ne_x`](macro@crate::assert_count_ne_x)
* [`debug_assert_count_ne_x`](macro@crate::debug_assert_count_ne_x)


```rust
pub macro_rules! debug_assert_count_ne_x {
    /* macro_rules! debug_assert_count_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_email_address_as_result`

**Attributes:**

- `#[macro_export]`

Assert expression is possibly an email address.

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_email_address`](macro@crate::assert_email_address)
* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)
* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)


```rust
pub macro_rules! assert_email_address_as_result {
    /* macro_rules! assert_email_address_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_email_address`

**Attributes:**

- `#[macro_export]`

Assert expression is possibly an email address.

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "hello@example.com";
assert_email_address!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "hello*example.com";
assert_email_address!(a);
# });
// assertion failed: `assert_email_address!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_email_address.html
//  Email address must contain an '@' at sign.
//  a label: `a`,
//  a debug: `\"hello*example.com\"`,
//  a: `hello*example.com`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_email_address!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_email_address.html\n",
#     " email address must contain an '@' at sign.\n",
#     " a label: `a`,\n",
#     " a debug: `\"hello*example.com\"`,\n",
#     " a: `hello*example.com`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_email_address`](macro@crate::assert_email_address)
* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)
* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)


```rust
pub macro_rules! assert_email_address {
    /* macro_rules! assert_email_address {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_email_address`

**Attributes:**

- `#[macro_export]`

Assert expression is possibly an email address.

This macro provides the same statements as [`assert_email_address`](macro.assert_email_address.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_email_address`](macro@crate::assert_email_address)
* [`assert_email_address_as_result`](macro@crate::assert_email_address_as_result)
* [`debug_assert_email_address`](macro@crate::debug_assert_email_address)


```rust
pub macro_rules! debug_assert_email_address {
    /* macro_rules! debug_assert_email_address {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_email_address_as_result`

**Attributes:**

- `#[macro_export]`

Assert expression is possibly not an email address.

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_email_address`](macro@crate::assert_not_email_address)
* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)
* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)


```rust
pub macro_rules! assert_not_email_address_as_result {
    /* macro_rules! assert_not_email_address_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_not_email_address`

**Attributes:**

- `#[macro_export]`

Assert expression is possibly not an email address.

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "hello*example.com";
assert_not_email_address!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "hello@example.com";
assert_not_email_address!(a);
# });
// assertion failed: `assert_not_email_address!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_email_address.html
//  Email address has local part with valid length 1..64, then an '@' sign, then a domain part with valid length 1..255.
//  a label: `a`,
//  a debug: `\"hello@example.com\"`,
//  a: `hello@example.com`,
//  local part length: 5,
//  domain part length: 11",
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_email_address!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_email_address.html\n",
#     " email address has local part with valid length 1..64, then an '@' sign, then a domain part with valid length 1..255.\n",
#     " a label: `a`,\n",
#     " a debug: `\"hello@example.com\"`,\n",
#     " a: `hello@example.com`,\n",
#     " local part length: 5,\n",
#     " domain part length: 11",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_email_address`](macro@crate::assert_not_email_address)
* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)
* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)


```rust
pub macro_rules! assert_not_email_address {
    /* macro_rules! assert_not_email_address {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_email_address`

**Attributes:**

- `#[macro_export]`

Assert expression is possibly not an email address.

This macro provides the same statements as [`assert_not_email_address`](macro.assert_not_email_address.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_email_address`](macro@crate::assert_not_email_address)
* [`assert_not_email_address_as_result`](macro@crate::assert_not_email_address_as_result)
* [`debug_assert_not_email_address`](macro@crate::debug_assert_not_email_address)


```rust
pub macro_rules! debug_assert_not_email_address {
    /* macro_rules! debug_assert_not_email_address {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ends_with_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) ends with an expression (such as a substring).

Pseudocode:<br>
a.ends_with(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ends_with`](macro@crate::assert_ends_with)
* [`assert_ends_with_as_result`](macro@crate::assert_ends_with_as_result)
* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)


```rust
pub macro_rules! assert_ends_with_as_result {
    /* macro_rules! assert_ends_with_as_result {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ends_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) ends with an expression (such as a string).

Pseudocode:<br>
a.ends_with(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
// String ends with substring?
let sequence: &str = "alfa";
let subsequence: &str = "fa";
assert_ends_with!(sequence, subsequence);

// Vector ends with element?
let sequence = vec![1, 2, 3];
let subsequence = [3];
assert_ends_with!(sequence, subsequence);

# let result = panic::catch_unwind(|| {
// This will panic
let sequence = "alfa";
let subsequence = "al";
assert_ends_with!(sequence, subsequence);
# });
// assertion failed: `assert_ends_with!(sequence, subsequence)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ends_with.html
//  sequence label: `sequence`,
//  sequence debug: `\"alfa\"`,
//   part label: `subsequence`,
//   part debug: `\"al\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ends_with!(sequence, subsequence)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ends_with.html\n",
#     "     sequence label: `sequence`,\n",
#     "     sequence debug: `\"alfa\"`,\n",
#     "  subsequence label: `subsequence`,\n",
#     "  subsequence debug: `\"al\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ends_with`](macro@crate::assert_ends_with)
* [`assert_ends_with_as_result`](macro@crate::assert_ends_with_as_result)
* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)


```rust
pub macro_rules! assert_ends_with {
    /* macro_rules! assert_ends_with {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ends_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) ends with an expression (such as a string).

Pseudocode:<br>
a.ends_with(b)

This macro provides the same statements as [`assert_ends_with`](macro.assert_ends_with.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ends_with`](macro@crate::assert_ends_with)
* [`assert_ends_with`](macro@crate::assert_ends_with)
* [`debug_assert_ends_with`](macro@crate::debug_assert_ends_with)


```rust
pub macro_rules! debug_assert_ends_with {
    /* macro_rules! debug_assert_ends_with {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_ends_with_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not end with an expression (such as a substring).

Pseudocode:<br>
¬ a.ends_with(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)
* [`assert_not_ends_with_as_result`](macro@crate::assert_not_ends_with_as_result)
* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)


```rust
pub macro_rules! assert_not_ends_with_as_result {
    /* macro_rules! assert_not_ends_with_as_result {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_not_ends_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not end with an expression (such as a string).

Pseudocode:<br>
¬ a.ends_with(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
// String ends with substring?
let sequence: &str = "alfa";
let subsequence: &str = "al";
assert_not_ends_with!(sequence, subsequence);

// Vector ends with element?
let sequence = vec![1, 2, 3];
let subsequence = [1];
assert_not_ends_with!(sequence, subsequence);

# let result = panic::catch_unwind(|| {
// This will panic
let sequence = "alfa";
let subsequence = "fa";
assert_not_ends_with!(sequence, subsequence);
# });
// assertion failed: `assert_not_ends_with!(sequence, subsequence)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_ends_with.html
//  sequence label: `sequence`,
//  sequence debug: `\"alfa\"`,
//   part label: `subsequence`,
//   part debug: `\"fa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_ends_with!(sequence, subsequence)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_ends_with.html\n",
#     "     sequence label: `sequence`,\n",
#     "     sequence debug: `\"alfa\"`,\n",
#     "  subsequence label: `subsequence`,\n",
#     "  subsequence debug: `\"fa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)
* [`assert_not_ends_with_as_result`](macro@crate::assert_not_ends_with_as_result)
* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)


```rust
pub macro_rules! assert_not_ends_with {
    /* macro_rules! assert_not_ends_with {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_ends_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not end with an expression (such as a string).

Pseudocode:<br>
¬ a.ends_with(b)

This macro provides the same statements as [`assert_not_ends_with`](macro.assert_not_ends_with.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)
* [`assert_not_ends_with`](macro@crate::assert_not_ends_with)
* [`debug_assert_not_ends_with`](macro@crate::debug_assert_not_ends_with)


```rust
pub macro_rules! debug_assert_not_ends_with {
    /* macro_rules! debug_assert_not_ends_with {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_is_empty_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a regex) is a match for an expression (such as a string).

Pseudocode:<br>
a.is_empty()

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_is_empty`](macro@crate::assert_is_empty)
* [`assert_is_empty_as_result`](macro@crate::assert_is_empty_as_result)
* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)


```rust
pub macro_rules! assert_is_empty_as_result {
    /* macro_rules! assert_is_empty_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_is_empty`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string or array) is empty.

Pseudocode:<br>
a.is_empty()

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "";
assert_is_empty!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa";
assert_is_empty!(a);
# });
// assertion failed: `assert_is_empty!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_is_empty.html
//  label: `a`,
//  debug: `\"alfa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_is_empty!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_is_empty.html\n",
#     " label: `a`,\n",
#     " debug: `\"alfa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_is_empty`](macro@crate::assert_is_empty)
* [`assert_is_empty_as_result`](macro@crate::assert_is_empty_as_result)
* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)


```rust
pub macro_rules! assert_is_empty {
    /* macro_rules! assert_is_empty {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_is_empty`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string or array) is empty.

Pseudocode:<br>
a.is_empty()

This macro provides the same statements as [`assert_is_empty`](macro.assert_is_empty.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_is_empty`](macro@crate::assert_is_empty)
* [`assert_is_empty`](macro@crate::assert_is_empty)
* [`debug_assert_is_empty`](macro@crate::debug_assert_is_empty)


```rust
pub macro_rules! debug_assert_is_empty {
    /* macro_rules! debug_assert_is_empty {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_empty_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string or array) is not empty.

Pseudocode:<br>
¬ a.is_empty()

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_empty`](macro@crate::assert_not_empty)
* [`assert_not_empty_as_result`](macro@crate::assert_not_empty_as_result)
* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)


```rust
pub macro_rules! assert_not_empty_as_result {
    /* macro_rules! assert_not_empty_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_not_empty`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string or array) is not empty.

Pseudocode:<br>
¬ a.is_empty()

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "alfa";
assert_not_empty!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "";
assert_not_empty!(a);
# });
// assertion failed: `assert_not_empty!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_empty.html
//  label: `a`,
//  debug: `\"\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_empty!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_empty.html\n",
#     " label: `a`,\n",
#     " debug: `\"\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_empty`](macro@crate::assert_not_empty)
* [`assert_not_empty_as_result`](macro@crate::assert_not_empty_as_result)
* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)


```rust
pub macro_rules! assert_not_empty {
    /* macro_rules! assert_not_empty {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_empty`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string or array) is not empty.

Pseudocode:<br>
¬ a.is_empty()

This macro provides the same statements as [`assert_not_empty`](macro.assert_not_empty.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_empty`](macro@crate::assert_not_empty)
* [`assert_not_empty`](macro@crate::assert_not_empty)
* [`debug_assert_not_empty`](macro@crate::debug_assert_not_empty)


```rust
pub macro_rules! debug_assert_not_empty {
    /* macro_rules! debug_assert_not_empty {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a regex) is a match for an expression (such as a string).

Pseudocode:<br>
a.is_match(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_is_match`](macro@crate::assert_is_match)
* [`assert_is_match_as_result`](macro@crate::assert_is_match_as_result)
* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)


```rust
pub macro_rules! assert_is_match_as_result {
    /* macro_rules! assert_is_match_as_result {
    ($matcher:expr, $matchee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_is_match`

**Attributes:**

- `#[macro_export]`

Assert a matcher is a match for an expression.

Pseudocode:<br>
a.is_match(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use regex::Regex;

# fn main() {
let a = Regex::new(r"lf").expect("regex");
let b = "alfa";
assert_is_match!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = Regex::new(r"xx").expect("regex");
let b = "alfa";
assert_is_match!(a, b);
# });
// assertion failed: `assert_is_match!(matcher, matchee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_is_match.html
//  matcher label: `a`,
//  matcher debug: `Regex(\"xx\")`,
//  matchee label: `b`,
//  matchee debug: `\"alfa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_is_match!(matcher, matchee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_is_match.html\n",
#     " matcher label: `a`,\n",
#     " matcher debug: `Regex(\"xx\")`,\n",
#     " matchee label: `b`,\n",
#     " matchee debug: `\"alfa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_is_match`](macro@crate::assert_is_match)
* [`assert_is_match_as_result`](macro@crate::assert_is_match_as_result)
* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)


```rust
pub macro_rules! assert_is_match {
    /* macro_rules! assert_is_match {
    ($matcher:expr, $matchee:expr $(,)?) => { ... };
    ($matcher:expr, $matchee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_is_match`

**Attributes:**

- `#[macro_export]`

Assert a matcher is a match for an expression.

Pseudocode:<br>
a.is_match(b)

This macro provides the same statements as [`assert_is_match`](macro.assert_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_is_match`](macro@crate::assert_is_match)
* [`assert_is_match`](macro@crate::assert_is_match)
* [`debug_assert_is_match`](macro@crate::debug_assert_is_match)


```rust
pub macro_rules! debug_assert_is_match {
    /* macro_rules! debug_assert_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a regex) is not a match for an expression (such as a string).

Pseudocode:<br>
¬ a.is_match(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_match`](macro@crate::assert_not_match)
* [`assert_not_match_as_result`](macro@crate::assert_not_match_as_result)
* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)


```rust
pub macro_rules! assert_not_match_as_result {
    /* macro_rules! assert_not_match_as_result {
    ($matcher:expr, $matchee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_not_match`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a regex) is not a match for an expression (such as a string).

Pseudocode:<br>
¬ a.is_match(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use regex::Regex;

# fn main() {
let a = Regex::new(r"xx").expect("regex");
let b = "alfa";
assert_not_match!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = Regex::new(r"lf").expect("regex");
let b = "alfa";
assert_not_match!(a, b);
# });
// assertion failed: `assert_not_match!(matcher, matchee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_match.html
//  matcher label: `a`,
//  matcher debug: `Regex(\"lf\")`,
//  matchee label: `b`,
//  matchee debug: `\"alfa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_match!(matcher, matchee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_match.html\n",
#     " matcher label: `a`,\n",
#     " matcher debug: `Regex(\"lf\")`,\n",
#     " matchee label: `b`,\n",
#     " matchee debug: `\"alfa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_match`](macro@crate::assert_not_match)
* [`assert_not_match_as_result`](macro@crate::assert_not_match_as_result)
* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)


```rust
pub macro_rules! assert_not_match {
    /* macro_rules! assert_not_match {
    ($matcher:expr, $matchee:expr $(,)?) => { ... };
    ($matcher:expr, $matchee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_match`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a regex) is not a match for an expression (such as a string).

Pseudocode:<br>
¬ a.is_match(b)

This macro provides the same statements as [`assert_not_match`](macro.assert_not_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_match`](macro@crate::assert_not_match)
* [`assert_not_match`](macro@crate::assert_not_match)
* [`debug_assert_not_match`](macro@crate::debug_assert_not_match)


```rust
pub macro_rules! debug_assert_not_match {
    /* macro_rules! debug_assert_not_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is equal to another.

Pseudocode:<br>
a.len() = b.len()

* If true, return Result `Ok((a.len(), b.len()))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_eq`](macro@crate::assert_len_eq)
* [`assert_len_eq_as_result`](macro@crate::assert_len_eq_as_result)
* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)


```rust
pub macro_rules! assert_len_eq_as_result {
    /* macro_rules! assert_len_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_eq`

**Attributes:**

- `#[macro_export]`

Assert a length is equal to another.

Pseudocode:<br>
a.len() = b.len()

* If true, return `(a.len(), b.len())`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = "x";
assert_len_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = "xx";
assert_len_eq!(a, b);
# });
// assertion failed: `assert_len_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_eq.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `\"xx\"`,
//  b.len(): `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"xx\"`\n",
#     " b.len(): `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_eq`](macro@crate::assert_len_eq)
* [`assert_len_eq_as_result`](macro@crate::assert_len_eq_as_result)
* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)


```rust
pub macro_rules! assert_len_eq {
    /* macro_rules! assert_len_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_eq`

**Attributes:**

- `#[macro_export]`

Assert a length is equal to another.

Pseudocode:<br>
a.len() = b.len()

This macro provides the same statements as [`assert_len_eq`](macro.assert_len_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_eq`](macro@crate::assert_len_eq)
* [`assert_len_eq`](macro@crate::assert_len_eq)
* [`debug_assert_len_eq`](macro@crate::debug_assert_len_eq)


```rust
pub macro_rules! debug_assert_len_eq {
    /* macro_rules! debug_assert_len_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than or equal to another.

Pseudocode:<br>
a.len() ≥ b.len()

* If true, return Result `Ok((a.len(), b.len()))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_ge`](macro@crate::assert_len_ge)
* [`assert_len_ge_as_result`](macro@crate::assert_len_ge_as_result)
* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)


```rust
pub macro_rules! assert_len_ge_as_result {
    /* macro_rules! assert_len_ge_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_ge`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than or equal to another.

Pseudocode:<br>
a.len() ≥ b.len()

* If true, return `(a.len(), b.len())`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx";
let b = "x";
assert_len_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = "xx";
assert_len_ge!(a, b);
# });
// assertion failed: `assert_len_ge!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_ge.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `\"xx\"`,
//  b.len(): `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_ge!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"xx\"`\n",
#     " b.len(): `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_ge`](macro@crate::assert_len_ge)
* [`assert_len_ge_as_result`](macro@crate::assert_len_ge_as_result)
* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)


```rust
pub macro_rules! assert_len_ge {
    /* macro_rules! assert_len_ge {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_ge`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than or equal to another.

Pseudocode:<br>
a.len() ≥ b.len()

This macro provides the same statements as [`assert_len_ge`](macro.assert_len_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_ge`](macro@crate::assert_len_ge)
* [`assert_len_ge`](macro@crate::assert_len_ge)
* [`debug_assert_len_ge`](macro@crate::debug_assert_len_ge)


```rust
pub macro_rules! debug_assert_len_ge {
    /* macro_rules! debug_assert_len_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than another.

Pseudocode:<br>
a.len() > b.len()

* If true, return Result `Ok((a.len(), b.len()))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_gt`](macro@crate::assert_len_gt)
* [`assert_len_gt_as_result`](macro@crate::assert_len_gt_as_result)
* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)


```rust
pub macro_rules! assert_len_gt_as_result {
    /* macro_rules! assert_len_gt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_gt`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than another.

Pseudocode:<br>
a.len() > b.len()

* If true, return `(a.len(), b.len())`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx";
let b = "x";
assert_len_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = "xx";
assert_len_gt!(a, b);
# });
// assertion failed: `assert_len_gt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_gt.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `\"xx\"`,
//  b.len(): `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_gt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"xx\"`\n",
#     " b.len(): `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_gt`](macro@crate::assert_len_gt)
* [`assert_len_gt_as_result`](macro@crate::assert_len_gt_as_result)
* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)


```rust
pub macro_rules! assert_len_gt {
    /* macro_rules! assert_len_gt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_gt`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than another.

Pseudocode:<br>
a.len() > b.len()

This macro provides the same statements as [`assert_len_gt`](macro.assert_len_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_gt`](macro@crate::assert_len_gt)
* [`assert_len_gt`](macro@crate::assert_len_gt)
* [`debug_assert_len_gt`](macro@crate::debug_assert_len_gt)


```rust
pub macro_rules! debug_assert_len_gt {
    /* macro_rules! debug_assert_len_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is less than or equal to another.

Pseudocode:<br>
a.len() ≤ b.len()

* If true, return Result `Ok((a.len(), b.len()))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_le`](macro@crate::assert_len_le)
* [`assert_len_le_as_result`](macro@crate::assert_len_le_as_result)
* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)


```rust
pub macro_rules! assert_len_le_as_result {
    /* macro_rules! assert_len_le_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_le`

**Attributes:**

- `#[macro_export]`

Assert a length is less than or equal to another.

Pseudocode:<br>
a.len() ≤ b.len()

* If true, return `(a.len(), b.len())`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = "xx";
assert_len_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx";
let b = "x";
assert_len_le!(a, b);
# });
// assertion failed: `assert_len_le!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_le.html
//  a label: `a`,
//  a debug: `\"xx\"`,
//  a.len(): `2`",
//  b label: `b`,
//  b debug: `\"x\"`,
//  b.len(): `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_le!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"xx\"`,\n",
#     " a.len(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"x\"`\n",
#     " b.len(): `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_le`](macro@crate::assert_len_le)
* [`assert_len_le_as_result`](macro@crate::assert_len_le_as_result)
* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)


```rust
pub macro_rules! assert_len_le {
    /* macro_rules! assert_len_le {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_le`

**Attributes:**

- `#[macro_export]`

Assert a length is less than or equal to another.

Pseudocode:<br>
a.len() ≤ b.len()

This macro provides the same statements as [`assert_len_le`](macro.assert_len_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_le`](macro@crate::assert_len_le)
* [`assert_len_le`](macro@crate::assert_len_le)
* [`debug_assert_len_le`](macro@crate::debug_assert_len_le)


```rust
pub macro_rules! debug_assert_len_le {
    /* macro_rules! debug_assert_len_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is less than another.

Pseudocode:<br>
a.len() < b.len()

* If true, return Result `Ok((a.len(), b.len()))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_lt`](macro@crate::assert_len_lt)
* [`assert_len_lt_as_result`](macro@crate::assert_len_lt_as_result)
* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)


```rust
pub macro_rules! assert_len_lt_as_result {
    /* macro_rules! assert_len_lt_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_lt`

**Attributes:**

- `#[macro_export]`

Assert a length is less than another.

Pseudocode:<br>
a.len() < b.len()

* If true, return `(a.len(), b.len())`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = "xx";
assert_len_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx";
let b = "x";
assert_len_lt!(a, b);
# });
// assertion failed: `assert_len_lt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_lt.html
//  a label: `a`,
//  a debug: `\"xx\"`,
//  a.len(): `2`",
//  b label: `b`,
//  b debug: `\"x\"`,
//  b.len(): `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_lt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"xx\"`,\n",
#     " a.len(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"x\"`\n",
#     " b.len(): `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_lt`](macro@crate::assert_len_lt)
* [`assert_len_lt_as_result`](macro@crate::assert_len_lt_as_result)
* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)


```rust
pub macro_rules! assert_len_lt {
    /* macro_rules! assert_len_lt {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_lt`

**Attributes:**

- `#[macro_export]`

Assert a length is less than another.

Pseudocode:<br>
a.len() < b.len()

This macro provides the same statements as [`assert_len_lt`](macro.assert_len_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_lt`](macro@crate::assert_len_lt)
* [`assert_len_lt`](macro@crate::assert_len_lt)
* [`debug_assert_len_lt`](macro@crate::debug_assert_len_lt)


```rust
pub macro_rules! debug_assert_len_lt {
    /* macro_rules! debug_assert_len_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is not equal to another.

Pseudocode:<br>
a.len() ≠ b.len()

* If true, return Result `Ok((a.len(), b.len()))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_ne`](macro@crate::assert_len_ne)
* [`assert_len_ne_as_result`](macro@crate::assert_len_ne_as_result)
* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)


```rust
pub macro_rules! assert_len_ne_as_result {
    /* macro_rules! assert_len_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_ne`

**Attributes:**

- `#[macro_export]`

Assert a length is not equal to another.

Pseudocode:<br>
a.len() ≠ b.len()

* If true, return `(a.len(), b.len())`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = "xx";
assert_len_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = "x";
assert_len_ne!(a, b);
# });
// assertion failed: `assert_len_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_ne.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `\"x\"`,
//  b.len(): `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"x\"`\n",
#     " b.len(): `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_ne`](macro@crate::assert_len_ne)
* [`assert_len_ne_as_result`](macro@crate::assert_len_ne_as_result)
* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)


```rust
pub macro_rules! assert_len_ne {
    /* macro_rules! assert_len_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_ne`

**Attributes:**

- `#[macro_export]`

Assert a length is not equal to another.

Pseudocode:<br>
a.len() ≠ b.len()

This macro provides the same statements as [`assert_len_ne`](macro.assert_len_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_ne`](macro@crate::assert_len_ne)
* [`assert_len_ne`](macro@crate::assert_len_ne)
* [`debug_assert_len_ne`](macro@crate::debug_assert_len_ne)


```rust
pub macro_rules! debug_assert_len_ne {
    /* macro_rules! debug_assert_len_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is equal to an expression.

Pseudocode:<br>
a.len() = b

* If true, return Result `Ok((a.len(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)
* [`assert_len_eq_x_as_result`](macro@crate::assert_len_eq_x_as_result)
* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)


```rust
pub macro_rules! assert_len_eq_x_as_result {
    /* macro_rules! assert_len_eq_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a length is equal to an expression.

Pseudocode:<br>
a.len() = b

* If true, return `(a.len(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = 1;
assert_len_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = 2;
assert_len_eq_x!(a, b);
# });
// assertion failed: `assert_len_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_eq_x.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)
* [`assert_len_eq_x_as_result`](macro@crate::assert_len_eq_x_as_result)
* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)


```rust
pub macro_rules! assert_len_eq_x {
    /* macro_rules! assert_len_eq_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a length is equal to an expression.

Pseudocode:<br>
a.len() = b

This macro provides the same statements as [`assert_len_eq_x`](macro.assert_len_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)
* [`assert_len_eq_x`](macro@crate::assert_len_eq_x)
* [`debug_assert_len_eq_x`](macro@crate::debug_assert_len_eq_x)


```rust
pub macro_rules! debug_assert_len_eq_x {
    /* macro_rules! debug_assert_len_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

* If true, return Result `Ok((a.len(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)
* [`assert_len_ge_x_as_result`](macro@crate::assert_len_ge_x_as_result)
* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)


```rust
pub macro_rules! assert_len_ge_x_as_result {
    /* macro_rules! assert_len_ge_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

* If true, return `(a.len(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx";
let b = 1;
assert_len_ge_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = 2;
assert_len_ge_x!(a, b);
# });
// assertion failed: `assert_len_ge_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_ge_x.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_ge_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_ge_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)
* [`assert_len_ge_x_as_result`](macro@crate::assert_len_ge_x_as_result)
* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)


```rust
pub macro_rules! assert_len_ge_x {
    /* macro_rules! assert_len_ge_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

This macro provides the same statements as [`assert_len_ge_x`](macro.assert_len_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)
* [`assert_len_ge_x`](macro@crate::assert_len_ge_x)
* [`debug_assert_len_ge_x`](macro@crate::debug_assert_len_ge_x)


```rust
pub macro_rules! debug_assert_len_ge_x {
    /* macro_rules! debug_assert_len_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than an expression.

Pseudocode:<br>
a.len() > b

* If true, return Result `Ok((a.len(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)
* [`assert_len_gt_x_as_result`](macro@crate::assert_len_gt_x_as_result)
* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)


```rust
pub macro_rules! assert_len_gt_x_as_result {
    /* macro_rules! assert_len_gt_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than an expression.

Pseudocode:<br>
a.len() > b

* If true, return `(a.len(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "xx";
let b = 1;
assert_len_gt_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = 2;
assert_len_gt_x!(a, b);
# });
// assertion failed: `assert_len_gt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_gt_x.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_gt_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_gt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)
* [`assert_len_gt_x_as_result`](macro@crate::assert_len_gt_x_as_result)
* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)


```rust
pub macro_rules! assert_len_gt_x {
    /* macro_rules! assert_len_gt_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a length is greater than an expression.

Pseudocode:<br>
a.len() > b

This macro provides the same statements as [`assert_len_gt_x`](macro.assert_len_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)
* [`assert_len_gt_x`](macro@crate::assert_len_gt_x)
* [`debug_assert_len_gt_x`](macro@crate::debug_assert_len_gt_x)


```rust
pub macro_rules! debug_assert_len_gt_x {
    /* macro_rules! debug_assert_len_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

* If true, return Result `Ok((a.len(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_le_x`](macro@crate::assert_len_le_x)
* [`assert_len_le_x_as_result`](macro@crate::assert_len_le_x_as_result)
* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)


```rust
pub macro_rules! assert_len_le_x_as_result {
    /* macro_rules! assert_len_le_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_le_x`

**Attributes:**

- `#[macro_export]`

Assert a length is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

* If true, return `(a.len(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = 2;
assert_len_le_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx";
let b = 1;
assert_len_le_x!(a, b);
# });
// assertion failed: `assert_len_le_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_le_x.html
//  a label: `a`,
//  a debug: `\"xx\"`,
//  a.len(): `2`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_le_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_le_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"xx\"`,\n",
#     " a.len(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_le_x`](macro@crate::assert_len_le_x)
* [`assert_len_le_x_as_result`](macro@crate::assert_len_le_x_as_result)
* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)


```rust
pub macro_rules! assert_len_le_x {
    /* macro_rules! assert_len_le_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_le_x`

**Attributes:**

- `#[macro_export]`

Assert a length is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

This macro provides the same statements as [`assert_len_le_x`](macro.assert_len_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_le_x`](macro@crate::assert_len_le_x)
* [`assert_len_le_x`](macro@crate::assert_len_le_x)
* [`debug_assert_len_le_x`](macro@crate::debug_assert_len_le_x)


```rust
pub macro_rules! debug_assert_len_le_x {
    /* macro_rules! debug_assert_len_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is less than an expression.

Pseudocode:<br>
a.len() < b

* If true, return Result `Ok((a.len(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)
* [`assert_len_lt_x_as_result`](macro@crate::assert_len_lt_x_as_result)
* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)


```rust
pub macro_rules! assert_len_lt_x_as_result {
    /* macro_rules! assert_len_lt_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a length is less than an expression.

Pseudocode:<br>
a.len() < b

* If true, return `(a.len(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = 2;
assert_len_lt_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "xx";
let b = 1;
assert_len_lt_x!(a, b);
# });
// assertion failed: `assert_len_lt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_lt_x.html
//  a label: `a`,
//  a debug: `\"xx\"`,
//  a.len(): `2`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_lt_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_lt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"xx\"`,\n",
#     " a.len(): `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)
* [`assert_len_lt_x_as_result`](macro@crate::assert_len_lt_x_as_result)
* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)


```rust
pub macro_rules! assert_len_lt_x {
    /* macro_rules! assert_len_lt_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a length is less than an expression.

Pseudocode:<br>
a.len() < b

This macro provides the same statements as [`assert_len_lt_x`](macro.assert_len_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)
* [`assert_len_lt_x`](macro@crate::assert_len_lt_x)
* [`debug_assert_len_lt_x`](macro@crate::debug_assert_len_lt_x)


```rust
pub macro_rules! debug_assert_len_lt_x {
    /* macro_rules! debug_assert_len_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_len_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a length is not equal to an expression.

Pseudocode:<br>
a.len() ≠ b

* If true, return Result `Ok((a.len(), b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)
* [`assert_len_ne_x_as_result`](macro@crate::assert_len_ne_x_as_result)
* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)


```rust
pub macro_rules! assert_len_ne_x_as_result {
    /* macro_rules! assert_len_ne_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_len_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a length is not equal to an expression.

Pseudocode:<br>
a.len() ≠ b

* If true, return `(a.len(), b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = "x";
let b = 2;
assert_len_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "x";
let b = 1;
assert_len_ne_x!(a, b);
# });
// assertion failed: `assert_len_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_len_ne_x.html
//  a label: `a`,
//  a debug: `\"x\"`,
//  a.len(): `1`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_len_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_len_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"x\"`,\n",
#     " a.len(): `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)
* [`assert_len_ne_x_as_result`](macro@crate::assert_len_ne_x_as_result)
* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)


```rust
pub macro_rules! assert_len_ne_x {
    /* macro_rules! assert_len_ne_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_len_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a length is not equal to an expression.

Pseudocode:<br>
a.len() ≠ b

This macro provides the same statements as [`assert_len_ne_x`](macro.assert_len_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)
* [`assert_len_ne_x`](macro@crate::assert_len_ne_x)
* [`debug_assert_len_ne_x`](macro@crate::debug_assert_len_ne_x)


```rust
pub macro_rules! debug_assert_len_ne_x {
    /* macro_rules! debug_assert_len_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_matches_as_result`

**Attributes:**

- `#[macro_export]`

Assert expression matches a case.

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_matches`](macro@crate::assert_matches)
* [`assert_matches_as_result`](macro@crate::assert_matches_as_result)
* [`debug_assert_matches`](macro@crate::debug_assert_matches)


```rust
pub macro_rules! assert_matches_as_result {
    /* macro_rules! assert_matches_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_matches`

**Attributes:**

- `#[macro_export]`

Assert expression is Some.

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 'a';
assert_matches!(a, 'a'..='z');

# let result = panic::catch_unwind(|| {
// This will panic
let a = 'a';
assert_matches!(a, 'b'..='z');
# });
// assertion failed: `assert_matches!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_matches.html
//  args: `a, 'b'..='z'`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_matches!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_matches.html\n",
#     " args: `a, 'b'..='z'`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_matches`](macro@crate::assert_matches)
* [`assert_matches_as_result`](macro@crate::assert_matches_as_result)
* [`debug_assert_matches`](macro@crate::debug_assert_matches)


```rust
pub macro_rules! assert_matches {
    /* macro_rules! assert_matches {
    ($expression:expr, $pattern:pat if $guard:expr $(,)?) => { ... };
    ($expression:expr, $pattern:pat) => { ... };
    ($expression:expr, $pattern:pat if $guard:expr, $($message:tt)+) => { ... };
    ($expression:expr, $pattern:pat, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_matches`

**Attributes:**

- `#[macro_export]`

Assert expression is Some.

This macro provides the same statements as [`assert_matches`](macro.assert_matches.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_matches`](macro@crate::assert_matches)
* [`assert_matches`](macro@crate::assert_matches)
* [`debug_assert_matches`](macro@crate::debug_assert_matches)


```rust
pub macro_rules! debug_assert_matches {
    /* macro_rules! debug_assert_matches {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_matches_as_result`

**Attributes:**

- `#[macro_export]`

Assert expression matches a case.

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_matches`](macro@crate::assert_not_matches)
* [`assert_not_matches_as_result`](macro@crate::assert_not_matches_as_result)
* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)


```rust
pub macro_rules! assert_not_matches_as_result {
    /* macro_rules! assert_not_matches_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_matches`

**Attributes:**

- `#[macro_export]`

Assert expression is Some.

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = 'a';
assert_not_matches!(a, 'b'..='z');

# let result = panic::catch_unwind(|| {
// This will panic
let a = 'a';
assert_not_matches!(a, 'a'..='z');
# });
// assertion failed: `assert_not_matches!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_matches.html
//  args: `a, 'a'..='z'`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_matches!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_matches.html\n",
#     " args: `a, 'a'..='z'`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_matches`](macro@crate::assert_not_matches)
* [`assert_not_matches_as_result`](macro@crate::assert_not_matches_as_result)
* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)


```rust
pub macro_rules! assert_not_matches {
    /* macro_rules! assert_not_matches {
    ($expression:expr, $pattern:pat if $guard:expr $(,)?) => { ... };
    ($expression:expr, $pattern:pat) => { ... };
    ($expression:expr, $pattern:pat if $guard:expr, $($message:tt)+) => { ... };
    ($expression:expr, $pattern:pat, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_matches`

**Attributes:**

- `#[macro_export]`

Assert expression is Some.

This macro provides the same statements as [`assert_not_matches`](macro.assert_not_matches.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_matches`](macro@crate::assert_not_matches)
* [`assert_not_matches`](macro@crate::assert_not_matches)
* [`debug_assert_not_matches`](macro@crate::debug_assert_not_matches)


```rust
pub macro_rules! debug_assert_not_matches {
    /* macro_rules! debug_assert_not_matches {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_not_starts_with_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not start with an expression (such as a substring).

Pseudocode:<br>
¬ a.starts_with(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)
* [`assert_not_starts_with_as_result`](macro@crate::assert_not_starts_with_as_result)
* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)


```rust
pub macro_rules! assert_not_starts_with_as_result {
    /* macro_rules! assert_not_starts_with_as_result {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_not_starts_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not start with an expression (such as a string).

Pseudocode:<br>
¬ a.starts_with(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
// String starts with substring?
let sequence: &str = "alfa";
let subsequence: &str = "z";
assert_not_starts_with!(sequence, subsequence);

// Vector starts with element?
let sequence = vec![1, 2, 3];
let subsequence = [3];
assert_not_starts_with!(sequence, subsequence);

# let result = panic::catch_unwind(|| {
// This will panic
let sequence = "alfa";
let subsequence = "al";
assert_not_starts_with!(sequence, subsequence);
# });
// assertion failed: `assert_not_starts_with!(sequence, subsequence)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_not_starts_with.html
//  sequence label: `sequence`,
//  sequence debug: `\"alfa\"`,
//   part label: `subsequence`,
//   part debug: `\"al\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_not_starts_with!(sequence, subsequence)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_not_starts_with.html\n",
#     "     sequence label: `sequence`,\n",
#     "     sequence debug: `\"alfa\"`,\n",
#     "  subsequence label: `subsequence`,\n",
#     "  subsequence debug: `\"al\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)
* [`assert_not_starts_with_as_result`](macro@crate::assert_not_starts_with_as_result)
* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)


```rust
pub macro_rules! assert_not_starts_with {
    /* macro_rules! assert_not_starts_with {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_not_starts_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) does not start with an expression (such as a string).

Pseudocode:<br>
¬ a.starts_with(b)

This macro provides the same statements as [`assert_not_starts_with`](macro.assert_not_starts_with.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)
* [`assert_not_starts_with`](macro@crate::assert_not_starts_with)
* [`debug_assert_not_starts_with`](macro@crate::debug_assert_not_starts_with)


```rust
pub macro_rules! debug_assert_not_starts_with {
    /* macro_rules! debug_assert_not_starts_with {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_starts_with_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) starts with an expression (such as a substring).

Pseudocode:<br>
a.starts_with(b)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_starts_with`](macro@crate::assert_starts_with)
* [`assert_starts_with_as_result`](macro@crate::assert_starts_with_as_result)
* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)


```rust
pub macro_rules! assert_starts_with_as_result {
    /* macro_rules! assert_starts_with_as_result {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_starts_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) starts with an expression (such as a string).

Pseudocode:<br>
a.starts_with(b)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
// String starts with substring?
let sequence: &str = "alfa";
let subsequence: &str = "al";
assert_starts_with!(sequence, subsequence);

// Vector starts with element?
let sequence = vec![1, 2, 3];
let subsequence = [1];
assert_starts_with!(sequence, subsequence);

# let result = panic::catch_unwind(|| {
// This will panic
let sequence = "alfa";
let subsequence = "fa";
assert_starts_with!(sequence, subsequence);
// assertion failed: `assert_starts_with!(sequence, subsequence)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_starts_with.html
//  sequence label: `sequence`,
//  sequence debug: `\"alfa\"`,
//   part label: `subsequence`,
//   part debug: `\"fa\"`
# });
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_starts_with!(sequence, subsequence)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_starts_with.html\n",
#     "     sequence label: `sequence`,\n",
#     "     sequence debug: `\"alfa\"`,\n",
#     "  subsequence label: `subsequence`,\n",
#     "  subsequence debug: `\"fa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_starts_with`](macro@crate::assert_starts_with)
* [`assert_starts_with_as_result`](macro@crate::assert_starts_with_as_result)
* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)


```rust
pub macro_rules! assert_starts_with {
    /* macro_rules! assert_starts_with {
    ($sequence:expr, $subsequence:expr $(,)?) => { ... };
    ($sequence:expr, $subsequence:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_starts_with`

**Attributes:**

- `#[macro_export]`

Assert an expression (such as a string) starts with an expression (such as a string).

Pseudocode:<br>
a.starts_with(b)

This macro provides the same statements as [`assert_starts_with`](macro.assert_starts_with.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_starts_with`](macro@crate::assert_starts_with)
* [`assert_starts_with`](macro@crate::assert_starts_with)
* [`debug_assert_starts_with`](macro@crate::debug_assert_starts_with)


```rust
pub macro_rules! debug_assert_starts_with {
    /* macro_rules! debug_assert_starts_with {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_err_as_result`

**Attributes:**

- `#[macro_export]`

Assert expression is Err.

Pseudocode:<br>
a is Err(a1)

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_err`](macro@crate::assert_err)
* [`assert_err_as_result`](macro@crate::assert_err_as_result)
* [`debug_assert_err`](macro@crate::debug_assert_err)


```rust
pub macro_rules! assert_err_as_result {
    /* macro_rules! assert_err_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_err`

**Attributes:**

- `#[macro_export]`

Assert expression is Err.

Pseudocode:<br>
a is Err(a1)

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Err(1);
assert_err!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Ok(1);
assert_err!(a);
# });
// assertion failed: `assert_err!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_err.html
//  a label: `a`,
//  a debug: `Ok(1)`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_err!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_err.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ok(1)`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_err`](macro@crate::assert_err)
* [`assert_err_as_result`](macro@crate::assert_err_as_result)
* [`debug_assert_err`](macro@crate::debug_assert_err)


```rust
pub macro_rules! assert_err {
    /* macro_rules! assert_err {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_err`

**Attributes:**

- `#[macro_export]`

Assert expression is Err.

Pseudocode:<br>
a is Err(_)

This macro provides the same statements as [`assert_err`](macro.assert_err.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_err`](macro@crate::assert_err)
* [`assert_err`](macro@crate::assert_err)
* [`debug_assert_err`](macro@crate::debug_assert_err)


```rust
pub macro_rules! debug_assert_err {
    /* macro_rules! debug_assert_err {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_err_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Err and their values are equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_err_eq`](macro@crate::assert_err_eq)
* [`assert_err_eq_as_result`](macro@crate::assert_err_eq_as_result)
* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)


```rust
pub macro_rules! assert_err_eq_as_result {
    /* macro_rules! assert_err_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_err_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Err and their values are equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Err(1);
let b: Result<i8, i8> = Err(1);
assert_err_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Err(1);
let b: Result<i8, i8> = Err(2);
assert_err_eq!(a, b);
# });
// assertion failed: `assert_err_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_err_eq.html
//  a label: `a`,
//  a debug: `Err(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Err(2)`,
//  b inner: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_err_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_err_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `Err(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Err(2)`,\n",
#     " b inner: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_err_eq`](macro@crate::assert_err_eq)
* [`assert_err_eq_as_result`](macro@crate::assert_err_eq_as_result)
* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)


```rust
pub macro_rules! assert_err_eq {
    /* macro_rules! assert_err_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_err_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Err and their values are equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = (b ⇒ Err(b1) ⇒ b1)

This macro provides the same statements as [`assert_err_eq`](macro.assert_err_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_err_eq`](macro@crate::assert_err_eq)
* [`assert_err_eq`](macro@crate::assert_err_eq)
* [`debug_assert_err_eq`](macro@crate::debug_assert_err_eq)


```rust
pub macro_rules! debug_assert_err_eq {
    /* macro_rules! debug_assert_err_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_err_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Err and their values are not equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_err_ne`](macro@crate::assert_err_ne)
* [`assert_err_ne_as_result`](macro@crate::assert_err_ne_as_result)
* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)


```rust
pub macro_rules! assert_err_ne_as_result {
    /* macro_rules! assert_err_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_err_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Err and their values are not equal.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) ≠ (b ⇒ Err(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Err(1);
let b: Result<i8, i8> = Err(2);
assert_err_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Err(1);
let b: Result<i8, i8> = Err(1);
assert_err_ne!(a, b);
# });
// assertion failed: `assert_err_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_err_ne.html
//  a label: `a`,
//  a debug: `Err(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Err(1)`,
//  b inner: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_err_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_err_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `Err(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Err(1)`,\n",
#     " b inner: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_err_ne`](macro@crate::assert_err_ne)
* [`assert_err_ne_as_result`](macro@crate::assert_err_ne_as_result)
* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)


```rust
pub macro_rules! assert_err_ne {
    /* macro_rules! assert_err_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_err_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Err and their values are not equal.

This macro provides the same statements as [`assert_err_ne`](macro.assert_err_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_err_ne`](macro@crate::assert_err_ne)
* [`assert_err_ne`](macro@crate::assert_err_ne)
* [`debug_assert_err_ne`](macro@crate::debug_assert_err_ne)


```rust
pub macro_rules! debug_assert_err_ne {
    /* macro_rules! debug_assert_err_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_err_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Err and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = b

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)
* [`assert_err_eq_x_as_result`](macro@crate::assert_err_eq_x_as_result)
* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)


```rust
pub macro_rules! assert_err_eq_x_as_result {
    /* macro_rules! assert_err_eq_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_err_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Err and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Err(1);
let b: i8 = 1;
assert_err_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Err(1);
let b: i8 = 2;
assert_err_eq_x!(a, b);
# });
// assertion failed: `assert_err_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_err_eq_x.html
//  a label: `a`,
//  a debug: `Err(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_err_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_err_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Err(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)
* [`assert_err_eq_x_as_result`](macro@crate::assert_err_eq_x_as_result)
* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)


```rust
pub macro_rules! assert_err_eq_x {
    /* macro_rules! assert_err_eq_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_err_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Err and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = b

This macro provides the same statements as [`assert_err_eq_x`](macro.assert_err_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)
* [`assert_err_eq_x`](macro@crate::assert_err_eq_x)
* [`debug_assert_err_eq_x`](macro@crate::debug_assert_err_eq_x)


```rust
pub macro_rules! debug_assert_err_eq_x {
    /* macro_rules! debug_assert_err_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_err_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Err and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) = b

* e, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)
* [`assert_err_ne_x_as_result`](macro@crate::assert_err_ne_x_as_result)
* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)


```rust
pub macro_rules! assert_err_ne_x_as_result {
    /* macro_rules! assert_err_ne_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_err_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Err and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) ≠ b

* e, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Err(1);
let b: i8 = 2;
assert_err_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Err(1);
let b: i8 = 1;
assert_err_ne_x!(a, b);
# });
// assertion failed: `assert_err_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_err_ne_x.html
//  a label: `a`,
//  a debug: `Err(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_err_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_err_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Err(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)
* [`assert_err_ne_x_as_result`](macro@crate::assert_err_ne_x_as_result)
* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)


```rust
pub macro_rules! assert_err_ne_x {
    /* macro_rules! assert_err_ne_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_err_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Err and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Err(a1) ⇒ a1) ≠ b

This macro provides the same statements as [`assert_err_ne_x`](macro.assert_err_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)
* [`assert_err_ne_x`](macro@crate::assert_err_ne_x)
* [`debug_assert_err_ne_x`](macro@crate::debug_assert_err_ne_x)


```rust
pub macro_rules! debug_assert_err_ne_x {
    /* macro_rules! debug_assert_err_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ok_as_result`

**Attributes:**

- `#[macro_export]`

Assert expression is Ok.

Pseudocode:<br>
a is Ok(a1)

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ok`](macro@crate::assert_ok)
* [`assert_ok_as_result`](macro@crate::assert_ok_as_result)
* [`debug_assert_ok`](macro@crate::debug_assert_ok)


```rust
pub macro_rules! assert_ok_as_result {
    /* macro_rules! assert_ok_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ok`

**Attributes:**

- `#[macro_export]`

Assert expression is Ok.

Pseudocode:<br>
a is Ok.

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Ok(1);
assert_ok!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Err(1);
assert_ok!(a);
# });
// assertion failed: `assert_ok!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ok.html
//  a label: `a`,
//  a debug: `Err(1)`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ok!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ok.html\n",
#     " a label: `a`,\n",
#     " a debug: `Err(1)`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ok`](macro@crate::assert_ok)
* [`assert_ok_as_result`](macro@crate::assert_ok_as_result)
* [`debug_assert_ok`](macro@crate::debug_assert_ok)


```rust
pub macro_rules! assert_ok {
    /* macro_rules! assert_ok {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ok`

**Attributes:**

- `#[macro_export]`

Assert expression is Ok.

Pseudocode:<br>
a is Ok.

This macro provides the same statements as [`assert_ok`](macro.assert_ok.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ok`](macro@crate::assert_ok)
* [`assert_ok`](macro@crate::assert_ok)
* [`debug_assert_ok`](macro@crate::debug_assert_ok)


```rust
pub macro_rules! debug_assert_ok {
    /* macro_rules! debug_assert_ok {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ok_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ok and their values are equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ok_eq`](macro@crate::assert_ok_eq)
* [`assert_ok_eq_as_result`](macro@crate::assert_ok_eq_as_result)
* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)


```rust
pub macro_rules! assert_ok_eq_as_result {
    /* macro_rules! assert_ok_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ok_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ok and their values are equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Ok(1);
let b: Result<i8, i8> = Ok(1);
assert_ok_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Ok(1);
let b: Result<i8, i8> = Ok(2);
assert_ok_eq!(a, b);
# });
// assertion failed: `assert_ok_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ok_eq.html
//  a label: `a`,
//  a debug: `Ok(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Ok(2)`,
//  b inner: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ok_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ok_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ok(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Ok(2)`,\n",
#     " b inner: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ok_eq`](macro@crate::assert_ok_eq)
* [`assert_ok_eq_as_result`](macro@crate::assert_ok_eq_as_result)
* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)


```rust
pub macro_rules! assert_ok_eq {
    /* macro_rules! assert_ok_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ok_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ok and their values are equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = (b ⇒ Ok(b1) ⇒ b1)

This macro provides the same statements as [`assert_ok_eq`](macro.assert_ok_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ok_eq`](macro@crate::assert_ok_eq)
* [`assert_ok_eq`](macro@crate::assert_ok_eq)
* [`debug_assert_ok_eq`](macro@crate::debug_assert_ok_eq)


```rust
pub macro_rules! debug_assert_ok_eq {
    /* macro_rules! debug_assert_ok_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ok_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ok and their values are not equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ok_ne`](macro@crate::assert_ok_ne)
* [`assert_ok_ne_as_result`](macro@crate::assert_ok_ne_as_result)
* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)


```rust
pub macro_rules! assert_ok_ne_as_result {
    /* macro_rules! assert_ok_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ok_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ok and their values are not equal.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) ≠ (b ⇒ Ok(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Ok(1);
let b: Result<i8, i8> = Ok(2);
assert_ok_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Ok(1);
let b: Result<i8, i8> = Ok(1);
assert_ok_ne!(a, b);
# });
// assertion failed: `assert_ok_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ok_ne.html
//  a label: `a`,
//  a debug: `Ok(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Ok(1)`,
//  b inner: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ok_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ok_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ok(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Ok(1)`,\n",
#     " b inner: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ok_ne`](macro@crate::assert_ok_ne)
* [`assert_ok_ne_as_result`](macro@crate::assert_ok_ne_as_result)
* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)


```rust
pub macro_rules! assert_ok_ne {
    /* macro_rules! assert_ok_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ok_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ok and their values are not equal.

This macro provides the same statements as [`assert_ok_ne`](macro.assert_ok_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ok_ne`](macro@crate::assert_ok_ne)
* [`assert_ok_ne`](macro@crate::assert_ok_ne)
* [`debug_assert_ok_ne`](macro@crate::debug_assert_ok_ne)


```rust
pub macro_rules! debug_assert_ok_ne {
    /* macro_rules! debug_assert_ok_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ok_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ok and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = b

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)
* [`assert_ok_eq_x_as_result`](macro@crate::assert_ok_eq_x_as_result)
* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)


```rust
pub macro_rules! assert_ok_eq_x_as_result {
    /* macro_rules! assert_ok_eq_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ok_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ok and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Ok(1);
let b: i8 = 1;
assert_ok_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Ok(1);
let b: i8 = 2;
assert_ok_eq_x!(a, b);
# });
// assertion failed: `assert_ok_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ok_eq_x.html
//  a label: `a`,
//  a debug: `Ok(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ok_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ok_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ok(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)
* [`assert_ok_eq_x_as_result`](macro@crate::assert_ok_eq_x_as_result)
* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)


```rust
pub macro_rules! assert_ok_eq_x {
    /* macro_rules! assert_ok_eq_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ok_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ok and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = b

This macro provides the same statements as [`assert_ok_eq_x`](macro.assert_ok_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)
* [`assert_ok_eq_x`](macro@crate::assert_ok_eq_x)
* [`debug_assert_ok_eq_x`](macro@crate::debug_assert_ok_eq_x)


```rust
pub macro_rules! debug_assert_ok_eq_x {
    /* macro_rules! debug_assert_ok_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ok_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ok and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) = b

* If true, return Result `Ok((a1))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)
* [`assert_ok_ne_x_as_result`](macro@crate::assert_ok_ne_x_as_result)
* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)


```rust
pub macro_rules! assert_ok_ne_x_as_result {
    /* macro_rules! assert_ok_ne_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ok_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ok and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) ≠ b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Result<i8, i8> = Ok(1);
let b: i8 = 2;
assert_ok_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Result<i8, i8> = Ok(1);
let b: i8 = 1;
assert_ok_ne_x!(a, b);
# });
// assertion failed: `assert_ok_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ok_ne_x.html
//  a label: `a`,
//  a debug: `Ok(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ok_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ok_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ok(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)
* [`assert_ok_ne_x_as_result`](macro@crate::assert_ok_ne_x_as_result)
* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)


```rust
pub macro_rules! assert_ok_ne_x {
    /* macro_rules! assert_ok_ne_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ok_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ok and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ok(a1) ⇒ a1) ≠ b

This macro provides the same statements as [`assert_ok_ne_x`](macro.assert_ok_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)
* [`assert_ok_ne_x`](macro@crate::assert_ok_ne_x)
* [`debug_assert_ok_ne_x`](macro@crate::debug_assert_ok_ne_x)


```rust
pub macro_rules! debug_assert_ok_ne_x {
    /* macro_rules! debug_assert_ok_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_err_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_err_as_result` into `assert_err_as_result` because more developers prefer the shorter name.

Assert expression is Err.

Deprecated. Please rename from `assert_result_err_as_result` into `assert_err_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_err_as_result {
    /* macro_rules! assert_result_err_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_err`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_err` into `assert_err` because more developers prefer the shorter name.

Assert expression is Err.

Deprecated. Please rename from `assert_result_err` into `assert_err` because more developers prefer the shorter name.

```rust
pub macro_rules! assert_result_err {
    /* macro_rules! assert_result_err {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_result_err`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_result_err` into `debug_assert_err` because more developers prefer the shorter name.

Assert expression is Err.

Deprecated. Please rename from `debug_assert_result_err` into `debug_assert_err` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_result_err {
    /* macro_rules! debug_assert_result_err {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_ok_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_ok_as_result` into `assert_ok_as_result` because more developers prefer the shorter name.

Assert expression is Ok.

Deprecated. Please rename from `assert_result_ok_as_result` into `assert_ok_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_ok_as_result {
    /* macro_rules! assert_result_ok_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_ok`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_ok` into `assert_ok` because more developers prefer the shorter name.

Assert expression is Ok.

Deprecated. Please rename from `assert_result_ok` into `assert_ok` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_ok {
    /* macro_rules! assert_result_ok {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_result_ok`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_result_ok` into `debug_assert_ok` because more developers prefer the shorter name.

Assert expression is Ok.

Deprecated. Please rename from `debug_assert_result_ok` into `debug_assert_ok` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_result_ok {
    /* macro_rules! debug_assert_result_ok {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_ok_eq_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_ok_eq_as_result` into `assert_ok_eq_as_result` because more developers prefer the shorter name.

Assert two expressions are Ok and their values are equal.

Deprecated. Please rename from `assert_result_ok_eq_as_result` into `assert_ok_eq_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_ok_eq_as_result {
    /* macro_rules! assert_result_ok_eq_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_ok_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_ok_eq` into `assert_ok_eq` because more developers prefer the shorter name.

Assert two expressions are Ok and their values are equal.

Deprecated. Please rename from `assert_result_ok_eq` into `assert_ok_eq` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_ok_eq {
    /* macro_rules! assert_result_ok_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_result_ok_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_result_ok_eq` into `debug_assert_ok_eq` because more developers prefer the shorter name.

Assert two expressions are Ok and their values are equal.

Deprecated. Please rename from `debug_assert_result_ok_eq` into `debug_assert_ok_eq` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_result_ok_eq {
    /* macro_rules! debug_assert_result_ok_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_ok_ne_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_ok_ne_as_result` into `assert_ok_ne_as_result` because more developers prefer the shorter name.

Assert two expressions are Ok and their values are not equal.

Please rename from `assert_result_ok_ne_as_result` into `assert_ok_ne_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_ok_ne_as_result {
    /* macro_rules! assert_result_ok_ne_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_result_ok_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_result_ok_ne` into `assert_ok_ne` because more developers prefer the shorter name.

Assert two expressions are Ok and their values are not equal.

Please rename from `assert_result_ok_ne` into `assert_ok_ne` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_result_ok_ne {
    /* macro_rules! assert_result_ok_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_result_ok_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_result_ok_ne` into `debug_result_ok_ne` because more developers prefer the shorter name.

Assert two expressions are Ok and their values are not equal.

Please rename from `debug_assert_result_ok_ne` into `deubg_assert_ok_ne` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_result_ok_ne {
    /* macro_rules! debug_assert_result_ok_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_none_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is None.

Pseudocode:<br>
a is None

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_none`](macro@crate::assert_none)
* [`assert_none_as_result`](macro@crate::assert_none_as_result)
* [`debug_assert_none`](macro@crate::debug_assert_none)


```rust
pub macro_rules! assert_none_as_result {
    /* macro_rules! assert_none_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_none`

**Attributes:**

- `#[macro_export]`

Assert expression is None.

Pseudocode:<br>
a is None

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Option<i8> = Option::None;
assert_none!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Option<i8> = Option::Some(1);
assert_none!(a);
# });
// assertion failed: `assert_none!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_none.html
//  a label: `a`,
//  a debug: `Some(1)`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_none!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_none.html\n",
#     " a label: `a`,\n",
#     " a debug: `Some(1)`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_none`](macro@crate::assert_none)
* [`assert_none_as_result`](macro@crate::assert_none_as_result)
* [`debug_assert_none`](macro@crate::debug_assert_none)


```rust
pub macro_rules! assert_none {
    /* macro_rules! assert_none {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_none`

**Attributes:**

- `#[macro_export]`

Assert expression is None.

Pseudocode:<br>
a is None

This macro provides the same statements as [`assert_none`](macro.assert_none.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_none`](macro@crate::assert_none)
* [`assert_none`](macro@crate::assert_none)
* [`debug_assert_none`](macro@crate::debug_assert_none)


```rust
pub macro_rules! debug_assert_none {
    /* macro_rules! debug_assert_none {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_none_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_none_as_result` into `assert_none_as_result` because more developers prefer the shorter name.

Assert expression is None.

Deprecated. Please rename from `assert_option_none_as_result` into `assert_none_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_none_as_result {
    /* macro_rules! assert_option_none_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_none`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_none` into `assert_none` because more developers prefer the shorter name.

Assert expression is None.

Deprecated. Please rename from `assert_option_none` into `assert_none` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_none {
    /* macro_rules! assert_option_none {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_option_none`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_option_none` into `debug_assert_none` because more developers prefer the shorter name.

Assert expression is None.

Deprecated. Please rename from `debug_assert_option_none` into `debug_assert_none` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_option_none {
    /* macro_rules! debug_assert_option_none {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_some_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_some_as_result` into `assert_some_as_result` because more developers prefer the shorter name.

Assert expression is Some.

Deprecated. Please rename from `assert_option_some_as_result` into `assert_some_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_some_as_result {
    /* macro_rules! assert_option_some_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_some`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_some` into `assert_some` because more developers prefer the shorter name.

Assert expression is Some.

Deprecated. Please rename from `assert_option_some` into `assert_some` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_some {
    /* macro_rules! assert_option_some {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_option_some`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_option_some` into `debug_assert_some` because more developers prefer the shorter name.

Assert expression is Some.

Deprecated. Please rename from `debug_assert_option_some` into `debug_assert_some` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_option_some {
    /* macro_rules! debug_assert_option_some {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_some_eq_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_some_eq_as_result` into `assert_some_eq_as_result` because more developers prefer the shorter name.

Assert two expressions are Some and their values are equal.

Deprecated. Please rename from `assert_option_some_eq_as_result` into `assert_some_eq_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_some_eq_as_result {
    /* macro_rules! assert_option_some_eq_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_some_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_some_eq` into `assert_some_eq` because more developers prefer the shorter name.

Assert two expressions are Some and their values are equal.

Deprecated. Please rename from `assert_option_some_eq` into `assert_some_eq` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_some_eq {
    /* macro_rules! assert_option_some_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_option_some_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_option_some_eq` into `debug_assert_some_eq` because more developers prefer the shorter name.

Assert two expressions are Some and their values are equal.

Deprecated. Please rename from `debug_assert_option_some_eq` into `debug_assert_some_eq` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_option_some_eq {
    /* macro_rules! debug_assert_option_some_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_some_ne_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_some_ne_as_result` into `assert_some_ne_as_result` because more developers prefer the shorter name.

Assert two expressions are Some and their values are not equal.

Deprecated. Please rename from `assert_option_some_ne_as_result` into `assert_some_ne_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_some_ne_as_result {
    /* macro_rules! assert_option_some_ne_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_option_some_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_option_some_ne` into `assert_some_ne` because more developers prefer the shorter name.

Assert two expressions are Some and their values are not equal.

Deprecated. Please rename from `assert_option_some_ne` into `assert_some_ne` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_option_some_ne {
    /* macro_rules! assert_option_some_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_option_some_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_option_some_ne` into `debug_assert_some_ne` because more developers prefer the shorter name.

Assert two expressions are Some and their values are not equal.

Please rename from `debug_assert_option_some_ne` into `debug_assert_some_ne` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_option_some_ne {
    /* macro_rules! debug_assert_option_some_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_some_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression.is_some() is true.

Pseudocode:<br>
a is Some(a1)

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_some`](macro@crate::assert_some)
* [`assert_some_as_result`](macro@crate::assert_some_as_result)
* [`debug_assert_some`](macro@crate::debug_assert_some)


```rust
pub macro_rules! assert_some_as_result {
    /* macro_rules! assert_some_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_some`

**Attributes:**

- `#[macro_export]`

Assert expression is Some.

Pseudocode:<br>
a is Some(a1)

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Option<i8> = Option::Some(1);
assert_some!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Option<i8> = Option::None;
assert_some!(a);
# });
// assertion failed: `assert_some!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_some.html
//  option label: `a`,
//  option debug: `None`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_some!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_some.html\n",
#     " option label: `a`,\n",
#     " option debug: `None`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_some`](macro@crate::assert_some)
* [`assert_some_as_result`](macro@crate::assert_some_as_result)
* [`debug_assert_some`](macro@crate::debug_assert_some)


```rust
pub macro_rules! assert_some {
    /* macro_rules! assert_some {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_some`

**Attributes:**

- `#[macro_export]`

Assert expression is Some.

Pseudocode:<br>
a is Some

This macro provides the same statements as [`assert_some`](macro.assert_some.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_some`](macro@crate::assert_some)
* [`assert_some`](macro@crate::assert_some)
* [`debug_assert_some`](macro@crate::debug_assert_some)


```rust
pub macro_rules! debug_assert_some {
    /* macro_rules! debug_assert_some {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_some_eq_as_result`

**Attributes:**

- `#[macro_export]`


Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_some_eq`](macro.assert_some_eq.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_some_eq`](macro@crate::assert_some_eq)
* [`assert_some_eq_as_result`](macro@crate::assert_some_eq_as_result)
* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)


```rust
pub macro_rules! assert_some_eq_as_result {
    /* macro_rules! assert_some_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_some_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Some and their values are equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Option<i8> = Option::Some(1);
let b: Option<i8> = Option::Some(1);
assert_some_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Option<i8> = Option::Some(1);
let b: Option<i8> = Option::Some(2);
assert_some_eq!(a, b);
# });
// assertion failed: `assert_some_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_some_eq.html
//  a label: `a`,
//  a debug: `Some(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Some(2)`,
//  b inner: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_some_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_some_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `Some(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Some(2)`,\n",
#     " b inner: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_some_eq`](macro@crate::assert_some_eq)
* [`assert_some_eq_as_result`](macro@crate::assert_some_eq_as_result)
* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)


```rust
pub macro_rules! assert_some_eq {
    /* macro_rules! assert_some_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_some_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Some and their values are equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = (b ⇒ Some(b1) ⇒ b1)

This macro provides the same statements as [`assert_some_eq`](macro.assert_some_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_some_eq`](macro@crate::assert_some_eq)
* [`assert_some_eq`](macro@crate::assert_some_eq)
* [`debug_assert_some_eq`](macro@crate::debug_assert_some_eq)


```rust
pub macro_rules! debug_assert_some_eq {
    /* macro_rules! debug_assert_some_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_some_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Some and their values are not equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1)`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_some_ne`](macro.assert_some_ne.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_some_ne`](macro@crate::assert_some_ne)
* [`assert_some_ne_as_result`](macro@crate::assert_some_ne_as_result)
* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)


```rust
pub macro_rules! assert_some_ne_as_result {
    /* macro_rules! assert_some_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_some_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Some and their values are not equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Option<i8> = Option::Some(1);
let b: Option<i8> = Option::Some(2);
assert_some_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Option<i8> = Option::Some(1);
let b: Option<i8> = Option::Some(1);
assert_some_ne!(a, b);
# });
// assertion failed: `assert_some_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_some_ne.html
//  a label: `a`,
//  a debug: `Some(1)`,
//  b label: `b`,
//  b debug: `Some(1)`,
//  a inner: `1`,
//  b inner: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_some_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_some_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `Some(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Some(1)`,\n",
#     " b inner: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_some_ne`](macro@crate::assert_some_ne)
* [`assert_some_ne_as_result`](macro@crate::assert_some_ne_as_result)
* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)


```rust
pub macro_rules! assert_some_ne {
    /* macro_rules! assert_some_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_some_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Some and their values are not equal.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ (b ⇒ Some(b1) ⇒ b1)

This macro provides the same statements as [`assert_some_ne`](macro.assert_some_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_some_ne`](macro@crate::assert_some_ne)
* [`assert_some_ne`](macro@crate::assert_some_ne)
* [`debug_assert_some_ne`](macro@crate::debug_assert_some_ne)


```rust
pub macro_rules! debug_assert_some_ne {
    /* macro_rules! debug_assert_some_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_some_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a.is_some() and a.unwrap() are equal to another.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = b

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_some_eq_x`](macro.assert_some_eq_x.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)
* [`assert_some_eq_x_as_result`](macro@crate::assert_some_eq_x_as_result)
* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)


```rust
pub macro_rules! assert_some_eq_x_as_result {
    /* macro_rules! assert_some_eq_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_some_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Some and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Option<i8> = Option::Some(1);
let b: i8 = 1;
assert_some_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Option<i8> = Option::Some(1);
let b: i8 = 2;
assert_some_eq_x!(a, b);
# });
// assertion failed: `assert_some_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_some_eq_x.html
//  a label: `a`,
//  a debug: `Some(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_some_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_some_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Some(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)
* [`assert_some_eq_x_as_result`](macro@crate::assert_some_eq_x_as_result)
* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)


```rust
pub macro_rules! assert_some_eq_x {
    /* macro_rules! assert_some_eq_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_some_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Some and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) = b

This macro provides the same statements as [`assert_some_eq_x`](macro.assert_some_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)
* [`assert_some_eq_x`](macro@crate::assert_some_eq_x)
* [`debug_assert_some_eq_x`](macro@crate::debug_assert_some_eq_x)


```rust
pub macro_rules! debug_assert_some_eq_x {
    /* macro_rules! debug_assert_some_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_some_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a.is_some() and a.unwrap() are equal to another.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ b

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_some_ne_x`](macro.assert_some_ne_x.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)
* [`assert_some_ne_x_as_result`](macro@crate::assert_some_ne_x_as_result)
* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)


```rust
pub macro_rules! assert_some_ne_x_as_result {
    /* macro_rules! assert_some_ne_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_some_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Some and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: Option<i8> = Option::Some(1);
let b: i8 = 2;
assert_some_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Option<i8> = Option::Some(1);
let b: i8 = 1;
assert_some_ne_x!(a, b);
# });
// assertion failed: `assert_some_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_some_ne_x.html
//  a label: `a`,
//  a debug: `Some(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_some_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_some_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Some(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)
* [`assert_some_ne_x_as_result`](macro@crate::assert_some_ne_x_as_result)
* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)


```rust
pub macro_rules! assert_some_ne_x {
    /* macro_rules! assert_some_ne_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_some_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Some and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Some(a1) ⇒ a1) ≠ b

This macro provides the same statements as [`assert_some_ne_x`](macro.assert_some_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)
* [`assert_some_ne_x`](macro@crate::assert_some_ne_x)
* [`debug_assert_some_ne_x`](macro@crate::debug_assert_some_ne_x)


```rust
pub macro_rules! debug_assert_some_ne_x {
    /* macro_rules! debug_assert_some_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_pending_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression.is_pending() is true.

Pseudocode:<br>
a is Pending

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_pending`](macro@crate::assert_pending)
* [`assert_pending_as_result`](macro@crate::assert_pending_as_result)
* [`debug_assert_pending`](macro@crate::debug_assert_pending)


```rust
pub macro_rules! assert_pending_as_result {
    /* macro_rules! assert_pending_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_pending`

**Attributes:**

- `#[macro_export]`

Assert an expression is Pending.

Pseudocode:<br>
a is Pending

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::task::Poll;
use std::task::Poll::*;
# fn main() {
let a: Poll<i8> = Pending;
assert_pending!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Poll<i8> = Ready(1);
assert_pending!(a);
# });
// assertion failed: `assert_pending!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_pending.html
//  a label: `a`,
//  a debug: `Ready(1)`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_pending!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_pending.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ready(1)`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_pending`](macro@crate::assert_pending)
* [`assert_pending_as_result`](macro@crate::assert_pending_as_result)
* [`debug_assert_pending`](macro@crate::debug_assert_pending)


```rust
pub macro_rules! assert_pending {
    /* macro_rules! assert_pending {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_pending`

**Attributes:**

- `#[macro_export]`

Assert an expression is Pending.

Pseudocode:<br>
a is Pending

This macro provides the same statements as [`assert_pending`](macro.assert_pending.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_pending`](macro@crate::assert_pending)
* [`assert_pending`](macro@crate::assert_pending)
* [`debug_assert_pending`](macro@crate::debug_assert_pending)


```rust
pub macro_rules! debug_assert_pending {
    /* macro_rules! debug_assert_pending {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_pending_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_pending_as_result` into `assert_pending_as_result` because more developers prefer the shorter name.

Assert an expression.is_pending() is true.

Deprecated. Please rename from `assert_poll_pending_as_result` into `assert_pending_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_pending_as_result {
    /* macro_rules! assert_poll_pending_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_pending`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_pending` into `assert_pending` because more developers prefer the shorter name.

Assert an expression is Pending.

Deprecated. Please rename from `assert_poll_pending` into `assert_pending` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_pending {
    /* macro_rules! assert_poll_pending {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_poll_pending`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_poll_pending` into `debug_assert_pending` because more developers prefer the shorter name.

Assert an expression is Pending.

Deprecated. Please rename from `debug_assert_poll_pending` into `debug_assert_pending` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_poll_pending {
    /* macro_rules! debug_assert_poll_pending {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_ready_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_ready_as_result` into `assert_ready_as_result` because more developers prefer the shorter name.

Assert an expression is Ready.

Deprecated. Please rename from `assert_poll_ready_as_result` into `assert_ready_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_ready_as_result {
    /* macro_rules! assert_poll_ready_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_ready`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_ready` into `assert_ready` because more developers prefer the shorter name.

Assert an expression is Ready.

Deprecated. Please rename from `assert_poll_ready` into `assert_ready` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_ready {
    /* macro_rules! assert_poll_ready {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_poll_ready`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_poll_ready` into `debug_assert_ready` because more developers prefer the shorter name.

Assert poll.is_ready() is true.

Deprecated. lease rename from `debug_assert_poll_ready` into `debug_assert_ready` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_poll_ready {
    /* macro_rules! debug_assert_poll_ready {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_ready_eq_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_ready_eq_as_result` into `assert_ready_eq_as_result` because more developers prefer the shorter name.

Assert two expressions are Ready(_) and their values are equal.

Deprecated. Please rename from `assert_poll_ready_eq_as_result` into `assert_ready_eq_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_ready_eq_as_result {
    /* macro_rules! assert_poll_ready_eq_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_ready_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_ready_eq` into `assert_ready_eq` because more developers prefer the shorter name.

Assert two expressions are Ready(_) and their values are equal.

Deprecated. Please rename from `assert_poll_ready_eq` into `assert_ready_eq` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_ready_eq {
    /* macro_rules! assert_poll_ready_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_poll_ready_eq`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_poll_ready_eq` into `debug_assert_ready_eq` because more developers prefer the shorter name.

Assert two expressions are Ready(_) and their values are equal.

Deprecated. Please rename from `debug_assert_poll_ready_eq` into `debug_assert_ready_eq` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_poll_ready_eq {
    /* macro_rules! debug_assert_poll_ready_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_ready_ne_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_ready_ne_as_result` into `assert_ready_ne_as_result` because more developers prefer the shorter name.

Assert two expressions are Ready(_) and their values are not equal.

Deprecated. Please rename from `assert_poll_ready_ne_as_result` into `assert_ready_ne_as_result` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_ready_ne_as_result {
    /* macro_rules! assert_poll_ready_ne_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_poll_ready_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_poll_ready_ne` into `assert_ready_ne` because more developers prefer the shorter name.

Assert two expressions are Ready(_) and their values are not equal.

Deprecated. Please rename from `assert_poll_ready_ne` into `assert_ready_ne` because more developers prefer the shorter name.


```rust
pub macro_rules! assert_poll_ready_ne {
    /* macro_rules! assert_poll_ready_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_poll_ready_ne`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_poll_ready_ne` into `debug_assert_ready_ne` because more developers prefer the shorter name.

Assert two expressions are Ready(_) and their values are not equal.

Deprecated. Please rename from `debug_assert_poll_ready_ne` into `debug_assert_ready_ne` because more developers prefer the shorter name.


```rust
pub macro_rules! debug_assert_poll_ready_ne {
    /* macro_rules! debug_assert_poll_ready_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ready_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready.

Pseudocode:<br>
a is Ready(a1)

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ready`](macro@crate::assert_ready)
* [`assert_ready_as_result`](macro@crate::assert_ready_as_result)
* [`debug_assert_ready`](macro@crate::debug_assert_ready)


```rust
pub macro_rules! assert_ready_as_result {
    /* macro_rules! assert_ready_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ready`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready.

Pseudocode:<br>
a is Ready(a1)

* If true, return `(a1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::task::Poll;
use std::task::Poll::*;
# fn main() {
let a: Poll<i8> = Ready(1);
assert_ready!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Poll<i8> = Pending;
assert_ready!(a);
# });
// assertion failed: `assert_ready!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ready.html
//  a label: `a`,
//  a debug: `Pending`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ready!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ready.html\n",
#     " a label: `a`,\n",
#     " a debug: `Pending`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ready`](macro@crate::assert_ready)
* [`assert_ready_as_result`](macro@crate::assert_ready_as_result)
* [`debug_assert_ready`](macro@crate::debug_assert_ready)


```rust
pub macro_rules! assert_ready {
    /* macro_rules! assert_ready {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ready`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready.

Pseudocode:<br>
a is Ready(a1)

This macro provides the same statements as [`assert_ready`](macro.assert_ready.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ready`](macro@crate::assert_ready)
* [`assert_ready`](macro@crate::assert_ready)
* [`debug_assert_ready`](macro@crate::debug_assert_ready)


```rust
pub macro_rules! debug_assert_ready {
    /* macro_rules! debug_assert_ready {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ready_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ready and their values are equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_ready_eq`](macro.assert_ready_eq.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ready_eq`](macro@crate::assert_ready_eq)
* [`assert_ready_eq_as_result`](macro@crate::assert_ready_eq_as_result)
* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)


```rust
pub macro_rules! assert_ready_eq_as_result {
    /* macro_rules! assert_ready_eq_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ready_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ready and their values are equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::task::Poll;
use std::task::Poll::*;
# fn main() {
let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(1);
assert_ready_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(2);
assert_ready_eq!(a, b);
# });
// assertion failed: `assert_ready_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ready_eq.html
//  a label: `a`,
//  a debug: `Ready(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Ready(2)`,
//  b inner: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ready_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ready_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ready(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Ready(2)`,\n",
#     " b inner: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ready_eq`](macro@crate::assert_ready_eq)
* [`assert_ready_eq_as_result`](macro@crate::assert_ready_eq_as_result)
* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)


```rust
pub macro_rules! assert_ready_eq {
    /* macro_rules! assert_ready_eq {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ready_eq`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ready and their values are equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = (b ⇒ Ready(b1) ⇒ b1)

This macro provides the same statements as [`assert_ready_eq`](macro.assert_ready_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ready_eq`](macro@crate::assert_ready_eq)
* [`assert_ready_eq`](macro@crate::assert_ready_eq)
* [`debug_assert_ready_eq`](macro@crate::debug_assert_ready_eq)


```rust
pub macro_rules! debug_assert_ready_eq {
    /* macro_rules! debug_assert_ready_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ready_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ready and their values are not equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)

* If true, return Result `Ok((a1, b1))`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_ready_ne`](macro.assert_ready_ne.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ready_ne`](macro@crate::assert_ready_ne)
* [`assert_ready_ne_as_result`](macro@crate::assert_ready_ne_as_result)
* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)


```rust
pub macro_rules! assert_ready_ne_as_result {
    /* macro_rules! assert_ready_ne_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ready_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ready and their values are not equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)

* If true, return `(a1, b1)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::task::Poll;
use std::task::Poll::*;
# fn main() {
let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(2);
assert_ready_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Poll<i8> = Ready(1);
let b: Poll<i8> = Ready(1);
assert_ready_ne!(a, b);
# });
// assertion failed: `assert_ready_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ready_ne.html
//  a label: `a`,
//  a debug: `Ready(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `Ready(1)`,
//  b inner: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ready_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ready_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ready(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `Ready(1)`,\n",
#     " b inner: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ready_ne`](macro@crate::assert_ready_ne)
* [`assert_ready_ne_as_result`](macro@crate::assert_ready_ne_as_result)
* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)


```rust
pub macro_rules! assert_ready_ne {
    /* macro_rules! assert_ready_ne {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ready_ne`

**Attributes:**

- `#[macro_export]`

Assert two expressions are Ready and their values are not equal.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ (b ⇒ Ready(b1) ⇒ b1)

This macro provides the same statements as [`assert_ready_ne`](macro.assert_ready_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ready_ne`](macro@crate::assert_ready_ne)
* [`assert_ready_ne`](macro@crate::assert_ready_ne)
* [`debug_assert_ready_ne`](macro@crate::debug_assert_ready_ne)


```rust
pub macro_rules! debug_assert_ready_ne {
    /* macro_rules! debug_assert_ready_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ready_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = b

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_ready_eq_x`](macro.assert_ready_eq_x.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)
* [`assert_ready_eq_x_as_result`](macro@crate::assert_ready_eq_x_as_result)
* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)


```rust
pub macro_rules! assert_ready_eq_x_as_result {
    /* macro_rules! assert_ready_eq_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ready_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::task::Poll;
use std::task::Poll::*;
# fn main() {
let a: Poll<i8> = Ready(1);
let b: i8 = 1;
assert_ready_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Poll<i8> = Ready(1);
let b: i8 = 2;
assert_ready_eq_x!(a, b);
# });
// assertion failed: `assert_ready_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ready_eq_x.html
//  a label: `a`,
//  a debug: `Ready(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ready_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ready_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ready(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)
* [`assert_ready_eq_x_as_result`](macro@crate::assert_ready_eq_x_as_result)
* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)


```rust
pub macro_rules! assert_ready_eq_x {
    /* macro_rules! assert_ready_eq_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ready_eq_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready and its value is equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) = b

This macro provides the same statements as [`assert_ready_eq_x`](macro.assert_ready_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)
* [`assert_ready_eq_x`](macro@crate::assert_ready_eq_x)
* [`debug_assert_ready_eq_x`](macro@crate::debug_assert_ready_eq_x)


```rust
pub macro_rules! debug_assert_ready_eq_x {
    /* macro_rules! debug_assert_ready_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_ready_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ b

* If true, return Result `Ok(a1)`.

* Otherwise, return Result `Err(message)`.

This macro provides the same statements as [`assert_ready_ne_x`](macro.assert_ready_ne_x.html),
except this macro returns a Option, rather than doing a panic.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)
* [`assert_ready_ne_x_as_result`](macro@crate::assert_ready_ne_x_as_result)
* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)


```rust
pub macro_rules! assert_ready_ne_x_as_result {
    /* macro_rules! assert_ready_ne_x_as_result {
    ($a:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_ready_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ b

* If true, return `a1`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::task::Poll;
use std::task::Poll::*;
# fn main() {
let a: Poll<i8> = Ready(1);
let b: i8 = 2;
assert_ready_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: Poll<i8> = Ready(1);
let b: i8 = 1;
assert_ready_ne_x!(a, b);
# });
// assertion failed: `assert_ready_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_ready_ne_x.html
//  a label: `a`,
//  a debug: `Ready(1)`,
//  a inner: `1`,
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_ready_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_ready_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `Ready(1)`,\n",
#     " a inner: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)
* [`assert_ready_ne_x_as_result`](macro@crate::assert_ready_ne_x_as_result)
* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)


```rust
pub macro_rules! assert_ready_ne_x {
    /* macro_rules! assert_ready_ne_x {
    ($a:expr, $b:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_ready_ne_x`

**Attributes:**

- `#[macro_export]`

Assert an expression is Ready and its value is not equal to an expression.

Pseudocode:<br>
(a ⇒ Ready(a1) ⇒ a1) ≠ b

This macro provides the same statements as [`assert_ready_ne_x`](macro.assert_ready_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)
* [`assert_ready_ne_x`](macro@crate::assert_ready_ne_x)
* [`debug_assert_ready_ne_x`](macro@crate::debug_assert_ready_ne_x)


```rust
pub macro_rules! debug_assert_ready_ne_x {
    /* macro_rules! debug_assert_ready_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_bag_impl_prep`

**Attributes:**

- `#[macro_export]`

Assert bag implementation preparation.

```rust
pub macro_rules! assert_bag_impl_prep {
    /* macro_rules! assert_bag_impl_prep {
    ($impl_into_iter:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_bag_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a bag is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)

* If true, return Result `Ok((a, b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_bag_eq!`](macro@crate::assert_bag_eq)
* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)
* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)


```rust
pub macro_rules! assert_bag_eq_as_result {
    /* macro_rules! assert_bag_eq_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_bag_eq`

**Attributes:**

- `#[macro_export]`

Assert a bag is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] in order to print the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 1];
let b = [1, 1];
assert_bag_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 1];
let b = [1, 1, 1];
assert_bag_eq!(a, b);
# });
// assertion failed: `assert_bag_eq!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_bag_eq.html
//  a label: `a`,
//  a debug: `[1, 1]`,
//  b label: `b`,
//  b debug: `[1, 1, 1]`,
//    a bag: `{1: 2}`,
//    b bag: `{1: 3}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_bag_eq!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_bag_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 1]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 1, 1]`,\n",
#     "   a bag: `{1: 2}`,\n",
#     "   b bag: `{1: 3}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_eq`](macro@crate::assert_bag_eq)
* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)
* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)


```rust
pub macro_rules! assert_bag_eq {
    /* macro_rules! assert_bag_eq {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_bag_eq`

**Attributes:**

- `#[macro_export]`

Assert a bag is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) = (b_collection ⇒ b_bag)

This macro provides the same statements as [`assert_bag_eq`](macro.assert_bag_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_bag_eq`](macro@crate::assert_bag_eq)
* [`assert_bag_eq_as_result`](macro@crate::assert_bag_eq_as_result)
* [`debug_assert_bag_eq`](macro@crate::debug_assert_bag_eq)


```rust
pub macro_rules! debug_assert_bag_eq {
    /* macro_rules! debug_assert_bag_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_bag_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a bag is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)

* If true, return Result `Ok((a, b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_bag_ne`](macro@crate::assert_bag_ne)
* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)
* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)


```rust
pub macro_rules! assert_bag_ne_as_result {
    /* macro_rules! assert_bag_ne_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_bag_ne`

**Attributes:**

- `#[macro_export]`

Assert a bag is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 1];
let b = [1, 1, 1];
assert_bag_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 1];
let b = [1, 1];
assert_bag_ne!(a, b);
# });
// assertion failed: `assert_bag_ne!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_bag_ne.html
//  a label: `a`,
//  a debug: `[1, 1]`,
//  b label: `b`,
//  b debug: `[1, 1]`,
//    a bag: `{1: 2}`,
//    b bag: `{1: 2}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_bag_ne!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_bag_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 1]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 1]`,\n",
#     "   a bag: `{1: 2}`,\n",
#     "   b bag: `{1: 2}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_ne`](macro@crate::assert_bag_ne)
* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)
* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)


```rust
pub macro_rules! assert_bag_ne {
    /* macro_rules! assert_bag_ne {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_bag_ne`

**Attributes:**

- `#[macro_export]`

Assert a bag is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ≠ (b_collection ⇒ b_bag)

This macro provides the same statements as [`assert_bag_ne`](macro.assert_bag_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_bag_ne`](macro@crate::assert_bag_ne)
* [`assert_bag_ne_as_result`](macro@crate::assert_bag_ne_as_result)
* [`debug_assert_bag_ne`](macro@crate::debug_assert_bag_ne)


```rust
pub macro_rules! debug_assert_bag_ne {
    /* macro_rules! debug_assert_bag_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_bag_subbag_as_result`

**Attributes:**

- `#[macro_export]`

Assert a bag is a subbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)

* If true, return Result `Ok((a, b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)
* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)
* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)


```rust
pub macro_rules! assert_bag_subbag_as_result {
    /* macro_rules! assert_bag_subbag_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_bag_subbag`

**Attributes:**

- `#[macro_export]`

Assert a bag is a subbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] in order to print the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 1];
let b = [1, 1, 1];
assert_bag_subbag!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 1, 1];
let b = [1, 1];
assert_bag_subbag!(a, b);
# });
// assertion failed: `assert_bag_subbag!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_bag_subbag.html
//  a label: `a`,
//  a debug: `[1, 1, 1]`,
//  b label: `b`,
//  b debug: `[1, 1]`,
//    a bag: `{1: 3}`,
//    b bag: `{1: 2}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_bag_subbag!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_bag_subbag.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 1, 1]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 1]`,\n",
#     "   a bag: `{1: 3}`,\n",
#     "   b bag: `{1: 2}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)
* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)
* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)


```rust
pub macro_rules! assert_bag_subbag {
    /* macro_rules! assert_bag_subbag {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_bag_subbag`

**Attributes:**

- `#[macro_export]`

Assert a bag is a subbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊂ (b_collection ⇒ b_bag)

This macro provides the same statements as [`assert_bag_subbag`](macro.assert_bag_subbag.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_bag_subbag`](macro@crate::assert_bag_subbag)
* [`assert_bag_subbag_as_result`](macro@crate::assert_bag_subbag_as_result)
* [`debug_assert_bag_subbag`](macro@crate::debug_assert_bag_subbag)


```rust
pub macro_rules! debug_assert_bag_subbag {
    /* macro_rules! debug_assert_bag_subbag {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_bag_superbag_as_result`

**Attributes:**

- `#[macro_export]`

Assert a bag is a superbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)

* If true, return Result `Ok((a, b))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)
* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)
* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)


```rust
pub macro_rules! assert_bag_superbag_as_result {
    /* macro_rules! assert_bag_superbag_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_bag_superbag`

**Attributes:**

- `#[macro_export]`

Assert a bag is a superbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] in order to print the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 1, 1];
let b = [1, 1];
assert_bag_superbag!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 1];
let b = [1, 1, 1];
assert_bag_superbag!(a, b);
# });
// assertion failed: `assert_bag_superbag!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_bag_superbag.html
//  a label: `a`,
//  a debug: `[1, 1]`,
//  b label: `b`,
//  b debug: `[1, 1, 1]`,
//    a bag: `{1: 2}`,
//    b bag: `{1: 3}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_bag_superbag!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_bag_superbag.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 1]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 1, 1]`,\n",
#     "   a bag: `{1: 2}`,\n",
#     "   b bag: `{1: 3}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeMap`](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html) to count items and sort them.

# Module macros

* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)
* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)
* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)


```rust
pub macro_rules! assert_bag_superbag {
    /* macro_rules! assert_bag_superbag {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_bag_superbag`

**Attributes:**

- `#[macro_export]`

Assert a bag is a superbag of another.

Pseudocode:<br>
(a_collection ⇒ a_bag) ⊃ (b_collection ⇒ b_bag)

This macro provides the same statements as [`assert_bag_superbag`](macro.assert_bag_superbag.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_bag_superbag`](macro@crate::assert_bag_superbag)
* [`assert_bag_superbag_as_result`](macro@crate::assert_bag_superbag_as_result)
* [`debug_assert_bag_superbag`](macro@crate::debug_assert_bag_superbag)


```rust
pub macro_rules! debug_assert_bag_superbag {
    /* macro_rules! debug_assert_bag_superbag {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_iter_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert an iterable is equal to another.

Pseudocode:<br>
(collection1 into iter) = (collection2 into iter)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_eq`](macro@crate::assert_iter_eq)
* [`assert_iter_eq_as_result`](macro@crate::assert_iter_eq_as_result)
* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)


```rust
pub macro_rules! assert_iter_eq_as_result {
    /* macro_rules! assert_iter_eq_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_iter_eq`

**Attributes:**

- `#[macro_export]`

Assert an iterable is equal to another.

Pseudocode:<br>
(collection1 into iter) = (collection2 into iter)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [1, 2];
assert_iter_eq!(&a, &b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [2, 1];
assert_iter_eq!(&a, &b);
# });
// assertion failed: `assert_iter_eq!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_iter_eq.html
//  a label: `&a`,
//  a debug: `[1, 2]`,
//  b label: `&b`,
//  b debug: `[2, 1]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_iter_eq!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_iter_eq.html\n",
#     " a label: `&a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `&b`,\n",
#     " b debug: `[2, 1]`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_eq`](macro@crate::assert_iter_eq)
* [`assert_iter_eq_as_result`](macro@crate::assert_iter_eq_as_result)
* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)


```rust
pub macro_rules! assert_iter_eq {
    /* macro_rules! assert_iter_eq {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_iter_eq`

**Attributes:**

- `#[macro_export]`

Assert an iterable is equal to another.

Pseudocode:<br>
(collection1 into iter) = (collection2 into iter)

This macro provides the same statements as [`assert_iter_eq`](macro.assert_iter_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_iter_eq`](macro@crate::assert_iter_eq)
* [`assert_iter_eq`](macro@crate::assert_iter_eq)
* [`debug_assert_iter_eq`](macro@crate::debug_assert_iter_eq)


```rust
pub macro_rules! debug_assert_iter_eq {
    /* macro_rules! debug_assert_iter_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_iter_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert an iterable is greater than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≥ (collection2 into iter)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_ge`](macro@crate::assert_iter_ge)
* [`assert_iter_ge_as_result`](macro@crate::assert_iter_ge_as_result)
* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)


```rust
pub macro_rules! assert_iter_ge_as_result {
    /* macro_rules! assert_iter_ge_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_iter_ge`

**Attributes:**

- `#[macro_export]`

Assert an iterable is greater than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≥ (collection2 into iter)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [3, 4];
let b = [1, 2];
assert_iter_ge!(&a, &b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [3, 4];
assert_iter_ge!(&a, &b);
# });
// assertion failed: `assert_iter_ge!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_iter_ge.html
//  a label: `&a`,
//  a debug: `[1, 2]`,
//  b label: `&b`,
//  b debug: `[3, 4]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_iter_ge!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_iter_ge.html\n",
#     " a label: `&a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `&b`,\n",
#     " b debug: `[3, 4]`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_ge`](macro@crate::assert_iter_ge)
* [`assert_iter_ge_as_result`](macro@crate::assert_iter_ge_as_result)
* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)


```rust
pub macro_rules! assert_iter_ge {
    /* macro_rules! assert_iter_ge {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_iter_ge`

**Attributes:**

- `#[macro_export]`

Assert an iterable is greater than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≥ (collection2 into iter)

This macro provides the same statements as [`assert_iter_ge`](macro.assert_iter_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_iter_ge`](macro@crate::assert_iter_ge)
* [`assert_iter_ge`](macro@crate::assert_iter_ge)
* [`debug_assert_iter_ge`](macro@crate::debug_assert_iter_ge)


```rust
pub macro_rules! debug_assert_iter_ge {
    /* macro_rules! debug_assert_iter_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_iter_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert an iterable is greater than another.

Pseudocode:<br>
(collection1 into iter) > (collection2 into iter)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_gt`](macro@crate::assert_iter_gt)
* [`assert_iter_gt_as_result`](macro@crate::assert_iter_gt_as_result)
* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)


```rust
pub macro_rules! assert_iter_gt_as_result {
    /* macro_rules! assert_iter_gt_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_iter_gt`

**Attributes:**

- `#[macro_export]`

Assert an iterable is greater than another.

Pseudocode:<br>
(collection1 into iter) > (collection2 into iter)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [3, 4];
let b = [1, 2];
assert_iter_gt!(&a, &b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [3, 4];
assert_iter_gt!(&a, &b);
# });
// assertion failed: `assert_iter_gt!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_iter_gt.html
//  a label: `&a`,
//  a debug: `[1, 2]`,
//  b label: `&b`,
//  b debug: `[3, 4]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_iter_gt!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_iter_gt.html\n",
#     " a label: `&a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `&b`,\n",
#     " b debug: `[3, 4]`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_gt`](macro@crate::assert_iter_gt)
* [`assert_iter_gt_as_result`](macro@crate::assert_iter_gt_as_result)
* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)


```rust
pub macro_rules! assert_iter_gt {
    /* macro_rules! assert_iter_gt {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_iter_gt`

**Attributes:**

- `#[macro_export]`

Assert an iterable is greater than another.

Pseudocode:<br>
(collection1 into iter) > (collection2 into iter)

This macro provides the same statements as [`assert_iter_gt`](macro.assert_iter_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_iter_gt`](macro@crate::assert_iter_gt)
* [`assert_iter_gt`](macro@crate::assert_iter_gt)
* [`debug_assert_iter_gt`](macro@crate::debug_assert_iter_gt)


```rust
pub macro_rules! debug_assert_iter_gt {
    /* macro_rules! debug_assert_iter_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_iter_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert an iterable is less than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≤ (collection2 into iter)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_le`](macro@crate::assert_iter_le)
* [`assert_iter_le_as_result`](macro@crate::assert_iter_le_as_result)
* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)


```rust
pub macro_rules! assert_iter_le_as_result {
    /* macro_rules! assert_iter_le_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_iter_le`

**Attributes:**

- `#[macro_export]`

Assert an iterable is less than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≤ (collection2 into iter)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [3, 4];
assert_iter_le!(&a, &b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [3, 4];
let b = [1, 2];
assert_iter_le!(&a, &b);
# });
// assertion failed: `assert_iter_le!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_iter_le.html
//  a label: `&a`,
//  a debug: `[3, 4]`,
//  b label: `&b`,
//  b debug: `[1, 2]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_iter_le!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_iter_le.html\n",
#     " a label: `&a`,\n",
#     " a debug: `[3, 4]`,\n",
#     " b label: `&b`,\n",
#     " b debug: `[1, 2]`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_le`](macro@crate::assert_iter_le)
* [`assert_iter_le_as_result`](macro@crate::assert_iter_le_as_result)
* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)


```rust
pub macro_rules! assert_iter_le {
    /* macro_rules! assert_iter_le {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_iter_le`

**Attributes:**

- `#[macro_export]`

Assert an iterable is less than or equal to another.

Pseudocode:<br>
(collection1 into iter) ≤ (collection2 into iter)

This macro provides the same statements as [`assert_iter_le`](macro.assert_iter_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_iter_le`](macro@crate::assert_iter_le)
* [`assert_iter_le`](macro@crate::assert_iter_le)
* [`debug_assert_iter_le`](macro@crate::debug_assert_iter_le)


```rust
pub macro_rules! debug_assert_iter_le {
    /* macro_rules! debug_assert_iter_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_iter_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert an iterable is less than another.

Pseudocode:<br>
(collection1 into iter) < (collection2 into iter)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_lt`](macro@crate::assert_iter_lt)
* [`assert_iter_lt_as_result`](macro@crate::assert_iter_lt_as_result)
* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)


```rust
pub macro_rules! assert_iter_lt_as_result {
    /* macro_rules! assert_iter_lt_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_iter_lt`

**Attributes:**

- `#[macro_export]`

Assert an iterable is less than another.

Pseudocode:<br>
(collection1 into iter) < (collection2 into iter)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [3, 4];
assert_iter_lt!(&a, &b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [3, 4];
let b = [1, 2];
assert_iter_lt!(&a, &b);
# });
// assertion failed: `assert_iter_lt!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_iter_lt.html
//  a label: `&a`,
//  a debug: `[3, 4]`,
//  b label: `&b`,
//  b debug: `[1, 2]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_iter_lt!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_iter_lt.html\n",
#     " a label: `&a`,\n",
#     " a debug: `[3, 4]`,\n",
#     " b label: `&b`,\n",
#     " b debug: `[1, 2]`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_lt`](macro@crate::assert_iter_lt)
* [`assert_iter_lt_as_result`](macro@crate::assert_iter_lt_as_result)
* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)


```rust
pub macro_rules! assert_iter_lt {
    /* macro_rules! assert_iter_lt {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_iter_lt`

**Attributes:**

- `#[macro_export]`

Assert an iterable is less than another.

Pseudocode:<br>
(collection1 into iter) < (collection2 into iter)

This macro provides the same statements as [`assert_iter_lt`](macro.assert_iter_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_iter_lt`](macro@crate::assert_iter_lt)
* [`assert_iter_lt`](macro@crate::assert_iter_lt)
* [`debug_assert_iter_lt`](macro@crate::debug_assert_iter_lt)


```rust
pub macro_rules! debug_assert_iter_lt {
    /* macro_rules! debug_assert_iter_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_iter_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert an iterable is not equal to another.

Pseudocode:<br>
(collection1 into iter) ≠ (collection2 into iter)

* If true, return Result `Ok(())`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_ne`](macro@crate::assert_iter_ne)
* [`assert_iter_ne_as_result`](macro@crate::assert_iter_ne_as_result)
* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)


```rust
pub macro_rules! assert_iter_ne_as_result {
    /* macro_rules! assert_iter_ne_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_iter_ne`

**Attributes:**

- `#[macro_export]`

Assert an iterable is not equal to another.

Pseudocode:<br>
(collection1 into iter) ≠ (collection2 into iter)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [3, 4];
assert_iter_ne!(&a, &b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [1, 2];
assert_iter_ne!(&a, &b);
# });
// assertion failed: `assert_iter_ne!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_iter_ne.html
//  a label: `&a`,
//  a debug: `[1, 2]`,
//  b label: `&b`,
//  b debug: `[1, 2]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_iter_ne!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_iter_ne.html\n",
#     " a label: `&a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `&b`,\n",
#     " b debug: `[1, 2]`",
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::iter::Iterator`](https://doc.rust-lang.org/std/iter/trait.Iterator.html).

# Module macros

* [`assert_iter_ne`](macro@crate::assert_iter_ne)
* [`assert_iter_ne_as_result`](macro@crate::assert_iter_ne_as_result)
* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)


```rust
pub macro_rules! assert_iter_ne {
    /* macro_rules! assert_iter_ne {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_iter_ne`

**Attributes:**

- `#[macro_export]`

Assert an iterable is not equal to another.

Pseudocode:<br>
(collection1 into iter) ≠ (collection2 into iter)

This macro provides the same statements as [`assert_iter_ne`](macro.assert_iter_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_iter_ne`](macro@crate::assert_iter_ne)
* [`assert_iter_ne`](macro@crate::assert_iter_ne)
* [`debug_assert_iter_ne`](macro@crate::debug_assert_iter_ne)


```rust
pub macro_rules! debug_assert_iter_ne {
    /* macro_rules! debug_assert_iter_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_set_impl_prep`

**Attributes:**

- `#[macro_export]`

Assert set implementation preparation.

```rust
pub macro_rules! assert_set_impl_prep {
    /* macro_rules! assert_set_impl_prep {
    ($impl_into_iter:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a set is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) = (b_collection ⇒ b_set)

* If true, return Result `Ok((a_set, b_set))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_eq`](macro@crate::assert_set_eq)
* [`assert_set_eq_as_result`](macro@crate::assert_set_eq_as_result)
* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)


```rust
pub macro_rules! assert_set_eq_as_result {
    /* macro_rules! assert_set_eq_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_eq`

**Attributes:**

- `#[macro_export]`

Assert a set is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) = (b_collection ⇒ b_set)

* If true, return `(a_set, b_set)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [2, 1];
assert_set_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [3, 4];
assert_set_eq!(a, b);
# });
// assertion failed: `assert_set_eq!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_set_eq.html
//  a label: `a`,
//  a debug: `[1, 2]`,
//  b label: `b`,
//  b debug: `[3, 4]`,
//        a: `{1, 2}`,
//        b: `{3, 4}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_set_eq!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_set_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[3, 4]`,\n",
#     "       a: `{1, 2}`,\n",
#     "       b: `{3, 4}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_eq`](macro@crate::assert_set_eq)
* [`assert_set_eq_as_result`](macro@crate::assert_set_eq_as_result)
* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)


```rust
pub macro_rules! assert_set_eq {
    /* macro_rules! assert_set_eq {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_set_eq`

**Attributes:**

- `#[macro_export]`

Assert a set is equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) = (b_collection ⇒ b_set)

This macro provides the same statements as [`assert_set_eq`](macro.assert_set_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_set_eq`](macro@crate::assert_set_eq)
* [`assert_set_eq`](macro@crate::assert_set_eq)
* [`debug_assert_set_eq`](macro@crate::debug_assert_set_eq)


```rust
pub macro_rules! debug_assert_set_eq {
    /* macro_rules! debug_assert_set_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_set_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a set is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)

* If true, return Result `Ok((a_set, b_set))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_set_ne`](macro@crate::assert_set_ne)
* [`assert_set_ne_as_result`](macro@crate::assert_set_ne_as_result)
* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)


```rust
pub macro_rules! assert_set_ne_as_result {
    /* macro_rules! assert_set_ne_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_ne`

**Attributes:**

- `#[macro_export]`

Assert a set is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)

* If true, return `(a_set, b_set)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [3, 4];
assert_set_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [1, 2];
assert_set_ne!(a, b);
# });
// assertion failed: `assert_set_ne!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_set_ne.html
//  a label: `a`,
//  a debug: `[1, 2]`,
//  b label: `b`,
//  b debug: `[1, 2]`,
//        a: `{1, 2}`,
//        b: `{1, 2}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_set_ne!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_set_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 2]`,\n",
#     "       a: `{1, 2}`,\n",
#     "       b: `{1, 2}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_ne`](macro@crate::assert_set_ne)
* [`assert_set_ne_as_result`](macro@crate::assert_set_ne_as_result)
* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)


```rust
pub macro_rules! assert_set_ne {
    /* macro_rules! assert_set_ne {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_set_ne`

**Attributes:**

- `#[macro_export]`

Assert a set is not equal to another.

Pseudocode:<br>
(a_collection ⇒ a_set) ≠ (b_collection ⇒ b_set)

This macro provides the same statements as [`assert_set_ne`](macro.assert_set_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_set_ne`](macro@crate::assert_set_ne)
* [`assert_set_ne`](macro@crate::assert_set_ne)
* [`debug_assert_set_ne`](macro@crate::debug_assert_set_ne)


```rust
pub macro_rules! debug_assert_set_ne {
    /* macro_rules! debug_assert_set_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_set_disjoint_as_result`

**Attributes:**

- `#[macro_export]`

Assert a set is disjoint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)

* If true, return Result `Ok((a_set, b_set))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)
* [`assert_set_disjoint_as_result`](macro@crate::assert_set_disjoint_as_result)
* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)


```rust
pub macro_rules! assert_set_disjoint_as_result {
    /* macro_rules! assert_set_disjoint_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_disjoint`

**Attributes:**

- `#[macro_export]`

Assert a set is disjoint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)

* If true, return `(a_set, b_set)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [3, 4];
assert_set_disjoint!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [2, 3];
assert_set_disjoint!(a, b);
# });
// assertion failed: `assert_set_disjoint!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_set_disjoint.html
//  a label: `a`,
//  a debug: `[1, 2]`,
//  b label: `b`,
//  b debug: `[2, 3]`,
//        a: `{1, 2}`,
//        b: `{2, 3}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_set_disjoint!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_set_disjoint.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[2, 3]`,\n",
#     "       a: `{1, 2}`,\n",
#     "       b: `{2, 3}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)
* [`assert_set_disjoint_as_result`](macro@crate::assert_set_disjoint_as_result)
* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)


```rust
pub macro_rules! assert_set_disjoint {
    /* macro_rules! assert_set_disjoint {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_set_disjoint`

**Attributes:**

- `#[macro_export]`

Assert a set is disjoint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⨃ (b_collection ⇒ b_set)

This macro provides the same statements as [`assert_set_disjoint`](macro.assert_set_disjoint.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)
* [`assert_set_disjoint`](macro@crate::assert_set_disjoint)
* [`debug_assert_set_disjoint`](macro@crate::debug_assert_set_disjoint)


```rust
pub macro_rules! debug_assert_set_disjoint {
    /* macro_rules! debug_assert_set_disjoint {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_set_joint_as_result`

**Attributes:**

- `#[macro_export]`

Assert a set is joint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)

* If true, return Result `Ok((a_set, b_set))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_set_joint`](macro@crate::assert_set_joint)
* [`assert_set_joint_as_result`](macro@crate::assert_set_joint_as_result)
* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)


```rust
pub macro_rules! assert_set_joint_as_result {
    /* macro_rules! assert_set_joint_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_joint`

**Attributes:**

- `#[macro_export]`

Assert a set is joint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)

* If true, return `(a_set, b_set)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [2, 3];
assert_set_joint!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [3, 4];
assert_set_joint!(a, b);
# });
// assertion failed: `assert_set_joint!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_set_joint.html
//  a label: `a`,
//  a debug: `[1, 2]`,
//  b label: `b`,
//  b debug: `[3, 4]`,
//        a: `{1, 2}`,
//        b: `{3, 4}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_set_joint!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_set_joint.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[3, 4]`,\n",
#     "       a: `{1, 2}`,\n",
#     "       b: `{3, 4}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_joint`](macro@crate::assert_set_joint)
* [`assert_set_joint_as_result`](macro@crate::assert_set_joint_as_result)
* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)


```rust
pub macro_rules! assert_set_joint {
    /* macro_rules! assert_set_joint {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_set_joint`

**Attributes:**

- `#[macro_export]`

Assert a set is joint with another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⋂ (b_collection ⇒ b_set)

This macro provides the same statements as [`assert_set_joint`](macro.assert_set_joint.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_set_joint`](macro@crate::assert_set_joint)
* [`assert_set_joint`](macro@crate::assert_set_joint)
* [`debug_assert_set_joint`](macro@crate::debug_assert_set_joint)


```rust
pub macro_rules! debug_assert_set_joint {
    /* macro_rules! debug_assert_set_joint {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_set_subset_as_result`

**Attributes:**

- `#[macro_export]`

Assert a set is a subset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)

* If true, return Result `Ok((a_set, b_set))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_set_subset`](macro@crate::assert_set_subset)
* [`assert_set_subset_as_result`](macro@crate::assert_set_subset_as_result)
* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)


```rust
pub macro_rules! assert_set_subset_as_result {
    /* macro_rules! assert_set_subset_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_subset`

**Attributes:**

- `#[macro_export]`

Assert a set is a subset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)

* If true, return `(a_set, b_set)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2];
let b = [1, 2, 3];
assert_set_subset!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2, 3];
let b = [1, 2];
assert_set_subset!(a, b);
# });
// assertion failed: `assert_set_subset!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_set_subset.html
//  a label: `a`,
//  a debug: `[1, 2, 3]`,
//  b label: `b`,
//  b debug: `[1, 2]`,
//        a: `{1, 2, 3}`,
//        b: `{1, 2}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_set_subset!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_set_subset.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 2, 3]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 2]`,\n",
#     "       a: `{1, 2, 3}`,\n",
#     "       b: `{1, 2}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_subset`](macro@crate::assert_set_subset)
* [`assert_set_subset_as_result`](macro@crate::assert_set_subset_as_result)
* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)


```rust
pub macro_rules! assert_set_subset {
    /* macro_rules! assert_set_subset {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_set_subset`

**Attributes:**

- `#[macro_export]`

Assert a set is a subset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊂ (b_collection ⇒ b_set)

This macro provides the same statements as [`assert_set_subset`](macro.assert_set_subset.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_set_subset`](macro@crate::assert_set_subset)
* [`assert_set_subset`](macro@crate::assert_set_subset)
* [`debug_assert_set_subset`](macro@crate::debug_assert_set_subset)


```rust
pub macro_rules! debug_assert_set_subset {
    /* macro_rules! debug_assert_set_subset {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_set_superset_as_result`

**Attributes:**

- `#[macro_export]`

Assert a set is a superset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)

* If true, return Result `Ok((a_set, b_set))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_superset`](macro@crate::assert_set_superset)
* [`assert_set_superset_as_result`](macro@crate::assert_set_superset_as_result)
* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)


```rust
pub macro_rules! assert_set_superset_as_result {
    /* macro_rules! assert_set_superset_as_result {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_set_superset`

**Attributes:**

- `#[macro_export]`

Assert a set is a superset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)

* If true, return `(a_set, b_set)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a = [1, 2, 3];
let b = [1, 2];
assert_set_superset!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = [1, 2];
let b = [1, 2, 3];
assert_set_superset!(a, b);
# });
// assertion failed: `assert_set_superset!(a_collection, b_collection)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_set_superset.html
//  a label: `a`,
//  a debug: `[1, 2]`,
//  b label: `b`,
//  b debug: `[1, 2, 3]`,
//        a: `{1, 2}`,
//        b: `{1, 2, 3}`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_set_superset!(a_collection, b_collection)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_set_superset.html\n",
#     " a label: `a`,\n",
#     " a debug: `[1, 2]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[1, 2, 3]`,\n",
#     "       a: `{1, 2}`,\n",
#     "       b: `{1, 2, 3}`"
# );
# assert_eq!(actual, message);
# }
```

This implementation uses [`::std::collections::BTreeSet`](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html) to count items and sort them.

# Module macros

* [`assert_set_superset`](macro@crate::assert_set_superset)
* [`assert_set_superset_as_result`](macro@crate::assert_set_superset_as_result)
* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)


```rust
pub macro_rules! assert_set_superset {
    /* macro_rules! assert_set_superset {
    ($a_collection:expr, $b_collection:expr $(,)?) => { ... };
    ($a_collection:expr, $b_collection:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_set_superset`

**Attributes:**

- `#[macro_export]`

Assert a set is a superset of another.

Pseudocode:<br>
(a_collection ⇒ a_set) ⊃ (b_collection ⇒ b_set)

This macro provides the same statements as [`assert_set_superset`](macro.assert_set_superset.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_set_superset`](macro@crate::assert_set_superset)
* [`assert_set_superset`](macro@crate::assert_set_superset)
* [`debug_assert_set_superset`](macro@crate::debug_assert_set_superset)


```rust
pub macro_rules! debug_assert_set_superset {
    /* macro_rules! debug_assert_set_superset {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is equal to another.

Pseudocode:<br>
a_function(a) == b_function(b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_eq`](macro@crate::assert_fn_eq)
* [`assert_fn_eq_as_result`](macro@crate::assert_fn_eq_as_result)
* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)


```rust
pub macro_rules! assert_fn_eq_as_result {
    /* macro_rules! assert_fn_eq_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_eq`

**Attributes:**

- `#[macro_export]`

Assert a function output is equal to another.

Pseudocode:<br>
a_function(a) == b_function(b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -1;
let b: i8 = 1;
assert_fn_eq!(i8::abs, a, i8::abs, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -1;
let b: i8 = 2;
assert_fn_eq!(i8::abs, a, i8::abs, b);
# });
// assertion failed: `assert_fn_eq!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_eq.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-1`,
//  b_function label: `i8::abs`,
//     b_param label: `b`,
//     b_param debug: `2`,
//                 a: `1`,
//                 b: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_eq!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_eq.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-1`,\n",
#     " b_function label: `i8::abs`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `2`,\n",
#     "                a: `1`,\n",
#     "                b: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_eq`](macro@crate::assert_fn_eq)
* [`assert_fn_eq_as_result`](macro@crate::assert_fn_eq_as_result)
* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)


```rust
pub macro_rules! assert_fn_eq {
    /* macro_rules! assert_fn_eq {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_eq`

**Attributes:**

- `#[macro_export]`

Assert a function output is equal to another.

Pseudocode:<br>
a_function(a) == b_function(b)

This macro provides the same statements as [`assert_fn_eq`](macro.assert_fn_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_eq`](macro@crate::assert_fn_eq)
* [`assert_fn_eq`](macro@crate::assert_fn_eq)
* [`debug_assert_fn_eq`](macro@crate::debug_assert_fn_eq)


```rust
pub macro_rules! debug_assert_fn_eq {
    /* macro_rules! debug_assert_fn_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than or equal to another.

Pseudocode:<br>
a_function(a) > b_function(b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ge`](macro@crate::assert_fn_ge)
* [`assert_fn_ge_as_result`](macro@crate::assert_fn_ge_as_result)
* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)


```rust
pub macro_rules! assert_fn_ge_as_result {
    /* macro_rules! assert_fn_ge_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ge`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than or equal to another.

Pseudocode:<br>
a_function(a) > b_function(b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -2;
let b: i8 = 1;
assert_fn_ge!(i8::abs, a, i8::abs, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b: i8 = -2;
assert_fn_ge!(i8::abs, a, i8::abs, b);
# });
// assertion failed: `assert_fn_ge!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ge.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `1`,
//  b_function label: `i8::abs`,
//     b_param label: `b`,
//     b_param debug: `-2`,
//                 a: `1`,
//                 b: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ge!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ge.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     " b_function label: `i8::abs`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `-2`,\n",
#     "                a: `1`,\n",
#     "                b: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ge`](macro@crate::assert_fn_ge)
* [`assert_fn_ge_as_result`](macro@crate::assert_fn_ge_as_result)
* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)


```rust
pub macro_rules! assert_fn_ge {
    /* macro_rules! assert_fn_ge {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path $(,)?) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ge`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than or equal to another.

Pseudocode:<br>
a_function(a) > b_function(b)

This macro provides the same statements as [`assert_fn_ge`](macro.assert_fn_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ge`](macro@crate::assert_fn_ge)
* [`assert_fn_ge`](macro@crate::assert_fn_ge)
* [`debug_assert_fn_ge`](macro@crate::debug_assert_fn_ge)


```rust
pub macro_rules! debug_assert_fn_ge {
    /* macro_rules! debug_assert_fn_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than another.

Pseudocode:<br>
a_function(a) > b_function(b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_gt`](macro@crate::assert_fn_gt)
* [`assert_fn_gt_as_result`](macro@crate::assert_fn_gt_as_result)
* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)


```rust
pub macro_rules! assert_fn_gt_as_result {
    /* macro_rules! assert_fn_gt_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_gt`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than another.

Pseudocode:<br>
a_function(a) > b_function(b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -2;
let b: i8 = 1;
assert_fn_gt!(i8::abs, a, i8::abs, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b: i8 = -2;
assert_fn_gt!(i8::abs, a, i8::abs, b);
# });
// assertion failed: `assert_fn_gt!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_gt.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `1`,
//  b_function label: `i8::abs`,
//     b_param label: `b`,
//     b_param debug: `-2`,
//                 a: `1`,
//                 b: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_gt!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_gt.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     " b_function label: `i8::abs`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `-2`,\n",
#     "                a: `1`,\n",
#     "                b: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_gt`](macro@crate::assert_fn_gt)
* [`assert_fn_gt_as_result`](macro@crate::assert_fn_gt_as_result)
* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)


```rust
pub macro_rules! assert_fn_gt {
    /* macro_rules! assert_fn_gt {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_gt`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than another.

Pseudocode:<br>
a_function(a) > b_function(b)

This macro provides the same statements as [`assert_fn_gt`](macro.assert_fn_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_gt`](macro@crate::assert_fn_gt)
* [`assert_fn_gt`](macro@crate::assert_fn_gt)
* [`debug_assert_fn_gt`](macro@crate::debug_assert_fn_gt)


```rust
pub macro_rules! debug_assert_fn_gt {
    /* macro_rules! debug_assert_fn_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than or equal to another.

Pseudocode:<br>
a_function(a) ≤ b_function(b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

# Examples

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_le`](macro@crate::assert_fn_le)
* [`assert_fn_le_as_result`](macro@crate::assert_fn_le_as_result)
* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)


```rust
pub macro_rules! assert_fn_le_as_result {
    /* macro_rules! assert_fn_le_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_le`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than or equal to another.

Pseudocode:<br>
a_function(a) ≤ b_function(b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 1;
let b: i8 = -2;
assert_fn_le!(i8::abs, a, i8::abs, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -2;
let b: i8 = 1;
assert_fn_le!(i8::abs, a, i8::abs, b);
# });
// assertion failed: `assert_fn_le!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_le.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-2`,
//  b_function label: `i8::abs`,
//     b_param label: `b`,
//     b_param debug: `1`,
//                 a: `2`,
//                 b: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_le!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_le.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-2`,\n",
#     " b_function label: `i8::abs`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `1`,\n",
#     "                a: `2`,\n",
#     "                b: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_le`](macro@crate::assert_fn_le)
* [`assert_fn_le_as_result`](macro@crate::assert_fn_le_as_result)
* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)


```rust
pub macro_rules! assert_fn_le {
    /* macro_rules! assert_fn_le {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_le`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than or equal to another.

Pseudocode:<br>
a_function(a) ≤ b_function(b)

This macro provides the same statements as [`assert_fn_le`](macro.assert_fn_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_le`](macro@crate::assert_fn_le)
* [`assert_fn_le`](macro@crate::assert_fn_le)
* [`debug_assert_fn_le`](macro@crate::debug_assert_fn_le)


```rust
pub macro_rules! debug_assert_fn_le {
    /* macro_rules! debug_assert_fn_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than another.

Pseudocode:<br>
a_function(a) < b_function(b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_lt`](macro@crate::assert_fn_lt)
* [`assert_fn_lt_as_result`](macro@crate::assert_fn_lt_as_result)
* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)


```rust
pub macro_rules! assert_fn_lt_as_result {
    /* macro_rules! assert_fn_lt_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_lt`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than another.

Pseudocode:<br>
a_function(a) < b_function(b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 1;
let b: i8 = -2;
assert_fn_lt!(i8::abs, a, i8::abs, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -2;
let b: i8 = 1;
assert_fn_lt!(i8::abs, a, i8::abs, b);
# });
// assertion failed: `assert_fn_lt!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_lt.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-2`,
//  b_function label: `i8::abs`,
//     b_param label: `b`,
//     b_param debug: `1`,
//                 a: `2`,
//                 b: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_lt!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_lt.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-2`,\n",
#     " b_function label: `i8::abs`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `1`,\n",
#     "                a: `2`,\n",
#     "                b: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_lt`](macro@crate::assert_fn_lt)
* [`assert_fn_lt_as_result`](macro@crate::assert_fn_lt_as_result)
* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)


```rust
pub macro_rules! assert_fn_lt {
    /* macro_rules! assert_fn_lt {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_lt`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than another.

Pseudocode:<br>
a_function(a) < b_function(b)

This macro provides the same statements as [`assert_fn_lt`](macro.assert_fn_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_lt`](macro@crate::assert_fn_lt)
* [`assert_fn_lt`](macro@crate::assert_fn_lt)
* [`debug_assert_fn_lt`](macro@crate::debug_assert_fn_lt)


```rust
pub macro_rules! debug_assert_fn_lt {
    /* macro_rules! debug_assert_fn_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is not equal to another.

Pseudocode:<br>
a_function(a) ≠ b_function(b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ne`](macro@crate::assert_fn_ne)
* [`assert_fn_ne_as_result`](macro@crate::assert_fn_ne_as_result)
* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)


```rust
pub macro_rules! assert_fn_ne_as_result {
    /* macro_rules! assert_fn_ne_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ne`

**Attributes:**

- `#[macro_export]`

Assert a function output is not equal to another.

Pseudocode:<br>
a_function(a) ≠ b_function(b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -1;
let b: i8 = 2;
assert_fn_ne!(i8::abs, a, i8::abs, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -1;
let b: i8 = 1;
assert_fn_ne!(i8::abs, a, i8::abs, b);
# });
// assertion failed: `assert_fn_ne!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ne.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-1`,
//  b_function label: `i8::abs`,
//     b_param label: `b`,
//     b_param debug: `1`,
//                 a: `1`,
//                 b: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ne!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ne.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-1`,\n",
#     " b_function label: `i8::abs`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `1`,\n",
#     "                a: `1`,\n",
#     "                b: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ne`](macro@crate::assert_fn_ne)
* [`assert_fn_ne_as_result`](macro@crate::assert_fn_ne_as_result)
* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)


```rust
pub macro_rules! assert_fn_ne {
    /* macro_rules! assert_fn_ne {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ne`

**Attributes:**

- `#[macro_export]`

Assert a function output is not equal to another.

Pseudocode:<br>
a_function(a) ≠ b_function(b)

This macro provides the same statements as [`assert_fn_ne`](macro.assert_fn_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ne`](macro@crate::assert_fn_ne)
* [`assert_fn_ne`](macro@crate::assert_fn_ne)
* [`debug_assert_fn_ne`](macro@crate::debug_assert_fn_ne)


```rust
pub macro_rules! debug_assert_fn_ne {
    /* macro_rules! debug_assert_fn_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is equal to an expression.

Pseudocode:<br>
function(a) = b

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)
* [`assert_fn_eq_x_as_result`](macro@crate::assert_fn_eq_x_as_result)
* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)


```rust
pub macro_rules! assert_fn_eq_x_as_result {
    /* macro_rules! assert_fn_eq_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is equal to an expression.

Pseudocode:<br>
function(a) = b

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -1;
let b: i8 = 1;
assert_fn_eq_x!(i8::abs, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -1;
let b: i8 = 2;
assert_fn_eq_x!(i8::abs, a, b);
# });
// assertion failed: `assert_fn_eq_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_eq_x.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-1`,
//      b_expr label: `b`,
//      b_expr debug: `2`,
//                 a: `1`,
//                 b: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_eq_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_eq_x.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `2`,\n",
#     "                a: `1`,\n",
#     "                b: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)
* [`assert_fn_eq_x_as_result`](macro@crate::assert_fn_eq_x_as_result)
* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)


```rust
pub macro_rules! assert_fn_eq_x {
    /* macro_rules! assert_fn_eq_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is equal to an expression.

Pseudocode:<br>
function(a) = b

This macro provides the same statements as [`assert_fn_eq_x`](macro.assert_fn_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)
* [`assert_fn_eq_x`](macro@crate::assert_fn_eq_x)
* [`debug_assert_fn_eq_x`](macro@crate::debug_assert_fn_eq_x)


```rust
pub macro_rules! debug_assert_fn_eq_x {
    /* macro_rules! debug_assert_fn_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than or equal to an expression.

Pseudocode:<br>
function(a) ≥ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)
* [`assert_fn_ge_x_as_result`](macro@crate::assert_fn_ge_x_as_result)
* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)


```rust
pub macro_rules! assert_fn_ge_x_as_result {
    /* macro_rules! assert_fn_ge_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than or equal to an expression.

Pseudocode:<br>
function(a) ≥ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -2;
let b: i8 = 1;
assert_fn_ge_x!(i8::abs, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -1;
let b: i8 = 2;
assert_fn_ge_x!(i8::abs, a, b);
# });
// assertion failed: `assert_fn_ge_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ge_x.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-1`,
//      b_expr label: `b`,
//      b_expr debug: `2`,
//                 a: `1`,
//                 b: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ge_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ge_x.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `2`,\n",
#     "                a: `1`,\n",
#     "                b: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)
* [`assert_fn_ge_x_as_result`](macro@crate::assert_fn_ge_x_as_result)
* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)


```rust
pub macro_rules! assert_fn_ge_x {
    /* macro_rules! assert_fn_ge_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than or equal to an expression.

Pseudocode:<br>
function(a) ≥ expr

This macro provides the same statements as [`assert_fn_ge_x`](macro.assert_fn_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)
* [`assert_fn_ge_x`](macro@crate::assert_fn_ge_x)
* [`debug_assert_fn_ge_x`](macro@crate::debug_assert_fn_ge_x)


```rust
pub macro_rules! debug_assert_fn_ge_x {
    /* macro_rules! debug_assert_fn_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than an expression.

Pseudocode:<br>
function(a) > b

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)
* [`assert_fn_gt_x_as_result`](macro@crate::assert_fn_gt_x_as_result)
* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)


```rust
pub macro_rules! assert_fn_gt_x_as_result {
    /* macro_rules! assert_fn_gt_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than an expression.

Pseudocode:<br>
function(a) > b

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -2;
let b: i8 = 1;
assert_fn_gt_x!(i8::abs, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -1;
let b: i8 = 2;
assert_fn_gt_x!(i8::abs, a, b);
# });
// assertion failed: `assert_fn_gt_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_gt_x.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-1`,
//      b_expr label: `b`,
//      b_expr debug: `2`,
//                 a: `1`,
//                 b: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_gt_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_gt_x.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `2`,\n",
#     "                a: `1`,\n",
#     "                b: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)
* [`assert_fn_gt_x_as_result`](macro@crate::assert_fn_gt_x_as_result)
* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)


```rust
pub macro_rules! assert_fn_gt_x {
    /* macro_rules! assert_fn_gt_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is greater than an expression.

Pseudocode:<br>
function(a) > b

This macro provides the same statements as [`assert_fn_gt_x`](macro.assert_fn_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)
* [`assert_fn_gt_x`](macro@crate::assert_fn_gt_x)
* [`debug_assert_fn_gt_x`](macro@crate::debug_assert_fn_gt_x)


```rust
pub macro_rules! debug_assert_fn_gt_x {
    /* macro_rules! debug_assert_fn_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than or equal to an expression.

Pseudocode:<br>
function(a) ≤ b

* If true, return `Ok(a)`.

* Otherwise, return [`Err`] with a message and the values of the
  expressions with their debug representations.

# Examples

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)
* [`assert_fn_le_x_as_result`](macro@crate::assert_fn_le_x_as_result)
* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)


```rust
pub macro_rules! assert_fn_le_x_as_result {
    /* macro_rules! assert_fn_le_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_le_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than or equal to an expression.

Pseudocode:<br>
function(a) ≤ b

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -1;
let b: i8 = 2;
assert_fn_le_x!(i8::abs, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -2;
let b: i8 = 1;
assert_fn_le_x!(i8::abs, a, b);
# });
// assertion failed: `assert_fn_le_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_le_x.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-2`,
//      b_expr label: `b`,
//      b_expr debug: `1`,
//                 a: `2`,
//                 b: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_le_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_le_x.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-2`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `1`,\n",
#     "                a: `2`,\n",
#     "                b: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)
* [`assert_fn_le_x_as_result`](macro@crate::assert_fn_le_x_as_result)
* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)


```rust
pub macro_rules! assert_fn_le_x {
    /* macro_rules! assert_fn_le_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_le_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than or equal to an expression.

Pseudocode:<br>
function(a) ≤ b

This macro provides the same statements as [`assert_fn_le_x`](macro.assert_fn_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)
* [`assert_fn_le_x`](macro@crate::assert_fn_le_x)
* [`debug_assert_fn_le_x`](macro@crate::debug_assert_fn_le_x)


```rust
pub macro_rules! debug_assert_fn_le_x {
    /* macro_rules! debug_assert_fn_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than an expression.

Pseudocode:<br>
a_function(a) < b

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)
* [`assert_fn_lt_x_as_result`](macro@crate::assert_fn_lt_x_as_result)
* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)


```rust
pub macro_rules! assert_fn_lt_x_as_result {
    /* macro_rules! assert_fn_lt_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than an expression.

Pseudocode:<br>
a_function(a) < b

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = -1;
let b: i8 = 2;
assert_fn_lt_x!(i8::abs, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -2;
let b: i8 = 1;
assert_fn_lt_x!(i8::abs, a, b);
# });
// assertion failed: `assert_fn_lt_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_lt_x.html
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-2`,
//      b_expr label: `b`,
//      b_expr debug: `1`,
//                 a: `2`,
//                 b: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_lt_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_lt_x.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-2`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `1`,\n",
#     "                a: `2`,\n",
#     "                b: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)
* [`assert_fn_lt_x_as_result`](macro@crate::assert_fn_lt_x_as_result)
* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)


```rust
pub macro_rules! assert_fn_lt_x {
    /* macro_rules! assert_fn_lt_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is less than an expression.

Pseudocode:<br>
a_function(a) < b

This macro provides the same statements as [`assert_fn_lt_x`](macro.assert_fn_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)
* [`assert_fn_lt_x`](macro@crate::assert_fn_lt_x)
* [`debug_assert_fn_lt_x`](macro@crate::debug_assert_fn_lt_x)


```rust
pub macro_rules! debug_assert_fn_lt_x {
    /* macro_rules! debug_assert_fn_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function output is not equal to an expression.

Pseudocode:<br>
function(a) ≠ b

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)
* [`assert_fn_ne_x_as_result`](macro@crate::assert_fn_ne_x_as_result)
* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)


```rust
pub macro_rules! assert_fn_ne_x_as_result {
    /* macro_rules! assert_fn_ne_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is not equal to an expression.

Pseudocode:<br>
function(a) ≠ b

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a: i8 = 1;
let b: i8 = -2;
assert_fn_ne_x!(i8::abs, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = -1;
let b: i8 = 1;
assert_fn_ne_x!(i8::abs, a, b);
# });
//  a_function label: `i8::abs`,
//     a_param label: `a`,
//     a_param debug: `-1`,
//      b_expr label: `b`,
//      b_expr debug: `1`,
//                 a: `1`,
//                 b: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ne_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ne_x.html\n",
#     " a_function label: `i8::abs`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `-1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `1`,\n",
#     "                a: `1`,\n",
#     "                b: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)
* [`assert_fn_ne_x_as_result`](macro@crate::assert_fn_ne_x_as_result)
* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)


```rust
pub macro_rules! assert_fn_ne_x {
    /* macro_rules! assert_fn_ne_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a function output is not equal to an expression.

Pseudocode:<br>
function(a) ≠ b

This macro provides the same statements as [`assert_fn_ne_x`](macro.assert_fn_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)
* [`assert_fn_ne_x`](macro@crate::assert_fn_ne_x)
* [`debug_assert_fn_ne_x`](macro@crate::debug_assert_fn_ne_x)


```rust
pub macro_rules! debug_assert_fn_ne_x {
    /* macro_rules! debug_assert_fn_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)

* e, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)
* [`assert_fn_err_eq_as_result`](macro@crate::assert_fn_err_eq_as_result)
* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)


```rust
pub macro_rules! assert_fn_err_eq_as_result {
    /* macro_rules! assert_fn_err_eq_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_err_eq`

**Attributes:**

- `#[macro_export]`

Assert a function error is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)

* e, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b: i8 = 10;
assert_fn_err_eq!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_eq!(f, a, f, b);
# });
// assertion failed: `assert_fn_err_eq!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_eq.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `20`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"20 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_eq!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_eq.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `20`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"20 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)
* [`assert_fn_err_eq_as_result`](macro@crate::assert_fn_err_eq_as_result)
* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)


```rust
pub macro_rules! assert_fn_err_eq {
    /* macro_rules! assert_fn_err_eq {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_eq`

**Attributes:**

- `#[macro_export]`

Assert a function error is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) = (b_function(b_param) ⇒ Err(b) ⇒ b)

This macro provides the same statements as [`assert_fn_err_eq`](macro.assert_fn_err_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)
* [`assert_fn_err_eq`](macro@crate::assert_fn_err_eq)
* [`debug_assert_fn_err_eq`](macro@crate::debug_assert_fn_err_eq)


```rust
pub macro_rules! debug_assert_fn_err_eq {
    /* macro_rules! debug_assert_fn_err_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)
* [`assert_fn_err_ge_as_result`](macro@crate::assert_fn_err_ge_as_result)
* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)


```rust
pub macro_rules! assert_fn_err_ge_as_result {
    /* macro_rules! assert_fn_err_ge_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_err_ge`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 20;
let b: i8 = 10;
assert_fn_err_ge!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_ge!(f, a, f, b);
# });
// assertion failed: `assert_fn_err_ge!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_ge.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `20`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"20 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_ge!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_ge.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `20`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"20 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)
* [`assert_fn_err_ge_as_result`](macro@crate::assert_fn_err_ge_as_result)
* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)


```rust
pub macro_rules! assert_fn_err_ge {
    /* macro_rules! assert_fn_err_ge {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_ge`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≥ (b_function(b_param) ⇒ Err(b) ⇒ b)

This macro provides the same statements as [`assert_fn_err_ge`](macro.assert_fn_err_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)
* [`assert_fn_err_ge`](macro@crate::assert_fn_err_ge)
* [`debug_assert_fn_err_ge`](macro@crate::debug_assert_fn_err_ge)


```rust
pub macro_rules! debug_assert_fn_err_ge {
    /* macro_rules! debug_assert_fn_err_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)
* [`assert_fn_err_gt_as_result`](macro@crate::assert_fn_err_gt_as_result)
* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)


```rust
pub macro_rules! assert_fn_err_gt_as_result {
    /* macro_rules! assert_fn_err_gt_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_err_gt`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 20;
let b: i8 = 10;
assert_fn_err_gt!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_gt!(f, a, f, b);
# });
// assertion failed: `assert_fn_err_gt!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_gt.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `20`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"20 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_gt!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_gt.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `20`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"20 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)
* [`assert_fn_err_gt_as_result`](macro@crate::assert_fn_err_gt_as_result)
* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)


```rust
pub macro_rules! assert_fn_err_gt {
    /* macro_rules! assert_fn_err_gt {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_gt`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) > (b_function(b_param) ⇒ Err(b) ⇒ b)

This macro provides the same statements as [`assert_fn_err_gt`](macro.assert_fn_err_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)
* [`assert_fn_err_gt`](macro@crate::assert_fn_err_gt)
* [`debug_assert_fn_err_gt`](macro@crate::debug_assert_fn_err_gt)


```rust
pub macro_rules! debug_assert_fn_err_gt {
    /* macro_rules! debug_assert_fn_err_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)
* [`assert_fn_err_le_as_result`](macro@crate::assert_fn_err_le_as_result)
* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)


```rust
pub macro_rules! assert_fn_err_le_as_result {
    /* macro_rules! assert_fn_err_le_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_err_le`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_le!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 20;
let b: i8 = 10;
assert_fn_err_le!(f, a, f, b);
# });
// assertion failed: `assert_fn_err_le!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_le.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `20`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `10`,
//                 a: `\"20 is out of range\"`,
//                 b: `\"10 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_le!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_le.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `20`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `10`,\n",
#     "                a: `\"20 is out of range\"`,\n",
#     "                b: `\"10 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)
* [`assert_fn_err_le_as_result`](macro@crate::assert_fn_err_le_as_result)
* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)


```rust
pub macro_rules! assert_fn_err_le {
    /* macro_rules! assert_fn_err_le {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_le`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

This macro provides the same statements as [`assert_fn_err_le`](macro.assert_fn_err_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)
* [`assert_fn_err_le`](macro@crate::assert_fn_err_le)
* [`debug_assert_fn_err_le`](macro@crate::debug_assert_fn_err_le)


```rust
pub macro_rules! debug_assert_fn_err_le {
    /* macro_rules! debug_assert_fn_err_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than another.

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)
* [`assert_fn_err_lt_as_result`](macro@crate::assert_fn_err_lt_as_result)
* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)


```rust
pub macro_rules! assert_fn_err_lt_as_result {
    /* macro_rules! assert_fn_err_lt_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_err_lt`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than another.

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_lt!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 20;
let b: i8 = 10;
assert_fn_err_lt!(f, a, f, b);
# });
// assertion failed: `assert_fn_err_lt!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_lt.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `20`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `10`,
//                 a: `\"20 is out of range\"`,
//                 b: `\"10 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_lt!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_lt.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `20`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `10`,\n",
#     "                a: `\"20 is out of range\"`,\n",
#     "                b: `\"10 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)
* [`assert_fn_err_lt_as_result`](macro@crate::assert_fn_err_lt_as_result)
* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)


```rust
pub macro_rules! assert_fn_err_lt {
    /* macro_rules! assert_fn_err_lt {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_lt`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than another.

This macro provides the same statements as [`assert_fn_err_lt`](macro.assert_fn_err_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)
* [`assert_fn_err_lt`](macro@crate::assert_fn_err_lt)
* [`debug_assert_fn_err_lt`](macro@crate::debug_assert_fn_err_lt)


```rust
pub macro_rules! debug_assert_fn_err_lt {
    /* macro_rules! debug_assert_fn_err_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)
* [`assert_fn_err_ne_as_result`](macro@crate::assert_fn_err_ne_as_result)
* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)


```rust
pub macro_rules! assert_fn_err_ne_as_result {
    /* macro_rules! assert_fn_err_ne_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_err_ne`

**Attributes:**

- `#[macro_export]`

Assert a function error is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b: i8 = 20;
assert_fn_err_ne!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b: i8 = 10;
assert_fn_err_ne!(f, a, f, b);
# });
// assertion failed: `assert_fn_err_ne!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_ne.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `10`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"10 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_ne!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_ne.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `10`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"10 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)
* [`assert_fn_err_ne_as_result`](macro@crate::assert_fn_err_ne_as_result)
* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)


```rust
pub macro_rules! assert_fn_err_ne {
    /* macro_rules! assert_fn_err_ne {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_ne`

**Attributes:**

- `#[macro_export]`

Assert a function error is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Err(a) ⇒ a) ≤ (b_function(b_param) ⇒ Err(b) ⇒ b)

This macro provides the same statements as [`assert_fn_err_ne`](macro.assert_fn_err_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)
* [`assert_fn_err_ne`](macro@crate::assert_fn_err_ne)
* [`debug_assert_fn_err_ne`](macro@crate::debug_assert_fn_err_ne)


```rust
pub macro_rules! debug_assert_fn_err_ne {
    /* macro_rules! debug_assert_fn_err_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) = expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)
* [`assert_fn_err_eq_x_as_result`](macro@crate::assert_fn_err_eq_x_as_result)
* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)


```rust
pub macro_rules! assert_fn_err_eq_x_as_result {
    /* macro_rules! assert_fn_err_eq_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_err_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) = expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b = String::from("10 is out of range");
assert_fn_err_eq_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_eq_x!(f, a, b);
# });
// assertion failed: `assert_fn_err_eq_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_eq_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//      b_expr label: `b`,
//      b_expr debug: `\"20 is out of range\"`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"20 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_eq_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_eq_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"20 is out of range\"`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"20 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)
* [`assert_fn_err_eq_x_as_result`](macro@crate::assert_fn_err_eq_x_as_result)
* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)


```rust
pub macro_rules! assert_fn_err_eq_x {
    /* macro_rules! assert_fn_err_eq_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) = expr

This macro provides the same statements as [`assert_fn_err_eq_x`](macro.assert_fn_err_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)
* [`assert_fn_err_eq_x`](macro@crate::assert_fn_err_eq_x)
* [`debug_assert_fn_err_eq_x`](macro@crate::debug_assert_fn_err_eq_x)


```rust
pub macro_rules! debug_assert_fn_err_eq_x {
    /* macro_rules! debug_assert_fn_err_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≥ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)
* [`assert_fn_err_ge_x_as_result`](macro@crate::assert_fn_err_ge_x_as_result)
* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)


```rust
pub macro_rules! assert_fn_err_ge_x_as_result {
    /* macro_rules! assert_fn_err_ge_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_err_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≥ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 20;
let b = String::from("10 is out of range");
assert_fn_err_ge_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_ge_x!(f, a, b);
# });
// assertion failed: `assert_fn_err_ge_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_ge_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//      b_expr label: `b`,
//      b_expr debug: `\"20 is out of range\"`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"20 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_ge_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_ge_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"20 is out of range\"`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"20 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)
* [`assert_fn_err_ge_x_as_result`](macro@crate::assert_fn_err_ge_x_as_result)
* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)


```rust
pub macro_rules! assert_fn_err_ge_x {
    /* macro_rules! assert_fn_err_ge_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≥ expr

This macro provides the same statements as [`assert_fn_err_ge_x`](macro.assert_fn_err_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)
* [`assert_fn_err_ge_x`](macro@crate::assert_fn_err_ge_x)
* [`debug_assert_fn_err_ge_x`](macro@crate::debug_assert_fn_err_ge_x)


```rust
pub macro_rules! debug_assert_fn_err_ge_x {
    /* macro_rules! debug_assert_fn_err_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) > expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)
* [`assert_fn_err_gt_x_as_result`](macro@crate::assert_fn_err_gt_x_as_result)
* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)


```rust
pub macro_rules! assert_fn_err_gt_x_as_result {
    /* macro_rules! assert_fn_err_gt_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_err_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) > expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 20;
let b = String::from("10 is out of range");
assert_fn_err_gt_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_gt_x!(f, a, b);
# });
// assertion failed: `assert_fn_err_gt_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_gt_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//      b_expr label: `b`,
//      b_expr debug: `\"20 is out of range\"`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"20 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_gt_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_gt_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"20 is out of range\"`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"20 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)
* [`assert_fn_err_gt_x_as_result`](macro@crate::assert_fn_err_gt_x_as_result)
* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)


```rust
pub macro_rules! assert_fn_err_gt_x {
    /* macro_rules! assert_fn_err_gt_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is greater than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) > expr

This macro provides the same statements as [`assert_fn_err_gt_x`](macro.assert_fn_err_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)
* [`assert_fn_err_gt_x`](macro@crate::assert_fn_err_gt_x)
* [`debug_assert_fn_err_gt_x`](macro@crate::debug_assert_fn_err_gt_x)


```rust
pub macro_rules! debug_assert_fn_err_gt_x {
    /* macro_rules! debug_assert_fn_err_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≤ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)
* [`assert_fn_err_le_x_as_result`](macro@crate::assert_fn_err_le_x_as_result)
* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)


```rust
pub macro_rules! assert_fn_err_le_x_as_result {
    /* macro_rules! assert_fn_err_le_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_err_le_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≤ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_le_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 20;
let b = String::from("10 is out of range");
assert_fn_err_le_x!(f, a, b);
# });
// assertion failed: `assert_fn_err_le_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_le_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `20`,
//      b_expr label: `b`,
//      b_expr debug: `\"10 is out of range\"`,
//                 a: `\"20 is out of range\"`,
//                 b: `\"10 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_le_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_le_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `20`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"10 is out of range\"`,\n",
#     "                a: `\"20 is out of range\"`,\n",
#     "                b: `\"10 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)
* [`assert_fn_err_le_x_as_result`](macro@crate::assert_fn_err_le_x_as_result)
* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)


```rust
pub macro_rules! assert_fn_err_le_x {
    /* macro_rules! assert_fn_err_le_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_le_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than or equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≤ expr

This macro provides the same statements as [`assert_fn_err_le_x`](macro.assert_fn_err_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)
* [`assert_fn_err_le_x`](macro@crate::assert_fn_err_le_x)
* [`debug_assert_fn_err_le_x`](macro@crate::debug_assert_fn_err_le_x)


```rust
pub macro_rules! debug_assert_fn_err_le_x {
    /* macro_rules! debug_assert_fn_err_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) < expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)
* [`assert_fn_err_lt_x_as_result`](macro@crate::assert_fn_err_lt_x_as_result)
* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)


```rust
pub macro_rules! assert_fn_err_lt_x_as_result {
    /* macro_rules! assert_fn_err_lt_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_err_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) < expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_lt_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 20;
let b = String::from("10 is out of range");
assert_fn_err_lt_x!(f, a, b);
# });
// assertion failed: `assert_fn_err_lt_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_lt_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `20`,
//      b_expr label: `b`,
//      b_expr debug: `\"10 is out of range\"`,
//                 a: `\"20 is out of range\"`,
//                 b: `\"10 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_lt_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_lt_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `20`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"10 is out of range\"`,\n",
#     "                a: `\"20 is out of range\"`,\n",
#     "                b: `\"10 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)
* [`assert_fn_err_lt_x_as_result`](macro@crate::assert_fn_err_lt_x_as_result)
* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)


```rust
pub macro_rules! assert_fn_err_lt_x {
    /* macro_rules! assert_fn_err_lt_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is less than an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) < expr

This macro provides the same statements as [`assert_fn_err_lt_x`](macro.assert_fn_err_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)
* [`assert_fn_err_lt_x`](macro@crate::assert_fn_err_lt_x)
* [`debug_assert_fn_err_lt_x`](macro@crate::debug_assert_fn_err_lt_x)


```rust
pub macro_rules! debug_assert_fn_err_lt_x {
    /* macro_rules! debug_assert_fn_err_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_err_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function error is not equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≠ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)
* [`assert_fn_err_ne_x_as_result`](macro@crate::assert_fn_err_ne_x_as_result)
* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)


```rust
pub macro_rules! assert_fn_err_ne_x_as_result {
    /* macro_rules! assert_fn_err_ne_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_err_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is not equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≠ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 10;
let b = String::from("20 is out of range");
assert_fn_err_ne_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 10;
let b = String::from("10 is out of range");
assert_fn_err_ne_x!(f, a, b);
# });
// assertion failed: `assert_fn_err_ne_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_err_ne_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `10`,
//      b_expr label: `b`,
//      b_expr debug: `\"10 is out of range\"`,
//                 a: `\"10 is out of range\"`,
//                 b: `\"10 is out of range\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_err_ne_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_err_ne_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `10`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"10 is out of range\"`,\n",
#     "                a: `\"10 is out of range\"`,\n",
#     "                b: `\"10 is out of range\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)
* [`assert_fn_err_ne_x_as_result`](macro@crate::assert_fn_err_ne_x_as_result)
* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)


```rust
pub macro_rules! assert_fn_err_ne_x {
    /* macro_rules! assert_fn_err_ne_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_err_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a function error is not equal to an expression.

Pseudocode:<br>
(function(param) ⇒ Err(a) ⇒ a) ≠ expr

This macro provides the same statements as [`assert_fn_err_ne_x`](macro.assert_fn_err_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)
* [`assert_fn_err_ne_x`](macro@crate::assert_fn_err_ne_x)
* [`debug_assert_fn_err_ne_x`](macro@crate::debug_assert_fn_err_ne_x)


```rust
pub macro_rules! debug_assert_fn_err_ne_x {
    /* macro_rules! debug_assert_fn_err_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)
* [`assert_fn_ok_eq_as_result`](macro@crate::assert_fn_ok_eq_as_result)
* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)


```rust
pub macro_rules! assert_fn_ok_eq_as_result {
    /* macro_rules! assert_fn_ok_eq_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ok_eq`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b: i8 = 1;
assert_fn_ok_eq!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_eq!(f, a, f, b);
# });
// assertion failed: `assert_fn_ok_eq!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_eq.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `2`,
//                 a: `\"1\"`,
//                 b: `\"2\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_eq!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_eq.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `2`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"2\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)
* [`assert_fn_ok_eq_as_result`](macro@crate::assert_fn_ok_eq_as_result)
* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)


```rust
pub macro_rules! assert_fn_ok_eq {
    /* macro_rules! assert_fn_ok_eq {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_eq`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = (b_function(b_param) ⇒ Ok(b) ⇒ b)

This macro provides the same statements as [`assert_fn_ok_eq`](macro.assert_fn_ok_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)
* [`assert_fn_ok_eq`](macro@crate::assert_fn_ok_eq)
* [`debug_assert_fn_ok_eq`](macro@crate::debug_assert_fn_ok_eq)


```rust
pub macro_rules! debug_assert_fn_ok_eq {
    /* macro_rules! debug_assert_fn_ok_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)
* [`assert_fn_ok_ge_as_result`](macro@crate::assert_fn_ok_ge_as_result)
* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)


```rust
pub macro_rules! assert_fn_ok_ge_as_result {
    /* macro_rules! assert_fn_ok_ge_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ok_ge`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 2;
let b: i8 = 1;
assert_fn_ok_ge!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_ge!(f, a, f, b);
# });
// assertion failed: `assert_fn_ok_ge!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_ge.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `2`,
//                 a: `\"1\"`,
//                 b: `\"2\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_ge!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_ge.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `2`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"2\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)
* [`assert_fn_ok_ge_as_result`](macro@crate::assert_fn_ok_ge_as_result)
* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)


```rust
pub macro_rules! assert_fn_ok_ge {
    /* macro_rules! assert_fn_ok_ge {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_ge`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ (b_function(b_param) ⇒ Ok(b) ⇒ b)

This macro provides the same statements as [`assert_fn_ok_ge`](macro.assert_fn_ok_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)
* [`assert_fn_ok_ge`](macro@crate::assert_fn_ok_ge)
* [`debug_assert_fn_ok_ge`](macro@crate::debug_assert_fn_ok_ge)


```rust
pub macro_rules! debug_assert_fn_ok_ge {
    /* macro_rules! debug_assert_fn_ok_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)
* [`assert_fn_ok_gt_as_result`](macro@crate::assert_fn_ok_gt_as_result)
* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)


```rust
pub macro_rules! assert_fn_ok_gt_as_result {
    /* macro_rules! assert_fn_ok_gt_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ok_gt`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 2;
let b: i8 = 1;
assert_fn_ok_gt!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_gt!(f, a, f, b);
# });
// assertion failed: `assert_fn_ok_gt!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_gt.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `2`,
//                 a: `\"1\"`,
//                 b: `\"2\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_gt!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_gt.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `2`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"2\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)
* [`assert_fn_ok_gt_as_result`](macro@crate::assert_fn_ok_gt_as_result)
* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)


```rust
pub macro_rules! assert_fn_ok_gt {
    /* macro_rules! assert_fn_ok_gt {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_gt`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > (b_function(b_param) ⇒ Ok(b) ⇒ b)

This macro provides the same statements as [`assert_fn_ok_gt`](macro.assert_fn_ok_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)
* [`assert_fn_ok_gt`](macro@crate::assert_fn_ok_gt)
* [`debug_assert_fn_ok_gt`](macro@crate::debug_assert_fn_ok_gt)


```rust
pub macro_rules! debug_assert_fn_ok_gt {
    /* macro_rules! debug_assert_fn_ok_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)
* [`assert_fn_ok_le_as_result`](macro@crate::assert_fn_ok_le_as_result)
* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)


```rust
pub macro_rules! assert_fn_ok_le_as_result {
    /* macro_rules! assert_fn_ok_le_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ok_le`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_le!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 2;
let b: i8 = 1;
assert_fn_ok_le!(f, a, f, b);
# });
// assertion failed: `assert_fn_ok_le!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_le.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `2`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `1`,
//                 a: `\"2\"`,
//                 b: `\"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_le!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_le.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `2`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `1`,\n",
#     "                a: `\"2\"`,\n",
#     "                b: `\"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)
* [`assert_fn_ok_le_as_result`](macro@crate::assert_fn_ok_le_as_result)
* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)


```rust
pub macro_rules! assert_fn_ok_le {
    /* macro_rules! assert_fn_ok_le {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_le`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than or equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ (b_function(b_param) ⇒ Ok(b) ⇒ b)

This macro provides the same statements as [`assert_fn_ok_le`](macro.assert_fn_ok_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)
* [`assert_fn_ok_le`](macro@crate::assert_fn_ok_le)
* [`debug_assert_fn_ok_le`](macro@crate::debug_assert_fn_ok_le)


```rust
pub macro_rules! debug_assert_fn_ok_le {
    /* macro_rules! debug_assert_fn_ok_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)
* [`assert_fn_ok_lt_as_result`](macro@crate::assert_fn_ok_lt_as_result)
* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)


```rust
pub macro_rules! assert_fn_ok_lt_as_result {
    /* macro_rules! assert_fn_ok_lt_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ok_lt`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_lt!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 2;
let b: i8 = 1;
assert_fn_ok_lt!(f, a, f, b);
# });
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `2`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `1`,
//                 a: `\"2\"`,
//                 b: `\"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_lt!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_lt.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `2`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `1`,\n",
#     "                a: `\"2\"`,\n",
#     "                b: `\"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)
* [`assert_fn_ok_lt_as_result`](macro@crate::assert_fn_ok_lt_as_result)
* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)


```rust
pub macro_rules! assert_fn_ok_lt {
    /* macro_rules! assert_fn_ok_lt {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_lt`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < (b_function(b_param) ⇒ Ok(b) ⇒ b)

This macro provides the same statements as [`assert_fn_ok_lt`](macro.assert_fn_ok_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)
* [`assert_fn_ok_lt`](macro@crate::assert_fn_ok_lt)
* [`debug_assert_fn_ok_lt`](macro@crate::debug_assert_fn_ok_lt)


```rust
pub macro_rules! debug_assert_fn_ok_lt {
    /* macro_rules! debug_assert_fn_ok_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return Result `Ok(a, b)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)
* [`assert_fn_ok_ne_as_result`](macro@crate::assert_fn_ok_ne_as_result)
* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)


```rust
pub macro_rules! assert_fn_ok_ne_as_result {
    /* macro_rules! assert_fn_ok_ne_as_result {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $b_function:path) => { ... };
} */
}
```

### Macro `assert_fn_ok_ne`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)

* If true, return `(a, b)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b: i8 = 2;
assert_fn_ok_ne!(f, a, f, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b: i8 = 1;
assert_fn_ok_ne!(f, a, f, b);
# });
// assertion failed: `assert_fn_ok_ne!(a_function, a_param, b_function, b_param)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_ne.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//  b_function label: `f`,
//     b_param label: `b`,
//     b_param debug: `1`,
//                 a: `\"1\"`,
//                 b: `\"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_ne!(a_function, a_param, b_function, b_param)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_ne.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     " b_function label: `f`,\n",
#     "    b_param label: `b`,\n",
#     "    b_param debug: `1`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)
* [`assert_fn_ok_ne_as_result`](macro@crate::assert_fn_ok_ne_as_result)
* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)


```rust
pub macro_rules! assert_fn_ok_ne {
    /* macro_rules! assert_fn_ok_ne {
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_function:path, $b_param:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_function:path) => { ... };
    ($a_function:path, $b_function:path, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_ne`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is not equal to another.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ (b_function(b_param) ⇒ Ok(b) ⇒ b)

This macro provides the same statements as [`assert_fn_ok_ne`](macro.assert_fn_ok_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)
* [`assert_fn_ok_ne`](macro@crate::assert_fn_ok_ne)
* [`debug_assert_fn_ok_ne`](macro@crate::debug_assert_fn_ok_ne)


```rust
pub macro_rules! debug_assert_fn_ok_ne {
    /* macro_rules! debug_assert_fn_ok_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)
* [`assert_fn_ok_eq_x_as_result`](macro@crate::assert_fn_ok_eq_x_as_result)
* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)


```rust
pub macro_rules! assert_fn_ok_eq_x_as_result {
    /* macro_rules! assert_fn_ok_eq_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ok_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b = String::from("1");
assert_fn_ok_eq_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_eq_x!(f, a, b);
# });
// assertion failed: `assert_fn_ok_eq_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_eq_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//      b_expr label: `b`,
//      b_expr debug: `\"2\"`,
//                 a: `\"1\"`,
//                 b: `\"2\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_eq_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_eq_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"2\"`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"2\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)
* [`assert_fn_ok_eq_x_as_result`](macro@crate::assert_fn_ok_eq_x_as_result)
* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)


```rust
pub macro_rules! assert_fn_ok_eq_x {
    /* macro_rules! assert_fn_ok_eq_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) = expr

This macro provides the same statements as [`assert_fn_ok_eq_x`](macro.assert_fn_ok_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)
* [`assert_fn_ok_eq_x`](macro@crate::assert_fn_ok_eq_x)
* [`debug_assert_fn_ok_eq_x`](macro@crate::debug_assert_fn_ok_eq_x)


```rust
pub macro_rules! debug_assert_fn_ok_eq_x {
    /* macro_rules! debug_assert_fn_ok_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)
* [`assert_fn_ok_ge_x_as_result`](macro@crate::assert_fn_ok_ge_x_as_result)
* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)


```rust
pub macro_rules! assert_fn_ok_ge_x_as_result {
    /* macro_rules! assert_fn_ok_ge_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ok_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 2;
let b = String::from("1");
assert_fn_ok_ge_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_ge_x!(f, a, b);
# });
// assertion failed: `assert_fn_ok_ge_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_ge_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//      b_expr label: `b`,
//      b_expr debug: `\"2\"`,
//                 a: `\"1\"`,
//                 b: `\"2\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_ge_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_ge_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"2\"`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"2\"`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)
* [`assert_fn_ok_ge_x_as_result`](macro@crate::assert_fn_ok_ge_x_as_result)
* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)


```rust
pub macro_rules! assert_fn_ok_ge_x {
    /* macro_rules! assert_fn_ok_ge_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≥ expr

This macro provides the same statements as [`assert_fn_ok_ge_x`](macro.assert_fn_ok_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)
* [`assert_fn_ok_ge_x`](macro@crate::assert_fn_ok_ge_x)
* [`debug_assert_fn_ok_ge_x`](macro@crate::debug_assert_fn_ok_ge_x)


```rust
pub macro_rules! debug_assert_fn_ok_ge_x {
    /* macro_rules! debug_assert_fn_ok_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)
* [`assert_fn_ok_gt_x_as_result`](macro@crate::assert_fn_ok_gt_x_as_result)
* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)


```rust
pub macro_rules! assert_fn_ok_gt_x_as_result {
    /* macro_rules! assert_fn_ok_gt_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ok_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 2;
let b = String::from("1");
assert_fn_ok_gt_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_gt_x!(f, a, b);
# });
// assertion failed: `assert_fn_ok_gt_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_gt_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//      b_expr label: `b`,
//      b_expr debug: `\"2\"`,
//                 a: `\"1\"`,
//                 b: `\"2\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_gt_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_gt_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"2\"`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"2\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)
* [`assert_fn_ok_gt_x_as_result`](macro@crate::assert_fn_ok_gt_x_as_result)
* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)


```rust
pub macro_rules! assert_fn_ok_gt_x {
    /* macro_rules! assert_fn_ok_gt_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is greater than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) > expr

This macro provides the same statements as [`assert_fn_ok_gt_x`](macro.assert_fn_ok_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)
* [`assert_fn_ok_gt_x`](macro@crate::assert_fn_ok_gt_x)
* [`debug_assert_fn_ok_gt_x`](macro@crate::debug_assert_fn_ok_gt_x)


```rust
pub macro_rules! debug_assert_fn_ok_gt_x {
    /* macro_rules! debug_assert_fn_ok_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)
* [`assert_fn_ok_le_x_as_result`](macro@crate::assert_fn_ok_le_x_as_result)
* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)


```rust
pub macro_rules! assert_fn_ok_le_x_as_result {
    /* macro_rules! assert_fn_ok_le_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ok_le_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_le_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 2;
let b = String::from("1");
assert_fn_ok_le_x!(f, a, b);
# });
// assertion failed: `assert_fn_ok_le_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_le_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `2`,
//      b_expr label: `b`,
//      b_expr debug: `\"1\"`,
//                 a: `\"2\"`,
//                 b: `\"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_le_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_le_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `2`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"1\"`,\n",
#     "                a: `\"2\"`,\n",
#     "                b: `\"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)
* [`assert_fn_ok_le_x_as_result`](macro@crate::assert_fn_ok_le_x_as_result)
* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)


```rust
pub macro_rules! assert_fn_ok_le_x {
    /* macro_rules! assert_fn_ok_le_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_le_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than or equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≤ expr

This macro provides the same statements as [`assert_fn_ok_le_x`](macro.assert_fn_ok_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)
* [`assert_fn_ok_le_x`](macro@crate::assert_fn_ok_le_x)
* [`debug_assert_fn_ok_le_x`](macro@crate::debug_assert_fn_ok_le_x)


```rust
pub macro_rules! debug_assert_fn_ok_le_x {
    /* macro_rules! debug_assert_fn_ok_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

# Examples

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)
* [`assert_fn_ok_lt_x_as_result`](macro@crate::assert_fn_ok_lt_x_as_result)
* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)


```rust
pub macro_rules! assert_fn_ok_lt_x_as_result {
    /* macro_rules! assert_fn_ok_lt_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ok_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_lt_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 2;
let b = String::from("1");
assert_fn_ok_lt_x!(f, a, b);
# });
// assertion failed: `assert_fn_ok_lt_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_lt_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `2`,
//      b_expr label: `b`,
//      b_expr debug: `\"1\"`,
//                 a: `\"2\"`,
//                 b: `\"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_lt_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_lt_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `2`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"1\"`,\n",
#     "                a: `\"2\"`,\n",
#     "                b: `\"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)
* [`assert_fn_ok_lt_x_as_result`](macro@crate::assert_fn_ok_lt_x_as_result)
* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)


```rust
pub macro_rules! assert_fn_ok_lt_x {
    /* macro_rules! assert_fn_ok_lt_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is less than an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) < expr

This macro provides the same statements as [`assert_fn_ok_lt_x`](macro.assert_fn_ok_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)
* [`assert_fn_ok_lt_x`](macro@crate::assert_fn_ok_lt_x)
* [`debug_assert_fn_ok_lt_x`](macro@crate::debug_assert_fn_ok_lt_x)


```rust
pub macro_rules! debug_assert_fn_ok_lt_x {
    /* macro_rules! debug_assert_fn_ok_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fn_ok_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is not equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr

* If true, return Result `Ok(a)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)
* [`assert_fn_ok_ne_x_as_result`](macro@crate::assert_fn_ok_ne_x_as_result)
* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)


```rust
pub macro_rules! assert_fn_ok_ne_x_as_result {
    /* macro_rules! assert_fn_ok_ne_x_as_result {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fn_ok_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is not equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr

* If true, return `a`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
fn f(i: i8) -> Result<String, String> {
    match i {
        0..=9 => Ok(format!("{}", i)),
        _ => Err(format!("{:?} is out of range", i)),
    }
}

# fn main() {
let a: i8 = 1;
let b = String::from("2");
assert_fn_ok_ne_x!(f, a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a: i8 = 1;
let b = String::from("1");
assert_fn_ok_ne_x!(f, a, b);
# });
// assertion failed: `assert_fn_ok_ne_x!(a_function, a_param, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fn_ok_ne_x.html
//  a_function label: `f`,
//     a_param label: `a`,
//     a_param debug: `1`,
//      b_expr label: `b`,
//      b_expr debug: `\"1\"`,
//                 a: `\"1\"`,
//                 b: `\"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fn_ok_ne_x!(a_function, a_param, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fn_ok_ne_x.html\n",
#     " a_function label: `f`,\n",
#     "    a_param label: `a`,\n",
#     "    a_param debug: `1`,\n",
#     "     b_expr label: `b`,\n",
#     "     b_expr debug: `\"1\"`,\n",
#     "                a: `\"1\"`,\n",
#     "                b: `\"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)
* [`assert_fn_ok_ne_x_as_result`](macro@crate::assert_fn_ok_ne_x_as_result)
* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)


```rust
pub macro_rules! assert_fn_ok_ne_x {
    /* macro_rules! assert_fn_ok_ne_x {
    ($a_function:path, $a_param:expr, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $a_param:expr, $b_expr:expr, $($message:tt)+) => { ... };
    ($a_function:path, $b_expr:expr $(,)?) => { ... };
    ($a_function:path, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fn_ok_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a function Ok(…) is not equal to an expression.

Pseudocode:<br>
(a_function(a_param) ⇒ Ok(a) ⇒ a) ≠ expr

This macro provides the same statements as [`assert_fn_ok_ne_x`](macro.assert_fn_ok_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)
* [`assert_fn_ok_ne_x`](macro@crate::assert_fn_ok_ne_x)
* [`debug_assert_fn_ok_ne_x`](macro@crate::debug_assert_fn_ok_ne_x)


```rust
pub macro_rules! debug_assert_fn_ok_ne_x {
    /* macro_rules! debug_assert_fn_ok_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)

* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)
* [`assert_fs_read_to_string_eq_as_result`](macro@crate::assert_fs_read_to_string_eq_as_result)
* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)


```rust
pub macro_rules! assert_fs_read_to_string_eq_as_result {
    /* macro_rules! assert_fs_read_to_string_eq_as_result {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_eq`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa.txt";
let b = "alfa.txt";
assert_fs_read_to_string_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_eq!(a, b);
# });
// assertion failed: `assert_fs_read_to_string_eq!(a_path, b_path)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_eq.html
//  a_path label: `a`,
//  a_path debug: `\"alfa.txt\"`,
//  b_path label: `b`,
//  b_path debug: `\"bravo.txt\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `bravo\\n`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_eq!(a_path, b_path)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_eq.html\n",
#     " a_path label: `a`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_path label: `b`,\n",
#     " b_path debug: `\"bravo.txt\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `bravo\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)
* [`assert_fs_read_to_string_eq_as_result`](macro@crate::assert_fs_read_to_string_eq_as_result)
* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)


```rust
pub macro_rules! assert_fs_read_to_string_eq {
    /* macro_rules! assert_fs_read_to_string_eq {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_eq`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) = std::fs::read_to_string(b_path)

This macro provides the same statements as [`assert_fs_read_to_string_eq`](macro.assert_fs_read_to_string_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)
* [`assert_fs_read_to_string_eq`](macro@crate::assert_fs_read_to_string_eq)
* [`debug_assert_fs_read_to_string_eq`](macro@crate::debug_assert_fs_read_to_string_eq)


```rust
pub macro_rules! debug_assert_fs_read_to_string_eq {
    /* macro_rules! debug_assert_fs_read_to_string_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)

* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)
* [`assert_fs_read_to_string_ge_as_result`](macro@crate::assert_fs_read_to_string_ge_as_result)
* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)


```rust
pub macro_rules! assert_fs_read_to_string_ge_as_result {
    /* macro_rules! assert_fs_read_to_string_ge_as_result {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ge`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_ge!(&b, &a);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_ge!(a, b);
# });
// assertion failed: `assert_fs_read_to_string_ge!(a_path, b_path)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_ge.html
//  a_path label: `a`,
//  a_path debug: `\"alfa.txt\"`,
//  b_path label: `b`,
//  b_path debug: `\"bravo.txt\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `bravo\\n`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_ge!(a_path, b_path)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_ge.html\n",
#     " a_path label: `a`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_path label: `b`,\n",
#     " b_path debug: `\"bravo.txt\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `bravo\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)
* [`assert_fs_read_to_string_ge_as_result`](macro@crate::assert_fs_read_to_string_ge_as_result)
* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)


```rust
pub macro_rules! assert_fs_read_to_string_ge {
    /* macro_rules! assert_fs_read_to_string_ge {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_ge`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≥ std::fs::read_to_string(b_path)

This macro provides the same statements as [`assert_fs_read_to_string_ge`](macro.assert_fs_read_to_string_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)
* [`assert_fs_read_to_string_ge`](macro@crate::assert_fs_read_to_string_ge)
* [`debug_assert_fs_read_to_string_ge`](macro@crate::debug_assert_fs_read_to_string_ge)


```rust
pub macro_rules! debug_assert_fs_read_to_string_ge {
    /* macro_rules! debug_assert_fs_read_to_string_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)

* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)
* [`assert_fs_read_to_string_gt_as_result`](macro@crate::assert_fs_read_to_string_gt_as_result)
* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)


```rust
pub macro_rules! assert_fs_read_to_string_gt_as_result {
    /* macro_rules! assert_fs_read_to_string_gt_as_result {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_gt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_gt!(&b, &a);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_gt!(a, b);
# });
// assertion failed: `assert_fs_read_to_string_gt!(a_path, b_path)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_gt.html
//  a_path label: `a`,
//  a_path debug: `\"alfa.txt\"`,
//  b_path label: `b`,
//  b_path debug: `\"bravo.txt\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `bravo\\n`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_gt!(a_path, b_path)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_gt.html\n",
#     " a_path label: `a`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_path label: `b`,\n",
#     " b_path debug: `\"bravo.txt\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `bravo\n`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)
* [`assert_fs_read_to_string_gt_as_result`](macro@crate::assert_fs_read_to_string_gt_as_result)
* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)


```rust
pub macro_rules! assert_fs_read_to_string_gt {
    /* macro_rules! assert_fs_read_to_string_gt {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_gt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) > std::fs::read_to_string(b_path)

This macro provides the same statements as [`assert_fs_read_to_string_gt`](macro.assert_fs_read_to_string_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)
* [`assert_fs_read_to_string_gt`](macro@crate::assert_fs_read_to_string_gt)
* [`debug_assert_fs_read_to_string_gt`](macro@crate::debug_assert_fs_read_to_string_gt)


```rust
pub macro_rules! debug_assert_fs_read_to_string_gt {
    /* macro_rules! debug_assert_fs_read_to_string_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)

* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)
* [`assert_fs_read_to_string_le_as_result`](macro@crate::assert_fs_read_to_string_le_as_result)
* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)


```rust
pub macro_rules! assert_fs_read_to_string_le_as_result {
    /* macro_rules! assert_fs_read_to_string_le_as_result {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_le`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "bravo.txt";
let b = "alfa.txt";
assert_fs_read_to_string_le!(a, b);
# });
// assertion failed: `assert_fs_read_to_string_le!(a_path, b_path)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_le.html
//  a_path label: `a`,
//  a_path debug: `\"bravo.txt\"`,
//  b_path label: `b`,
//  b_path debug: `\"alfa.txt\"`,
//      a string: `\"bravo\\n\"`,
//      b string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_le!(a_path, b_path)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_le.html\n",
#     " a_path label: `a`,\n",
#     " a_path debug: `\"bravo.txt\"`,\n",
#     " b_path label: `b`,\n",
#     " b_path debug: `\"alfa.txt\"`,\n",
#     "     a string: `bravo\n`,\n",
#     "     b string: `alfa\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)
* [`assert_fs_read_to_string_le_as_result`](macro@crate::assert_fs_read_to_string_le_as_result)
* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)


```rust
pub macro_rules! assert_fs_read_to_string_le {
    /* macro_rules! assert_fs_read_to_string_le {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_le`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than or equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≤ std::fs::read_to_string(b_path)

This macro provides the same statements as [`assert_fs_read_to_string_le`](macro.assert_fs_read_to_string_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)
* [`assert_fs_read_to_string_le`](macro@crate::assert_fs_read_to_string_le)
* [`debug_assert_fs_read_to_string_le`](macro@crate::debug_assert_fs_read_to_string_le)


```rust
pub macro_rules! debug_assert_fs_read_to_string_le {
    /* macro_rules! debug_assert_fs_read_to_string_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)

* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)
* [`assert_fs_read_to_string_lt_as_result`](macro@crate::assert_fs_read_to_string_lt_as_result)
* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)


```rust
pub macro_rules! assert_fs_read_to_string_lt_as_result {
    /* macro_rules! assert_fs_read_to_string_lt_as_result {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_lt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "bravo.txt";
let b = "alfa.txt";
assert_fs_read_to_string_lt!(a, b);
# });
// assertion failed: `assert_fs_read_to_string_lt!(a_path, b_path)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_lt.html
//  a_path label: `a`,
//  a_path debug: `\"bravo.txt\"`,
//  b_path label: `b`,
//  b_path debug: `\"alfa.txt\"`,
//      a string: `\"bravo\\n\"`,
//      b string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_lt!(a_path, b_path)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_lt.html\n",
#     " a_path label: `a`,\n",
#     " a_path debug: `\"bravo.txt\"`,\n",
#     " b_path label: `b`,\n",
#     " b_path debug: `\"alfa.txt\"`,\n",
#     "     a string: `bravo\n`,\n",
#     "     b string: `alfa\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)
* [`assert_fs_read_to_string_lt_as_result`](macro@crate::assert_fs_read_to_string_lt_as_result)
* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)


```rust
pub macro_rules! assert_fs_read_to_string_lt {
    /* macro_rules! assert_fs_read_to_string_lt {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_lt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than another.

Pseudocode:<br>
std::fs::read_to_string(a_path) < std::fs::read_to_string(b_path)

This macro provides the same statements as [`assert_fs_read_to_string_lt`](macro.assert_fs_read_to_string_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)
* [`assert_fs_read_to_string_lt`](macro@crate::assert_fs_read_to_string_lt)
* [`debug_assert_fs_read_to_string_lt`](macro@crate::debug_assert_fs_read_to_string_lt)


```rust
pub macro_rules! debug_assert_fs_read_to_string_lt {
    /* macro_rules! debug_assert_fs_read_to_string_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is not equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)

* If true, return Result `Ok((a_path_into_string, b_path_into_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)
* [`assert_fs_read_to_string_ne_as_result`](macro@crate::assert_fs_read_to_string_ne_as_result)
* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)


```rust
pub macro_rules! assert_fs_read_to_string_ne_as_result {
    /* macro_rules! assert_fs_read_to_string_ne_as_result {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ne`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is not equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa.txt";
let b = "bravo.txt";
assert_fs_read_to_string_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa.txt";
let b = "alfa.txt";
assert_fs_read_to_string_ne!(a, b);
// assertion failed: `assert_fs_read_to_string_ne!(a_path, b_path)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_ne.html
//  a_path label: `a`,
//  a_path debug: `\"alfa.txt\"`,
//  b_path label: `b`,
//  b_path debug: `\"alfa.txt\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `\"alfa\\n\"`
# });
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_ne!(a_path, b_path)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_ne.html\n",
#     " a_path label: `a`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_path label: `b`,\n",
#     " b_path debug: `\"alfa.txt\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `alfa\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)
* [`assert_fs_read_to_string_ne_as_result`](macro@crate::assert_fs_read_to_string_ne_as_result)
* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)


```rust
pub macro_rules! assert_fs_read_to_string_ne {
    /* macro_rules! assert_fs_read_to_string_ne {
    ($a_path:expr, $b_path:expr $(,)?) => { ... };
    ($a_path:expr, $b_path:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_ne`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is not equal to another.

Pseudocode:<br>
std::fs::read_to_string(a_path) ≠ std::fs::read_to_string(b_path)

This macro provides the same statements as [`assert_fs_read_to_string_ne`](macro.assert_fs_read_to_string_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)
* [`assert_fs_read_to_string_ne`](macro@crate::assert_fs_read_to_string_ne)
* [`debug_assert_fs_read_to_string_ne`](macro@crate::debug_assert_fs_read_to_string_ne)


```rust
pub macro_rules! debug_assert_fs_read_to_string_ne {
    /* macro_rules! debug_assert_fs_read_to_string_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) = expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)
* [`assert_fs_read_to_string_eq_x_as_result`](macro@crate::assert_fs_read_to_string_eq_x_as_result)
* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)


```rust
pub macro_rules! assert_fs_read_to_string_eq_x_as_result {
    /* macro_rules! assert_fs_read_to_string_eq_x_as_result {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) = expr

* If true, return `path_into_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "alfa.txt";
let x = "alfa\n";
assert_fs_read_to_string_eq_x!(path, x);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_eq_x!(path, x);
# });
// assertion failed: `assert_fs_read_to_string_eq_x!(a_path, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_eq_x.html
//  a_path label: `path`,
//  a_path debug: `\"alfa.txt\"`,
//  b_expr label: `x`,
//  b_expr debug: `\"bravo\\n\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `bravo\\n`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_eq_x!(a_path, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_eq_x.html\n",
#     " a_path label: `path`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_expr label: `x`,\n",
#     " b_expr debug: `\"bravo\\n\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `bravo\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)
* [`assert_fs_read_to_string_eq_x_as_result`](macro@crate::assert_fs_read_to_string_eq_x_as_result)
* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)


```rust
pub macro_rules! assert_fs_read_to_string_eq_x {
    /* macro_rules! assert_fs_read_to_string_eq_x {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) = expr

This macro provides the same statements as [`assert_fs_read_to_string_eq_x`](macro.assert_fs_read_to_string_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)
* [`assert_fs_read_to_string_eq_x`](macro@crate::assert_fs_read_to_string_eq_x)
* [`debug_assert_fs_read_to_string_eq_x`](macro@crate::debug_assert_fs_read_to_string_eq_x)


```rust
pub macro_rules! debug_assert_fs_read_to_string_eq_x {
    /* macro_rules! debug_assert_fs_read_to_string_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≥ expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)
* [`assert_fs_read_to_string_ge_x_as_result`](macro@crate::assert_fs_read_to_string_ge_x_as_result)
* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)


```rust
pub macro_rules! assert_fs_read_to_string_ge_x_as_result {
    /* macro_rules! assert_fs_read_to_string_ge_x_as_result {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≥ expr

* If true, return (a_path_into_string, b_path_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "bravo.txt";
let x = "alfa\n";
assert_fs_read_to_string_ge_x!(path, x);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_ge_x!(path, x);
# });
// assertion failed: `assert_fs_read_to_string_ge_x!(a_path, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_ge_x.html
//  a_path label: `path`,
//  a_path debug: `\"alfa.txt\"`,
//  b_expr label: `x`,
//  b_expr debug: `\"bravo\\n\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `bravo\\n`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_ge_x!(a_path, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_ge_x.html\n",
#     " a_path label: `path`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_expr label: `x`,\n",
#     " b_expr debug: `\"bravo\\n\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `bravo\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)
* [`assert_fs_read_to_string_ge_x_as_result`](macro@crate::assert_fs_read_to_string_ge_x_as_result)
* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)


```rust
pub macro_rules! assert_fs_read_to_string_ge_x {
    /* macro_rules! assert_fs_read_to_string_ge_x {
    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≥ expr

This macro provides the same statements as [`assert_fs_read_to_string_ge_x`](macro.assert_fs_read_to_string_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)
* [`assert_fs_read_to_string_ge_x`](macro@crate::assert_fs_read_to_string_ge_x)
* [`debug_assert_fs_read_to_string_ge_x`](macro@crate::debug_assert_fs_read_to_string_ge_x)


```rust
pub macro_rules! debug_assert_fs_read_to_string_ge_x {
    /* macro_rules! debug_assert_fs_read_to_string_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) > expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)
* [`assert_fs_read_to_string_gt_x_as_result`](macro@crate::assert_fs_read_to_string_gt_x_as_result)
* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)


```rust
pub macro_rules! assert_fs_read_to_string_gt_x_as_result {
    /* macro_rules! assert_fs_read_to_string_gt_x_as_result {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) > expr

* If true, return (path_into_string, expr_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "bravo.txt";
let x = "alfa\n";
assert_fs_read_to_string_gt_x!(path, x);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_gt_x!(path, x);
# });
// assertion failed: `assert_fs_read_to_string_gt_x!(a_path, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_gt_x.html
//  a_path label: `path`,
//  a_path debug: `\"alfa.txt\"`,
//  b_expr label: `x`,
//  b_expr debug: `\"bravo\\n\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `bravo\\n`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_gt_x!(a_path, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_gt_x.html\n",
#     " a_path label: `path`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_expr label: `x`,\n",
#     " b_expr debug: `\"bravo\\n\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `bravo\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)
* [`assert_fs_read_to_string_gt_x_as_result`](macro@crate::assert_fs_read_to_string_gt_x_as_result)
* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)


```rust
pub macro_rules! assert_fs_read_to_string_gt_x {
    /* macro_rules! assert_fs_read_to_string_gt_x {
    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is greater than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) > expr

This macro provides the same statements as [`assert_fs_read_to_string_gt_x`](macro.assert_fs_read_to_string_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)
* [`assert_fs_read_to_string_gt_x`](macro@crate::assert_fs_read_to_string_gt_x)
* [`debug_assert_fs_read_to_string_gt_x`](macro@crate::debug_assert_fs_read_to_string_gt_x)


```rust
pub macro_rules! debug_assert_fs_read_to_string_gt_x {
    /* macro_rules! debug_assert_fs_read_to_string_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≤ expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)
* [`assert_fs_read_to_string_le_x_as_result`](macro@crate::assert_fs_read_to_string_le_x_as_result)
* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)


```rust
pub macro_rules! assert_fs_read_to_string_le_x_as_result {
    /* macro_rules! assert_fs_read_to_string_le_x_as_result {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_le_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≤ expr

* If true, return (path_into_string, expr_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_le_x!(path, x);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "bravo.txt";
let x = "alfa\n";
assert_fs_read_to_string_le_x!(path, x);
# });
// assertion failed: `assert_fs_read_to_string_le_x!(a_path, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_le_x.html
//  a_path label: `path`,
//  a_path debug: `\"bravo.txt\"`,
//  b_expr label: `x`,
//  b_expr debug: `\"alfa\\n\"`,
//      a string: `\"bravo\\n\"`,
//      b string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_le_x!(a_path, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_le_x.html\n",
#     " a_path label: `path`,\n",
#     " a_path debug: `\"bravo.txt\"`,\n",
#     " b_expr label: `x`,\n",
#     " b_expr debug: `\"alfa\\n\"`,\n",
#     "     a string: `bravo\n`,\n",
#     "     b string: `alfa\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)
* [`assert_fs_read_to_string_le_x_as_result`](macro@crate::assert_fs_read_to_string_le_x_as_result)
* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)


```rust
pub macro_rules! assert_fs_read_to_string_le_x {
    /* macro_rules! assert_fs_read_to_string_le_x {
    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_le_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than or equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≤ expr

This macro provides the same statements as [`assert_fs_read_to_string_le_x`](macro.assert_fs_read_to_string_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)
* [`assert_fs_read_to_string_le_x`](macro@crate::assert_fs_read_to_string_le_x)
* [`debug_assert_fs_read_to_string_le_x`](macro@crate::debug_assert_fs_read_to_string_le_x)


```rust
pub macro_rules! debug_assert_fs_read_to_string_le_x {
    /* macro_rules! debug_assert_fs_read_to_string_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) < expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)
* [`assert_fs_read_to_string_lt_x_as_result`](macro@crate::assert_fs_read_to_string_lt_x_as_result)
* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)


```rust
pub macro_rules! assert_fs_read_to_string_lt_x_as_result {
    /* macro_rules! assert_fs_read_to_string_lt_x_as_result {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) < expr

* If true, return (path_into_string, expr_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_lt_x!(path, x);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "bravo.txt";
let x = "alfa\n";
assert_fs_read_to_string_lt_x!(path, x);
# });
// assertion failed: `assert_fs_read_to_string_lt_x!(a_path, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_lt_x.html
//  a_path label: `path`,
//  a_path debug: `\"bravo.txt\"`,
//  b_expr label: `x`,
//  b_expr debug: `\"alfa\\n\"`,
//      a string: `\"bravo\\n\"`,
//      b string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_lt_x!(a_path, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_lt_x.html\n",
#     " a_path label: `path`,\n",
#     " a_path debug: `\"bravo.txt\"`,\n",
#     " b_expr label: `x`,\n",
#     " b_expr debug: `\"alfa\\n\"`,\n",
#     "     a string: `bravo\n`,\n",
#     "     b string: `alfa\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)
* [`assert_fs_read_to_string_lt_x_as_result`](macro@crate::assert_fs_read_to_string_lt_x_as_result)
* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)


```rust
pub macro_rules! assert_fs_read_to_string_lt_x {
    /* macro_rules! assert_fs_read_to_string_lt_x {
    ($a_path:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) value is less than an expression.

Pseudocode:<br>
std::fs::read_to_string(path) < expr

This macro provides the same statements as [`assert_fs_read_to_string_lt_x`](macro.assert_fs_read_to_string_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)
* [`assert_fs_read_to_string_lt_x`](macro@crate::assert_fs_read_to_string_lt_x)
* [`debug_assert_fs_read_to_string_lt_x`](macro@crate::debug_assert_fs_read_to_string_lt_x)


```rust
pub macro_rules! debug_assert_fs_read_to_string_lt_x {
    /* macro_rules! debug_assert_fs_read_to_string_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is not equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≠ expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)
* [`assert_fs_read_to_string_ne_x_as_result`](macro@crate::assert_fs_read_to_string_ne_x_as_result)
* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)


```rust
pub macro_rules! assert_fs_read_to_string_ne_x_as_result {
    /* macro_rules! assert_fs_read_to_string_ne_x_as_result {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is not equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≠ expr

* If true, return (path_into_string, expr_into_string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "alfa.txt";
let x = "bravo\n";
assert_fs_read_to_string_ne_x!(path, x);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "alfa.txt";
let x = "alfa\n";
assert_fs_read_to_string_ne_x!(path, x);
# });
// assertion failed: `assert_fs_read_to_string_ne_x!(a_path, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_ne_x.html
//  a_path label: `path`,
//  a_path debug: `\"alfa.txt\"`,
//  b_expr label: `x`,
//  b_expr debug: `\"alfa\\n\"`,
//      a string: `\"alfa\\n\"`,
//      b string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_ne_x!(a_path, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_ne_x.html\n",
#     " a_path label: `path`,\n",
#     " a_path debug: `\"alfa.txt\"`,\n",
#     " b_expr label: `x`,\n",
#     " b_expr debug: `\"alfa\\n\"`,\n",
#     "     a string: `alfa\n`,\n",
#     "     b string: `alfa\n`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)
* [`assert_fs_read_to_string_ne_x_as_result`](macro@crate::assert_fs_read_to_string_ne_x_as_result)
* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)


```rust
pub macro_rules! assert_fs_read_to_string_ne_x {
    /* macro_rules! assert_fs_read_to_string_ne_x {
    ($a_path:expr, $b_expr:expr $(,)?) => { ... };
    ($a_path:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is not equal to an expression.

Pseudocode:<br>
std::fs::read_to_string(path) ≠ expr

This macro provides the same statements as [`assert_fs_read_to_string_ne_x`](macro.assert_fs_read_to_string_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)
* [`assert_fs_read_to_string_ne_x`](macro@crate::assert_fs_read_to_string_ne_x)
* [`debug_assert_fs_read_to_string_ne_x`](macro@crate::debug_assert_fs_read_to_string_ne_x)


```rust
pub macro_rules! debug_assert_fs_read_to_string_ne_x {
    /* macro_rules! debug_assert_fs_read_to_string_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) contains a pattern.

Pseudocode:<br>
std::fs::read_to_string(path) contains expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)
* [`assert_fs_read_to_string_contains_as_result`](macro@crate::assert_fs_read_to_string_contains_as_result)
* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)


```rust
pub macro_rules! assert_fs_read_to_string_contains_as_result {
    /* macro_rules! assert_fs_read_to_string_contains_as_result {
    ($path:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) contains a pattern.

Pseudocode:<br>
std::fs::read_to_string(path) contains expr

* If true, return `path_into_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let path = "alfa.txt";
let containee = "alfa";
assert_fs_read_to_string_contains!(path, containee);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "alfa.txt";
let containee = "zz";
assert_fs_read_to_string_contains!(path, containee);
# });
// assertion failed: `assert_fs_read_to_string_contains!(path, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_contains.html
//       path label: `path`,
//       path debug: `\"alfa.txt\"`,
//  containee label: `containee`,
//  containee debug: `\"zz\"`,
//           string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_contains!(path, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_contains.html\n",
#     "      path label: `path`,\n",
#     "      path debug: `\"alfa.txt\"`,\n",
#     " containee label: `containee`,\n",
#     " containee debug: `\"zz\"`,\n",
#     "          string: `\"alfa\\n\"`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)
* [`assert_fs_read_to_string_contains_as_result`](macro@crate::assert_fs_read_to_string_contains_as_result)
* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)


```rust
pub macro_rules! assert_fs_read_to_string_contains {
    /* macro_rules! assert_fs_read_to_string_contains {
    ($path:expr, $containee:expr $(,)?) => { ... };
    ($path:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) contains a pattern.

Pseudocode:<br>
std::fs::read_to_string(path) contains expr

This macro provides the same statements as [`assert_fs_read_to_string_contains`](macro.assert_fs_read_to_string_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)
* [`assert_fs_read_to_string_contains`](macro@crate::assert_fs_read_to_string_contains)
* [`debug_assert_fs_read_to_string_contains`](macro@crate::debug_assert_fs_read_to_string_contains)


```rust
pub macro_rules! debug_assert_fs_read_to_string_contains {
    /* macro_rules! debug_assert_fs_read_to_string_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Pseudocode:<br>
std::fs::read_to_string(path) matches expr

* If true, return Result `Ok(path_into_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)
* [`assert_fs_read_to_string_is_match_as_result`](macro@crate::assert_fs_read_to_string_is_match_as_result)
* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)


```rust
pub macro_rules! assert_fs_read_to_string_is_match_as_result {
    /* macro_rules! assert_fs_read_to_string_is_match_as_result {
    ($path:expr, $matcher:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Pseudocode:<br>
std::fs::read_to_string(path) matches expr

* If true, return `path_into_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;
use regex::Regex;

# fn main() {
let path = "alfa.txt";
let matcher = Regex::new(r"lf").expect("regex");
assert_fs_read_to_string_is_match!(path, matcher);

# let result = panic::catch_unwind(|| {
// This will panic
let path = "alfa.txt";
let matcher = Regex::new(r"zz").expect("regex");
assert_fs_read_to_string_is_match!(path, matcher);
# });
// assertion failed: `assert_fs_read_to_string_is_match!(path, matcher)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_fs_read_to_string_is_match.html
//     path label: `path`,
//     path debug: `\"alfa.txt\"`,
//  matcher label: `matcher`,
//  matcher debug: `Regex(\"zz\")`,
//         string: `\"alfa\\n\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_fs_read_to_string_is_match!(path, matcher)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_fs_read_to_string_is_match.html\n",
#     "    path label: `path`,\n",
#     "    path debug: `\"alfa.txt\"`,\n",
#     " matcher label: `matcher`,\n",
#     " matcher debug: `Regex(\"zz\")`,\n",
#     "        string: `\"alfa\\n\"`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)
* [`assert_fs_read_to_string_is_match_as_result`](macro@crate::assert_fs_read_to_string_is_match_as_result)
* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)


```rust
pub macro_rules! assert_fs_read_to_string_is_match {
    /* macro_rules! assert_fs_read_to_string_is_match {
    ($path:expr, $matcher:expr $(,)?) => { ... };
    ($path:expr, $matcher:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Pseudocode:<br>
std::fs::read_to_string(path) matches expr

This macro provides the same statements as [`assert_fs_read_to_string_is_match`](macro.assert_fs_read_to_string_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)
* [`assert_fs_read_to_string_is_match`](macro@crate::assert_fs_read_to_string_is_match)
* [`debug_assert_fs_read_to_string_is_match`](macro@crate::debug_assert_fs_read_to_string_is_match)


```rust
pub macro_rules! debug_assert_fs_read_to_string_is_match {
    /* macro_rules! debug_assert_fs_read_to_string_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_matches_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_fs_read_to_string_matches_as_result` into `assert_fs_read_to_string_is_match_as_result`.

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `assert_fs_read_to_string_matches_as_result` into `assert_fs_read_to_string_is_match_as_result`.


```rust
pub macro_rules! assert_fs_read_to_string_matches_as_result {
    /* macro_rules! assert_fs_read_to_string_matches_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_fs_read_to_string_matches`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_fs_read_to_string_matches` into `assert_fs_read_to_string_is_match`.

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `assert_fs_read_to_string_matches` into `assert_fs_read_to_string_is_match`.


```rust
pub macro_rules! assert_fs_read_to_string_matches {
    /* macro_rules! assert_fs_read_to_string_matches {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_fs_read_to_string_matches`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_fs_read_to_string_matches` into `debug_assert_fs_read_to_string_is_match`.

Assert a ::std::fs::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `debug_assert_fs_read_to_string_matches` into `debug_assert_fs_read_to_string_is_match`.


```rust
pub macro_rules! debug_assert_fs_read_to_string_matches {
    /* macro_rules! debug_assert_fs_read_to_string_matches {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)
* [`assert_io_read_to_string_eq_as_result`](macro@crate::assert_io_read_to_string_eq_as_result)
* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)


```rust
pub macro_rules! assert_io_read_to_string_eq_as_result {
    /* macro_rules! assert_io_read_to_string_eq_as_result {
    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_eq`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa".as_bytes();
let b = "alfa".as_bytes();
assert_io_read_to_string_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_eq!(a, b);
# });
// assertion failed: `assert_io_read_to_string_eq!(a_reader, b_reader)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_eq.html
//  a label: `a`,
//  a debug: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `[122, 122]`,
//        a: `\"alfa\"`,
//        b: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_eq!(a_reader, b_reader)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[122, 122]`,\n",
#     "       a: `\"alfa\"`,\n",
#     "       b: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)
* [`assert_io_read_to_string_eq_as_result`](macro@crate::assert_io_read_to_string_eq_as_result)
* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)


```rust
pub macro_rules! assert_io_read_to_string_eq {
    /* macro_rules! assert_io_read_to_string_eq {
    ($a_reader:expr, $b:expr $(,)?) => { ... };
    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_eq`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) = (b_reader.read_to_string(b_string) ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_eq`](macro.assert_io_read_to_string_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)
* [`assert_io_read_to_string_eq`](macro@crate::assert_io_read_to_string_eq)
* [`debug_assert_io_read_to_string_eq`](macro@crate::debug_assert_io_read_to_string_eq)


```rust
pub macro_rules! debug_assert_io_read_to_string_eq {
    /* macro_rules! debug_assert_io_read_to_string_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)
* [`assert_io_read_to_string_ge_as_result`](macro@crate::assert_io_read_to_string_ge_as_result)
* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)


```rust
pub macro_rules! assert_io_read_to_string_ge_as_result {
    /* macro_rules! assert_io_read_to_string_ge_as_result {
    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ge`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa".as_bytes();
let b = "aa".as_bytes();
assert_io_read_to_string_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_ge!(a, b);
# });
// assertion failed: `assert_io_read_to_string_ge!(a_reader, b_reader)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_ge.html
//  a label: `a`,
//  a debug: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `[122, 122]`,
//        a: `\"alfa\"`,
//        b: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_ge!(a_reader, b_reader)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[122, 122]`,\n",
#     "       a: `\"alfa\"`,\n",
#     "       b: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)
* [`assert_io_read_to_string_ge_as_result`](macro@crate::assert_io_read_to_string_ge_as_result)
* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)


```rust
pub macro_rules! assert_io_read_to_string_ge {
    /* macro_rules! assert_io_read_to_string_ge {
    ($a_reader:expr, $b:expr $(,)?) => { ... };
    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_ge`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≥ (b_reader.read_to_string(b_string) ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_ge`](macro.assert_io_read_to_string_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)
* [`assert_io_read_to_string_ge`](macro@crate::assert_io_read_to_string_ge)
* [`debug_assert_io_read_to_string_ge`](macro@crate::debug_assert_io_read_to_string_ge)


```rust
pub macro_rules! debug_assert_io_read_to_string_ge {
    /* macro_rules! debug_assert_io_read_to_string_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)
* [`assert_io_read_to_string_gt_as_result`](macro@crate::assert_io_read_to_string_gt_as_result)
* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)


```rust
pub macro_rules! assert_io_read_to_string_gt_as_result {
    /* macro_rules! assert_io_read_to_string_gt_as_result {
    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_gt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa".as_bytes();
let b = "aa".as_bytes();
assert_io_read_to_string_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_gt!(a, b);
# });
// assertion failed: `assert_io_read_to_string_gt!(a_reader, b_reader)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_gt.html
//  a label: `a`,
//  a debug: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `[122, 122]`,
//        a: `\"alfa\"`,
//        b: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_gt!(a_reader, b_reader)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[122, 122]`,\n",
#     "       a: `\"alfa\"`,\n",
#     "       b: `\"zz\"`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)
* [`assert_io_read_to_string_gt_as_result`](macro@crate::assert_io_read_to_string_gt_as_result)
* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)


```rust
pub macro_rules! assert_io_read_to_string_gt {
    /* macro_rules! assert_io_read_to_string_gt {
    ($a_reader:expr, $b:expr $(,)?) => { ... };
    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_gt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) > (b_reader.read_to_string(b_string) ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_gt`](macro.assert_io_read_to_string_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)
* [`assert_io_read_to_string_gt`](macro@crate::assert_io_read_to_string_gt)
* [`debug_assert_io_read_to_string_gt`](macro@crate::debug_assert_io_read_to_string_gt)


```rust
pub macro_rules! debug_assert_io_read_to_string_gt {
    /* macro_rules! debug_assert_io_read_to_string_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)
* [`assert_io_read_to_string_le_as_result`](macro@crate::assert_io_read_to_string_le_as_result)
* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)


```rust
pub macro_rules! assert_io_read_to_string_le_as_result {
    /* macro_rules! assert_io_read_to_string_le_as_result {
    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_le`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa".as_bytes();
let b = "aa".as_bytes();
assert_io_read_to_string_le!(a, b);
# });
// assertion failed: `assert_io_read_to_string_le!(a_reader, b_reader)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_le.html
//  a label: `a`,
//  a debug: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `[97, 97]`,
//        a: `\"alfa\"`,
//        b: `\"aa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_le!(a_reader, b_reader)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[97, 97]`,\n",
#     "       a: `\"alfa\"`,\n",
#     "       b: `\"aa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)
* [`assert_io_read_to_string_le_as_result`](macro@crate::assert_io_read_to_string_le_as_result)
* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)


```rust
pub macro_rules! assert_io_read_to_string_le {
    /* macro_rules! assert_io_read_to_string_le {
    ($a_reader:expr, $b:expr $(,)?) => { ... };
    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_le`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than or equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≤ (b_reader.read_to_string(b_string) ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_le`](macro.assert_io_read_to_string_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)
* [`assert_io_read_to_string_le`](macro@crate::assert_io_read_to_string_le)
* [`debug_assert_io_read_to_string_le`](macro@crate::debug_assert_io_read_to_string_le)


```rust
pub macro_rules! debug_assert_io_read_to_string_le {
    /* macro_rules! debug_assert_io_read_to_string_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)
* [`assert_io_read_to_string_lt_as_result`](macro@crate::assert_io_read_to_string_lt_as_result)
* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)


```rust
pub macro_rules! assert_io_read_to_string_lt_as_result {
    /* macro_rules! assert_io_read_to_string_lt_as_result {
    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_lt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa".as_bytes();
let b = "aa".as_bytes();
assert_io_read_to_string_lt!(a, b);
# });
// assertion failed: `assert_io_read_to_string_lt!(a_reader, b_reader)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_lt.html
//  a label: `a`,
//  a debug: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `[97, 97]`,
//        a: `\"alfa\"`,
//        b: `\"aa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_lt!(a_reader, b_reader)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[97, 97]`,\n",
#     "       a: `\"alfa\"`,\n",
#     "       b: `\"aa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)
* [`assert_io_read_to_string_lt_as_result`](macro@crate::assert_io_read_to_string_lt_as_result)
* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)


```rust
pub macro_rules! assert_io_read_to_string_lt {
    /* macro_rules! assert_io_read_to_string_lt {
    ($a_reader:expr, $b:expr $(,)?) => { ... };
    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_lt`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) < (b_reader.read_to_string(b_string) ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_lt`](macro.assert_io_read_to_string_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)
* [`assert_io_read_to_string_lt`](macro@crate::assert_io_read_to_string_lt)
* [`debug_assert_io_read_to_string_lt`](macro@crate::debug_assert_io_read_to_string_lt)


```rust
pub macro_rules! debug_assert_io_read_to_string_lt {
    /* macro_rules! debug_assert_io_read_to_string_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is not equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)
* [`assert_io_read_to_string_ne_as_result`](macro@crate::assert_io_read_to_string_ne_as_result)
* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)


```rust
pub macro_rules! assert_io_read_to_string_ne_as_result {
    /* macro_rules! assert_io_read_to_string_ne_as_result {
    ($a_reader:expr, $b_reader:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ne`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is not equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let a = "alfa".as_bytes();
let b = "zz".as_bytes();
assert_io_read_to_string_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let a = "alfa".as_bytes();
let b = "alfa".as_bytes();
assert_io_read_to_string_ne!(a, b);
# });
// assertion failed: `assert_io_read_to_string_ne!(a_reader, b_reader)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_ne.html
//  a label: `a`,
//  a debug: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `[97, 108, 102, 97]`,
//        a: `\"alfa\"`,
//        b: `\"alfa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_ne!(a_reader, b_reader)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `[97, 108, 102, 97]`,\n",
#     "       a: `\"alfa\"`,\n",
#     "       b: `\"alfa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)
* [`assert_io_read_to_string_ne_as_result`](macro@crate::assert_io_read_to_string_ne_as_result)
* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)


```rust
pub macro_rules! assert_io_read_to_string_ne {
    /* macro_rules! assert_io_read_to_string_ne {
    ($a_reader:expr, $b:expr $(,)?) => { ... };
    ($a_reader:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_ne`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is not equal to another.

Pseudocode:<br>
(a_reader.read_to_string(a_string) ⇒ a_string) ≠ (b_reader.read_to_string(b_string) ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_ne`](macro.assert_io_read_to_string_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)
* [`assert_io_read_to_string_ne`](macro@crate::assert_io_read_to_string_ne)
* [`debug_assert_io_read_to_string_ne`](macro@crate::debug_assert_io_read_to_string_ne)


```rust
pub macro_rules! debug_assert_io_read_to_string_ne {
    /* macro_rules! debug_assert_io_read_to_string_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) = expr

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)
* [`assert_io_read_to_string_eq_x_as_result`](macro@crate::assert_io_read_to_string_eq_x_as_result)
* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)


```rust
pub macro_rules! assert_io_read_to_string_eq_x_as_result {
    /* macro_rules! assert_io_read_to_string_eq_x_as_result {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) = expr

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "alfa".as_bytes();
let x = String::from("alfa");
assert_io_read_to_string_eq_x!(reader, x);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_eq_x!(reader, x);
# });
// assertion failed: `assert_io_read_to_string_eq_x!(a_reader, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_eq_x.html
//  a_reader label: `reader`,
//  a_reader debug: `[97, 108, 102, 97]`,
//    b_expr label: `x`,
//    b_expr debug: `\"zz\"`,
//               a: `\"alfa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_eq_x!(a_reader, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_eq_x.html\n",
#     " a_reader label: `reader`,\n",
#     " a_reader debug: `[97, 108, 102, 97]`,\n",
#     "   b_expr label: `x`,\n",
#     "   b_expr debug: `\"zz\"`,\n",
#     "              a: `\"alfa\"`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)
* [`assert_io_read_to_string_eq_x_as_result`](macro@crate::assert_io_read_to_string_eq_x_as_result)
* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)


```rust
pub macro_rules! assert_io_read_to_string_eq_x {
    /* macro_rules! assert_io_read_to_string_eq_x {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) = expr

This macro provides the same statements as [`assert_io_read_to_string_eq_x`](macro.assert_io_read_to_string_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)
* [`assert_io_read_to_string_eq_x`](macro@crate::assert_io_read_to_string_eq_x)
* [`debug_assert_io_read_to_string_eq_x`](macro@crate::debug_assert_io_read_to_string_eq_x)


```rust
pub macro_rules! debug_assert_io_read_to_string_eq_x {
    /* macro_rules! debug_assert_io_read_to_string_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)
* [`assert_io_read_to_string_ge_x_as_result`](macro@crate::assert_io_read_to_string_ge_x_as_result)
* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)


```rust
pub macro_rules! assert_io_read_to_string_ge_x_as_result {
    /* macro_rules! assert_io_read_to_string_ge_x_as_result {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "alfa".as_bytes();
let x = String::from("aa");
assert_io_read_to_string_ge_x!(reader, x);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_ge_x!(reader, x);
# });
// assertion failed: `assert_io_read_to_string_ge_x!(a_reader, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_ge_x.html
//  a_reader label: `reader`,
//  a_reader debug: `[97, 108, 102, 97]`,
//    b_expr label: `x`,
//    b_expr debug: `\"zz\"`,
//               a: `\"alfa\"`,
//               b: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_ge_x!(a_reader, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_ge_x.html\n",
#     " a_reader label: `reader`,\n",
#     " a_reader debug: `[97, 108, 102, 97]`,\n",
#     "   b_expr label: `x`,\n",
#     "   b_expr debug: `\"zz\"`,\n",
#     "              a: `\"alfa\"`,\n",
#     "              b: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)
* [`assert_io_read_to_string_ge_x_as_result`](macro@crate::assert_io_read_to_string_ge_x_as_result)
* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)


```rust
pub macro_rules! assert_io_read_to_string_ge_x {
    /* macro_rules! assert_io_read_to_string_ge_x {
    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_ge_x`

**Attributes:**

- `#[macro_export]`

Assert zzz.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≥ (expr ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_ge_x`](macro.assert_io_read_to_string_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)
* [`assert_io_read_to_string_ge_x`](macro@crate::assert_io_read_to_string_ge_x)
* [`debug_assert_io_read_to_string_ge_x`](macro@crate::debug_assert_io_read_to_string_ge_x)


```rust
pub macro_rules! debug_assert_io_read_to_string_ge_x {
    /* macro_rules! debug_assert_io_read_to_string_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)
* [`assert_io_read_to_string_gt_x_as_result`](macro@crate::assert_io_read_to_string_gt_x_as_result)
* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)


```rust
pub macro_rules! assert_io_read_to_string_gt_x_as_result {
    /* macro_rules! assert_io_read_to_string_gt_x_as_result {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "alfa".as_bytes();
let x = String::from("aa");
assert_io_read_to_string_gt_x!(reader, x);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_gt_x!(reader, x);
# });
// assertion failed: `assert_io_read_to_string_gt_x!(a_reader, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_gt_x.html
//  a_reader label: `reader`,
//  a_reader debug: `[97, 108, 102, 97]`,
//    b_expr label: `x`,
//    b_expr debug: `\"zz\"`,
//               a: `\"alfa\"`,
//               b: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_gt_x!(a_reader, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_gt_x.html\n",
#     " a_reader label: `reader`,\n",
#     " a_reader debug: `[97, 108, 102, 97]`,\n",
#     "   b_expr label: `x`,\n",
#     "   b_expr debug: `\"zz\"`,\n",
#     "              a: `\"alfa\"`,\n",
#     "              b: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)
* [`assert_io_read_to_string_gt_x_as_result`](macro@crate::assert_io_read_to_string_gt_x_as_result)
* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)


```rust
pub macro_rules! assert_io_read_to_string_gt_x {
    /* macro_rules! assert_io_read_to_string_gt_x {
    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is greater than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) > (expr ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_gt_x`](macro.assert_io_read_to_string_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)
* [`assert_io_read_to_string_gt_x`](macro@crate::assert_io_read_to_string_gt_x)
* [`debug_assert_io_read_to_string_gt_x`](macro@crate::debug_assert_io_read_to_string_gt_x)


```rust
pub macro_rules! debug_assert_io_read_to_string_gt_x {
    /* macro_rules! debug_assert_io_read_to_string_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)
* [`assert_io_read_to_string_le_x_as_result`](macro@crate::assert_io_read_to_string_le_x_as_result)
* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)


```rust
pub macro_rules! assert_io_read_to_string_le_x_as_result {
    /* macro_rules! assert_io_read_to_string_le_x_as_result {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_le_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_le_x!(reader, x);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "alfa".as_bytes();
let x = String::from("aa");
assert_io_read_to_string_le_x!(reader, x);
# });
// assertion failed: `assert_io_read_to_string_le_x!(a_reader, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_le_x.html
//  a_reader label: `reader`,
//  a_reader debug: `[97, 108, 102, 97]`,
//    b_expr label: `x`,
//    b_expr debug: `\"aa\"`,
//               a: `\"alfa\"`,
//               b: `\"aa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_le_x!(a_reader, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_le_x.html\n",
#     " a_reader label: `reader`,\n",
#     " a_reader debug: `[97, 108, 102, 97]`,\n",
#     "   b_expr label: `x`,\n",
#     "   b_expr debug: `\"aa\"`,\n",
#     "              a: `\"alfa\"`,\n",
#     "              b: `\"aa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)
* [`assert_io_read_to_string_le_x_as_result`](macro@crate::assert_io_read_to_string_le_x_as_result)
* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)


```rust
pub macro_rules! assert_io_read_to_string_le_x {
    /* macro_rules! assert_io_read_to_string_le_x {
    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_le_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than or equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≤ (expr ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_le_x`](macro.assert_io_read_to_string_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)
* [`assert_io_read_to_string_le_x`](macro@crate::assert_io_read_to_string_le_x)
* [`debug_assert_io_read_to_string_le_x`](macro@crate::debug_assert_io_read_to_string_le_x)


```rust
pub macro_rules! debug_assert_io_read_to_string_le_x {
    /* macro_rules! debug_assert_io_read_to_string_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)
* [`assert_io_read_to_string_lt_x_as_result`](macro@crate::assert_io_read_to_string_lt_x_as_result)
* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)


```rust
pub macro_rules! assert_io_read_to_string_lt_x_as_result {
    /* macro_rules! assert_io_read_to_string_lt_x_as_result {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_lt_x!(reader, x);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "alfa".as_bytes();
let x = String::from("aa");
assert_io_read_to_string_lt_x!(reader, x);
# });
// assertion failed: `assert_io_read_to_string_lt_x!(a_reader, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_lt_x.html
//  a_reader label: `reader`,
//  a_reader debug: `[97, 108, 102, 97]`,
//    b_expr label: `x`,
//    b_expr debug: `\"aa\"`,
//               a: `\"alfa\"`,
//               b: `\"aa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_lt_x!(a_reader, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_lt_x.html\n",
#     " a_reader label: `reader`,\n",
#     " a_reader debug: `[97, 108, 102, 97]`,\n",
#     "   b_expr label: `x`,\n",
#     "   b_expr debug: `\"aa\"`,\n",
#     "              a: `\"alfa\"`,\n",
#     "              b: `\"aa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)
* [`assert_io_read_to_string_lt_x_as_result`](macro@crate::assert_io_read_to_string_lt_x_as_result)
* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)


```rust
pub macro_rules! assert_io_read_to_string_lt_x {
    /* macro_rules! assert_io_read_to_string_lt_x {
    ($a_reader:expr,  $b_expr:expr $(,)?) => { ... };
    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() value is less than an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) < (expr ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_lt_x`](macro.assert_io_read_to_string_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)
* [`assert_io_read_to_string_lt_x`](macro@crate::assert_io_read_to_string_lt_x)
* [`debug_assert_io_read_to_string_lt_x`](macro@crate::debug_assert_io_read_to_string_lt_x)


```rust
pub macro_rules! debug_assert_io_read_to_string_lt_x {
    /* macro_rules! debug_assert_io_read_to_string_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is not equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)
* [`assert_io_read_to_string_ne_x_as_result`](macro@crate::assert_io_read_to_string_ne_x_as_result)
* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)


```rust
pub macro_rules! assert_io_read_to_string_ne_x_as_result {
    /* macro_rules! assert_io_read_to_string_ne_x_as_result {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is not equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "alfa".as_bytes();
let x = String::from("zz");
assert_io_read_to_string_ne_x!(reader, x);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "alfa".as_bytes();
let x = String::from("alfa");
assert_io_read_to_string_ne_x!(reader, x);
# });
// assertion failed: `assert_io_read_to_string_ne_x!(a_reader, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_ne_x.html
//  a_reader label: `reader`,
//  a_reader debug: `[97, 108, 102, 97]`,
//    b_expr label: `x`,
//    b_expr debug: `\"alfa\"`,
//               a: `\"alfa\"`,
//               b: `\"alfa\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_ne_x!(a_reader, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_ne_x.html\n",
#     " a_reader label: `reader`,\n",
#     " a_reader debug: `[97, 108, 102, 97]`,\n",
#     "   b_expr label: `x`,\n",
#     "   b_expr debug: `\"alfa\"`,\n",
#     "              a: `\"alfa\"`,\n",
#     "              b: `\"alfa\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)
* [`assert_io_read_to_string_ne_x_as_result`](macro@crate::assert_io_read_to_string_ne_x_as_result)
* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)


```rust
pub macro_rules! assert_io_read_to_string_ne_x {
    /* macro_rules! assert_io_read_to_string_ne_x {
    ($a_reader:expr, $b_expr:expr $(,)?) => { ... };
    ($a_reader:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is not equal to an expression.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) ≠ (expr ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_ne_x`](macro.assert_io_read_to_string_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)
* [`assert_io_read_to_string_ne_x`](macro@crate::assert_io_read_to_string_ne_x)
* [`debug_assert_io_read_to_string_ne_x`](macro@crate::debug_assert_io_read_to_string_ne_x)


```rust
pub macro_rules! debug_assert_io_read_to_string_ne_x {
    /* macro_rules! debug_assert_io_read_to_string_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() contains a pattern.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) contains (expr)

* If true, return Result `Ok(a_string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)
* [`assert_io_read_to_string_contains_as_result`](macro@crate::assert_io_read_to_string_contains_as_result)
* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)


```rust
pub macro_rules! assert_io_read_to_string_contains_as_result {
    /* macro_rules! assert_io_read_to_string_contains_as_result {
    ($reader:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() contains a pattern.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) contains (expr)

* If true, return `a_string`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::io::Read;

# fn main() {
let reader = "hello".as_bytes();
let containee = "ell";
assert_io_read_to_string_contains!(reader, containee);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "hello".as_bytes();
let containee = "zz";
assert_io_read_to_string_contains!(reader, containee);
# });
// assertion failed: `assert_io_read_to_string_contains!(reader, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_contains.html
//     reader label: `&reader`,
//     reader debug: `[104, 101, 108, 108, 111]`,
//  containee label: `containee`,
//  containee debug: `\"zz\"`,
//           string: `\"hello\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_contains!(reader, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_contains.html\n",
#     "    reader label: `reader`,\n",
#     "    reader debug: `[104, 101, 108, 108, 111]`,\n",
#     " containee label: `containee`,\n",
#     " containee debug: `\"zz\"`,\n",
#     "          string: `\"hello\"`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)
* [`assert_io_read_to_string_contains_as_result`](macro@crate::assert_io_read_to_string_contains_as_result)
* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)


```rust
pub macro_rules! assert_io_read_to_string_contains {
    /* macro_rules! assert_io_read_to_string_contains {
    ($reader:expr, $containee:expr $(,)?) => { ... };
    ($a:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() contains a pattern.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) contains (expr ⇒ b_string)

This macro provides the same statements as [`assert_io_read_to_string_contains`](macro.assert_io_read_to_string_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)
* [`assert_io_read_to_string_contains`](macro@crate::assert_io_read_to_string_contains)
* [`debug_assert_io_read_to_string_contains`](macro@crate::debug_assert_io_read_to_string_contains)


```rust
pub macro_rules! debug_assert_io_read_to_string_contains {
    /* macro_rules! debug_assert_io_read_to_string_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is a match to a regex.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) matches matcher

* If true, return Result `Ok((a_string, b_string))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)
* [`assert_io_read_to_string_is_match_as_result`](macro@crate::assert_io_read_to_string_is_match_as_result)
* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)


```rust
pub macro_rules! assert_io_read_to_string_is_match_as_result {
    /* macro_rules! assert_io_read_to_string_is_match_as_result {
    ($reader:expr, $matcher:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is a match to a regex.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) matches matcher

* If true, return `(a_string, b_string)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use regex::Regex;

# fn main() {
let reader = "hello".as_bytes();
let matcher = Regex::new(r"ell").expect("regex");
assert_io_read_to_string_is_match!(reader, matcher);

# let result = panic::catch_unwind(|| {
// This will panic
let reader = "hello".as_bytes();
let matcher = Regex::new(r"zz").expect("regex");
assert_io_read_to_string_is_match!(reader, matcher);
# });
// assertion failed: `assert_io_read_to_string_is_match!(a_reader, &matcher)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_io_read_to_string_is_match.html
//   reader label: `reader`,
//   reader debug: `[104, 101, 108, 108, 111]`,
//  matcher label: `matcher`,
//  matcher debug: `Regex(\"zz\")`,
//  reader string: `\"hello\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_io_read_to_string_is_match!(a_reader, &matcher)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_io_read_to_string_is_match.html\n",
#     "  reader label: `reader`,\n",
#     "  reader debug: `[104, 101, 108, 108, 111]`,\n",
#     " matcher label: `matcher`,\n",
#     " matcher debug: `Regex(\"zz\")`,\n",
#     " reader string: `\"hello\"`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)
* [`assert_io_read_to_string_is_match_as_result`](macro@crate::assert_io_read_to_string_is_match_as_result)
* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)


```rust
pub macro_rules! assert_io_read_to_string_is_match {
    /* macro_rules! assert_io_read_to_string_is_match {
    ($a_reader:expr, $b_matcher:expr $(,)?) => { ... };
    ($a_reader:expr, $b_matcher:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a ::std::io::Read read_to_string() is a match to a regex.

Pseudocode:<br>
(reader.read_to_string(a_string) ⇒ a_string) matches matcher

This macro provides the same statements as [`assert_io_read_to_string_is_match`](macro.assert_io_read_to_string_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)
* [`assert_io_read_to_string_is_match`](macro@crate::assert_io_read_to_string_is_match)
* [`debug_assert_io_read_to_string_is_match`](macro@crate::debug_assert_io_read_to_string_is_match)


```rust
pub macro_rules! debug_assert_io_read_to_string_is_match {
    /* macro_rules! debug_assert_io_read_to_string_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_matches_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_io_read_to_string_matches_as_result` into `assert_io_read_to_string_is_match_as_result`.

Assert a ::std::io::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `assert_io_read_to_string_matches_as_result` into `assert_io_read_to_string_is_match_as_result`.


```rust
pub macro_rules! assert_io_read_to_string_matches_as_result {
    /* macro_rules! assert_io_read_to_string_matches_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_io_read_to_string_matches`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_io_read_to_string_matches` into `assert_io_read_to_string_is_match`.

Assert a ::std::io::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `assert_io_read_to_string_matches` into `assert_io_read_to_string_is_match`.


```rust
pub macro_rules! assert_io_read_to_string_matches {
    /* macro_rules! assert_io_read_to_string_matches {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_io_read_to_string_matches`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_io_read_to_string_matches` into `debug_assert_io_read_to_string_is_match`.

Assert a ::std::io::read_to_string(path) is a match to a regex.

Deprecated. Please rename from `debug_assert_io_read_to_string_matches` into `debug_assert_io_read_to_string_is_match`.


```rust
pub macro_rules! debug_assert_io_read_to_string_matches {
    /* macro_rules! debug_assert_io_read_to_string_matches {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_eq`](macro@crate::assert_command_stdout_eq)
* [`assert_command_stdout_eq_as_result`](macro@crate::assert_command_stdout_eq_as_result)
* [`debug_assert_command_stdout_eq`](macro@crate::debug_assert_command_stdout_eq)


```rust
pub macro_rules! assert_command_stdout_eq_as_result {
    /* macro_rules! assert_command_stdout_eq_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_eq`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "alfa"]);
assert_command_stdout_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_eq!(a, b);
# });
// assertion failed: `assert_command_stdout_eq!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_eq.html
//  a label: `a`,
//  a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `\"bin/printf-stdout\" \"%s\" \"zz\"`,
//  b value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_eq!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stdout\" \"%s\" \"zz\"`,\n",
#     " b value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_eq`](macro@crate::assert_command_stdout_eq)
* [`assert_command_stdout_eq_as_result`](macro@crate::assert_command_stdout_eq_as_result)
* [`debug_assert_command_stdout_eq`](macro@crate::debug_assert_command_stdout_eq)


```rust
pub macro_rules! assert_command_stdout_eq {
    /* macro_rules! assert_command_stdout_eq {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_eq`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is equal to another.

This macro provides the same statements as [`assert_command_stdout_eq {`](macro.assert_command_stdout_eq {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_eq {`](macro@crate::assert_command_stdout_eq {)
* [`assert_command_stdout_eq {`](macro@crate::assert_command_stdout_eq {)
* [`debug_assert_command_stdout_eq {`](macro@crate::debug_assert_command_stdout_eq {)


```rust
pub macro_rules! debug_assert_command_stdout_eq {
    /* macro_rules! debug_assert_command_stdout_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than or equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_ge`](macro@crate::assert_command_stdout_ge)
* [`assert_command_stdout_ge_as_result`](macro@crate::assert_command_stdout_ge_as_result)
* [`debug_assert_command_stdout_ge`](macro@crate::debug_assert_command_stdout_ge)


```rust
pub macro_rules! assert_command_stdout_ge_as_result {
    /* macro_rules! assert_command_stdout_ge_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_ge`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than or equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "aa"]);
assert_command_stdout_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_ge!(a, b);
# });
// assertion failed: `assert_command_stdout_ge!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_ge.html
//  a label: `a`,
//  a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stdout\" \"%s\" \"zz\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_ge!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stdout\" \"%s\" \"zz\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_ge`](macro@crate::assert_command_stdout_ge)
* [`assert_command_stdout_ge_as_result`](macro@crate::assert_command_stdout_ge_as_result)
* [`debug_assert_command_stdout_ge`](macro@crate::debug_assert_command_stdout_ge)


```rust
pub macro_rules! assert_command_stdout_ge {
    /* macro_rules! assert_command_stdout_ge {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_ge`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than or equal to another.

This macro provides the same statements as [`assert_command_stdout_ge {`](macro.assert_command_stdout_ge {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_ge {`](macro@crate::assert_command_stdout_ge {)
* [`assert_command_stdout_ge {`](macro@crate::assert_command_stdout_ge {)
* [`debug_assert_command_stdout_ge {`](macro@crate::debug_assert_command_stdout_ge {)


```rust
pub macro_rules! debug_assert_command_stdout_ge {
    /* macro_rules! debug_assert_command_stdout_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_gt`](macro@crate::assert_command_stdout_gt)
* [`assert_command_stdout_gt_as_result`](macro@crate::assert_command_stdout_gt_as_result)
* [`debug_assert_command_stdout_gt`](macro@crate::debug_assert_command_stdout_gt)


```rust
pub macro_rules! assert_command_stdout_gt_as_result {
    /* macro_rules! assert_command_stdout_gt_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_gt`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "aa"]);
assert_command_stdout_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_gt!(a, b);
# });
// assertion failed: `assert_command_stdout_gt!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_gt.html
//  a label: `a`,
//  a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stdout\" \"%s\" \"zz\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_gt!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stdout\" \"%s\" \"zz\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_gt`](macro@crate::assert_command_stdout_gt)
* [`assert_command_stdout_gt_as_result`](macro@crate::assert_command_stdout_gt_as_result)
* [`debug_assert_command_stdout_gt`](macro@crate::debug_assert_command_stdout_gt)


```rust
pub macro_rules! assert_command_stdout_gt {
    /* macro_rules! assert_command_stdout_gt {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_gt`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than another.

This macro provides the same statements as [`assert_command_stdout_gt {`](macro.assert_command_stdout_gt {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_gt {`](macro@crate::assert_command_stdout_gt {)
* [`assert_command_stdout_gt {`](macro@crate::assert_command_stdout_gt {)
* [`debug_assert_command_stdout_gt {`](macro@crate::debug_assert_command_stdout_gt {)


```rust
pub macro_rules! debug_assert_command_stdout_gt {
    /* macro_rules! debug_assert_command_stdout_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than or equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_le`](macro@crate::assert_command_stdout_le)
* [`assert_command_stdout_le_as_result`](macro@crate::assert_command_stdout_le_as_result)
* [`debug_assert_command_stdout_le`](macro@crate::debug_assert_command_stdout_le)


```rust
pub macro_rules! assert_command_stdout_le_as_result {
    /* macro_rules! assert_command_stdout_le_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_le`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than or equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "aa"]);
assert_command_stdout_le!(a, b);
# });
// assertion failed: `assert_command_stdout_le!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_le.html
//  a label: `a`,
//  a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stdout\" \"%s\" \"aa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_le!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stdout\" \"%s\" \"aa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_le`](macro@crate::assert_command_stdout_le)
* [`assert_command_stdout_le_as_result`](macro@crate::assert_command_stdout_le_as_result)
* [`debug_assert_command_stdout_le`](macro@crate::debug_assert_command_stdout_le)


```rust
pub macro_rules! assert_command_stdout_le {
    /* macro_rules! assert_command_stdout_le {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_le`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than or equal to another.

This macro provides the same statements as [`assert_command_stdout_le {`](macro.assert_command_stdout_le {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_le {`](macro@crate::assert_command_stdout_le {)
* [`assert_command_stdout_le {`](macro@crate::assert_command_stdout_le {)
* [`debug_assert_command_stdout_le {`](macro@crate::debug_assert_command_stdout_le {)


```rust
pub macro_rules! debug_assert_command_stdout_le {
    /* macro_rules! debug_assert_command_stdout_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_lt`](macro@crate::assert_command_stdout_lt)
* [`assert_command_stdout_lt_as_result`](macro@crate::assert_command_stdout_lt_as_result)
* [`debug_assert_command_stdout_lt`](macro@crate::debug_assert_command_stdout_lt)


```rust
pub macro_rules! assert_command_stdout_lt_as_result {
    /* macro_rules! assert_command_stdout_lt_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_lt`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "aa"]);
assert_command_stdout_lt!(a, b);
# });
// assertion failed: `assert_command_stdout_lt!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_lt.html
//  a label: `a`,
//  a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stdout\" \"%s\" \"aa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[97, 997]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_lt!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stdout\" \"%s\" \"aa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_lt`](macro@crate::assert_command_stdout_lt)
* [`assert_command_stdout_lt_as_result`](macro@crate::assert_command_stdout_lt_as_result)
* [`debug_assert_command_stdout_lt`](macro@crate::debug_assert_command_stdout_lt)


```rust
pub macro_rules! assert_command_stdout_lt {
    /* macro_rules! assert_command_stdout_lt {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_lt`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than another.

This macro provides the same statements as [`assert_command_stdout_lt {`](macro.assert_command_stdout_lt {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_lt {`](macro@crate::assert_command_stdout_lt {)
* [`assert_command_stdout_lt {`](macro@crate::assert_command_stdout_lt {)
* [`debug_assert_command_stdout_lt {`](macro@crate::debug_assert_command_stdout_lt {)


```rust
pub macro_rules! debug_assert_command_stdout_lt {
    /* macro_rules! debug_assert_command_stdout_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is not equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_ne`](macro@crate::assert_command_stdout_ne)
* [`assert_command_stdout_ne_as_result`](macro@crate::assert_command_stdout_ne_as_result)
* [`debug_assert_command_stdout_ne`](macro@crate::debug_assert_command_stdout_ne)


```rust
pub macro_rules! assert_command_stdout_ne_as_result {
    /* macro_rules! assert_command_stdout_ne_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_ne`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is not equal to another.

Pseudocode:<br>
(a_command ⇒ stdout) = (b_command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "zz"]);
assert_command_stdout_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stdout");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stdout");
b.args(["%s", "alfa"]);
assert_command_stdout_ne!(a, b);
# });
// assertion failed: `assert_command_stdout_ne!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_ne.html
//  a label: `a`,
//  a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_ne!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b value: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_ne`](macro@crate::assert_command_stdout_ne)
* [`assert_command_stdout_ne_as_result`](macro@crate::assert_command_stdout_ne_as_result)
* [`debug_assert_command_stdout_ne`](macro@crate::debug_assert_command_stdout_ne)


```rust
pub macro_rules! assert_command_stdout_ne {
    /* macro_rules! assert_command_stdout_ne {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_ne`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is not equal to another.

This macro provides the same statements as [`assert_command_stdout_ne {`](macro.assert_command_stdout_ne {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_ne {`](macro@crate::assert_command_stdout_ne {)
* [`assert_command_stdout_ne {`](macro@crate::assert_command_stdout_ne {)
* [`debug_assert_command_stdout_ne {`](macro@crate::debug_assert_command_stdout_ne {)


```rust
pub macro_rules! debug_assert_command_stdout_ne {
    /* macro_rules! debug_assert_command_stdout_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)
* [`assert_command_stdout_eq_x_as_result`](macro@crate::assert_command_stdout_eq_x_as_result)
* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)


```rust
pub macro_rules! assert_command_stdout_eq_x_as_result {
    /* macro_rules! assert_command_stdout_eq_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_command_stdout_eq_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_eq_x!(command, bytes);
# });
// assertion failed: `assert_command_stdout_eq_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_eq_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[122, 122]`,
//     expr value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_eq_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_eq_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[122, 122]`,\n",
#     "    expr value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)
* [`assert_command_stdout_eq_x_as_result`](macro@crate::assert_command_stdout_eq_x_as_result)
* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)


```rust
pub macro_rules! assert_command_stdout_eq_x {
    /* macro_rules! assert_command_stdout_eq_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_command_stdout_eq_x`](macro.assert_command_stdout_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)
* [`assert_command_stdout_eq_x`](macro@crate::assert_command_stdout_eq_x)
* [`debug_assert_command_stdout_eq_x`](macro@crate::debug_assert_command_stdout_eq_x)


```rust
pub macro_rules! debug_assert_command_stdout_eq_x {
    /* macro_rules! debug_assert_command_stdout_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)
* [`assert_command_stdout_ge_x_as_result`](macro@crate::assert_command_stdout_ge_x_as_result)
* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)


```rust
pub macro_rules! assert_command_stdout_ge_x_as_result {
    /* macro_rules! assert_command_stdout_ge_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stdout_ge_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_ge_x!(command, bytes);
# });
// assertion failed: `assert_command_stdout_ge_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_ge_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[122, 122]`,
//     expr value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_ge_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_ge_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[122, 122]`,\n",
#     "    expr value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)
* [`assert_command_stdout_ge_x_as_result`](macro@crate::assert_command_stdout_ge_x_as_result)
* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)


```rust
pub macro_rules! assert_command_stdout_ge_x {
    /* macro_rules! assert_command_stdout_ge_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_command_stdout_ge_x`](macro.assert_command_stdout_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)
* [`assert_command_stdout_ge_x`](macro@crate::assert_command_stdout_ge_x)
* [`debug_assert_command_stdout_ge_x`](macro@crate::debug_assert_command_stdout_ge_x)


```rust
pub macro_rules! debug_assert_command_stdout_ge_x {
    /* macro_rules! debug_assert_command_stdout_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)
* [`assert_command_stdout_gt_x_as_result`](macro@crate::assert_command_stdout_gt_x_as_result)
* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)


```rust
pub macro_rules! assert_command_stdout_gt_x_as_result {
    /* macro_rules! assert_command_stdout_gt_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stdout_gt_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_gt_x!(command, bytes);
# });
// assertion failed: `assert_command_stdout_gt_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_gt_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[122, 122]`,
//     expr value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_gt_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_gt_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[122, 122]`,\n",
#     "    expr value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)
* [`assert_command_stdout_gt_x_as_result`](macro@crate::assert_command_stdout_gt_x_as_result)
* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)


```rust
pub macro_rules! assert_command_stdout_gt_x {
    /* macro_rules! assert_command_stdout_gt_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is greater than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_command_stdout_gt_x`](macro.assert_command_stdout_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)
* [`assert_command_stdout_gt_x`](macro@crate::assert_command_stdout_gt_x)
* [`debug_assert_command_stdout_gt_x`](macro@crate::debug_assert_command_stdout_gt_x)


```rust
pub macro_rules! debug_assert_command_stdout_gt_x {
    /* macro_rules! debug_assert_command_stdout_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)
* [`assert_command_stdout_le_x_as_result`](macro@crate::assert_command_stdout_le_x_as_result)
* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)


```rust
pub macro_rules! assert_command_stdout_le_x_as_result {
    /* macro_rules! assert_command_stdout_le_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_le_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stdout_le_x!(command, bytes);
# });
// assertion failed: `assert_command_stdout_le_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_le_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[97, 97]`,
//     expr value: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_le_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_le_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[97, 97]`,\n",
#     "    expr value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)
* [`assert_command_stdout_le_x_as_result`](macro@crate::assert_command_stdout_le_x_as_result)
* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)


```rust
pub macro_rules! assert_command_stdout_le_x {
    /* macro_rules! assert_command_stdout_le_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_command_stdout_le_x`](macro.assert_command_stdout_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)
* [`assert_command_stdout_le_x`](macro@crate::assert_command_stdout_le_x)
* [`debug_assert_command_stdout_le_x`](macro@crate::debug_assert_command_stdout_le_x)


```rust
pub macro_rules! debug_assert_command_stdout_le_x {
    /* macro_rules! debug_assert_command_stdout_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)
* [`assert_command_stdout_lt_x_as_result`](macro@crate::assert_command_stdout_lt_x_as_result)
* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)


```rust
pub macro_rules! assert_command_stdout_lt_x_as_result {
    /* macro_rules! assert_command_stdout_lt_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_lt_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stdout_lt_x!(command, bytes);
# });
// assertion failed: `assert_command_stdout_lt_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_lt_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[97, 97]`,
//     expr value: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_lt_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_lt_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[97, 97]`,\n",
#     "    expr value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)
* [`assert_command_stdout_lt_x_as_result`](macro@crate::assert_command_stdout_lt_x_as_result)
* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)


```rust
pub macro_rules! assert_command_stdout_lt_x {
    /* macro_rules! assert_command_stdout_lt_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is less than an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_command_stdout_lt_x`](macro.assert_command_stdout_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)
* [`assert_command_stdout_lt_x`](macro@crate::assert_command_stdout_lt_x)
* [`debug_assert_command_stdout_lt_x`](macro@crate::debug_assert_command_stdout_lt_x)


```rust
pub macro_rules! debug_assert_command_stdout_lt_x {
    /* macro_rules! debug_assert_command_stdout_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)
* [`assert_command_stdout_ne_x_as_result`](macro@crate::assert_command_stdout_ne_x_as_result)
* [`debug_assert_command_stdout_ne_x`](macro@crate::debug_assert_command_stdout_ne_x)


```rust
pub macro_rules! assert_command_stdout_ne_x_as_result {
    /* macro_rules! assert_command_stdout_ne_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stdout_ne_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_command_stdout_ne_x!(command, bytes);
# });
// assertion failed: `assert_command_stdout_ne_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_ne_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[97, 108, 102, 97]`,
//     expr value: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_ne_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_ne_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[97, 108, 102, 97]`,\n",
#     "    expr value: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)
* [`assert_command_stdout_ne_x_as_result`](macro@crate::assert_command_stdout_ne_x_as_result)
* [`debug_assert_command_stdout_ne_x`](macro@crate::debug_assert_command_stdout_ne_x)


```rust
pub macro_rules! assert_command_stdout_ne_x {
    /* macro_rules! assert_command_stdout_ne_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_command_stdout_ne_x`](macro.assert_command_stdout_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)
* [`assert_command_stdout_ne_x`](macro@crate::assert_command_stdout_ne_x)
* [`debug_assert_command_stdout_ne_x`](macro@crate::debug_assert_command_stdout_ne_x)


```rust
pub macro_rules! debug_assert_command_stdout_ne_x {
    /* macro_rules! debug_assert_command_stdout_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_contains_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stdout_contains_as_result` into `assert_command_stdout_string_contains_as_result`.

Assert a command stdout string contains a given containee.

Deprecated. Please rename from `assert_command_stdout_contains_as_result` into `assert_command_stdout_string_contains_as_result`.


```rust
pub macro_rules! assert_command_stdout_contains_as_result {
    /* macro_rules! assert_command_stdout_contains_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stdout_contains` into `assert_command_stdout_string_contains`.

Assert a command stdout string contains a given containee.

Deprecated. Please rename from `assert_command_stdout_contains` into `assert_command_stdout_string_contains`.")]


```rust
pub macro_rules! assert_command_stdout_contains {
    /* macro_rules! assert_command_stdout_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_command_stdout_contains` into `debug_assert_command_stdout_string_contains`.

Assert a command stdout string contains a given containee.

Deprecated. Please rename from `debug_assert_command_stdout_contains` into `debug_assert_command_stdout_string_contains`.


```rust
pub macro_rules! debug_assert_command_stdout_contains {
    /* macro_rules! debug_assert_command_stdout_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_is_match_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stdout_is_match_as_result` into `assert_command_stdout_string_is_match_as_result`.

Assert a command stdout string is a match to a regex.

Deprecated. Please rename from `assert_command_stdout_is_match_as_result` into `assert_command_stdout_string_is_match_as_result`.


```rust
pub macro_rules! assert_command_stdout_is_match_as_result {
    /* macro_rules! assert_command_stdout_is_match_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stdout_is_match` into `assert_command_stdout_string_is_match`.

Assert a command stdout string is a match to a regex.

Deprecated. Please rename from `assert_command_stdout_is_match` into `assert_command_stdout_string_is_match`.


```rust
pub macro_rules! assert_command_stdout_is_match {
    /* macro_rules! assert_command_stdout_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_command_stdout_is_match` into `debug_assert_command_stdout_string_is_match`.

Assert a command stdout string is a match to a regex.

Deprecated. Please rename from `debug_assert_command_stdout_is_match` into `debug_assert_command_stdout_string_is_match`.


```rust
pub macro_rules! debug_assert_command_stdout_is_match {
    /* macro_rules! debug_assert_command_stdout_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_string_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string contains a given containee.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) contains (expr into string)

* If true, return Result `Ok(command ⇒ stdout ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)
* [`assert_command_stdout_string_contains_as_result`](macro@crate::assert_command_stdout_string_contains_as_result)
* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)


```rust
pub macro_rules! assert_command_stdout_string_contains_as_result {
    /* macro_rules! assert_command_stdout_string_contains_as_result {
    ($command:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string contains a given containee.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) contains (expr into string)

* If true, return (command ⇒ stdout ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

This uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.

* The containee can be a &str, char, a slice of chars, or a function or
closure that determines if a character contains.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let containee = "lf";
assert_command_stdout_string_contains!(command, containee);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let containee = "zz";
assert_command_stdout_string_contains!(command, containee);
# });
// assertion failed: `assert_command_stdout_string_contains!(command, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_string_contains.html
//    command label: `command`,
//    command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//    command value: `\"alfa\"`,
//  containee label: `containee`,
//  containee debug: `\"zz\"`,
//  containee value: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_string_contains!(command, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_string_contains.html\n",
#     "   command label: `command`,\n",
#     "   command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     "   command value: `\"alfa\"`,\n",
#     " containee label: `containee`,\n",
#     " containee debug: `\"zz\"`,\n",
#     " containee value: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)
* [`assert_command_stdout_string_contains_as_result`](macro@crate::assert_command_stdout_string_contains_as_result)
* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)


```rust
pub macro_rules! assert_command_stdout_string_contains {
    /* macro_rules! assert_command_stdout_string_contains {
    ($command:expr, $containee:expr $(,)?) => { ... };
    ($command:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string contains a given containee.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) contains (expr into string)

This macro provides the same statements as [`assert_command_stdout_string_contains`](macro.assert_command_stdout_string_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)
* [`assert_command_stdout_string_contains`](macro@crate::assert_command_stdout_string_contains)
* [`debug_assert_command_stdout_string_contains`](macro@crate::debug_assert_command_stdout_string_contains)


```rust
pub macro_rules! debug_assert_command_stdout_string_contains {
    /* macro_rules! debug_assert_command_stdout_string_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stdout_string_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is a match to a regex.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) is match (expr into string)

* If true, return Result `Ok(command ⇒ stdout ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)
* [`assert_command_stdout_string_is_match_as_result`](macro@crate::assert_command_stdout_string_is_match_as_result)
* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)


```rust
pub macro_rules! assert_command_stdout_string_is_match_as_result {
    /* macro_rules! assert_command_stdout_string_is_match_as_result {
    ($command:expr, $matcher:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stdout_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is a match to a regex.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) is match (expr into string)

* If true, return (command ⇒ stdout ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;
use regex::Regex;

# fn main() {
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let matcher = Regex::new(r"lf").expect("regex");
assert_command_stdout_string_is_match!(command, matcher);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stdout");
command.args(["%s", "alfa"]);
let matcher = Regex::new(r"zz").expect("regex");
assert_command_stdout_string_is_match!(command, matcher);
# });
// assertion failed: `assert_command_stdout_string_is_match!(command, matcher)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stdout_string_is_match.html
//  command label: `command`,
//  command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,
//  command value: `\"alfa\"`,
//  matcher label: `matcher`,
//  matcher debug: `Regex(\"zz\")`,
//  matcher value: `Regex(\"zz\")`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stdout_string_is_match!(command, matcher)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stdout_string_is_match.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stdout\" \"%s\" \"alfa\"`,\n",
#     " command value: `\"alfa\"`,\n",
#     " matcher label: `matcher`,\n",
#     " matcher debug: `Regex(\"zz\")`,\n",
#     " matcher value: `Regex(\"zz\")`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)
* [`assert_command_stdout_string_is_match_as_result`](macro@crate::assert_command_stdout_string_is_match_as_result)
* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)


```rust
pub macro_rules! assert_command_stdout_string_is_match {
    /* macro_rules! assert_command_stdout_string_is_match {
    ($command:expr, $matcher:expr $(,)?) => { ... };
    ($command:expr, $matcher:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stdout_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command stdout string is a match to a regex.

Pseudocode:<br>
(command ⇒ stdout ⇒ string) is match (expr into string)

This macro provides the same statements as [`assert_command_stdout_string_is_match`](macro.assert_command_stdout_string_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)
* [`assert_command_stdout_string_is_match`](macro@crate::assert_command_stdout_string_is_match)
* [`debug_assert_command_stdout_string_is_match`](macro@crate::debug_assert_command_stdout_string_is_match)


```rust
pub macro_rules! debug_assert_command_stdout_string_is_match {
    /* macro_rules! debug_assert_command_stdout_string_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_eq`](macro@crate::assert_command_stderr_eq)
* [`assert_command_stderr_eq_as_result`](macro@crate::assert_command_stderr_eq_as_result)
* [`debug_assert_command_stderr_eq`](macro@crate::debug_assert_command_stderr_eq)


```rust
pub macro_rules! assert_command_stderr_eq_as_result {
    /* macro_rules! assert_command_stderr_eq_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_eq`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "alfa"]);
assert_command_stderr_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_eq!(a, b);
# });
// assertion failed: `assert_command_stderr_eq!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_eq.html
//  a label: `a`,
//  a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `\"bin/printf-stderr\" \"%s\" \"zz\"`,
//  b value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_eq!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stderr\" \"%s\" \"zz\"`,\n",
#     " b value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_eq`](macro@crate::assert_command_stderr_eq)
* [`assert_command_stderr_eq_as_result`](macro@crate::assert_command_stderr_eq_as_result)
* [`debug_assert_command_stderr_eq`](macro@crate::debug_assert_command_stderr_eq)


```rust
pub macro_rules! assert_command_stderr_eq {
    /* macro_rules! assert_command_stderr_eq {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_eq`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is equal to another.

This macro provides the same statements as [`assert_command_stderr_eq {`](macro.assert_command_stderr_eq {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_eq {`](macro@crate::assert_command_stderr_eq {)
* [`assert_command_stderr_eq {`](macro@crate::assert_command_stderr_eq {)
* [`debug_assert_command_stderr_eq {`](macro@crate::debug_assert_command_stderr_eq {)


```rust
pub macro_rules! debug_assert_command_stderr_eq {
    /* macro_rules! debug_assert_command_stderr_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than or equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_ge`](macro@crate::assert_command_stderr_ge)
* [`assert_command_stderr_ge_as_result`](macro@crate::assert_command_stderr_ge_as_result)
* [`debug_assert_command_stderr_ge`](macro@crate::debug_assert_command_stderr_ge)


```rust
pub macro_rules! assert_command_stderr_ge_as_result {
    /* macro_rules! assert_command_stderr_ge_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_ge`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than or equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "aa"]);
assert_command_stderr_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_ge!(a, b);
# });
// assertion failed: `assert_command_stderr_ge!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_ge.html
//  a label: `a`,
//  a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `\"bin/printf-stderr\" \"%s\" \"zz\"`,
//  b value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_ge!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stderr\" \"%s\" \"zz\"`,\n",
#     " b value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_ge`](macro@crate::assert_command_stderr_ge)
* [`assert_command_stderr_ge_as_result`](macro@crate::assert_command_stderr_ge_as_result)
* [`debug_assert_command_stderr_ge`](macro@crate::debug_assert_command_stderr_ge)


```rust
pub macro_rules! assert_command_stderr_ge {
    /* macro_rules! assert_command_stderr_ge {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_ge`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than or equal to another.

This macro provides the same statements as [`assert_command_stderr_ge {`](macro.assert_command_stderr_ge {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_ge {`](macro@crate::assert_command_stderr_ge {)
* [`assert_command_stderr_ge {`](macro@crate::assert_command_stderr_ge {)
* [`debug_assert_command_stderr_ge {`](macro@crate::debug_assert_command_stderr_ge {)


```rust
pub macro_rules! debug_assert_command_stderr_ge {
    /* macro_rules! debug_assert_command_stderr_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_gt`](macro@crate::assert_command_stderr_gt)
* [`assert_command_stderr_gt_as_result`](macro@crate::assert_command_stderr_gt_as_result)
* [`debug_assert_command_stderr_gt`](macro@crate::debug_assert_command_stderr_gt)


```rust
pub macro_rules! assert_command_stderr_gt_as_result {
    /* macro_rules! assert_command_stderr_gt_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_gt`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "aa"]);
assert_command_stderr_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_gt!(a, b);
# });
// assertion failed: `assert_command_stderr_gt!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_gt.html
//  a label: `a`,
//  a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stderr\" \"%s\" \"zz\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_gt!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stderr\" \"%s\" \"zz\"`,\n",
#     " b value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_gt`](macro@crate::assert_command_stderr_gt)
* [`assert_command_stderr_gt_as_result`](macro@crate::assert_command_stderr_gt_as_result)
* [`debug_assert_command_stderr_gt`](macro@crate::debug_assert_command_stderr_gt)


```rust
pub macro_rules! assert_command_stderr_gt {
    /* macro_rules! assert_command_stderr_gt {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_gt`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than another.

This macro provides the same statements as [`assert_command_stderr_gt {`](macro.assert_command_stderr_gt {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_gt {`](macro@crate::assert_command_stderr_gt {)
* [`assert_command_stderr_gt {`](macro@crate::assert_command_stderr_gt {)
* [`debug_assert_command_stderr_gt {`](macro@crate::debug_assert_command_stderr_gt {)


```rust
pub macro_rules! debug_assert_command_stderr_gt {
    /* macro_rules! debug_assert_command_stderr_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than or equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_le`](macro@crate::assert_command_stderr_le)
* [`assert_command_stderr_le_as_result`](macro@crate::assert_command_stderr_le_as_result)
* [`debug_assert_command_stderr_le`](macro@crate::debug_assert_command_stderr_le)


```rust
pub macro_rules! assert_command_stderr_le_as_result {
    /* macro_rules! assert_command_stderr_le_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_le`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than or equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "aa"]);
assert_command_stderr_le!(a, b);
# });
// assertion failed: `assert_command_stderr_le!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_le.html
//  a label: `a`,
//  a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  b label: `b`,
//  b debug: `\"bin/printf-stderr\" \"%s\" \"aa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b value: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_le!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stderr\" \"%s\" \"aa\"`,\n",
#     " b value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_le`](macro@crate::assert_command_stderr_le)
* [`assert_command_stderr_le_as_result`](macro@crate::assert_command_stderr_le_as_result)
* [`debug_assert_command_stderr_le`](macro@crate::debug_assert_command_stderr_le)


```rust
pub macro_rules! assert_command_stderr_le {
    /* macro_rules! assert_command_stderr_le {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_le`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than or equal to another.

This macro provides the same statements as [`assert_command_stderr_le {`](macro.assert_command_stderr_le {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_le {`](macro@crate::assert_command_stderr_le {)
* [`assert_command_stderr_le {`](macro@crate::assert_command_stderr_le {)
* [`debug_assert_command_stderr_le {`](macro@crate::debug_assert_command_stderr_le {)


```rust
pub macro_rules! debug_assert_command_stderr_le {
    /* macro_rules! debug_assert_command_stderr_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_lt`](macro@crate::assert_command_stderr_lt)
* [`assert_command_stderr_lt_as_result`](macro@crate::assert_command_stderr_lt_as_result)
* [`debug_assert_command_stderr_lt`](macro@crate::debug_assert_command_stderr_lt)


```rust
pub macro_rules! assert_command_stderr_lt_as_result {
    /* macro_rules! assert_command_stderr_lt_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_lt`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "aa"]);
assert_command_stderr_lt!(a, b);
# });
// assertion failed: `assert_command_stderr_lt!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_lt.html
//  a label: `a`,
//  a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `\"bin/printf-stderr\" \"%s\" \"aa\"`,
//  b value: `[97, 997]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_lt!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stderr\" \"%s\" \"aa\"`,\n",
#     " b value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_lt`](macro@crate::assert_command_stderr_lt)
* [`assert_command_stderr_lt_as_result`](macro@crate::assert_command_stderr_lt_as_result)
* [`debug_assert_command_stderr_lt`](macro@crate::debug_assert_command_stderr_lt)


```rust
pub macro_rules! assert_command_stderr_lt {
    /* macro_rules! assert_command_stderr_lt {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_lt`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than another.

This macro provides the same statements as [`assert_command_stderr_lt {`](macro.assert_command_stderr_lt {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_lt {`](macro@crate::assert_command_stderr_lt {)
* [`assert_command_stderr_lt {`](macro@crate::assert_command_stderr_lt {)
* [`debug_assert_command_stderr_lt {`](macro@crate::debug_assert_command_stderr_lt {)


```rust
pub macro_rules! debug_assert_command_stderr_lt {
    /* macro_rules! debug_assert_command_stderr_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is not equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_ne`](macro@crate::assert_command_stderr_ne)
* [`assert_command_stderr_ne_as_result`](macro@crate::assert_command_stderr_ne_as_result)
* [`debug_assert_command_stderr_ne`](macro@crate::debug_assert_command_stderr_ne)


```rust
pub macro_rules! assert_command_stderr_ne_as_result {
    /* macro_rules! assert_command_stderr_ne_as_result {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_ne`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is not equal to another.

Pseudocode:<br>
(a_command ⇒ stderr) = (b_command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "zz"]);
assert_command_stderr_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/printf-stderr");
a.args(["%s", "alfa"]);
let mut b = Command::new("bin/printf-stderr");
b.args(["%s", "alfa"]);
assert_command_stderr_ne!(a, b);
# });
// assertion failed: `assert_command_stderr_ne!(a_command, b_command)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_ne.html
//  a label: `a`,
//  a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  a value: `[97, 108, 102, 97]`,
//  b label: `b`,
//  b debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  b value: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_ne!(a_command, b_command)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " a value: `[97, 108, 102, 97]`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " b value: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_ne`](macro@crate::assert_command_stderr_ne)
* [`assert_command_stderr_ne_as_result`](macro@crate::assert_command_stderr_ne_as_result)
* [`debug_assert_command_stderr_ne`](macro@crate::debug_assert_command_stderr_ne)


```rust
pub macro_rules! assert_command_stderr_ne {
    /* macro_rules! assert_command_stderr_ne {
    ($a_command:expr, $b_command:expr $(,)?) => { ... };
    ($a_command:expr, $b_command:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_ne`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is not equal to another.

This macro provides the same statements as [`assert_command_stderr_ne {`](macro.assert_command_stderr_ne {.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_ne {`](macro@crate::assert_command_stderr_ne {)
* [`assert_command_stderr_ne {`](macro@crate::assert_command_stderr_ne {)
* [`debug_assert_command_stderr_ne {`](macro@crate::debug_assert_command_stderr_ne {)


```rust
pub macro_rules! debug_assert_command_stderr_ne {
    /* macro_rules! debug_assert_command_stderr_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)
* [`assert_command_stderr_eq_x_as_result`](macro@crate::assert_command_stderr_eq_x_as_result)
* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)


```rust
pub macro_rules! assert_command_stderr_eq_x_as_result {
    /* macro_rules! assert_command_stderr_eq_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_command_stderr_eq_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_eq_x!(command, bytes);
# });
// assertion failed: `assert_command_stderr_eq_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_eq_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[122, 122]`,
//     expr value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_eq_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_eq_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[122, 122]`,\n",
#     "    expr value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)
* [`assert_command_stderr_eq_x_as_result`](macro@crate::assert_command_stderr_eq_x_as_result)
* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)


```rust
pub macro_rules! assert_command_stderr_eq_x {
    /* macro_rules! assert_command_stderr_eq_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_command_stderr_eq_x`](macro.assert_command_stderr_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)
* [`assert_command_stderr_eq_x`](macro@crate::assert_command_stderr_eq_x)
* [`debug_assert_command_stderr_eq_x`](macro@crate::debug_assert_command_stderr_eq_x)


```rust
pub macro_rules! debug_assert_command_stderr_eq_x {
    /* macro_rules! debug_assert_command_stderr_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)
* [`assert_command_stderr_ge_x_as_result`](macro@crate::assert_command_stderr_ge_x_as_result)
* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)


```rust
pub macro_rules! assert_command_stderr_ge_x_as_result {
    /* macro_rules! assert_command_stderr_ge_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stderr_ge_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_ge_x!(command, bytes);
# });
// assertion failed: `assert_command_stderr_ge_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_ge_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[122, 122]`,
//     expr value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_ge_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_ge_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[122, 122]`,\n",
#     "    expr value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)
* [`assert_command_stderr_ge_x_as_result`](macro@crate::assert_command_stderr_ge_x_as_result)
* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)


```rust
pub macro_rules! assert_command_stderr_ge_x {
    /* macro_rules! assert_command_stderr_ge_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_command_stderr_ge_x`](macro.assert_command_stderr_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)
* [`assert_command_stderr_ge_x`](macro@crate::assert_command_stderr_ge_x)
* [`debug_assert_command_stderr_ge_x`](macro@crate::debug_assert_command_stderr_ge_x)


```rust
pub macro_rules! debug_assert_command_stderr_ge_x {
    /* macro_rules! debug_assert_command_stderr_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)
* [`assert_command_stderr_gt_x_as_result`](macro@crate::assert_command_stderr_gt_x_as_result)
* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)


```rust
pub macro_rules! assert_command_stderr_gt_x_as_result {
    /* macro_rules! assert_command_stderr_gt_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stderr_gt_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_gt_x!(command, bytes);
# });
// assertion failed: `assert_command_stderr_gt_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_gt_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[122, 122]`,
//     expr value: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_gt_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_gt_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[122, 122]`,\n",
#     "    expr value: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)
* [`assert_command_stderr_gt_x_as_result`](macro@crate::assert_command_stderr_gt_x_as_result)
* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)


```rust
pub macro_rules! assert_command_stderr_gt_x {
    /* macro_rules! assert_command_stderr_gt_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is greater than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_command_stderr_gt_x`](macro.assert_command_stderr_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)
* [`assert_command_stderr_gt_x`](macro@crate::assert_command_stderr_gt_x)
* [`debug_assert_command_stderr_gt_x`](macro@crate::debug_assert_command_stderr_gt_x)


```rust
pub macro_rules! debug_assert_command_stderr_gt_x {
    /* macro_rules! debug_assert_command_stderr_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)
* [`assert_command_stderr_le_x_as_result`](macro@crate::assert_command_stderr_le_x_as_result)
* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)


```rust
pub macro_rules! assert_command_stderr_le_x_as_result {
    /* macro_rules! assert_command_stderr_le_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_le_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stderr_le_x!(command, bytes);
# });
// assertion failed: `assert_command_stderr_le_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_le_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[97, 97]`,
//     expr value: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_le_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_le_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[97, 97]`,\n",
#     "    expr value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)
* [`assert_command_stderr_le_x_as_result`](macro@crate::assert_command_stderr_le_x_as_result)
* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)


```rust
pub macro_rules! assert_command_stderr_le_x {
    /* macro_rules! assert_command_stderr_le_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than or equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_command_stderr_le_x`](macro.assert_command_stderr_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)
* [`assert_command_stderr_le_x`](macro@crate::assert_command_stderr_le_x)
* [`debug_assert_command_stderr_le_x`](macro@crate::debug_assert_command_stderr_le_x)


```rust
pub macro_rules! debug_assert_command_stderr_le_x {
    /* macro_rules! debug_assert_command_stderr_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)
* [`assert_command_stderr_lt_x_as_result`](macro@crate::assert_command_stderr_lt_x_as_result)
* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)


```rust
pub macro_rules! assert_command_stderr_lt_x_as_result {
    /* macro_rules! assert_command_stderr_lt_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_lt_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'a'];
assert_command_stderr_lt_x!(command, bytes);
# });
// assertion failed: `assert_command_stderr_lt_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_lt_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[97, 97]`,
//     expr value: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_lt_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_lt_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[97, 97]`,\n",
#     "    expr value: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)
* [`assert_command_stderr_lt_x_as_result`](macro@crate::assert_command_stderr_lt_x_as_result)
* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)


```rust
pub macro_rules! assert_command_stderr_lt_x {
    /* macro_rules! assert_command_stderr_lt_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is less than an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_command_stderr_lt_x`](macro.assert_command_stderr_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)
* [`assert_command_stderr_lt_x`](macro@crate::assert_command_stderr_lt_x)
* [`debug_assert_command_stderr_lt_x`](macro@crate::debug_assert_command_stderr_lt_x)


```rust
pub macro_rules! debug_assert_command_stderr_lt_x {
    /* macro_rules! debug_assert_command_stderr_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)
* [`assert_command_stderr_ne_x_as_result`](macro@crate::assert_command_stderr_ne_x_as_result)
* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)


```rust
pub macro_rules! assert_command_stderr_ne_x_as_result {
    /* macro_rules! assert_command_stderr_ne_x_as_result {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'z', b'z'];
assert_command_stderr_ne_x!(command, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_command_stderr_ne_x!(command, bytes);
# });
// assertion failed: `assert_command_stderr_ne_x!(command, expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_ne_x.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `[97, 108, 102, 97]`,
//     expr label: `bytes`,
//     expr debug: `[97, 108, 102, 97]`,
//     expr value: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_ne_x!(command, expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_ne_x.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `[97, 108, 102, 97]`,\n",
#     "    expr label: `bytes`,\n",
#     "    expr debug: `[97, 108, 102, 97]`,\n",
#     "    expr value: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)
* [`assert_command_stderr_ne_x_as_result`](macro@crate::assert_command_stderr_ne_x_as_result)
* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)


```rust
pub macro_rules! assert_command_stderr_ne_x {
    /* macro_rules! assert_command_stderr_ne_x {
    ($a_command:expr, $b_expr:expr $(,)?) => { ... };
    ($a_command:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is not equal to an expression.

Pseudocode:<br>
(command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_command_stderr_ne_x`](macro.assert_command_stderr_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)
* [`assert_command_stderr_ne_x`](macro@crate::assert_command_stderr_ne_x)
* [`debug_assert_command_stderr_ne_x`](macro@crate::debug_assert_command_stderr_ne_x)


```rust
pub macro_rules! debug_assert_command_stderr_ne_x {
    /* macro_rules! debug_assert_command_stderr_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_contains_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stderr_contains_as_result` into `assert_command_stderr_string_contains_as_result`.

into `assert_command_stderr_string_contains`.
Assert a command stderr string contains a given containee.

Deprecated. Please rename from `assert_command_stderr_contains_as_result`
into `assert_command_stderr_string_contains_as_result`.


```rust
pub macro_rules! assert_command_stderr_contains_as_result {
    /* macro_rules! assert_command_stderr_contains_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stderr_contains` into `assert_command_stderr_string_contains`.

Assert a command stderr string contains a given containee.

Deprecated. Please rename from `assert_command_stderr_contains` into
`assert_command_stderr_string_contains`.


```rust
pub macro_rules! assert_command_stderr_contains {
    /* macro_rules! assert_command_stderr_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_command_stderr_contains` into `debug_assert_command_stderr_string_contains`.

Assert a command stderr string contains a given containee.

Deprecated. Please rename from `debug_assert_command_stderr_contains` into
`debug_assert_command_stderr_string_contains`.


```rust
pub macro_rules! debug_assert_command_stderr_contains {
    /* macro_rules! debug_assert_command_stderr_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_is_match_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stderr_is_match_as_result` into `assert_command_stderr_string_is_match_as_result`.

Assert a command stderr string is a match to a regex.

Deprecated. Please rename from `assert_command_stderr_is_match_as_result`
into `assert_command_stderr_string_is_match_as_result`.


```rust
pub macro_rules! assert_command_stderr_is_match_as_result {
    /* macro_rules! assert_command_stderr_is_match_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_command_stderr_is_match` into `assert_command_stderr_string_is_match`.

Assert a command stderr string is a match to a regex.

Deprecated. Please rename from `assert_command_stderr_is_match` into `assert_command_stderr_string_is_match`.


```rust
pub macro_rules! assert_command_stderr_is_match {
    /* macro_rules! assert_command_stderr_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_command_stderr_is_match` into `debug_assert_command_stderr_string_is_match`.

Assert a command stderr string is a match to a regex.

Deprecated. Please rename from `debug_assert_command_stderr_is_match` into `debug_assert_command_stderr_string_is_match`.


```rust
pub macro_rules! debug_assert_command_stderr_is_match {
    /* macro_rules! debug_assert_command_stderr_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_string_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string contains a given containee.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) contains (expr into string)

* If true, return Result `Ok(command ⇒ stderr ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)
* [`assert_command_stderr_string_contains_as_result`](macro@crate::assert_command_stderr_string_contains_as_result)
* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)


```rust
pub macro_rules! assert_command_stderr_string_contains_as_result {
    /* macro_rules! assert_command_stderr_string_contains_as_result {
    ($command:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string contains a given containee.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) contains (expr into string)

* If true, return (command ⇒ stderr ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

This uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.

* The containee can be a &str, char, a slice of chars, or a function or
closure that determines if a character contains.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let containee = "lf";
assert_command_stderr_string_contains!(command, containee);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let containee = "zz";
assert_command_stderr_string_contains!(command, containee);
# });
// assertion failed: `assert_command_stderr_string_contains!(command, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_string_contains.html
//    command label: `command`,
//    command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//    command value: `\"alfa\"`,
//  containee label: `containee`,
//  containee debug: `\"zz\"`,
//  containee value: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_string_contains!(command, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_string_contains.html\n",
#     "   command label: `command`,\n",
#     "   command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     "   command value: `\"alfa\"`,\n",
#     " containee label: `containee`,\n",
#     " containee debug: `\"zz\"`,\n",
#     " containee value: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)
* [`assert_command_stderr_string_contains_as_result`](macro@crate::assert_command_stderr_string_contains_as_result)
* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)


```rust
pub macro_rules! assert_command_stderr_string_contains {
    /* macro_rules! assert_command_stderr_string_contains {
    ($command:expr, $containee:expr $(,)?) => { ... };
    ($command:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string contains a given containee.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) contains (expr into string)

This macro provides the same statements as [`assert_command_stderr_string_contains`](macro.assert_command_stderr_string_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)
* [`assert_command_stderr_string_contains`](macro@crate::assert_command_stderr_string_contains)
* [`debug_assert_command_stderr_string_contains`](macro@crate::debug_assert_command_stderr_string_contains)


```rust
pub macro_rules! debug_assert_command_stderr_string_contains {
    /* macro_rules! debug_assert_command_stderr_string_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_command_stderr_string_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is a match to a regex.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) is match (expr into string)

* If true, return Result `Ok(command ⇒ stderr ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)
* [`assert_command_stderr_string_is_match_as_result`](macro@crate::assert_command_stderr_string_is_match_as_result)
* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)


```rust
pub macro_rules! assert_command_stderr_string_is_match_as_result {
    /* macro_rules! assert_command_stderr_string_is_match_as_result {
    ($command:expr, $matcher:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_command_stderr_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is a match to a regex.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) is match (expr into string)

* If true, return (command ⇒ stderr ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use std::process::Command;
use regex::Regex;

# fn main() {
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let matcher = Regex::new(r"lf").expect("regex");
assert_command_stderr_string_is_match!(command, matcher);

# let result = panic::catch_unwind(|| {
// This will panic
let mut command = Command::new("bin/printf-stderr");
command.args(["%s", "alfa"]);
let matcher = Regex::new(r"zz").expect("regex");
assert_command_stderr_string_is_match!(command, matcher);
# });
// assertion failed: `assert_command_stderr_string_is_match!(command, matcher)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_command_stderr_string_is_match.html
//  command label: `command`,
//  command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,
//  command value: `\"alfa\"`,
//  matcher label: `matcher`,
//  matcher debug: `Regex(\"zz\")`,
//  matcher value: `Regex(\"zz\")`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_command_stderr_string_is_match!(command, matcher)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_command_stderr_string_is_match.html\n",
#     " command label: `command`,\n",
#     " command debug: `\"bin/printf-stderr\" \"%s\" \"alfa\"`,\n",
#     " command value: `\"alfa\"`,\n",
#     " matcher label: `matcher`,\n",
#     " matcher debug: `Regex(\"zz\")`,\n",
#     " matcher value: `Regex(\"zz\")`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)
* [`assert_command_stderr_string_is_match_as_result`](macro@crate::assert_command_stderr_string_is_match_as_result)
* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)


```rust
pub macro_rules! assert_command_stderr_string_is_match {
    /* macro_rules! assert_command_stderr_string_is_match {
    ($command:expr, $matcher:expr $(,)?) => { ... };
    ($command:expr, $matcher:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_command_stderr_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command stderr string is a match to a regex.

Pseudocode:<br>
(command ⇒ stderr ⇒ string) is match (expr into string)

This macro provides the same statements as [`assert_command_stderr_string_is_match`](macro.assert_command_stderr_string_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)
* [`assert_command_stderr_string_is_match`](macro@crate::assert_command_stderr_string_is_match)
* [`debug_assert_command_stderr_string_is_match`](macro@crate::debug_assert_command_stderr_string_is_match)


```rust
pub macro_rules! debug_assert_command_stderr_string_is_match {
    /* macro_rules! debug_assert_command_stderr_string_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_impl_prep`

**Attributes:**

- `#[macro_export]`

Assert program args implementation preparation.

```rust
pub macro_rules! assert_program_args_impl_prep {
    /* macro_rules! assert_program_args_impl_prep {
    ($program:expr, $args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* If true, return Result `Err` with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)
* [`assert_program_args_stdout_eq_as_result`](macro@crate::assert_program_args_stdout_eq_as_result)
* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)


```rust
pub macro_rules! assert_program_args_stdout_eq_as_result {
    /* macro_rules! assert_program_args_stdout_eq_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_eq`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s%s%s", "a", "l", "f", "a"];
assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z" ];
assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_eq.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stdout\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s%s\", \"z\", \"z\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_eq!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_eq.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stdout\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s%s\", \"z\", \"z\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)
* [`assert_program_args_stdout_eq_as_result`](macro@crate::assert_program_args_stdout_eq_as_result)
* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)


```rust
pub macro_rules! assert_program_args_stdout_eq {
    /* macro_rules! assert_program_args_stdout_eq {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_eq`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (b_program + b_args ⇒ command ⇒ stdout)

This macro provides the same statements as [`assert_program_args_stdout_eq`](macro.assert_program_args_stdout_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)
* [`assert_program_args_stdout_eq`](macro@crate::assert_program_args_stdout_eq)
* [`debug_assert_program_args_stdout_eq`](macro@crate::debug_assert_program_args_stdout_eq)


```rust
pub macro_rules! debug_assert_program_args_stdout_eq {
    /* macro_rules! debug_assert_program_args_stdout_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* If true, return Result `Err` with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)
* [`assert_program_args_stdout_ge_as_result`](macro@crate::assert_program_args_stdout_ge_as_result)
* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)


```rust
pub macro_rules! assert_program_args_stdout_ge_as_result {
    /* macro_rules! assert_program_args_stdout_ge_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ge`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "a", "a"];
assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z"];
assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_ge.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stdout\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s%s\", \"z\", \"z\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_ge!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_ge.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stdout\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s%s\", \"z\", \"z\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)
* [`assert_program_args_stdout_ge_as_result`](macro@crate::assert_program_args_stdout_ge_as_result)
* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)


```rust
pub macro_rules! assert_program_args_stdout_ge {
    /* macro_rules! assert_program_args_stdout_ge {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_ge`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (b_program + b_args ⇒ command ⇒ stdout)

This macro provides the same statements as [`assert_program_args_stdout_ge`](macro.assert_program_args_stdout_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)
* [`assert_program_args_stdout_ge`](macro@crate::assert_program_args_stdout_ge)
* [`debug_assert_program_args_stdout_ge`](macro@crate::debug_assert_program_args_stdout_ge)


```rust
pub macro_rules! debug_assert_program_args_stdout_ge {
    /* macro_rules! debug_assert_program_args_stdout_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* If true, return Result `Err` with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)
* [`assert_program_args_stdout_gt_as_result`](macro@crate::assert_program_args_stdout_gt_as_result)
* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)


```rust
pub macro_rules! assert_program_args_stdout_gt_as_result {
    /* macro_rules! assert_program_args_stdout_gt_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_gt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "a", "a"];
assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z"];
assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_gt.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stdout\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s%s\", \"z\", \"z\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_gt!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_gt.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stdout\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s%s\", \"z\", \"z\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)
* [`assert_program_args_stdout_gt_as_result`](macro@crate::assert_program_args_stdout_gt_as_result)
* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)


```rust
pub macro_rules! assert_program_args_stdout_gt {
    /* macro_rules! assert_program_args_stdout_gt {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_gt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (b_program + b_args ⇒ command ⇒ stdout)

This macro provides the same statements as [`assert_program_args_stdout_gt`](macro.assert_program_args_stdout_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)
* [`assert_program_args_stdout_gt`](macro@crate::assert_program_args_stdout_gt)
* [`debug_assert_program_args_stdout_gt`](macro@crate::debug_assert_program_args_stdout_gt)


```rust
pub macro_rules! debug_assert_program_args_stdout_gt {
    /* macro_rules! debug_assert_program_args_stdout_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* If true, return Result `Err` with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)
* [`assert_program_args_stdout_le_as_result`](macro@crate::assert_program_args_stdout_le_as_result)
* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)


```rust
pub macro_rules! assert_program_args_stdout_le_as_result {
    /* macro_rules! assert_program_args_stdout_le_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_le`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z"];
assert_program_args_stdout_le!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "a", "a"];
assert_program_args_stdout_le!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stdout_le!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_le.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stdout\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s%s\", \"a\", \"a\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_le!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_le.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stdout\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s%s\", \"a\", \"a\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)
* [`assert_program_args_stdout_le_as_result`](macro@crate::assert_program_args_stdout_le_as_result)
* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)


```rust
pub macro_rules! assert_program_args_stdout_le {
    /* macro_rules! assert_program_args_stdout_le {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_le`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (b_program + b_args ⇒ command ⇒ stdout)

This macro provides the same statements as [`assert_program_args_stdout_le`](macro.assert_program_args_stdout_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)
* [`assert_program_args_stdout_le`](macro@crate::assert_program_args_stdout_le)
* [`debug_assert_program_args_stdout_le`](macro@crate::debug_assert_program_args_stdout_le)


```rust
pub macro_rules! debug_assert_program_args_stdout_le {
    /* macro_rules! debug_assert_program_args_stdout_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* If true, return Result `Err` with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)
* [`assert_program_args_stdout_lt_as_result`](macro@crate::assert_program_args_stdout_lt_as_result)
* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)


```rust
pub macro_rules! assert_program_args_stdout_lt_as_result {
    /* macro_rules! assert_program_args_stdout_lt_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_lt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z"];
assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "a", "a"];
assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_lt.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stdout\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s%s\", \"a\", \"a\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_lt!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_lt.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stdout\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s%s\", \"a\", \"a\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)
* [`assert_program_args_stdout_lt_as_result`](macro@crate::assert_program_args_stdout_lt_as_result)
* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)


```rust
pub macro_rules! assert_program_args_stdout_lt {
    /* macro_rules! assert_program_args_stdout_lt {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_lt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (b_program + b_args ⇒ command ⇒ stdout)

This macro provides the same statements as [`assert_program_args_stdout_lt`](macro.assert_program_args_stdout_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)
* [`assert_program_args_stdout_lt`](macro@crate::assert_program_args_stdout_lt)
* [`debug_assert_program_args_stdout_lt`](macro@crate::debug_assert_program_args_stdout_lt)


```rust
pub macro_rules! debug_assert_program_args_stdout_lt {
    /* macro_rules! debug_assert_program_args_stdout_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* If true, return Result `Err` with a message and the values of the
  expressions with their debug representations.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)
* [`assert_program_args_stdout_ne_as_result`](macro@crate::assert_program_args_stdout_ne_as_result)
* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)


```rust
pub macro_rules! assert_program_args_stdout_ne_as_result {
    /* macro_rules! assert_program_args_stdout_ne_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ne`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (b_program + b_args ⇒ command ⇒ stdout)

* If true, return `(a_stdout, b_stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s", "z", "z" ];
assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stdout";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stdout";
let b_args = ["%s%s%s%s", "a", "l", "f", "a"];
assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_ne.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stdout\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_ne!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_ne.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stdout\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s%s%s%s\", \"a\", \"l\", \"f\", \"a\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)
* [`assert_program_args_stdout_ne_as_result`](macro@crate::assert_program_args_stdout_ne_as_result)
* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)


```rust
pub macro_rules! assert_program_args_stdout_ne {
    /* macro_rules! assert_program_args_stdout_ne {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_ne`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is not equal to another.

This macro provides the same statements as [`assert_program_args_stdout_ne`](macro.assert_program_args_stdout_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)
* [`assert_program_args_stdout_ne`](macro@crate::assert_program_args_stdout_ne)
* [`debug_assert_program_args_stdout_ne`](macro@crate::debug_assert_program_args_stdout_ne)


```rust
pub macro_rules! debug_assert_program_args_stdout_ne {
    /* macro_rules! debug_assert_program_args_stdout_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)
* [`assert_program_args_stdout_eq_x_as_result`](macro@crate::assert_program_args_stdout_eq_x_as_result)
* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)


```rust
pub macro_rules! assert_program_args_stdout_eq_x_as_result {
    /* macro_rules! assert_program_args_stdout_eq_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stdout_eq_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_eq_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stdout_eq_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_eq_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[122, 122]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_eq_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_eq_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[122, 122]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)
* [`assert_program_args_stdout_eq_x_as_result`](macro@crate::assert_program_args_stdout_eq_x_as_result)
* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)


```rust
pub macro_rules! assert_program_args_stdout_eq_x {
    /* macro_rules! assert_program_args_stdout_eq_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) = (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_eq_x`](macro.assert_program_args_stdout_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)
* [`assert_program_args_stdout_eq_x`](macro@crate::assert_program_args_stdout_eq_x)
* [`debug_assert_program_args_stdout_eq_x`](macro@crate::debug_assert_program_args_stdout_eq_x)


```rust
pub macro_rules! debug_assert_program_args_stdout_eq_x {
    /* macro_rules! debug_assert_program_args_stdout_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)
* [`assert_program_args_stdout_ge_x_as_result`](macro@crate::assert_program_args_stdout_ge_x_as_result)
* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)


```rust
pub macro_rules! assert_program_args_stdout_ge_x_as_result {
    /* macro_rules! assert_program_args_stdout_ge_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stdout_ge_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_ge_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stdout_ge_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_ge_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[122, 122]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_ge_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_ge_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[122, 122]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)
* [`assert_program_args_stdout_ge_x_as_result`](macro@crate::assert_program_args_stdout_ge_x_as_result)
* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)


```rust
pub macro_rules! assert_program_args_stdout_ge_x {
    /* macro_rules! assert_program_args_stdout_ge_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≥ (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_ge_x`](macro.assert_program_args_stdout_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)
* [`assert_program_args_stdout_ge_x`](macro@crate::assert_program_args_stdout_ge_x)
* [`debug_assert_program_args_stdout_ge_x`](macro@crate::debug_assert_program_args_stdout_ge_x)


```rust
pub macro_rules! debug_assert_program_args_stdout_ge_x {
    /* macro_rules! debug_assert_program_args_stdout_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)
* [`assert_program_args_stdout_gt_x_as_result`](macro@crate::assert_program_args_stdout_gt_x_as_result)
* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)


```rust
pub macro_rules! assert_program_args_stdout_gt_x_as_result {
    /* macro_rules! assert_program_args_stdout_gt_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stdout_gt_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_gt_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stdout_gt_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_gt_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[122, 122]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_gt_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_gt_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[122, 122]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)
* [`assert_program_args_stdout_gt_x_as_result`](macro@crate::assert_program_args_stdout_gt_x_as_result)
* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)


```rust
pub macro_rules! assert_program_args_stdout_gt_x {
    /* macro_rules! assert_program_args_stdout_gt_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) > (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_gt_x`](macro.assert_program_args_stdout_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)
* [`assert_program_args_stdout_gt_x`](macro@crate::assert_program_args_stdout_gt_x)
* [`debug_assert_program_args_stdout_gt_x`](macro@crate::debug_assert_program_args_stdout_gt_x)


```rust
pub macro_rules! debug_assert_program_args_stdout_gt_x {
    /* macro_rules! debug_assert_program_args_stdout_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)
* [`assert_program_args_stdout_le_x_as_result`](macro@crate::assert_program_args_stdout_le_x_as_result)
* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)


```rust
pub macro_rules! assert_program_args_stdout_le_x_as_result {
    /* macro_rules! assert_program_args_stdout_le_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_le_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stdout_le_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stdout_le_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_le_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[97, 97]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_le_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_le_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[97, 97]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)
* [`assert_program_args_stdout_le_x_as_result`](macro@crate::assert_program_args_stdout_le_x_as_result)
* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)


```rust
pub macro_rules! assert_program_args_stdout_le_x {
    /* macro_rules! assert_program_args_stdout_le_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≤ (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_le_x`](macro.assert_program_args_stdout_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)
* [`assert_program_args_stdout_le_x`](macro@crate::assert_program_args_stdout_le_x)
* [`debug_assert_program_args_stdout_le_x`](macro@crate::debug_assert_program_args_stdout_le_x)


```rust
pub macro_rules! debug_assert_program_args_stdout_le_x {
    /* macro_rules! debug_assert_program_args_stdout_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)
* [`assert_program_args_stdout_lt_x_as_result`](macro@crate::assert_program_args_stdout_lt_x_as_result)
* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)


```rust
pub macro_rules! assert_program_args_stdout_lt_x_as_result {
    /* macro_rules! assert_program_args_stdout_lt_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stdout_lt_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stdout_lt_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stdout_lt_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_lt_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[97, 97]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_lt_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_lt_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[97, 97]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)
* [`assert_program_args_stdout_lt_x_as_result`](macro@crate::assert_program_args_stdout_lt_x_as_result)
* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)


```rust
pub macro_rules! assert_program_args_stdout_lt_x {
    /* macro_rules! assert_program_args_stdout_lt_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) < (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_lt_x`](macro.assert_program_args_stdout_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)
* [`assert_program_args_stdout_lt_x`](macro@crate::assert_program_args_stdout_lt_x)
* [`debug_assert_program_args_stdout_lt_x`](macro@crate::debug_assert_program_args_stdout_lt_x)


```rust
pub macro_rules! debug_assert_program_args_stdout_lt_x {
    /* macro_rules! debug_assert_program_args_stdout_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)

* If true, return Result `Ok(stdout)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)
* [`assert_program_args_stdout_ne_x_as_result`](macro@crate::assert_program_args_stdout_ne_x_as_result)
* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)


```rust
pub macro_rules! assert_program_args_stdout_ne_x_as_result {
    /* macro_rules! assert_program_args_stdout_ne_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)

* If true, return `(stdout)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'x', b'x'];
assert_program_args_stdout_ne_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stdout_ne_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stdout_ne_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_ne_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[97, 108, 102, 97]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_ne_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_ne_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[97, 108, 102, 97]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)
* [`assert_program_args_stdout_ne_x_as_result`](macro@crate::assert_program_args_stdout_ne_x_as_result)
* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)


```rust
pub macro_rules! assert_program_args_stdout_ne_x {
    /* macro_rules! assert_program_args_stdout_ne_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout) ≠ (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_ne_x`](macro.assert_program_args_stdout_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)
* [`assert_program_args_stdout_ne_x`](macro@crate::assert_program_args_stdout_ne_x)
* [`debug_assert_program_args_stdout_ne_x`](macro@crate::debug_assert_program_args_stdout_ne_x)


```rust
pub macro_rules! debug_assert_program_args_stdout_ne_x {
    /* macro_rules! debug_assert_program_args_stdout_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_contains_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stdout_contains_as_result` to `assert_program_args_stdout_string_contains_as_result`.

Assert a command (built with program and args) stdout into a string contains a given containee.

Deprecated. Please rename from `assert_program_args_stdout_contains_as_result` to `assert_program_args_stdout_string_contains_as_result`.


```rust
pub macro_rules! assert_program_args_stdout_contains_as_result {
    /* macro_rules! assert_program_args_stdout_contains_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stdout_contains` to `assert_program_args_stdout_string_contains`.

Assert a command (built with program and args) stdout into a string contains a given containee.

Deprecated. Please rename from `assert_program_args_stdout_contains` to `assert_program_args_stdout_string_contains`.


```rust
pub macro_rules! assert_program_args_stdout_contains {
    /* macro_rules! assert_program_args_stdout_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_program_args_stdout_contains` to `debug_assert_program_args_stdout_string_contains`.

Assert a command (built with program and args) stdout into a string contains a given containee.

Deprecated. Please rename from `debug_assert_program_args_stdout_contains` to `debug_assert_program_args_stdout_string_contains`.


```rust
pub macro_rules! debug_assert_program_args_stdout_contains {
    /* macro_rules! debug_assert_program_args_stdout_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_is_match_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stdout_is_match_as_result` to `assert_program_args_stdout_string_is_match_as_result`.

Assert a command (built with program and args) stdout into a string is a match to a regex.

Deprecated. Please rename from `assert_program_args_stdout_is_match_as_result` to `assert_program_args_stdout_string_is_match_as_result`.


```rust
pub macro_rules! assert_program_args_stdout_is_match_as_result {
    /* macro_rules! assert_program_args_stdout_is_match_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stdout_is_match` to `assert_program_args_stdout_string_is_match`.

Assert a command (built with program and args) stdout into a string is a match to a regex.

Deprecated. Please rename from `assert_program_args_stdout_is_match` to `assert_program_args_stdout_string_is_match`.


```rust
pub macro_rules! assert_program_args_stdout_is_match {
    /* macro_rules! assert_program_args_stdout_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_program_args_stdout_is_match` to `debug_assert_program_args_stdout_string_is_match`.

Assert a command (built with program and args) stdout into a string is a match to a regex.

Deprecated. Please rename from `debug_assert_program_args_stdout_is_match` to `debug_assert_program_args_stdout_string_is_match`.


```rust
pub macro_rules! debug_assert_program_args_stdout_is_match {
    /* macro_rules! debug_assert_program_args_stdout_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_string_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) contains (expr into string)

* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stdout ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)
* [`assert_program_args_stdout_string_contains_as_result`](macro@crate::assert_program_args_stdout_string_contains_as_result)
* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)


```rust
pub macro_rules! assert_program_args_stdout_string_contains_as_result {
    /* macro_rules! assert_program_args_stdout_string_contains_as_result {
    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) contains (expr into string)

* If true, return (a_program + a_args ⇒ command ⇒ stdout ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

This uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.

* The containee can be a &str, char, a slice of chars, or a function or
closure that determines if a character contains.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let containee = "lf";
assert_program_args_stdout_string_contains!(program, args, containee);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let containee = "zz";
assert_program_args_stdout_string_contains!(program, args, containee);
# });
// assertion failed: `assert_program_args_stdout_string_contains!(a_program, a_args, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_string_contains.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  containee label: `containee`,
//  containee debug: `\"zz\"`,
//                a: `\"alfa\"`,
//                b: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_string_contains!(a_program, a_args, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_string_contains.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " containee label: `containee`,\n",
#     " containee debug: `\"zz\"`,\n",
#     "               a: `\"alfa\"`,\n",
#     "               b: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)
* [`assert_program_args_stdout_string_contains_as_result`](macro@crate::assert_program_args_stdout_string_contains_as_result)
* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)


```rust
pub macro_rules! assert_program_args_stdout_string_contains {
    /* macro_rules! assert_program_args_stdout_string_contains {
    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout into a string contains a given containee.

This macro provides the same statements as [`assert_program_args_stdout_string_contains`](macro.assert_program_args_stdout_string_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)
* [`assert_program_args_stdout_string_contains`](macro@crate::assert_program_args_stdout_string_contains)
* [`debug_assert_program_args_stdout_string_contains`](macro@crate::debug_assert_program_args_stdout_string_contains)


```rust
pub macro_rules! debug_assert_program_args_stdout_string_contains {
    /* macro_rules! debug_assert_program_args_stdout_string_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_string_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)

* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stdout ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)
* [`assert_program_args_stdout_string_is_match_as_result`](macro@crate::assert_program_args_stdout_string_is_match_as_result)
* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)


```rust
pub macro_rules! assert_program_args_stdout_string_is_match_as_result {
    /* macro_rules! assert_program_args_stdout_string_is_match_as_result {
    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stdout_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)

* If true, return (a_program + a_args ⇒ command ⇒ stdout ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use regex::Regex;

# fn main() {
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let matcher = Regex::new(r"lf").expect("regex");
assert_program_args_stdout_string_is_match!(program, args, matcher);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stdout";
let args = ["%s", "alfa"];
let matcher = Regex::new(r"zz").expect("regex");
assert_program_args_stdout_string_is_match!(program, args, matcher);
# });
// assertion failed: `assert_program_args_stdout_string_is_match!(a_program, b_matcher)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stdout_string_is_match.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stdout\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_matcher label: `matcher`,
//  b_matcher debug: `Regex(\"zz\")`,
//                a: `\"alfa\"`,
//                b: `Regex(\"zz\")`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stdout_string_is_match!(a_program, b_matcher)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stdout_string_is_match.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stdout\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_matcher label: `matcher`,\n",
#     " b_matcher debug: `Regex(\"zz\")`,\n",
#     "               a: `\"alfa\"`,\n",
#     "               b: `Regex(\"zz\")`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)
* [`assert_program_args_stdout_string_is_match_as_result`](macro@crate::assert_program_args_stdout_string_is_match_as_result)
* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)


```rust
pub macro_rules! assert_program_args_stdout_string_is_match {
    /* macro_rules! assert_program_args_stdout_string_is_match {
    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $matcher:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stdout_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stdout into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stdout ⇒ string) is match (expr into string)

This macro provides the same statements as [`assert_program_args_stdout_string_is_match`](macro.assert_program_args_stdout_string_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)
* [`assert_program_args_stdout_string_is_match`](macro@crate::assert_program_args_stdout_string_is_match)
* [`debug_assert_program_args_stdout_string_is_match`](macro@crate::debug_assert_program_args_stdout_string_is_match)


```rust
pub macro_rules! debug_assert_program_args_stdout_string_is_match {
    /* macro_rules! debug_assert_program_args_stdout_string_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)
* [`assert_program_args_stderr_eq_as_result`](macro@crate::assert_program_args_stderr_eq_as_result)
* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)


```rust
pub macro_rules! assert_program_args_stderr_eq_as_result {
    /* macro_rules! assert_program_args_stderr_eq_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_eq`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "alfa"];
assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_eq.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stderr\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s\", \"zz\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_eq!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_eq.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stderr\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s\", \"zz\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)
* [`assert_program_args_stderr_eq_as_result`](macro@crate::assert_program_args_stderr_eq_as_result)
* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)


```rust
pub macro_rules! assert_program_args_stderr_eq {
    /* macro_rules! assert_program_args_stderr_eq {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_eq`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (b_program + b_args ⇒ command ⇒ stderr)

This macro provides the same statements as [`assert_program_args_stderr_eq`](macro.assert_program_args_stderr_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)
* [`assert_program_args_stderr_eq`](macro@crate::assert_program_args_stderr_eq)
* [`debug_assert_program_args_stderr_eq`](macro@crate::debug_assert_program_args_stderr_eq)


```rust
pub macro_rules! debug_assert_program_args_stderr_eq {
    /* macro_rules! debug_assert_program_args_stderr_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)
* [`assert_program_args_stderr_ge_as_result`](macro@crate::assert_program_args_stderr_ge_as_result)
* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)


```rust
pub macro_rules! assert_program_args_stderr_ge_as_result {
    /* macro_rules! assert_program_args_stderr_ge_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ge`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "aa"];
assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_ge.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stderr\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s\", \"zz\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_ge!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_ge.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stderr\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s\", \"zz\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)
* [`assert_program_args_stderr_ge_as_result`](macro@crate::assert_program_args_stderr_ge_as_result)
* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)


```rust
pub macro_rules! assert_program_args_stderr_ge {
    /* macro_rules! assert_program_args_stderr_ge {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_ge`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr greater than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (b_program + b_args ⇒ command ⇒ stderr)

This macro provides the same statements as [`assert_program_args_stderr_ge`](macro.assert_program_args_stderr_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)
* [`assert_program_args_stderr_ge`](macro@crate::assert_program_args_stderr_ge)
* [`debug_assert_program_args_stderr_ge`](macro@crate::debug_assert_program_args_stderr_ge)


```rust
pub macro_rules! debug_assert_program_args_stderr_ge {
    /* macro_rules! debug_assert_program_args_stderr_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)
* [`assert_program_args_stderr_gt_as_result`](macro@crate::assert_program_args_stderr_gt_as_result)
* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)


```rust
pub macro_rules! assert_program_args_stderr_gt_as_result {
    /* macro_rules! assert_program_args_stderr_gt_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_gt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "aa"];
assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_gt.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stderr\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s\", \"zz\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_gt!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_gt.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stderr\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s\", \"zz\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)
* [`assert_program_args_stderr_gt_as_result`](macro@crate::assert_program_args_stderr_gt_as_result)
* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)


```rust
pub macro_rules! assert_program_args_stderr_gt {
    /* macro_rules! assert_program_args_stderr_gt {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_gt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (b_program + b_args ⇒ command ⇒ stderr)

This macro provides the same statements as [`assert_program_args_stderr_gt`](macro.assert_program_args_stderr_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)
* [`assert_program_args_stderr_gt`](macro@crate::assert_program_args_stderr_gt)
* [`debug_assert_program_args_stderr_gt`](macro@crate::debug_assert_program_args_stderr_gt)


```rust
pub macro_rules! debug_assert_program_args_stderr_gt {
    /* macro_rules! debug_assert_program_args_stderr_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)
* [`assert_program_args_stderr_le_as_result`](macro@crate::assert_program_args_stderr_le_as_result)
* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)


```rust
pub macro_rules! assert_program_args_stderr_le_as_result {
    /* macro_rules! assert_program_args_stderr_le_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_le`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_le!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "aa"];
assert_program_args_stderr_le!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stderr_le!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_le.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stderr\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s\", \"aa\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_le!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_le.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stderr\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s\", \"aa\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)
* [`assert_program_args_stderr_le_as_result`](macro@crate::assert_program_args_stderr_le_as_result)
* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)


```rust
pub macro_rules! assert_program_args_stderr_le {
    /* macro_rules! assert_program_args_stderr_le {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_le`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than or equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (b_program + b_args ⇒ command ⇒ stderr)

This macro provides the same statements as [`assert_program_args_stderr_le`](macro.assert_program_args_stderr_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)
* [`assert_program_args_stderr_le`](macro@crate::assert_program_args_stderr_le)
* [`debug_assert_program_args_stderr_le`](macro@crate::debug_assert_program_args_stderr_le)


```rust
pub macro_rules! debug_assert_program_args_stderr_le {
    /* macro_rules! debug_assert_program_args_stderr_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)
* [`assert_program_args_stderr_lt_as_result`](macro@crate::assert_program_args_stderr_lt_as_result)
* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)


```rust
pub macro_rules! assert_program_args_stderr_lt_as_result {
    /* macro_rules! assert_program_args_stderr_lt_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_lt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "aa"];
assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_lt.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stderr\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s\", \"aa\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_lt!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_lt.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stderr\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s\", \"aa\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)
* [`assert_program_args_stderr_lt_as_result`](macro@crate::assert_program_args_stderr_lt_as_result)
* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)


```rust
pub macro_rules! assert_program_args_stderr_lt {
    /* macro_rules! assert_program_args_stderr_lt {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_lt`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (b_program + b_args ⇒ command ⇒ stderr)

This macro provides the same statements as [`assert_program_args_stderr_lt`](macro.assert_program_args_stderr_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)
* [`assert_program_args_stderr_lt`](macro@crate::assert_program_args_stderr_lt)
* [`debug_assert_program_args_stderr_lt`](macro@crate::debug_assert_program_args_stderr_lt)


```rust
pub macro_rules! debug_assert_program_args_stderr_lt {
    /* macro_rules! debug_assert_program_args_stderr_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)
* [`assert_program_args_stderr_ne_as_result`](macro@crate::assert_program_args_stderr_ne_as_result)
* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)


```rust
pub macro_rules! assert_program_args_stderr_ne_as_result {
    /* macro_rules! assert_program_args_stderr_ne_as_result {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ne`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "zz"];
assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args);

# let result = panic::catch_unwind(|| {
// This will panic
let a_program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let b_program = "bin/printf-stderr";
let b_args = ["%s", "alfa"];
assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args);
# });
// assertion failed: `assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_ne.html
//  a_program label: `a_program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `a_args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_program label: `b_program`,
//  b_program debug: `\"bin/printf-stderr\"`,
//     b_args label: `b_args`,
//     b_args debug: `[\"%s\", \"alfa\"]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_ne!(a_program, a_args, b_program, b_args)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_ne.html\n",
#     " a_program label: `a_program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `a_args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_program label: `b_program`,\n",
#     " b_program debug: `\"bin/printf-stderr\"`,\n",
#     "    b_args label: `b_args`,\n",
#     "    b_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

/// # Module macros

* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)
* [`assert_program_args_stderr_ne_as_result`](macro@crate::assert_program_args_stderr_ne_as_result)
* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)


```rust
pub macro_rules! assert_program_args_stderr_ne {
    /* macro_rules! assert_program_args_stderr_ne {
    ($a_program:expr, $a_args:expr, $b_program:expr, $b_args:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_program:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_ne`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is not equal to another.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (b_program + b_args ⇒ command ⇒ stderr)

This macro provides the same statements as [`assert_program_args_stderr_ne`](macro.assert_program_args_stderr_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)
* [`assert_program_args_stderr_ne`](macro@crate::assert_program_args_stderr_ne)
* [`debug_assert_program_args_stderr_ne`](macro@crate::debug_assert_program_args_stderr_ne)


```rust
pub macro_rules! debug_assert_program_args_stderr_ne {
    /* macro_rules! debug_assert_program_args_stderr_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)
* [`assert_program_args_stderr_eq_x_as_result`](macro@crate::assert_program_args_stderr_eq_x_as_result)
* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)


```rust
pub macro_rules! assert_program_args_stderr_eq_x_as_result {
    /* macro_rules! assert_program_args_stderr_eq_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stderr_eq_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_eq_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stderr_eq_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_eq_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[122, 122]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_eq_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_eq_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[122, 122]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)
* [`assert_program_args_stderr_eq_x_as_result`](macro@crate::assert_program_args_stderr_eq_x_as_result)
* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)


```rust
pub macro_rules! assert_program_args_stderr_eq_x {
    /* macro_rules! assert_program_args_stderr_eq_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) = (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_eq_x`](macro.assert_program_args_stderr_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)
* [`assert_program_args_stderr_eq_x`](macro@crate::assert_program_args_stderr_eq_x)
* [`debug_assert_program_args_stderr_eq_x`](macro@crate::debug_assert_program_args_stderr_eq_x)


```rust
pub macro_rules! debug_assert_program_args_stderr_eq_x {
    /* macro_rules! debug_assert_program_args_stderr_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)
* [`assert_program_args_stderr_ge_x_as_result`](macro@crate::assert_program_args_stderr_ge_x_as_result)
* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)


```rust
pub macro_rules! assert_program_args_stderr_ge_x_as_result {
    /* macro_rules! assert_program_args_stderr_ge_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stderr_ge_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_ge_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stderr_ge_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_ge_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[122, 122]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_ge_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_ge_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[122, 122]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)
* [`assert_program_args_stderr_ge_x_as_result`](macro@crate::assert_program_args_stderr_ge_x_as_result)
* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)


```rust
pub macro_rules! assert_program_args_stderr_ge_x {
    /* macro_rules! assert_program_args_stderr_ge_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≥ (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_ge_x`](macro.assert_program_args_stderr_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)
* [`assert_program_args_stderr_ge_x`](macro@crate::assert_program_args_stderr_ge_x)
* [`debug_assert_program_args_stderr_ge_x`](macro@crate::debug_assert_program_args_stderr_ge_x)


```rust
pub macro_rules! debug_assert_program_args_stderr_ge_x {
    /* macro_rules! debug_assert_program_args_stderr_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)
* [`assert_program_args_stderr_gt_x_as_result`](macro@crate::assert_program_args_stderr_gt_x_as_result)
* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)


```rust
pub macro_rules! assert_program_args_stderr_gt_x_as_result {
    /* macro_rules! assert_program_args_stderr_gt_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stderr_gt_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_gt_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stderr_gt_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_gt_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[122, 122]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[122, 122]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_gt_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_gt_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[122, 122]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[122, 122]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)
* [`assert_program_args_stderr_gt_x_as_result`](macro@crate::assert_program_args_stderr_gt_x_as_result)
* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)


```rust
pub macro_rules! assert_program_args_stderr_gt_x {
    /* macro_rules! assert_program_args_stderr_gt_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is greater than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) > (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_gt_x`](macro.assert_program_args_stderr_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)
* [`assert_program_args_stderr_gt_x`](macro@crate::assert_program_args_stderr_gt_x)
* [`debug_assert_program_args_stderr_gt_x`](macro@crate::debug_assert_program_args_stderr_gt_x)


```rust
pub macro_rules! debug_assert_program_args_stderr_gt_x {
    /* macro_rules! debug_assert_program_args_stderr_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)
* [`assert_program_args_stderr_le_x_as_result`](macro@crate::assert_program_args_stderr_le_x_as_result)
* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)


```rust
pub macro_rules! assert_program_args_stderr_le_x_as_result {
    /* macro_rules! assert_program_args_stderr_le_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_le_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stderr_le_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stderr_le_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_le_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[97, 97]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_le_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_le_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[97, 97]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)
* [`assert_program_args_stderr_le_x_as_result`](macro@crate::assert_program_args_stderr_le_x_as_result)
* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)


```rust
pub macro_rules! assert_program_args_stderr_le_x {
    /* macro_rules! assert_program_args_stderr_le_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_le_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than or equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≤ (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_le_x`](macro.assert_program_args_stderr_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)
* [`assert_program_args_stderr_le_x`](macro@crate::assert_program_args_stderr_le_x)
* [`debug_assert_program_args_stderr_le_x`](macro@crate::debug_assert_program_args_stderr_le_x)


```rust
pub macro_rules! debug_assert_program_args_stderr_le_x {
    /* macro_rules! debug_assert_program_args_stderr_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)
* [`assert_program_args_stderr_lt_x_as_result`](macro@crate::assert_program_args_stderr_lt_x_as_result)
* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)


```rust
pub macro_rules! assert_program_args_stderr_lt_x_as_result {
    /* macro_rules! assert_program_args_stderr_lt_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'z', b'z'];
assert_program_args_stderr_lt_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let a_args = ["%s", "alfa"];
let bytes = vec![b'a', b'a'];
assert_program_args_stderr_lt_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stderr_lt_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_lt_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[97, 97]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_lt_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_lt_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[97, 97]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)
* [`assert_program_args_stderr_lt_x_as_result`](macro@crate::assert_program_args_stderr_lt_x_as_result)
* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)


```rust
pub macro_rules! assert_program_args_stderr_lt_x {
    /* macro_rules! assert_program_args_stderr_lt_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is less than an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) < (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_lt_x`](macro.assert_program_args_stderr_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)
* [`assert_program_args_stderr_lt_x`](macro@crate::assert_program_args_stderr_lt_x)
* [`debug_assert_program_args_stderr_lt_x`](macro@crate::debug_assert_program_args_stderr_lt_x)


```rust
pub macro_rules! debug_assert_program_args_stderr_lt_x {
    /* macro_rules! debug_assert_program_args_stderr_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)

* If true, return Result `Ok(stderr)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)
* [`assert_program_args_stderr_ne_x_as_result`](macro@crate::assert_program_args_stderr_ne_x_as_result)
* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)


```rust
pub macro_rules! assert_program_args_stderr_ne_x_as_result {
    /* macro_rules! assert_program_args_stderr_ne_x_as_result {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)

* If true, return `()`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'x', b'x'];
assert_program_args_stderr_ne_x!(program, args, bytes);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let bytes = vec![b'a', b'l', b'f', b'a'];
assert_program_args_stderr_ne_x!(program, args, bytes);
# });
// assertion failed: `assert_program_args_stderr_ne_x!(a_program, a_args, b_expr)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_ne_x.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//     b_expr label: `bytes`,
//     b_expr debug: `[97, 108, 102, 97]`,
//                a: `[97, 108, 102, 97]`,
//                b: `[97, 108, 102, 97]`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_ne_x!(a_program, a_args, b_expr)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_ne_x.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     "    b_expr label: `bytes`,\n",
#     "    b_expr debug: `[97, 108, 102, 97]`,\n",
#     "               a: `[97, 108, 102, 97]`,\n",
#     "               b: `[97, 108, 102, 97]`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)
* [`assert_program_args_stderr_ne_x_as_result`](macro@crate::assert_program_args_stderr_ne_x_as_result)
* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)


```rust
pub macro_rules! assert_program_args_stderr_ne_x {
    /* macro_rules! assert_program_args_stderr_ne_x {
    ($a_program:expr, $a_args:expr, $b_expr:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $b_expr:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr is not equal to an expression.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr) ≠ (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_ne_x`](macro.assert_program_args_stderr_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)
* [`assert_program_args_stderr_ne_x`](macro@crate::assert_program_args_stderr_ne_x)
* [`debug_assert_program_args_stderr_ne_x`](macro@crate::debug_assert_program_args_stderr_ne_x)


```rust
pub macro_rules! debug_assert_program_args_stderr_ne_x {
    /* macro_rules! debug_assert_program_args_stderr_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_contains_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stderr_contains_as_result` to `assert_program_args_stderr_string_contains_as_result`.

Assert a command (built with program and args) stderr into a string contains a given containee.

Deprecated. Please rename from `assert_program_args_stderr_contains_as_result` to `assert_program_args_stderr_string_contains_as_result`.


```rust
pub macro_rules! assert_program_args_stderr_contains_as_result {
    /* macro_rules! assert_program_args_stderr_contains_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stderr_contains` to `assert_program_args_stderr_string_contains`.

Assert a command (built with program and args) stderr into a string contains a given containee.

Deprecated. Please rename from `assert_program_args_stderr_contains` to `assert_program_args_stderr_string_contains`.


```rust
pub macro_rules! assert_program_args_stderr_contains {
    /* macro_rules! assert_program_args_stderr_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_contains`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_program_args_stderr_contains` to `debug_assert_program_args_stderr_string_contains`.

Assert a command (built with program and args) stderr into a string contains a given containee.

Deprecated. Please rename from `debug_assert_program_args_stderr_contains` to `debug_assert_program_args_stderr_string_contains`.


```rust
pub macro_rules! debug_assert_program_args_stderr_contains {
    /* macro_rules! debug_assert_program_args_stderr_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_is_match_as_result`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stderr_is_match_as_result` to `assert_program_args_stderr_string_is_match_as_result`.

Assert a command (built with program and args) stderr into a string is a match to a regex.

Deprecated. Please rename from `assert_program_args_stderr_is_match_as_result` to `assert_program_args_stderr_string_is_match_as_result`.


```rust
pub macro_rules! assert_program_args_stderr_is_match_as_result {
    /* macro_rules! assert_program_args_stderr_is_match_as_result {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `assert_program_args_stderr_is_match` to `assert_program_args_stderr_string_is_match`.

Assert a command (built with program and args) stderr into a string is a match to a regex.

Deprecated. Please rename from `assert_program_args_stderr_is_match` to `assert_program_args_stderr_string_is_match`.


```rust
pub macro_rules! assert_program_args_stderr_is_match {
    /* macro_rules! assert_program_args_stderr_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_is_match`

**Attributes:**

- `#[macro_export]`

**⚠️ Deprecated**: Please rename from `debug_assert_program_args_stderr_is_match` to `debug_assert_program_args_stderr_string_is_match`.

Assert a command (built with program and args) stderr into a string is a match to a regex.

Deprecated. Please rename from `debug_assert_program_args_stderr_is_match` to `debug_assert_program_args_stderr_string_is_match`.


```rust
pub macro_rules! debug_assert_program_args_stderr_is_match {
    /* macro_rules! debug_assert_program_args_stderr_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_string_contains_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)

* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stderr ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)
* [`assert_program_args_stderr_string_contains_as_result`](macro@crate::assert_program_args_stderr_string_contains_as_result)
* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)


```rust
pub macro_rules! assert_program_args_stderr_string_contains_as_result {
    /* macro_rules! assert_program_args_stderr_string_contains_as_result {
    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)

* If true, return (a_program + a_args ⇒ command ⇒ stderr ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

This uses [`::std::String`](https://doc.rust-lang.org/std/string/struct.String.html) method `contains`.

* The containee can be a &str, char, a slice of chars, or a function or
closure that determines if a character contains.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let containee = "lf";
assert_program_args_stderr_string_contains!(program, args, containee);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let containee = "zz";
assert_program_args_stderr_string_contains!(program, args, containee);
# });
// assertion failed: `assert_program_args_stderr_string_contains!(a_program, a_args, containee)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_string_contains.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  containee label: `containee`,
//  containee debug: `\"zz\"`,
//                a: `\"alfa\"`,
//        containee: `\"zz\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_string_contains!(a_program, a_args, containee)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_string_contains.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " containee label: `containee`,\n",
#     " containee debug: `\"zz\"`,\n",
#     "               a: `\"alfa\"`,\n",
#     "       containee: `\"zz\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)
* [`assert_program_args_stderr_string_contains_as_result`](macro@crate::assert_program_args_stderr_string_contains_as_result)
* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)


```rust
pub macro_rules! assert_program_args_stderr_string_contains {
    /* macro_rules! assert_program_args_stderr_string_contains {
    ($a_program:expr, $a_args:expr, $containee:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $containee:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_string_contains`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr into a string contains a given containee.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) contains (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_string_contains`](macro.assert_program_args_stderr_string_contains.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)
* [`assert_program_args_stderr_string_contains`](macro@crate::assert_program_args_stderr_string_contains)
* [`debug_assert_program_args_stderr_string_contains`](macro@crate::debug_assert_program_args_stderr_string_contains)


```rust
pub macro_rules! debug_assert_program_args_stderr_string_contains {
    /* macro_rules! debug_assert_program_args_stderr_string_contains {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_string_is_match_as_result`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)

* If true, return Result `Ok(a_program + a_args ⇒ command ⇒ stderr ⇒ string)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)
* [`assert_program_args_stderr_string_is_match_as_result`](macro@crate::assert_program_args_stderr_string_is_match_as_result)
* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)


```rust
pub macro_rules! assert_program_args_stderr_string_is_match_as_result {
    /* macro_rules! assert_program_args_stderr_string_is_match_as_result {
    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_program_args_stderr_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)

* If true, return (a_program + a_args ⇒ command ⇒ stderr ⇒ string).

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;
use regex::Regex;

# fn main() {
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let matcher = Regex::new(r"lf").expect("regex");
assert_program_args_stderr_string_is_match!(program, args, matcher);

# let result = panic::catch_unwind(|| {
// This will panic
let program = "bin/printf-stderr";
let args = ["%s", "alfa"];
let matcher = Regex::new(r"zz").expect("regex");
assert_program_args_stderr_string_is_match!(program, args, matcher);
# });
// assertion failed: `assert_program_args_stderr_string_is_match!(a_program, b_matcher)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_program_args_stderr_string_is_match.html
//  a_program label: `program`,
//  a_program debug: `\"bin/printf-stderr\"`,
//     a_args label: `args`,
//     a_args debug: `[\"%s\", \"alfa\"]`,
//  b_matcher label: `matcher`,
//  b_matcher debug: `Regex(\"zz\")`,
//                a: `\"alfa\"`,
//                b: `Regex(\"zz\")`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_program_args_stderr_string_is_match!(a_program, b_matcher)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_program_args_stderr_string_is_match.html\n",
#     " a_program label: `program`,\n",
#     " a_program debug: `\"bin/printf-stderr\"`,\n",
#     "    a_args label: `args`,\n",
#     "    a_args debug: `[\"%s\", \"alfa\"]`,\n",
#     " b_matcher label: `matcher`,\n",
#     " b_matcher debug: `Regex(\"zz\")`,\n",
#     "               a: `\"alfa\"`,\n",
#     "               b: `Regex(\"zz\")`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)
* [`assert_program_args_stderr_string_is_match_as_result`](macro@crate::assert_program_args_stderr_string_is_match_as_result)
* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)


```rust
pub macro_rules! assert_program_args_stderr_string_is_match {
    /* macro_rules! assert_program_args_stderr_string_is_match {
    ($a_program:expr, $a_args:expr, $matcher:expr $(,)?) => { ... };
    ($a_program:expr, $a_args:expr, $matcher:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_program_args_stderr_string_is_match`

**Attributes:**

- `#[macro_export]`

Assert a command (built with program and args) stderr into a string is a match to a regex.

Pseudocode:<br>
(a_program + a_args ⇒ command ⇒ stderr ⇒ string) is match (expr into string)

This macro provides the same statements as [`assert_program_args_stderr_string_is_match`](macro.assert_program_args_stderr_string_is_match.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a program in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)
* [`assert_program_args_stderr_string_is_match`](macro@crate::assert_program_args_stderr_string_is_match)
* [`debug_assert_program_args_stderr_string_is_match`](macro@crate::debug_assert_program_args_stderr_string_is_match)


```rust
pub macro_rules! debug_assert_program_args_stderr_string_is_match {
    /* macro_rules! debug_assert_program_args_stderr_string_is_match {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_success_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status is a success.

Pseudocode:<br>
a ⇒ status ⇒ success = true

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_success`](macro@crate::assert_status_success)
* [`assert_status_success_as_result`](macro@crate::assert_status_success_as_result)
* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)


```rust
pub macro_rules! assert_status_success_as_result {
    /* macro_rules! assert_status_success_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_success`

**Attributes:**

- `#[macro_export]`

Assert a status is a success.

Pseudocode:<br>
a ⇒ status ⇒ success = true

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("0");
assert_status_success!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
assert_status_success!(a);
# });
// assertion failed: `assert_status_success!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_success.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_success!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_success.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_success`](macro@crate::assert_status_success)
* [`assert_status_success_as_result`](macro@crate::assert_status_success_as_result)
* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)


```rust
pub macro_rules! assert_status_success {
    /* macro_rules! assert_status_success {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_success`

**Attributes:**

- `#[macro_export]`

Assert a status is a success.

Pseudocode:<br>
a ⇒ status ⇒ success = true

This macro provides the same statements as [`assert_status_success`](macro.assert_status_success.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_success`](macro@crate::assert_status_success)
* [`assert_status_success`](macro@crate::assert_status_success)
* [`debug_assert_status_success`](macro@crate::debug_assert_status_success)


```rust
pub macro_rules! debug_assert_status_success {
    /* macro_rules! debug_assert_status_success {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_success_false_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_success_false`](macro@crate::assert_status_success_false)
* [`assert_status_success_false_as_result`](macro@crate::assert_status_success_false_as_result)
* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)


```rust
pub macro_rules! assert_status_success_false_as_result {
    /* macro_rules! assert_status_success_false_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_success_false`

**Attributes:**

- `#[macro_export]`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
assert_status_success_false!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("0");
assert_status_success_false!(a);
# });
// assertion failed: `assert_status_success_false!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_success_false.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"0\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_success_false!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_success_false.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"0\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_success_false`](macro@crate::assert_status_success_false)
* [`assert_status_success_false_as_result`](macro@crate::assert_status_success_false_as_result)
* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)


```rust
pub macro_rules! assert_status_success_false {
    /* macro_rules! assert_status_success_false {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_success_false`

**Attributes:**

- `#[macro_export]`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

This macro provides the same statements as [`assert_status_success_false`](macro.assert_status_success_false.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_success_false`](macro@crate::assert_status_success_false)
* [`assert_status_success_false`](macro@crate::assert_status_success_false)
* [`debug_assert_status_success_false`](macro@crate::debug_assert_status_success_false)


```rust
pub macro_rules! debug_assert_status_success_false {
    /* macro_rules! debug_assert_status_success_false {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_failure_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_failure`](macro@crate::assert_status_failure)
* [`assert_status_failure_as_result`](macro@crate::assert_status_failure_as_result)
* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)


```rust
pub macro_rules! assert_status_failure_as_result {
    /* macro_rules! assert_status_failure_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_failure`

**Attributes:**

- `#[macro_export]`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
assert_status_failure!(a);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("0");
assert_status_failure!(a);
# });
// assertion failed: `assert_status_failure!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_failure.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"0\"`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_failure!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_failure.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"0\"`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_failure`](macro@crate::assert_status_failure)
* [`assert_status_failure_as_result`](macro@crate::assert_status_failure_as_result)
* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)


```rust
pub macro_rules! assert_status_failure {
    /* macro_rules! assert_status_failure {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_failure`

**Attributes:**

- `#[macro_export]`

Assert a status is a failure.

Pseudocode:<br>
a ⇒ status ⇒ success = false

This macro provides the same statements as [`assert_status_failure`](macro.assert_status_failure.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_failure`](macro@crate::assert_status_failure)
* [`assert_status_failure`](macro@crate::assert_status_failure)
* [`debug_assert_status_failure`](macro@crate::debug_assert_status_failure)


```rust
pub macro_rules! debug_assert_status_failure {
    /* macro_rules! debug_assert_status_failure {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_eq_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)
* [`assert_status_code_value_eq_as_result`](macro@crate::assert_status_code_value_eq_as_result)
* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)


```rust
pub macro_rules! assert_status_code_value_eq_as_result {
    /* macro_rules! assert_status_code_value_eq_as_result {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_eq`

**Attributes:**

- `#[macro_export]`

Assert a status code value is equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_eq!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_eq!(a, b);
# });
// assertion failed: `assert_status_code_value_eq!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_eq.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `\"bin/exit-with-arg\" \"2\"`,
//  b value: `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_eq!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_eq.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/exit-with-arg\" \"2\"`\n",
#     "  b code: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)
* [`assert_status_code_value_eq_as_result`](macro@crate::assert_status_code_value_eq_as_result)
* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)


```rust
pub macro_rules! assert_status_code_value_eq {
    /* macro_rules! assert_status_code_value_eq {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_eq`

**Attributes:**

- `#[macro_export]`

Assert a status code value is equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_eq`](macro.assert_status_code_value_eq.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)
* [`assert_status_code_value_eq`](macro@crate::assert_status_code_value_eq)
* [`debug_assert_status_code_value_eq`](macro@crate::debug_assert_status_code_value_eq)


```rust
pub macro_rules! debug_assert_status_code_value_eq {
    /* macro_rules! debug_assert_status_code_value_eq {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_ge_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)
* [`assert_status_code_value_ge_as_result`](macro@crate::assert_status_code_value_ge_as_result)
* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)


```rust
pub macro_rules! assert_status_code_value_ge_as_result {
    /* macro_rules! assert_status_code_value_ge_as_result {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_ge`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_ge!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_ge!(a, b);
# });
// assertion failed: `assert_status_code_value_ge!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_ge.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `\"bin/exit-with-arg\" \"1\"`,
//  b value: `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_ge!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_ge.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/exit-with-arg\" \"2\"`\n",
#     "  b code: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)
* [`assert_status_code_value_ge_as_result`](macro@crate::assert_status_code_value_ge_as_result)
* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)


```rust
pub macro_rules! assert_status_code_value_ge {
    /* macro_rules! assert_status_code_value_ge {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_ge`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≥ b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_ge`](macro.assert_status_code_value_ge.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)
* [`assert_status_code_value_ge`](macro@crate::assert_status_code_value_ge)
* [`debug_assert_status_code_value_ge`](macro@crate::debug_assert_status_code_value_ge)


```rust
pub macro_rules! debug_assert_status_code_value_ge {
    /* macro_rules! debug_assert_status_code_value_ge {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_gt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)
* [`assert_status_code_value_gt_as_result`](macro@crate::assert_status_code_value_gt_as_result)
* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)


```rust
pub macro_rules! assert_status_code_value_gt_as_result {
    /* macro_rules! assert_status_code_value_gt_as_result {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_gt`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_gt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_gt!(a, b);
# });
// assertion failed: `assert_status_code_value_gt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_gt.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `\"bin/exit-with-arg\" \"1\"`,
//  b value: `2`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_gt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_gt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/exit-with-arg\" \"2\"`\n",
#     "  b code: `2`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)
* [`assert_status_code_value_gt_as_result`](macro@crate::assert_status_code_value_gt_as_result)
* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)


```rust
pub macro_rules! assert_status_code_value_gt {
    /* macro_rules! assert_status_code_value_gt {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_gt`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value > b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_gt`](macro.assert_status_code_value_gt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)
* [`assert_status_code_value_gt`](macro@crate::assert_status_code_value_gt)
* [`debug_assert_status_code_value_gt`](macro@crate::debug_assert_status_code_value_gt)


```rust
pub macro_rules! debug_assert_status_code_value_gt {
    /* macro_rules! debug_assert_status_code_value_gt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_le_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)
* [`assert_status_code_value_le_as_result`](macro@crate::assert_status_code_value_le_as_result)
* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)


```rust
pub macro_rules! assert_status_code_value_le_as_result {
    /* macro_rules! assert_status_code_value_le_as_result {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_le`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_le!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_le!(a, b);
# });
// assertion failed: `assert_status_code_value_le!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_le.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `2`",
//  b label: `b`,
//  b debug: `\"bin/exit-with-arg\" \"1\"`,
//  b value: `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_le!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_le.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"2\"`,\n",
#     "  a code: `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/exit-with-arg\" \"1\"`\n",
#     "  b code: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)
* [`assert_status_code_value_le_as_result`](macro@crate::assert_status_code_value_le_as_result)
* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)


```rust
pub macro_rules! assert_status_code_value_le {
    /* macro_rules! assert_status_code_value_le {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_le`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than or equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≤ b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_le`](macro.assert_status_code_value_le.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)
* [`assert_status_code_value_le`](macro@crate::assert_status_code_value_le)
* [`debug_assert_status_code_value_le`](macro@crate::debug_assert_status_code_value_le)


```rust
pub macro_rules! debug_assert_status_code_value_le {
    /* macro_rules! debug_assert_status_code_value_le {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_lt_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)
* [`assert_status_code_value_lt_as_result`](macro@crate::assert_status_code_value_lt_as_result)
* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)


```rust
pub macro_rules! assert_status_code_value_lt_as_result {
    /* macro_rules! assert_status_code_value_lt_as_result {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_lt`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_lt!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_lt!(a, b);
# });
// assertion failed: `assert_status_code_value_lt!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_lt.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `2`",
//  b label: `b`,
//  b debug: `\"bin/exit-with-arg\" \"1\"`,
//  b value: `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_lt!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_lt.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"2\"`,\n",
#     "  a code: `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/exit-with-arg\" \"1\"`\n",
#     "  b code: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)
* [`assert_status_code_value_lt_as_result`](macro@crate::assert_status_code_value_lt_as_result)
* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)


```rust
pub macro_rules! assert_status_code_value_lt {
    /* macro_rules! assert_status_code_value_lt {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_lt`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value < b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_lt`](macro.assert_status_code_value_lt.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)
* [`assert_status_code_value_lt`](macro@crate::assert_status_code_value_lt)
* [`debug_assert_status_code_value_lt`](macro@crate::debug_assert_status_code_value_lt)


```rust
pub macro_rules! debug_assert_status_code_value_lt {
    /* macro_rules! debug_assert_status_code_value_lt {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_ne_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne_as_result`](macro@crate::assert_status_code_value_ne_as_result)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)


```rust
pub macro_rules! assert_status_code_value_ne_as_result {
    /* macro_rules! assert_status_code_value_ne_as_result {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_ne`

**Attributes:**

- `#[macro_export]`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("2");
assert_status_code_value_ne!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let mut b = Command::new("bin/exit-with-arg"); b.arg("1");
assert_status_code_value_ne!(a, b);
# });
// assertion failed: `assert_status_code_value_ne!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_ne.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `\"bin/exit-with-arg\" \"1\"`,
//  b value: `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_ne!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_ne.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `\"bin/exit-with-arg\" \"1\"`\n",
#     "  b code: `1`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne_as_result`](macro@crate::assert_status_code_value_ne_as_result)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)


```rust
pub macro_rules! assert_status_code_value_ne {
    /* macro_rules! assert_status_code_value_ne {
    ($a_process:expr, $b_process:expr $(,)?) => { ... };
    ($a_process:expr, $b_process:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_ne`

**Attributes:**

- `#[macro_export]`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value ≠ b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_ne`](macro.assert_status_code_value_ne.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)


```rust
pub macro_rules! debug_assert_status_code_value_ne {
    /* macro_rules! debug_assert_status_code_value_ne {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_eq_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is equal to an expression.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)
* [`assert_status_code_value_eq_x_as_result`](macro@crate::assert_status_code_value_eq_x_as_result)
* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)


```rust
pub macro_rules! assert_status_code_value_eq_x_as_result {
    /* macro_rules! assert_status_code_value_eq_x_as_result {
    ($a_process:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is equal to an expression.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 1;
assert_status_code_value_eq_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_eq_x!(a, b);
# });
// assertion failed: `assert_status_code_value_eq_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_eq_x.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_eq_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_eq_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)
* [`assert_status_code_value_eq_x_as_result`](macro@crate::assert_status_code_value_eq_x_as_result)
* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)


```rust
pub macro_rules! assert_status_code_value_eq_x {
    /* macro_rules! assert_status_code_value_eq_x {
    ($a_process:expr, $b:expr $(,)?) => { ... };
    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_eq_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is equal to an expression.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b

This macro provides the same statements as [`assert_status_code_value_eq_x`](macro.assert_status_code_value_eq_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)
* [`assert_status_code_value_eq_x`](macro@crate::assert_status_code_value_eq_x)
* [`debug_assert_status_code_value_eq_x`](macro@crate::debug_assert_status_code_value_eq_x)


```rust
pub macro_rules! debug_assert_status_code_value_eq_x {
    /* macro_rules! debug_assert_status_code_value_eq_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_ge_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)
* [`assert_status_code_value_ge_x_as_result`](macro@crate::assert_status_code_value_ge_x_as_result)
* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)


```rust
pub macro_rules! assert_status_code_value_ge_x_as_result {
    /* macro_rules! assert_status_code_value_ge_x_as_result {
    ($a_process:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let b = 1;
assert_status_code_value_ge_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_ge_x!(a, b);
# });
// assertion failed: `assert_status_code_value_ge_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_ge_x.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_ge_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_ge_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)
* [`assert_status_code_value_ge_x_as_result`](macro@crate::assert_status_code_value_ge_x_as_result)
* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)


```rust
pub macro_rules! assert_status_code_value_ge_x {
    /* macro_rules! assert_status_code_value_ge_x {
    ($a_process:expr, $b:expr $(,)?) => { ... };
    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_ge_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than or equal to an expression.

Pseudocode:<br>
a.len() ≥ b

This macro provides the same statements as [`assert_status_code_value_ge_x`](macro.assert_status_code_value_ge_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)
* [`assert_status_code_value_ge_x`](macro@crate::assert_status_code_value_ge_x)
* [`debug_assert_status_code_value_ge_x`](macro@crate::debug_assert_status_code_value_ge_x)


```rust
pub macro_rules! debug_assert_status_code_value_ge_x {
    /* macro_rules! debug_assert_status_code_value_ge_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_gt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than an expression.

Pseudocode:<br>
a.len() > b

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)
* [`assert_status_code_value_gt_x_as_result`](macro@crate::assert_status_code_value_gt_x_as_result)
* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)


```rust
pub macro_rules! assert_status_code_value_gt_x_as_result {
    /* macro_rules! assert_status_code_value_gt_x_as_result {
    ($a_process:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than an expression.

Pseudocode:<br>
a.len() > b

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let b = 1;
assert_status_code_value_gt_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_gt_x!(a, b);
# });
// assertion failed: `assert_status_code_value_gt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_gt_x.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `2`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_gt_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_gt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `2`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)
* [`assert_status_code_value_gt_x_as_result`](macro@crate::assert_status_code_value_gt_x_as_result)
* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)


```rust
pub macro_rules! assert_status_code_value_gt_x {
    /* macro_rules! assert_status_code_value_gt_x {
    ($a_process:expr, $b:expr $(,)?) => { ... };
    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_gt_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is greater than an expression.

Pseudocode:<br>
a.len() > b

This macro provides the same statements as [`assert_status_code_value_gt_x`](macro.assert_status_code_value_gt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)
* [`assert_status_code_value_gt_x`](macro@crate::assert_status_code_value_gt_x)
* [`debug_assert_status_code_value_gt_x`](macro@crate::debug_assert_status_code_value_gt_x)


```rust
pub macro_rules! debug_assert_status_code_value_gt_x {
    /* macro_rules! debug_assert_status_code_value_gt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_le_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)
* [`assert_status_code_value_le_x_as_result`](macro@crate::assert_status_code_value_le_x_as_result)
* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)


```rust
pub macro_rules! assert_status_code_value_le_x_as_result {
    /* macro_rules! assert_status_code_value_le_x_as_result {
    ($a_process:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_le_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_le_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let b = 1;
assert_status_code_value_le_x!(a, b);
# });
// assertion failed: `assert_status_code_value_le_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_le_x.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `2`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_le_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_le_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"2\"`,\n",
#     "  a code: `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)
* [`assert_status_code_value_le_x_as_result`](macro@crate::assert_status_code_value_le_x_as_result)
* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)


```rust
pub macro_rules! assert_status_code_value_le_x {
    /* macro_rules! assert_status_code_value_le_x {
    ($a_process:expr, $b:expr $(,)?) => { ... };
    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_le_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than or equal to an expression.

Pseudocode:<br>
a.len() ≤ b

This macro provides the same statements as [`assert_status_code_value_le_x`](macro.assert_status_code_value_le_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)
* [`assert_status_code_value_le_x`](macro@crate::assert_status_code_value_le_x)
* [`debug_assert_status_code_value_le_x`](macro@crate::debug_assert_status_code_value_le_x)


```rust
pub macro_rules! debug_assert_status_code_value_le_x {
    /* macro_rules! debug_assert_status_code_value_le_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_lt_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than an expression.

Pseudocode:<br>
a.len() < b

* If true, return Result `Ok(a ⇒ status ⇒ code ⇒ value)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)
* [`assert_status_code_value_lt_x_as_result`](macro@crate::assert_status_code_value_lt_x_as_result)
* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)


```rust
pub macro_rules! assert_status_code_value_lt_x_as_result {
    /* macro_rules! assert_status_code_value_lt_x_as_result {
    ($a_process:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than an expression.

Pseudocode:<br>
a.len() < b

* If true, return `a ⇒ status ⇒ code ⇒ value``.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_lt_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("2");
let b = 1;
assert_status_code_value_lt_x!(a, b);
# });
// assertion failed: `assert_status_code_value_lt_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_lt_x.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `2`",
//  b label: `b`,
//  b debug: `1`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_lt_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_lt_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"2\"`,\n",
#     "  a code: `2`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)
* [`assert_status_code_value_lt_x_as_result`](macro@crate::assert_status_code_value_lt_x_as_result)
* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)


```rust
pub macro_rules! assert_status_code_value_lt_x {
    /* macro_rules! assert_status_code_value_lt_x {
    ($a_process:expr, $b:expr $(,)?) => { ... };
    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_lt_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is less than an expression.

Pseudocode:<br>
a.len() < b

This macro provides the same statements as [`assert_status_code_value_lt_x`](macro.assert_status_code_value_lt_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)
* [`assert_status_code_value_lt_x`](macro@crate::assert_status_code_value_lt_x)
* [`debug_assert_status_code_value_lt_x`](macro@crate::debug_assert_status_code_value_lt_x)


```rust
pub macro_rules! debug_assert_status_code_value_lt_x {
    /* macro_rules! debug_assert_status_code_value_lt_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_status_code_value_ne_x_as_result`

**Attributes:**

- `#[macro_export]`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

* If true, return Result `Ok((a value, b value)))`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne_x_as_result`](macro@crate::assert_status_code_value_ne_x_as_result)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)


```rust
pub macro_rules! assert_status_code_value_ne_x_as_result {
    /* macro_rules! assert_status_code_value_ne_x_as_result {
    ($a_process:expr, $b:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_status_code_value_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

* If true, return `(a value, b value)`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
use std::process::Command;
# use std::panic;

# fn main() {
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 2;
assert_status_code_value_ne_x!(a, b);

# let result = panic::catch_unwind(|| {
// This will panic
let mut a = Command::new("bin/exit-with-arg"); a.arg("1");
let b = 1;
assert_status_code_value_ne_x!(a, b);
# });
// assertion failed: `assert_status_code_value_ne_x!(a, b)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_status_code_value_ne_x.html
//  a label: `a`,
//  a debug: `\"bin/exit-with-arg\" \"1\"`,
//  a value: `1`",
//  b label: `b`,
//  b debug: `1`"
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_status_code_value_ne_x!(a, b)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_status_code_value_ne_x.html\n",
#     " a label: `a`,\n",
#     " a debug: `\"bin/exit-with-arg\" \"1\"`,\n",
#     "  a code: `1`,\n",
#     " b label: `b`,\n",
#     " b debug: `1`"
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne_x_as_result`](macro@crate::assert_status_code_value_ne_x_as_result)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)


```rust
pub macro_rules! assert_status_code_value_ne_x {
    /* macro_rules! assert_status_code_value_ne_x {
    ($a_process:expr, $b:expr $(,)?) => { ... };
    ($a_process:expr, $b:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_status_code_value_ne_x`

**Attributes:**

- `#[macro_export]`

Assert a status code value is not equal to another.

Pseudocode:<br>
a ⇒ status ⇒ code ⇒ value = b ⇒ status ⇒ code ⇒ value

This macro provides the same statements as [`assert_status_code_value_ne`](macro.assert_status_code_value_ne_x.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`assert_status_code_value_ne`](macro@crate::assert_status_code_value_ne)
* [`debug_assert_status_code_value_ne`](macro@crate::debug_assert_status_code_value_ne)


```rust
pub macro_rules! debug_assert_status_code_value_ne_x {
    /* macro_rules! debug_assert_status_code_value_ne_x {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_success_as_result`

**Attributes:**

- `#[macro_export]`

Assert a success method is true.

Pseudocode:<br>
a.success() = true

* If true, return Result `Ok(true)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_success`](macro@crate::assert_success)
* [`assert_success_as_result`](macro@crate::assert_success_as_result)
* [`debug_assert_success`](macro@crate::debug_assert_success)


```rust
pub macro_rules! assert_success_as_result {
    /* macro_rules! assert_success_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_success`

**Attributes:**

- `#[macro_export]`

Assert a success method is true.

Pseudocode:<br>
a.success() = true

* If true, return `true`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { true }}
let a = A{};
assert_success!(a);

# let result = panic::catch_unwind(|| {
// This will panic
#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { false }}
let a = A{};
assert_success!(a);
# });
// assertion failed: `assert_success!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_success.html
//  a label: `a`,
//  a debug: `A`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_success!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_success.html\n",
#     " a label: `a`,\n",
#     " a debug: `A`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_success`](macro@crate::assert_success)
* [`assert_success_as_result`](macro@crate::assert_success_as_result)
* [`debug_assert_success`](macro@crate::debug_assert_success)


```rust
pub macro_rules! assert_success {
    /* macro_rules! assert_success {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_success`

**Attributes:**

- `#[macro_export]`

Assert a success method is true.

Pseudocode:<br>
a.success() = true

This macro provides the same statements as [`assert_success`](macro.assert_success.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_success`](macro@crate::assert_success)
* [`assert_success`](macro@crate::assert_success)
* [`debug_assert_success`](macro@crate::debug_assert_success)


```rust
pub macro_rules! debug_assert_success {
    /* macro_rules! debug_assert_success {
    ($($arg:tt)*) => { ... };
} */
}
```

### Macro `assert_success_false_as_result`

**Attributes:**

- `#[macro_export]`

Assert a failure method is true.

Pseudocode:<br>
a.success() = false

* If true, return Result `Ok(true)`.

* Otherwise, return Result `Err(message)`.

This macro is useful for runtime checks, such as checking parameters,
or sanitizing inputs, or handling different results in different ways.

# Module macros

* [`assert_success_false`](macro@crate::assert_success_false)
* [`assert_success_false_as_result`](macro@crate::assert_success_false_as_result)
* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)


```rust
pub macro_rules! assert_success_false_as_result {
    /* macro_rules! assert_success_false_as_result {
    ($a:expr $(,)?) => { ... };
} */
}
```

### Macro `assert_success_false`

**Attributes:**

- `#[macro_export]`

Assert a failure method is true.

Pseudocode:<br>
a.success() = false

* If true, return `true`.

* Otherwise, call [`panic!`] with a message and the values of the
  expressions with their debug representations.

# Examples

```rust
use assertables::*;
# use std::panic;

# fn main() {
#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { false }}
let a = A{};
assert_success_false!(a);

# let result = panic::catch_unwind(|| {
// This will panic
#[derive(Debug)]
struct A;
impl A { fn success(&self) -> bool { true }}
let a = A{};
assert_success_false!(a);
# });
// assertion failed: `assert_success_false!(a)`
// https://docs.rs/assertables/9.8.0/assertables/macro.assert_success_false.html
//  a label: `a`,
//  a debug: `A`
# let actual = result.unwrap_err().downcast::<String>().unwrap().to_string();
# let message = concat!(
#     "assertion failed: `assert_success_false!(a)`\n",
#     "https://docs.rs/assertables/", env!("CARGO_PKG_VERSION"), "/assertables/macro.assert_success_false.html\n",
#     " a label: `a`,\n",
#     " a debug: `A`",
# );
# assert_eq!(actual, message);
# }
```

# Module macros

* [`assert_success_false`](macro@crate::assert_success_false)
* [`assert_success_false_as_result`](macro@crate::assert_success_false_as_result)
* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)


```rust
pub macro_rules! assert_success_false {
    /* macro_rules! assert_success_false {
    ($a:expr $(,)?) => { ... };
    ($a:expr, $($message:tt)+) => { ... };
} */
}
```

### Macro `debug_assert_success_false`

**Attributes:**

- `#[macro_export]`

Assert a failure method is true.

Pseudocode:<br>
a.success() = false

This macro provides the same statements as [`assert_success_false`](macro.assert_success_false.html),
except this macro's statements are only enabled in non-optimized
builds by default. An optimized build will not execute this macro's
statements unless `-C debug-assertions` is passed to the compiler.

This macro is useful for checks that are too expensive to be present
in a release build but may be helpful during development.

The result of expanding this macro is always type checked.

An unchecked assertion allows a "bin/exit-with-arg" in an inconsistent state to
keep running, which might have unexpected consequences but does not
introduce unsafety as long as this only happens in safe code. The
performance cost of assertions, however, is not measurable in general.
Replacing `assert*!` with `debug_assert*!` is thus only encouraged
after thorough profiling, and more importantly, only in safe code!

This macro is intended to work in a similar way to
[`::std::debug_assert`](https://doc.rust-lang.org/std/macro.debug_assert.html).

# Module macros

* [`assert_success_false`](macro@crate::assert_success_false)
* [`assert_success_false`](macro@crate::assert_success_false)
* [`debug_assert_success_false`](macro@crate::debug_assert_success_false)


```rust
pub macro_rules! debug_assert_success_false {
    /* macro_rules! debug_assert_success_false {
    ($($arg:tt)*) => { ... };
} */
}
```

